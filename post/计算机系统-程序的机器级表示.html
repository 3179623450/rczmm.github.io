
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>计算机系统-程序的机器级表示 - 小小世界</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="你看到的不止如此,程序的机器级表示计算机执行机器代码。编译器基于编程语言、目标机器的指令集以及操作系统，生成机器代码。
汇编代码是机器代码的文本表示。
对于严谨的程序员来说，能阅读和理解汇编代码形式是一项重要的技能。,"> 
    <meta name="author" content="rczmm"> 
    <link rel="alternative" href="atom.xml" title="小小世界" type="application/atom+xml"> 
    <link rel="icon" href="/img/logo.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="计算机系统-程序的机器级表示 - 小小世界"/>
    <meta name="twitter:description" content="你看到的不止如此,程序的机器级表示计算机执行机器代码。编译器基于编程语言、目标机器的指令集以及操作系统，生成机器代码。
汇编代码是机器代码的文本表示。
对于严谨的程序员来说，能阅读和理解汇编代码形式是一项重要的技能。,"/>
    
    
    
    
    <meta property="og:site_name" content="小小世界"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="计算机系统-程序的机器级表示 - 小小世界"/>
    <meta property="og:description" content="你看到的不止如此,程序的机器级表示计算机执行机器代码。编译器基于编程语言、目标机器的指令集以及操作系统，生成机器代码。
汇编代码是机器代码的文本表示。
对于严谨的程序员来说，能阅读和理解汇编代码形式是一项重要的技能。,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">小小世界</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://rczmm.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">计算机系统-程序的机器级表示</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">计算机系统-程序的机器级表示</h1>
        <div class="stuff">
            <span>十月 12, 2022</span>
            

        </div>
        <div class="content markdown">
            <h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><p>计算机执行机器代码。编译器基于编程语言、目标机器的指令集以及操作系统，生成机器代码。</p>
<p>汇编代码是机器代码的文本表示。</p>
<p>对于严谨的程序员来说，能阅读和理解汇编代码形式是一项重要的技能。</p>
<p>对于处理器的机器语言，比较常见的就是x86-64，IA32是他的32位前身。</p>
<h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><p>各类处理器中的晶体管数量与他们出现的年份呈现正比例增长的趋势，晶体管基本每26个月都会翻一番。</p>
<p>预测未来10年，芯片上的晶体管每年都会翻一番，这个预测就是摩尔定律。</p>
<h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>GCC C编译器，这是linux上的默认编译器，实际上GCC调用了一整套的程序，将源代码转化为可执行代码。</p>
<p>首先，C预处理器扩展源代码，插入所有#include命令指定的文件，并扩展所有用#include声明的宏。</p>
<p>其次，编译器会产生两个源文件的汇编代码，后缀为.s。</p>
<p>接下来，汇编器会将汇编代码转化为二进制目标代码文件，后缀为.o。（目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。）</p>
<p>最后，链接器将两个目标代码文件与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件。</p>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>计算机系统使用了不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。</p>
<p>ISA指令集体系结构或者指令集架构来定义机器级程序的格式和行为，他定义处理器状态、指令的格式，以及每条指令对状态的影响。</p>
<p>机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去一个非常大的字节数组。</p>
<p>在整个编译过程中，编译器完成大部分的工作，汇编代码非常接近于机器代码，他的主要特点是他的可读性更好。</p>
<p>x86-64的机器代码与C代码差别很大，一些通常对C程序员隐藏的处理器状态都是可见。</p>
<p>PC（计数器，在%rip来表示）给出将要执行的下一条指令在内存中的地址。</p>
<p>整数寄存器，包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址或整数数据，有些寄存器被用来记录重要的程序状态，其他的寄存器用来保存临时数据。</p>
<p>条件码寄存器，保存最近执行的算术或逻辑指令的状态信息。</p>
<p>向量寄存器，存放一个或多个整数或浮点数值。</p>
<p>程序内存包括：用来管理过程调用和返回的运行时栈，以及用户分配的内存块。</p>
<p>一条机器指令只执行一个非常基本的操作。</p>
<p>在C语言程序经过预处理与编译之后，就能得到汇编文件，代码中已经出去了所有的局部变量名或数据类型的信息。</p>
<p>但是机器执行的程序只是一个简单的字节序列，它是对一系列指令的编码，机器对产生这些指令的源代码几乎一无所知。</p>
<p>要查看机器代码的内容，反汇编器的程序就有作用，他会根据机器代码产生一种类似汇编代码的格式。并且不会去访问汇编代码或者源代码。</p>
<h3 id="关于格式的注解"><a href="#关于格式的注解" class="headerlink" title="关于格式的注解"></a>关于格式的注解</h3><pre class="line-numbers language-none"><code class="language-none">    .file  &quot;Node.c&quot;
   .text
   .globl InitList
   .def   InitList;  .scl   2; .type  32;    .endef
   .seh_proc  InitList
InitList:
   subq   $40, %rsp
   .seh_stackalloc    40
   .seh_endprologue
   movl   $16, %ecx
   call   malloc
   movq   $0, 8(%rax)
   addq   $40, %rsp
   ret
   .seh_endproc
   .section .rdata,&quot;dr&quot;</code></pre>

<p>如上是一段C语言代码经过GCC编译后的内容，它包含我们不需要关心的信息，另一方面，他不提供任何程序的描述或者他如何工作的描述。</p>
<p>所有以“.”开头的行都是知道汇编器和链接器工作的伪指令，通常可以忽略掉他们。</p>
<p>一种汇编语言程序员的代码风格是，只会给出与讨论内容相关的代码行，每一行的左边有行号提供引用，右边是注释。</p>
<p>还有网络旁注，提供一些资料，一个网络旁注者描述的是IA32的机器代码，有了x86-64的背景，学习IA32会相当简单，除此之外，它还描述了在C语言中插入汇编语言的方法。</p>
<h3 id="ATT与Intel汇编格式"><a href="#ATT与Intel汇编格式" class="headerlink" title="ATT与Intel汇编格式"></a>ATT与Intel汇编格式</h3><p>一般的表示，包括如上的表示都是AT&amp;T的，这也是很多工具的默认的编码格式，其他的一些编程工具，都是Intel的，这两种格式在许多的方面有所不同。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20221013144105321.png" alt="image-20221013144105321"></p>
<pre class="line-numbers language-none"><code class="language-none">    .file  &quot;Node.c&quot;
   .intel_syntax noprefix
   .text
   .globl InitList
   .def   InitList;  .scl   2; .type  32;    .endef
   .seh_proc  InitList
InitList:
   sub    rsp, 40
   .seh_stackalloc    40
   .seh_endprologue
   mov    ecx, 16
   call   malloc
   mov    QWORD PTR 8[rax], 0
   add    rsp, 40
   ret
   .seh_endproc
   .section .rdata,&quot;dr&quot;</code></pre>

<p>使用如上的命令行，GCC可以产生Intel格式的代码。</p>
<p>Intel代码省略了指示大小的后缀。</p>
<p>Intel代码省略了寄存器名字前面的“%”符号。</p>
<p>Intel代码用不同的方式来描述在内存中的位置。</p>
<p>在带有多个操作数的指令情况下，列出操作数的顺序相反。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>32位的体系结构是由16位扩展而来的，在Intel中用术语“字（word）”来表述16位数据类型，因此，32位数据类型成为双字，64位数称为四字。</p>
<p>C语言数据类型在x86-64中的大小。</p>
<table>
<thead>
<tr>
<th>C声明</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody></table>
<p>住：指针在64位的系统中，长8个字节。</p>
<p>大多数GCC产生的汇编代码指令中都有一个字符的后缀，表明操作数的大小，例如数据传送指令的变种：movb（字节）、movw（字）、movl（双字）、movq（四字）。</p>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针，他们都以%r开头，最初的8086中有8个16位的寄存器，扩展到IA32时，这些寄存器也扩展为32位寄存器，标号从%eax到%ebp。</p>
<table>
<thead>
<tr>
<th>64位</th>
<th>32位</th>
<th>16位</th>
<th>8位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%rax</td>
<td>%eax</td>
<td>%ax</td>
<td>%al</td>
<td>返回值</td>
</tr>
<tr>
<td>%rbx</td>
<td>%ebx</td>
<td>%bx</td>
<td>%bl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td>%ecx</td>
<td>%cx</td>
<td>%cl</td>
<td>第4个参数</td>
</tr>
<tr>
<td>%rdx</td>
<td>%edx</td>
<td>%dx</td>
<td>%dl</td>
<td>第3个参数</td>
</tr>
<tr>
<td>%rsi</td>
<td>%esi</td>
<td>%si</td>
<td>%sil</td>
<td>第2个参数</td>
</tr>
<tr>
<td>%rdi</td>
<td>%edi</td>
<td>%di</td>
<td>%dil</td>
<td>第1个参数</td>
</tr>
<tr>
<td>%rbp</td>
<td>%ebp</td>
<td>%bp</td>
<td>%bpl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td>%esp</td>
<td>%sp</td>
<td>%spl</td>
<td>栈指针</td>
</tr>
<tr>
<td>%r8</td>
<td>%r8d</td>
<td>%r8w</td>
<td>%r8b</td>
<td>第5个参数</td>
</tr>
<tr>
<td>%r9</td>
<td>%r9d</td>
<td>%r9w</td>
<td>%r9b</td>
<td>第6个参数</td>
</tr>
<tr>
<td>%r10</td>
<td>%r10d</td>
<td>%r10w</td>
<td>%r10b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>%r11d</td>
<td>%r11w</td>
<td>%r11b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>%r12d</td>
<td>%r12w</td>
<td>%r12b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>%r13d</td>
<td>%r13w</td>
<td>%r13b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>%r14d</td>
<td>%r14w</td>
<td>%r14b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>%r15d</td>
<td>%r15w</td>
<td>%r15b</td>
<td>被调用者保存</td>
</tr>
</tbody></table>
<p>整数寄存器，所有16个寄存器的低位部分都可以作为字节、字、双字和四字来访问。</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令都有一个或多个操作数，指示出一个操作中要使用的源数据值，以及放置结果的目的位置。</p>
<p>操作数被分为三种类型：</p>
<p>​	立即数：表示常数值，在AT&amp;T中，立即数的书写方式是“$”后面跟一个标准C表示法表示的整数。</p>
<p>​	寄存器：表示某个寄存器内的内容。</p>
<p>​	内存引用：根据计算出来的地址访问某个的内存位置。</p>
<p>有多种不同的寻址方式，其中比例变址寻址比较常见，Imm（rb，ri，s），Imm表示立即数偏移，rb表示基址寄存器，ri表示变址寄存器和一个比例因子s。</p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>最频繁的指令是将数据从一个位置让复制到另一个位置的指令。</p>
<p>最简单形式的数据传送指令是——MOV类，这些指令把数据从源位置复制到目的位置，不做任何变化。</p>
<p>movb、movw、movl、movq组成了MOV类，这些指令都执行相同的操作，区别在于他们操作的数据大小不同，分别为1 2 4 8字节。</p>
<p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中，目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址，传送指令的两个操作数不能都指向内存地址。</p>
<p>这些指令的寄存器数可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符指定的大小相匹配，MOV指令只会更新目的操作数指令的那些寄存器字节或内存位置，唯一的例外是movl指令以寄存器作为目的时，他会把该寄存器的高位4字节设置为0。</p>
<p>在做数据传送时，常常会遇到将较小的源传送到较大的目的，对此MOV有两类数据移动指令。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MOVZ S R</td>
<td>R 零扩展S</td>
<td>以零扩展进行传送</td>
</tr>
<tr>
<td>movzbw</td>
<td></td>
<td>将做了零扩展的字节传送到字</td>
</tr>
<tr>
<td>movzbl</td>
<td></td>
<td>字节传送到双字</td>
</tr>
<tr>
<td>movzwl</td>
<td></td>
<td>字传送到双字</td>
</tr>
<tr>
<td>movzbq</td>
<td></td>
<td>字节传送到四字</td>
</tr>
<tr>
<td>movzwq</td>
<td></td>
<td>字传送到四字</td>
</tr>
<tr>
<td>MOVS S R</td>
<td>R 符号扩展S</td>
<td>传送符号扩展的字节</td>
</tr>
<tr>
<td>movsbw</td>
<td></td>
<td>字节传送到字</td>
</tr>
<tr>
<td>movsbl</td>
<td></td>
<td>字节传送到双字</td>
</tr>
<tr>
<td>cltp</td>
<td>%rax——（符号扩展）%eax</td>
<td>把%eax符号扩展到%rax</td>
</tr>
</tbody></table>
<p>如上的表省略了部分。</p>
<h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><p>两个数据传送操作可以将数据先压入栈中，再从栈中弹出。</p>
<p>pushq 压栈</p>
<p>popq 弹栈</p>
<p>将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.</span> <span class="toc-text">程序的机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">摩尔定律</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">程序编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">机器级代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">关于格式的注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ATT%E4%B8%8EIntel%E6%B1%87%E7%BC%96%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">ATT与Intel汇编格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.</span> <span class="toc-text">访问信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.4.1.</span> <span class="toc-text">操作数指示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.2.</span> <span class="toc-text">数据传送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.3.</span> <span class="toc-text">压入和弹出栈数据</span></a></li></ol></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
