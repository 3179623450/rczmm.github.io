
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>C++自学笔记（1） - 小小世界</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="你看到的不止如此,C++很重要，很重要，很重要。
HelloWorld&amp;#x2F;&amp;#x2F; 头文件引入
#include &amp;lt;iostream&amp;gt;
&amp;#x2F;&amp;#x2F; 使用名为std的命名空间
us,"> 
    <meta name="author" content="rczmm"> 
    <link rel="alternative" href="atom.xml" title="小小世界" type="application/atom+xml"> 
    <link rel="icon" href="/img/logo.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="C++自学笔记（1） - 小小世界"/>
    <meta name="twitter:description" content="你看到的不止如此,C++很重要，很重要，很重要。
HelloWorld&amp;#x2F;&amp;#x2F; 头文件引入
#include &amp;lt;iostream&amp;gt;
&amp;#x2F;&amp;#x2F; 使用名为std的命名空间
us,"/>
    
    
    
    
    <meta property="og:site_name" content="小小世界"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="C++自学笔记（1） - 小小世界"/>
    <meta property="og:description" content="你看到的不止如此,C++很重要，很重要，很重要。
HelloWorld&amp;#x2F;&amp;#x2F; 头文件引入
#include &amp;lt;iostream&amp;gt;
&amp;#x2F;&amp;#x2F; 使用名为std的命名空间
us,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">小小世界</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://rczmm.top"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">C++自学笔记（1）</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">C++自学笔记（1）</h1>
        <div class="stuff">
            <span>八月 29, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>


        </div>
        <div class="content markdown">
            <p>C++很重要，很重要，很重要。</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 头文件引入
#include &lt;iostream&gt;
&#x2F;&#x2F; 使用名为std的命名空间
using namespace std;
&#x2F;&#x2F; main方法，程序开始的地方，返回值为整形
int main()&#123;
    &#x2F;&#x2F; 打印消息hello！
    cout&lt;&lt;&quot;hello!&quot;;
    &#x2F;&#x2F; 返回0，终止main函数，并且向调用进程返回0
    return 0;
&#125;</code></pre>

<p>分号 &amp; 语句块</p>
<p>在c++里，分号是语句的结束符，并且每一条语句都必须以分号结尾。</p>
<p>语句块是一组用大括号包含起来的语句。</p>
<p>c++里，你可以在一行里写多条语句，只要他们在结尾时使用分号。</p>
<p>标识符 &amp; 关键字</p>
<p>标识符用来标识变量、函数、类、模块或者其他的自定义的名称，标识符的组成是大小写字母、数字以及下划线，但是要注意的是，数字不能开头。</p>
<p>同时，c++内严格区分大小写。</p>
<p>关键字是c++的保留字，这些保留字无法作为常量名、变量、函数等其他标识符的名称。</p>
<p>三字符序列 &amp; 空格</p>
<p>三字符序列，用于表示另一个字符的三个字符组成的序列，这些序列总是以两个问号开头。</p>
<p>这并不常见，但是c++允许这样的表示，为了表示键盘上没有的字符。值得注意的是，三字符序列可以出现在任何的地方，包括字符串、字符序列、注释和预处理指令。</p>
<p>当然如果希望在源码中有两个连续的问号，并且不希望他们被替换掉，可以使用转义字符或者是字符串自动拼接。</p>
<p>空格也是必要的符号，空格用于描述空白符、制表符、换行符和注释，同时它也起到了分割语句各个部分的作用。有时候，为了增加一些可读性，我们也会主动的添加一些不是必要的空格。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>c++的注释是解释性的语句，在c++中支持单行和多行两种注释。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 我是单行注释

&#x2F;*
  
  我是多行注释内的内容！！
&#x2F;&#x2F;  我是单行注释
  
*&#x2F; </code></pre>

<p>单行注释，从&#x2F;&#x2F;开始，直到一行结束</p>
<p>多行注释，在&#x2F;* 到 *&#x2F;的内容都是多行注释的内容，并且可以在其中添加单行注释，实现注释的嵌套。</p>
<p>注意的是，多行中无法嵌套多行。</p>
<p>除此之外，还可以通过条件编译在实现注释：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#if 0
cout&lt;&lt;&quot;hello&quot;;
#endif</code></pre>



<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>c++为程序员提供了七种基本数据类型。</p>
<p>布尔（bool）、字符（char）、整形（int）、浮点（float）、双浮点（double）、宽字符（wchar_1）、无类型（void）。</p>
<p>一些基本类型可以使用一个或者多个卡类型修饰符进行修饰。</p>
<p>signed、unsigned、short、long</p>
<p>这些修饰符可以改变数据类型所能存储的最大值和最小值。</p>
<p>其中，各个类型的大小和系统的位数有关。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;limits&gt;

using namespace std;

int main() &#123;
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;bool: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(bool);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;char: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;signed char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(signed char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;wchar_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(wchar_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;short: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(short);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;int: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(int);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned long: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;float: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(float);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;size_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(size_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;string: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(string) &lt;&lt; endl;
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot; &lt;&lt; endl;
    return 0;
&#125;</code></pre>

<p>变量的大小会编译器所在的系统有所不同，上面的实例会输出你实际电脑上各种类型的大小。</p>
<p>其中，endl，这会在每一行后插入换行符，&lt;&lt;运算度可以向平复传送多个值，sizeof（）可以获取各个数据类型的大小。</p>
<p>typedef声明 &amp; 枚举类型</p>
<p>可以使用typedef为一个已有的类型取一个新的名字。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef int id;
id student_id;</code></pre>

<p>如上的声明就完全合法。</p>
<p>枚举是一种派生的数据类型，他是由用户定义的若干枚举类型常量的集合。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum sex&#123;man&#x3D;1,woman&#x3D;0&#125; xiaoming;
xiaoming &#x3D; man;</code></pre>

<p>默认的，如果不设置整形常数，他会根据顺序赋值，从0开始，但是可以给一些特殊的值，默认的，每个名称都会比前一个名称大一，因此如果你设置了man等于3，那么woman等于4。</p>
<p>变量类型 &amp; 作用域</p>
<p>变量是程序可操作的存储区的名称，每一个变量都应该有指定的类型，类型决定了变量的大小和布局，这个范围内的值都可以存储在内存中。</p>
<p>变量名称遵循标识符的命名规范，由字母、数字、下划线组成，数字不能开头。</p>
<p>变量定义</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int age &#x3D; 10;</code></pre>

<p>如上的语句就可以声明一个变量，并且赋值为10。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">extern int age;</code></pre>

<p>extern关键字可以任何一个地方声明变量，当使用多个文件，但是只在一个文件内定义变量的时候，就可以使用它。</p>
<p>当然，虽然可以在c++中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int age;
char age;</code></pre>

<p>如上，即使类型不一样，但依旧无法被定义，并且编译器报错。</p>
<p>左值和右值</p>
<p>C ++ 有两种类型的表达式：</p>
<p>左值：指向内存位置的表达式</p>
<p>右值：存储在内存中某些地址的数值</p>
<p>其中右值表达式无法进行赋值的操作。</p>
<p>作用域</p>
<p>程序的一个区域，一般来说有三个地方可以定义变量</p>
<p>在函数或者代码块中，局部变量。</p>
<p>在函数参数定义中声明，形式参数。</p>
<p>在所有函数外部声明的变量，全局变量。它通常在程序的头部。</p>
<p>其中局部变量和全局变量的名称可以相同，但是在区域内使用是，局部变量会覆盖全局变量的值。</p>
<p>局部变量定义时，不会初始化，但是全局变量定义系统会自动初始化。</p>
<p>常量</p>
<p>固定值，在程序执行期间不会发生改变的值，又叫做字面量。常量就像是特殊的变量，只是他的值在定义后无法修改而已。</p>
<p>其中，整数常量的表示可以是无符号与长整数，在常量后加后缀U或者L。</p>
<p>也可以表示为，二进制、十进制、八进制、十六进制。由前缀指定，0x指定十六进制，0表示八进制，0b表示二进制，什么都不带表示十进制。</p>
<p>浮点常量，可以带小数点，也可以使用指数形式表达。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double a &#x3D; 31415956e-6;
cout &lt;&lt; a &lt;&lt; endl;</code></pre>

<p>其中e-6代表10的-6次方，如果是float单精度浮点类型，可以在末尾加l。</p>
<p>输出后，自动保留三位小数，对于这样的精度设置问题，解决方案如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double a &#x3D; 31415956e-6;

cout &lt;&lt; setprecision(8) &lt;&lt; a &lt;&lt; endl;

cout &lt;&lt; setiosflags(ios::fixed|ios::showpoint)&lt;&lt;setprecision(10)&lt;&lt; a &lt;&lt; endl;</code></pre>

<p>其中，范例中用到的函数都需要引入头文件</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;</code></pre>

<p>其中，setprecision用来设置精度，也就是控制输出的位数，自动四舍五入，且不保留小数后的不影响大小的0。setiosflags是一个格式控制函数，此处用到的fixed、以定点方式显示实数，也就是整数部分，搭配setprecision使用，此时后者就用来只控制小数位数了，但是他依旧不能保留0，于是引入showpoint。</p>
<p>布尔常量</p>
<p>true false</p>
<p>值得注意的是，不应该把他们看成是0和1.</p>
<p>字符常量</p>
<p>字符常量在单引号中，如果它以大写L开头（在单引号外），表示他是一个宽字符常量，此时他必须存在wchar_t类型的变量中。</p>
<p>字符常量也可以是一个转义序列，例如常用的换行、制表等等。</p>
<p>字符串常量</p>
<p>字符串的字面值或常量是在双引号里的，其中\可以用来换行分隔。</p>
<p>常量定义</p>
<p>常量的定义，有两种方式。</p>
<p>使用 <strong>#define</strong> 预处理器。</p>
<p>使用 <strong>const</strong> 关键字</p>
<p><img src="/post/C-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/image-20220905133619556.png" alt="image-20220905133619556"></p>
<p>最好的，将常量定义为大写字母形式。</p>
<p>修饰符类型</p>
<p>修饰符用来改变基本类型的含义，c++允许在char、int和double面前使用修饰符。</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>long</li>
<li>short</li>
</ul>
<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>
<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>
<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>long</strong>，<strong>int</strong> 是隐含的。</p>
<p>例如：</p>
<p><img src="/post/C-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/image-20220905133858789.png" alt="image-20220905133858789"></p>
<p>以上都表示声明了一个无符号短整数。</p>
<p>其中无符号数表示，所有的位都用来表示大小，因此无符号数只能是正数。</p>
<p>对于二者的转换，主要看转换数第一位是否为1，为1，直接取原数，不为1取补码。</p>
<p>类型限定符</p>
<p>const ： 声明常量，表示对象在程序执行期间不能被修改</p>
<p>volatile： 不需要优化，传统的变量，编译器对其优化后，会把值放在寄存器里加快读写，但是这个关键字让程序直接在内存中读取变量。</p>
<p>restrict：指针修饰符，表示该指针是唯一一种访问对象的方式。（只有C99才用）</p>
<p>存储类</p>
<p>某种程度上说，这也是限定符，他定义了变量或者函数的范围和生命周期。</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
<p>auto，c++17中删除，自动推断变量类型，声明函数返回值。</p>
<p>register 存储类用于定义存储在寄存器中而不是内存中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。</p>
<p><strong>mutable</strong> 说明符仅适用于类的对象。它允许对象的成员替代常量。</p>
<p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
<p>thread_local 说明符可以与 static 或 extern 合并。</p>
<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>
<p>运算符</p>
<ul>
<li>算术运算符（+、-、*、\、%、++、–）</li>
<li>关系运算符（&#x3D;&#x3D;、!&#x3D;、 &gt; 、&lt;、 &gt;&#x3D; 、&lt;&#x3D;）</li>
<li>逻辑运算符（&amp;&amp; 、||、 !）</li>
<li>位运算符（&amp; | ^）</li>
<li>赋值运算符(除了&#x3D;&#x3D;，其余带有&#x3D;的。)</li>
<li>杂项运算符（sizeof , &amp; * Cast Condition ? x:y）</li>
</ul>
<p>循环</p>
<p>while</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(condition)
&#123;
   statement(s);
&#125;</code></pre>

<p>for</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for ( init; condition; increment )
&#123;
   statement(s);
&#125;</code></pre>

<p>do while</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">do
&#123;
   statement(s);

&#125;while( condition );</code></pre>

<p>循环控制语句</p>
<p>break</p>
<p>跳出循环</p>
<p>continue</p>
<p>跳过剩余部分，开始下次循环</p>
<p>goto</p>
<p>允许把控制无条件转移到同一函数内的被标记的语句。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">goto label;
..
.
label: statement;</code></pre>

<p>分支</p>
<p>if</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(boolean_expression)
&#123;
   &#x2F;&#x2F; 如果布尔表达式为真将执行的语句
&#125;</code></pre>

<p>if else</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(boolean_expression)
&#123;
   &#x2F;&#x2F; 如果布尔表达式为真将执行的语句
&#125;
else
&#123;
   &#x2F;&#x2F; 如果布尔表达式为假将执行的语句
&#125;</code></pre>

<p>switch case</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">switch(expression)&#123;
    case constant-expression  :
       statement(s);
       break; &#x2F;&#x2F; 可选的
    case constant-expression  :
       statement(s);
       break; &#x2F;&#x2F; 可选的
  
    &#x2F;&#x2F; 您可以有任意数量的 case 语句
    default : &#x2F;&#x2F; 可选的
       statement(s);
&#125;</code></pre>

<p><strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量</p>
<p>条件运算符</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Exp1 ? Exp2 : Exp3;</code></pre>

<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>
<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>
<p>函数</p>
<p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>
<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>
<p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>
<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>
<p>函数定义</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">return_type function_name( parameter list )
&#123;
   body of the function
&#125;</code></pre>

<ul>
<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<p>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>
<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
<p>函数参数</p>
<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。</p>
<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有三种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">传值调用</td>
<td align="left">该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>
</tr>
<tr>
<td align="left">指针调用</td>
<td align="left">该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
<tr>
<td align="left">引用调用</td>
<td align="left">该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
</tbody></table>
<p>默认情况下，C++ 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。</p>
<p>Lambda 函数与表达式</p>
<p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>
<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[capture](parameters)-&gt;return-type&#123;body&#125;</code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto m &#x3D; [](int m,int n)-&gt;int &#123; int z &#x3D; m +n;return z;&#125;;

int a11 &#x3D; m(2,7);
cout &lt;&lt; a11 &lt;&lt;endl;</code></pre>

<p>数组</p>
<p>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double balance[5] &#x3D; &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;</code></pre>

<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>
<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double balance[] &#x3D; &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;</code></pre>

<p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double salary &#x3D; balance[9];</code></pre>

<p>字符串</p>
<p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 <strong>null</strong> 字符 <strong>\0</strong> 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char site[] &#x3D; &quot;RUNOOB&quot;;</code></pre>

<p>C++ 标准库提供了 <strong>string</strong> 类类型</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str1 &#x3D; &quot;runoob&quot;;</code></pre>

<p>指针 </p>
<p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。</p>
<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。</p>
<p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">type *var-name;</code></pre>

<p>引用</p>
<p>本质是个别名。</p>
<p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p>变量名称是变量附属在内存位置中的标签，可以把引用当成是变量附属在内存位置中的第二个标签。因此，可以通过原始变量名称或引用来访问变量的内容。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 17;
int&amp;  r &#x3D; i;
double&amp; s &#x3D; d;</code></pre>

<p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *i;
int j &#x3D; 1000;
i &#x3D; &amp;j;
cout &lt;&lt; i &lt;&lt;endl;

int var1 &#x3D; 100;
int&amp; var2 &#x3D; var1;
cout &lt;&lt; var2 &lt;&lt; endl;</code></pre>

<p>日期与时间</p>
<p>C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</ctime></p>
<p>有四个与时间相关的类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong>。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">time_t now &#x3D; time(0);
cout &lt;&lt; now &lt;&lt; endl;
char *dt &#x3D; ctime(&amp;now);
cout &lt;&lt; dt;
tm *gmtm &#x3D; gmtime(&amp;now);
dt &#x3D; asctime(gmtm);
cout &lt;&lt; dt;
cout &lt;&lt;  &quot;年：&quot; &lt;&lt;gmtm -&gt;tm_year + 1900;</code></pre>

<p>基本的IO</p>
<p>C++ 标准库提供了一组丰富的输入&#x2F;输出功能。</p>
<p>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>
<p>cout</p>
<p>预定义的对象 <strong>cout</strong> 是 <strong>iostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>
<p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，endl** 用于在行末添加一个换行符。</p>
<p>cin</p>
<p>预定义的对象 <strong>cin</strong> 是 <strong>iostream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char name[10];
cin &gt;&gt; name;
cout &lt;&lt; name &lt;&lt; endl;</code></pre>

<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用。</p>
<p>cerr</p>
<p>预定义的对象 <strong>cerr</strong> 是 <strong>iostream</strong> 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>
<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p>clog</p>
<p>预定义的对象 <strong>clog</strong> 是 <strong>iostream</strong> 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</p>
<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p>通过小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。 </p>
<p>数据结构</p>
<p>C&#x2F;C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">struct type_name &#123;
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
&#125; object_names;</code></pre>

<p><strong>type_name</strong> 是结构体类型的名称，<strong>member_type1 member_name1</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong> 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。</p>
<p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p>
<p>类 &amp; 对象</p>
<p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>
<p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p>
<p>类定义</p>
<p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 <strong>class</strong> 定义 Box 数据类型。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Book &#123;
public :
    int id;
    string name;
    double price;
&#125;;</code></pre>

<p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>。</p>
<p>定义对象</p>
<p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。</p>
<p>数据成员访问</p>
<p>类的对象的公共数据成员可以使用直接成员访问运算符 <strong>.</strong> 来访问。</p>
<p>构造函数 &amp; 析构函数</p>
<p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<p>类的<strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>
<p>继承</p>
<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 基类
class Animal &#123;
    &#x2F;&#x2F; eat() 函数
    &#x2F;&#x2F; sleep() 函数
&#125;;


&#x2F;&#x2F;派生类
class Dog : public Animal &#123;
    &#x2F;&#x2F; bark() 函数
&#125;;</code></pre>

<p>重载运算符 &amp; 重载函数</p>
<p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>
<p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Box operator+(const Box&amp;);</code></pre>

<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数。</p>
<p>多态</p>
<p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>
<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>虚函数</p>
<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>
<p>数据抽象</p>
<p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
<p>数据抽象是一种依赖于接口和实现分离的编程（设计）技术。</p>
<p>让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。</p>
<p>因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。</p>
<p>现在，让我们言归正传，就 C++ 编程而言，C++ 类为<strong>数据抽象</strong>提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p>
<p>例如，您的程序可以调用 <strong>sort()</strong> 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p>
<p>在 C++ 中，我们使用<strong>类</strong>来定义我们自己的抽象数据类型（ADT）。您可以使用类 <strong>iostream</strong> 的 <strong>cout</strong> 对象来输出数据到标准输出。</p>
<p>接口</p>
<p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>
<p>C++ 接口是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。</p>
<p>文件和流</p>
<p>C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ofstream</td>
<td align="left">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>
</tr>
<tr>
<td align="left">ifstream</td>
<td align="left">该数据类型表示输入文件流，用于从文件读取信息。</td>
</tr>
<tr>
<td align="left">fstream</td>
<td align="left">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>
</tr>
</tbody></table>
<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</fstream></iostream></p>
<p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void open(const char *filename, ios::openmode mode);</code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;fstream&gt;
#include &lt;iostream&gt;
using namespace std;
 
int main ()
&#123;
    
   char data[100];
 
   &#x2F;&#x2F; 以写模式打开文件
   ofstream outfile;
   outfile.open(&quot;afile.dat&quot;);
 
   cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;Enter your name: &quot;; 
   cin.getline(data, 100);
 
   &#x2F;&#x2F; 向文件写入用户输入的数据
   outfile &lt;&lt; data &lt;&lt; endl;
 
   cout &lt;&lt; &quot;Enter your age: &quot;; 
   cin &gt;&gt; data;
   cin.ignore();
   
   &#x2F;&#x2F; 再次向文件写入用户输入的数据
   outfile &lt;&lt; data &lt;&lt; endl;
 
   &#x2F;&#x2F; 关闭打开的文件
   outfile.close();
 
   &#x2F;&#x2F; 以读模式打开文件
   ifstream infile; 
   infile.open(&quot;afile.dat&quot;); 
 
   cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; 
   infile &gt;&gt; data; 
 
   &#x2F;&#x2F; 在屏幕上写入数据
   cout &lt;&lt; data &lt;&lt; endl;
   
   &#x2F;&#x2F; 再次从文件读取数据，并显示它
   infile &gt;&gt; data; 
   cout &lt;&lt; data &lt;&lt; endl; 
 
   &#x2F;&#x2F; 关闭打开的文件
   infile.close();
 
   return 0;
&#125;</code></pre>

<p>异常处理</p>
<p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。</p>
<p>动态内存</p>
<p>C++ 程序中的内存分为两个部分：</p>
<ul>
<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>
<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>
<p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p>
<p>如果您不再需要动态分配的内存空间，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p>
<p>命名空间</p>
<p>假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。</p>
<p>同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。</p>
<p>因此，引入了<strong>命名空间</strong>这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p>
<p>我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。</p>
<p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称。</p>
<pre class="line-numbers language-none"><code class="language-none">namespace namespace_name &#123;
   &#x2F;&#x2F; 代码声明
&#125;
name::code;  &#x2F;&#x2F; code 可以是变量或函数</code></pre>

<p>预处理器</p>
<p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>
<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</p>
<p>我们已经看到，之前所有的实例中都有 <strong>#include</strong> 指令。这个宏用于把头文件包含到源文件中。</p>
<p>C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等。</p>
<p>#define 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>。</p>
<p>有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。</p>
<p>条件预处理器的结构与 if 选择结构很像。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifdef NULL
   #define NULL 0
#endif</code></pre>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HelloWorld"><span class="toc-number">1.</span> <span class="toc-text">HelloWorld</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a></li></ol>
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
