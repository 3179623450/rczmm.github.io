<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你好，朋友</title>
    <url>/2021/07/18/hello-world/</url>
    <content><![CDATA[<p>欢迎来到“小小世界”，博主是一名编程爱好者，在这里你将会看到博主总结的宝贵经验、看到博主狼狈的踩坑，如果你是初学者，那么恭喜你，你能得到很良好的体验。</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java语言特点</title>
    <url>/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<p>java语言特点</p>
<p>java之所以能广泛的活跃在互联网和电子设备上，主要是因为其开发语言简洁并且有完善的生态系统，是一门优秀编程语言。</p>
<p><img src="/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/u=656404101,826481724&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>java不仅拥有完善的编程体系，同时也收到众多软件厂商的追捧——围绕其开发出来了大量的第三方应用，使得java的技术得以迅速的发展壮大，并且被广泛的应用，在长期的技术发展中，java语言的特性也在不断的提升。</p>
<p>1、简洁有效</p>
<p>克服了c++中所有的难以理解和容易混淆的特点，比如：头文件、指针、结构、单元、运算符重载和虚拟基础类，java更加的严谨、简洁、因此也足够简单。</p>
<p>2、可移植性</p>
<p>一次编写、处处运行。因为java的执行是基于jvm，在源代码编译后形成字节码文件，在不同的os上只需要植入与系统匹配的jvm就可以直接利用jvm的指令集解释程序运行，降低了开发难度，提高了开发效率。</p>
<p>3、面向对象</p>
<p>java是面向对象的语言，并且有着良好的程序结构定义，</p>
<p>4、垃圾回收</p>
<p><img src="/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/u=3964968350,1272502470&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>gc，无用的内存回收，java提供了垃圾回收机制。</p>
<p>5、引用传递</p>
<p>指针的代替品，更加简单。（指针虽然高效，但是需要较强的逻辑分析能力）</p>
<p>6、分布式</p>
<p>java适合网络编程，适合分布式程序开发，socket（套接字），还包括公共网关接口，cgi等，还有包括nio、aio等。</p>
<p>7、健壮性</p>
<p>编译时，有语法检查，异常可以避免错误产生时程序中断运行。</p>
<p>8、多线程</p>
<p>线程是轻量级的进程、juc多线程开发框架。</p>
<p>9、安全性</p>
<p>jvm安全，jdk更新，jvm也能更新。</p>
<p>10、函数式编程</p>
<p>lambda表达式编程</p>
<p>11、模块化支持</p>
<p>拉锯（代码名字）、jdk9之后的功能。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java发展历史</title>
    <url>/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<p>java发展历史</p>
<p><img src="/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/u=593216026,135847718&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>java语言诞生于20世纪90年代，经过长期的发展，已经成为最流行的编程语言之一，java不但广泛应用在服务端编程上，而且各个移动设备也大量使用java平台。</p>
<p>java是sun公司开发出来的一套编程语言，来源于一个green的嵌入式程序项目，目的是为了电子消费产品开发一个分布式代码系统，这样子就可以通过网络对家用电器进行控制。</p>
<p>在green项目最开始，工程师本来是打算c++进行开发，但是考虑到c++语言开发的复杂性，于是就基于c++设计了自己的一套的独立平台oak，这个就被称为是java的前身，是一种用于网络的安全语言，刚好碰到了当时的一个mosaic和netscape项目，这两个项目启发了oak的工程师，于是他们设计了一个hotjava浏览器，触发了java进军互联网，但是由于后来互联网低潮，sun公司被oracle收购。</p>
<p>java是一门综合性的编程语言，从最初设计的时候就考虑了嵌入式系统开发以及企业平台的支持。</p>
<p><img src="/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/u=2578611845,4184638346&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>实际java开发过程之中，主要有三种方向。</p>
<p>java se （java标准开发，包含的主要是语言核心类，（jdbc、接口定义、输入输出、网络io）当用户安装jdk之后，就自动支持java se开发）</p>
<p>java ee（包含了java se部分的类，用于是电子产品的软件开发，但是此类开发已经几乎被安卓替代）</p>
<p>java me（包含se所有类，并且还包含了开发企业级的应用类。（xml、事务控制、jsp、servlet）、也是目前大型系统和互联网项目开发的主要平台）</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架初步解析</title>
    <url>/2021/07/21/scrapy%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>scrapy框架是一个常用的爬虫框架，其中内嵌了许多的内容，使得爬取网页的过程不再像原生那样复杂。</p>
<p>Scrapy的架构</p>
<p><img src="/2021/07/21/scrapy%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5%E8%A7%A3%E6%9E%90/clip_image001.png" alt="架构图"></p>
<p>引擎：负责控制数据流在所有组件流动，并在相应动作是触发事件。可以理解为爬虫的大脑</p>
<p>调度器：从引擎接受请求（requests）并将它们加入爬虫队列，可以理解把等待爬取的网页排队的功能</p>
<p>下载器：负责获取页面并提供给引擎，相当于之前学的“获取网页”数据</p>
<p>爬虫器：负责解析网页（response），提取数据，或额外跟进一些url，相当于之前的解析网页的功能。</p>
<p>管道：负责处理被爬虫提取的数据（items），例如保存下来，相当于之前的“储存数据”功能</p>
<p>下载器中间件：引擎的下载器中间的一个部分，处理下载器传递给引擎的数据（response），一般不做处理</p>
<p>爬虫器中间件：引擎和爬虫器中间的一部分，处理爬虫器的输入（response）和输出（items，requests）</p>
<p>作为一个框架，上面列出来的各种组件还是很复杂的，一不小心就处于一个懵逼的状态了。</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>对应爬虫三大流程</th>
<th>Scrapy项目是否需要修改</th>
</tr>
</thead>
<tbody><tr>
<td>引擎</td>
<td></td>
<td>无需修改</td>
</tr>
<tr>
<td>调度器</td>
<td></td>
<td>无需修改</td>
</tr>
<tr>
<td>下载器</td>
<td>获取网页（requests库）</td>
<td>无需修改</td>
</tr>
<tr>
<td>爬虫器</td>
<td>解析网页（beautifulsoup库）</td>
<td>需要</td>
</tr>
<tr>
<td>管道</td>
<td>储存数据</td>
<td>需要</td>
</tr>
<tr>
<td>下载器中间件</td>
<td>获取网页（个性化部分）</td>
<td>一般不用</td>
</tr>
<tr>
<td>爬虫器中间件</td>
<td>解析网页（个性化部分）</td>
<td>一般不用</td>
</tr>
</tbody></table>
<p>可以看出来，使用scrapy框架之后，我们要写的内容就变得少了很多，一般来说，只需要负责好爬虫器和管道就可以了。</p>
<p>?</p>
<p>到底数据是怎么在scrapy中流动的呐？</p>
<p>（1）   引擎：向爬虫器发送第一个要抓取的url</p>
<p>（2）   爬虫器：提供www…….给引擎</p>
<p>（3）   引擎：接收到网址，交给调度器排序入队</p>
<p>（4）   调度器：将它处理成请求（requests）给引擎</p>
<p>（5）   引擎：接收到request，并通过下载器中间件给下载器下载</p>
<p>（6）   下载器：根据request下载页面，返回回应（response）给引擎</p>
<p>（7）   引擎：接收到response，并通过爬虫器中间件给爬虫器处理</p>
<p>（8）   爬虫器：处理response，提取内容，返回item给引擎，如果有跟进的request也会提交给引擎</p>
<p>（9）   引擎：接收到item，交给管道，新的request交给调度器</p>
<p>（10） 管道：储存数据</p>
<p>从这里就可以很明显的看出来scrapy框架的优缺点。</p>
<p>写爬虫的人，就像古代练剑一样，从开始用的木剑，到绝世好剑，最后到一草一木，爬虫也是这样，从最开始的不用框架，到使用框架，最后再到不用框架。</p>
<p>最开始使用request和bs4的时候很方便，但是接触了scrapy之后，你就会发现，原来真正的只需要几行代码就可以实现一个爬虫，这时候你会觉得scrapy很好用，但是随着需求越来越奇怪，也就是说你需要特地的去定制化一些功能的时候，scrapy作为一种条条框框的框架已经是不能满足这些需求了，所以还是会回到原始的request和bs4上。</p>
<p>Scrapy的优势就是并发性比较强，在做大批量的数据爬虫的时候简单易用，此外，做一些长期的爬虫项目维护管理也比较容易。</p>
<p>相比之下，不使用框架的话，爬虫的定制化就比较高，身经百战的高手总是可以杀人无形之中，爬虫之中最关键的就是反爬虫，scrapy毕竟作为一个框架，写的太死了，固然他也有中间件可以用来使用，但是比起不用框架的各种扩展功能，scrapy功能还是不够强大。</p>
<p>scrapy的安装</p>
<p>在Windows下的scrapy安装非常简单，只需要pip install scrapy就可以。但是一般来说都不会这么简单。</p>
<p>Scrapy框架是一个Python爬虫的框架没错，但是他确是要基于Twisted的，所以我们可以直接选择先安装Twisted组件，再安装Scrapy框架程序可以成功安装。</p>
<p>组件下载完成后文件名为“Twisted-20.3.0-cp38-cp38-win_amd64.whl”。我们打开cmd命令，在dos窗口中直接输入“pip install D:\软件安装包\Twisted-20.3.0-cp38-cp38-win_amd64.whl”其中“D:\软件安装包\Twisted-20.3.0-cp38-cp38-win_amd64.whl”为Twisted安装文件在电脑上的存放路径</p>
<p>使用pip安装Scrapy框架程序。</p>
<p>在cmd命令的DOS窗口中输入“pip install scrapy”进行安装。</p>
<p>制作爬虫</p>
<p>制作Scrapy爬虫大致需要4步：<br> 新建项目（scrapy startproject xxx）:新建一个新的爬虫项目。<br> 明确目标（编写items.py）:明确你想要抓取的目标。<br> 制作爬虫（spiders/xxspider.py）:制作爬虫开始爬取网页。<br> 存储内容（pipelines.py）:设计管道存储爬取内容</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>入门部分</title>
    <url>/2021/07/20/%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="计算机基础知识（电子计算机）"><a href="#计算机基础知识（电子计算机）" class="headerlink" title="计算机基础知识（电子计算机）"></a>计算机基础知识（电子计算机）</h2><h3 id="1、计算机是什么？"><a href="#1、计算机是什么？" class="headerlink" title="1、计算机是什么？"></a>1、计算机是什么？</h3><p>计算机就是一个用来计算的机器</p>
<p>目前来讲，计算机智能根据人类的指令来完成各种操作，人让他干嘛他就得干嘛</p>
<p>所以说，我们现在学习计算机，就是学习如何的去控制计算机</p>
<h3 id="2、计算机的组成"><a href="#2、计算机的组成" class="headerlink" title="2、计算机的组成"></a>2、计算机的组成</h3><p>硬件</p>
<p>键盘、鼠标、显示器、cpu（中央处理器）、主板（连接）、内存（运行内存、内存条）、硬盘（机械、固态…）…</p>
<p>看得见、摸得着的东西</p>
<p>软件</p>
<p><strong>系统</strong>软件（操作系统）</p>
<p>Windows、linux、macos</p>
<p>应用软件</p>
<p>办公软件（office、wps、xmind）、游戏、浏览器、聊天工具….</p>
<p>看得见、但是摸不着，软件起到的作用是负责控制计算机的硬件。</p>
<h3 id="3、计算机的使用方式"><a href="#3、计算机的使用方式" class="headerlink" title="3、计算机的使用方式"></a>3、计算机的使用方式</h3><p>必须要通过软件来完成对计算机的各种操作</p>
<p>但是、注意一点</p>
<p>一个软件并不是说，你下载了这个软件，你就可以使用它的全部功能。</p>
<p>用户需要的功能：接口（interface（接口） 交互界面）来操作计算机。</p>
<p>接口这个概念， c# java 这些编程语言当中，大多数是以一种方法集的形式，本质上说他是个类</p>
<p>web开发，写网站。写接口（例子：修改我的密码（第一个接口）、我想充值（也是一个接口）、注册（也是一个接口））</p>
<p>用户界面：文本交互界面（TUI） 和图形化交互界面（GUI）</p>
<p>TUI（Windows）</p>
<p>命令行（cmd，dos命令窗口、命令提示符、cmd窗口、shell、终端、terminal）</p>
<p>shell编程（命令行输入指令去操作系统）</p>
<p>终端</p>
<p>terminal 控制台</p>
<p>文本交互界面，指令去操作计算机</p>
<p>任何一个计算机操作系统都拥有命令行</p>
<h3 id="windows-命令行"><a href="#windows-命令行" class="headerlink" title="windows 命令行"></a>windows 命令行</h3><p>进入方式：1、底部搜索框 2、win键加r键，运行窗口，输入cmd</p>
<p>结构：</p>
<p>-版本以及版权的声明（一般没有什么用处）</p>
<p>Microsoft Windows [版本 10.0.18363.1316]<br>(c) 2019 Microsoft Corporation。保留所有权利。</p>
<p>-命令提示符</p>
<p>C:\Users***  **&gt;**（命令提示符、在&gt;后面可以直接输入指令）</p>
<p>C：</p>
<p>​    -当前所在的磁盘的根目录</p>
<p>​    -可以通过x：来切换盘符（x是表示你的盘符）</p>
<p>\Users***</p>
<p>​    -所在磁盘的路径、当前所在的文件夹</p>
<p>​    -cd切换目录</p>
<p>常见的dos命令</p>
<p>dir（查看当前路径下的所有文件包括文件夹）</p>
<p>cd（切换到指定的目录）. ..（正则表达式）</p>
<p>.表示的当前的目录</p>
<p>..表示的是上一级目录</p>
<p>md 创建一个目录</p>
<p>rd 删除一个目录</p>
<p>del 删除文件</p>
<p>cls 清屏</p>
<p>小技巧：</p>
<p>方向键上下键：会出现命令的历史记录</p>
<p>tab键：自动补全命令</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>path（路径）</p>
<p>Windows，path或许没有，可以手动添加</p>
<p>path不区分大小写pAth</p>
<p>修改完环境变量，必须重启命令行窗口</p>
<p>多个路径必须用;（英文的分号）隔开</p>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>十进制（满十进一）</p>
<p>0、1、2、3、4、5、6、7、8、9</p>
<p>千位、百位、个位</p>
<p>10^3  10^2    10^1</p>
<p>二进制（计算机底层使用的进制、满二进一）</p>
<p>01、001、01101</p>
<p>0000011010100   1      0        1</p>
<p>​                            2^2      2^1    2^0</p>
<p>计算机底层储存方式，二进制方式，内存中的每一个小格子，我们称之为一个bit（位）</p>
<p>一位（1 bit（其实就是一个1或者0））</p>
<p>bit是计算机中最小的单位</p>
<p>byte（字节）才是我们最小的可操作的单位</p>
<p>1 byte=8 bit</p>
<p>1024 byte =1 kb</p>
<p>……</p>
<p>八进制（一般不用）</p>
<p>十六进制</p>
<p>（不是给计算机底部用的，而是给我们（用户、开发者）看的）</p>
<p>一般来讲，查看二进制数据的时候，都不会用二进制来显示，而是用提供十六进制</p>
<h3 id="文本文件和字符集"><a href="#文本文件和字符集" class="headerlink" title="文本文件和字符集"></a>文本文件和字符集</h3><p>文本分成两种：纯文本（只能保存单一的文本内容、（字体、颜色、图片….）这些都不能保存） 富文本（可以保存文本之外的内容）</p>
<p>但是，在开发的时候，使用的全都是纯文本</p>
<p>纯文本在计算机底层转换成二进制保存</p>
<p>将字符转换二进制的过程、编码</p>
<p>二进制码转换成字符的过程、解码</p>
<p>编码与解码、所采用的规则，叫做字符集</p>
<p>常见：</p>
<p>ascll 美国人</p>
<p>iso 欧洲</p>
<p>ltain（mysql默认的编码方式）只认英文</p>
<p>gbk gb2312 中国</p>
<p>unicode 编码（万国码）utf-8 、utf-16、utf-32</p>
<h2 id="python入门"><a href="#python入门" class="headerlink" title="python入门"></a>python入门</h2><h3 id="python是什么？"><a href="#python是什么？" class="headerlink" title="python是什么？"></a>python是什么？</h3><p>计算机语言</p>
<p>机器语言(全是二进制，执行效率高、编写太麻烦)</p>
<p>符号语言（汇编语言）</p>
<p>（符号来代替二进制）</p>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>基本跟英语语法很相似，并且和硬件的关系没有那么紧密了，而且学习起来更容易。</p>
<p>c c++ c# java JavaScript（node.js）（本质上写服务器的时候还是用的服务器加客户端的结构，而且一般不用js写服务器，用js写中间件，因为他的并发处理）、python….</p>
<p>高级语言又分类：编译型语言（在代码执行前，转化为二进制（机器码），然后交给计算机执行）</p>
<p>源码——编译——机器码</p>
<p>c语言</p>
<p>执行速度很快，跨平台性很差</p>
<p>解释型语言（不对代码进行编译，而是一边执行一边编译）</p>
<p>源码–解释器–解释运行</p>
<p>执行速度会比较慢，但是跨平台性会非常好</p>
<p>js java python</p>
<p>python 使用广泛、可读性强、比较简洁，用更少的代码去完成自己的想法，不管是大程序还是小程序，都让结构变得清晰明了。</p>
<h3 id="python的用途"><a href="#python的用途" class="headerlink" title="python的用途"></a>python的用途</h3><p>web（facebook、豆瓣）</p>
<p>爬虫</p>
<p>科学计算</p>
<p>大数据（数据清洗）</p>
<p>云计算</p>
<p>人工智能</p>
<p>游戏</p>
<p>…</p>
<h3 id="python开发环境的搭建"><a href="#python开发环境的搭建" class="headerlink" title="python开发环境的搭建"></a>python开发环境的搭建</h3><p>python是有解释器的</p>
<p>cpython（官方）</p>
<p>用c语言（c语言直接作用在内存上）编写的python解释器</p>
<p>大型游戏（全部都是由c或者c#编写的，为什么？因为c能够直接作用在内存上）</p>
<p>pypy</p>
<p>用python语言编写的Python解释器</p>
<p>ironpython</p>
<p>.net编写</p>
<p>jpython</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>基于vm的完全分布式hadoop3-2集群搭建</title>
    <url>/2021/07/20/%E5%9F%BA%E4%BA%8Evm%E7%9A%84%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8Fhadoop3-2%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>文章最终效果为，三台虚拟机三个namenode节点，依赖zkfc处理活跃问题，两个rm节点，同样依赖zkfc处理活跃问题。3之后的hadoop。hdfs的http端口改为了9870，也可以自行修改，yarn不变，依旧是8088。</p>
<h2 id="1、部署环境"><a href="#1、部署环境" class="headerlink" title="1、部署环境"></a>1、部署环境</h2><p>Windows 10 家庭中文版（家庭版不存在问题）</p>
<p>vmware 16.0 （百度到处都有激活码，可尝试下面的激活码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZF3R0-FHED2-M80TY-8QYGC-NPKYF</span><br><span class="line">YF390-0HF8P-M81RQ-2DXQE-M2UT6</span><br><span class="line">ZF71R-DMX85-08DQY-8YMNC-PPHV8</span><br></pre></td></tr></table></figure>

<p>centos 7.4  64位（linux系统，附带官网链接）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://isoredirect.centos.org/centos/7/isos/x86_64/</span><br></pre></td></tr></table></figure>

<p>jdk 1.8 （稳定版本，hadoop神器版本）</p>
<p>hadoop 3.2.1</p>
<p>zookeeper 3.6.2（版本不限）</p>
<h2 id="2、准备工作"><a href="#2、准备工作" class="headerlink" title="2、准备工作"></a>2、准备工作</h2><p>1、完成ssh免密配置的三台虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三台虚拟机生成秘钥</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">三节点拷贝到同一节点</span><br><span class="line">ssh-copy-id node1 </span><br><span class="line">将此节点上的秘钥通过scp发送到其他节点，此处可通过编写sh脚本，简化。</span><br></pre></td></tr></table></figure>

<p>2、三台安装jdk并且配置其环境变量</p>
<p>3、三台虚拟机成功安装并且部署好zookeeper集群</p>
<h2 id="3、配置文件"><a href="#3、配置文件" class="headerlink" title="3、配置文件"></a>3、配置文件</h2><p>1、/etc/profile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar</span><br><span class="line"></span><br><span class="line">export ZOOKEEPER_HOME=/export/server/zookeeper</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$ZOOKEEPER_HOME/bin</span><br><span class="line"></span><br><span class="line">export HADOOP_HOME=/export/server/hadoop</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure>

<p>2、core-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;hdfs://my01&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;/export/server/hadoop/tmp&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;io.file.buffer.size&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;131072&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">          &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">          &lt;value&gt;node1:2181,node2:2181,node3:2181&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>3、hdfs-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.nameservices&lt;/name&gt;                                      </span><br><span class="line"> &lt;value&gt;my01&lt;/value&gt;                               </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.replication&lt;/name&gt;                  </span><br><span class="line"> &lt;value&gt;3&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                                                 </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.namenodes.my01&lt;/name&gt;             </span><br><span class="line"> &lt;value&gt;nn1,nn2,nn3&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.rpc-address.my01.nn1&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node1:9820&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.rpc-address.my01.nn2&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node2:9820&lt;/value&gt;                                 </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.rpc-address.my01.nn3&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node3:9820&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                                              </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.http-address.my01.nn1&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node1:9870&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.http-address.my01.nn2&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node2:9870&lt;/value&gt;                               </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.http-address.my01.nn3&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node3:9870&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                          </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;true&lt;/value&gt;                                 </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;                                   </span><br><span class="line"> &lt;value&gt;qjournal://node1:8485;node2:8485;node3:8485/my01&lt;/value&gt;               </span><br><span class="line">&lt;/property&gt;                               </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;                                      </span><br><span class="line"> &lt;value&gt;/export/data/hadoop/journaldata&lt;/value&gt;                               </span><br><span class="line">&lt;/property&gt;     </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.client.failover.proxy.provider.my01&lt;/name&gt;                         &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;                                  </span><br><span class="line">&lt;/property&gt;                    </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;                   </span><br><span class="line"> &lt;value&gt;sshfence</span><br><span class="line"> shell(/bin/true)&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;                             </span><br><span class="line"> &lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                      </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.fencing.ssh.connect-timeout&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;30000&lt;/value&gt;                   </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.handler.count&lt;/name&gt;                                       </span><br><span class="line"> &lt;value&gt;100&lt;/value&gt;                           </span><br><span class="line">&lt;/property&gt;                    </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;true&lt;/value&gt;                          </span><br><span class="line">&lt;/property&gt;   </span><br><span class="line">&lt;property&gt; </span><br><span class="line">       &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; </span><br><span class="line">       &lt;value&gt;file:///export/data/hadoop/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt; </span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; </span><br><span class="line">        &lt;value&gt;file:///export/data/hadoop/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;ture&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>4、mapred-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;                                    </span><br><span class="line">&lt;value&gt;yarn&lt;/value&gt;            </span><br><span class="line">&lt;/property&gt; </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">    &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;                               </span><br><span class="line">    &lt;value&gt;                                    </span><br><span class="line">        /export/server/hadoop/etc/hadoop,                                    </span><br><span class="line">        /export/server/hadoop/share/hadoop/common/*,                           </span><br><span class="line">        /export/server/hadoop/share/hadoop/common/lib/*,                       </span><br><span class="line">        /export/server/hadoop/share/hadoop/hdfs/*,</span><br><span class="line">        /export/server/hadoop/share/hadoop/hdfs/lib/*,                         </span><br><span class="line">        /export/server/hadoop/share/hadoop/mapreduce/*,                       </span><br><span class="line">        /export/server/hadoop/share/hadoop/mapreduce/lib/*,</span><br><span class="line">        /export/server/hadoop/share/hadoop/yarn/*,</span><br><span class="line">        /export/server/hadoop/share/hadoop/yarn/lib/*                         </span><br><span class="line">    &lt;/value&gt;                                    </span><br><span class="line">  &lt;/property&gt;    </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">  &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;HADOOP_MAPRED_HOME=/export/server/hadoop&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.map.env&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;HADOOP_MAPRED_HOME=/export/server/hadoop&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.reduce.env&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;HADOOP_MAPRED_HOME=/export/server/hadoop&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>5、yarn-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- Site specific YARN configuration properties --&gt;                           </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;                      </span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.automatic-failover.enabled&lt;/name&gt;       </span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                                                   </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;            </span><br><span class="line">        &lt;value&gt;yarn-rm-cluster&lt;/value&gt;                  </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;        </span><br><span class="line">        &lt;value&gt;rm1,rm2&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;                           </span><br><span class="line">        &lt;value&gt;node1&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;                         </span><br><span class="line">        &lt;value&gt;node2&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.recovery.enabled&lt;/name&gt;                     </span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;                      </span><br><span class="line">&lt;/property&gt;   </span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.id&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;rm1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;      </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;                           </span><br><span class="line">        &lt;value&gt;node1:2181,node2:2181,node3:2181&lt;/value&gt;                       </span><br><span class="line">&lt;/property&gt;                                                         </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;                            </span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;                       </span><br><span class="line">&lt;/property&gt;       </span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.store.class&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address.rm1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;node1:8088&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;   </span><br><span class="line">        &lt;property&gt;                                    </span><br><span class="line">    &lt;name&gt;yarn.application.classpath&lt;/name&gt;                                   </span><br><span class="line">    &lt;value&gt;                                    </span><br><span class="line">/export/server/hadoop/etc/hadoop:/export/server/hadoop//share/hadoop/common/lib/*:/export/server/hadoop//share/hadoop/co  mmon/*:/export/server/hadoop//share/hadoop/hdfs:/export/server/hadoop//share/hadoop/hdfs/lib/*:/export/server/hadoop//sh  are/hadoop/hdfs/*:/export/server/hadoop//share/hadoop/mapreduce/lib/*:/export/server/hadoop//share/hadoop/mapreduce/*:/e  xport/server/hadoop//share/hadoop/yarn:/export/server/hadoop//share/hadoop/yarn/lib/*:/export/server/hadoop//share/hadoop/yarn/*                             </span><br><span class="line">    &lt;/value&gt;                                    </span><br><span class="line">  &lt;/property&gt;    </span><br><span class="line"> &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt;</span><br><span class="line">&lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">         &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.scheduler.address.rm2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;node2&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address.rm2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;node2&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>6、yarn-env.sh  hadoop-env.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line">export HADOOP_HOME=/export/server/hadoop/</span><br></pre></td></tr></table></figure>

<p>7、start-dfs.sh  stop-dfs.sh  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HDFS_DATANODE_USER=root</span><br><span class="line">HDFS_DATANODE_SECURE_USER=hdfs </span><br><span class="line">HDFS_NAMENODE_USER=root </span><br><span class="line">HDFS_SECONDARYNAMENODE_USER=root</span><br><span class="line">HDFS_JOURNALNODE_USER=root</span><br><span class="line">HDFS_ZKFC_USER=root</span><br></pre></td></tr></table></figure>

<p>8、start-yarn.sh  stop-yarn.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YARN_RESOURCEMANAGER_USER=root</span><br><span class="line">HADOOP_SECURE_DN_USER=yarn</span><br><span class="line">YARN_NODEMANAGER_USER=root</span><br></pre></td></tr></table></figure>

<p>9、启动顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zkServer.sh start</span><br><span class="line">hadoop-daemon.sh start journalnode</span><br><span class="line">hdfs namenode -format / /namenode 格式化</span><br><span class="line">hdfs zkfc -formatZK //格式化高可用</span><br><span class="line">hdfs namenode //启动namenode</span><br><span class="line">hdfs namenode -bootstrapStandby</span><br><span class="line">hadoop-daemon.sh stop namenode</span><br><span class="line">hadoop-daemon.sh stop journalnode</span><br><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>

<h2 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h2><p>1、启动顺序一定不要乱</p>
<p>2、格式化出错就排错</p>
<p>3、配置文件写完之后，先开启zk集群，先status查看集群状态，确认无误之后再进行初始化操作</p>
<p>4、zk集群状态，开启后等待半分钟左右再去查看</p>
<p>5、如何验证集群搭好了，jps查看节点无误，向集群上传文件无误，启动wordcount实例无误。</p>
<p>6、启动顺序，先开启zk，一键启动start-all.sh或者分别启动yarn和hdfs都可以。不需要再次格式化了。</p>
<p>7、防火墙关闭</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>序列</title>
    <url>/2021/07/20/%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>序列</p>
<p>1、列表 list</p>
<p>​    1、列表是python中的一个对象</p>
<p>​    2、之前所说的对象，他只能单一的保存数据</p>
<p>​    3、列表可以保存很多个<strong>有序</strong>的数据</p>
<p>​    4、列表是用来存储对象的对象</p>
<p>​    5、列表的使用（本身、里面数据）</p>
<p>2、序列</p>
<p>​    1、序列是python中最基本的数据结构</p>
<p>​    2、数据结构是计算机中数据储存的方式</p>
<p>​    3、序列用于保存一组有序的数据，所有数据在序列当中是唯一的。（索引）</p>
<p>​    4、序列中的数据会按照添加的顺序来分配索引（从0开始）</p>
<p>​    5、序列的分类：</p>
<p>​            可变序列：list</p>
<p>​            不可变序列：str、tuple</p>
<p>3、字典 dict</p>
<p>​    1、字典又叫映射（mapping）</p>
<p>​    2、列表存的性能很好，查的性能很差。</p>
<p>​    3、字典查的性能很好，在字典中，每一个元素都有一个唯一的名字，通过这个名字可以很快的找到指定的元素</p>
<p>​    4、字典有可以被称为键值对，唯一的名字，键，那个值叫做值</p>
<p>4、集合 set</p>
<pre><code> 1、集合和列表很像
</code></pre>
<p>​     2、集合只能存不可变的对象</p>
<p>​     3、集合中的对象是无序的</p>
<p>​     4、集合中不能出现重复的元素</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>安装和几个概念</title>
    <url>/2021/07/20/%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>python的安装</p>
<p><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></p>
<p>python   2和3两个版本，这两个版本是并行，而且差距还有点大</p>
<p>idle python自带的一个开发工具（tab 自动补全）</p>
<p>交互界面去完成一些简单的测试</p>
<p>一般将python代码保存到一个py文件里，然后通过python指令来执行文件中的代码。</p>
<p> 几个概念</p>
<p>1、表达式</p>
<p>表达式就是类似于数学公式的东西</p>
<p>表达式一般仅仅用来计算，不会对程序有什么实质性影响，如果说你在交互模式直接输入表达式，那么解释器会自动的表达式的值输出。</p>
<p>2、语句</p>
<p>语句，一般需要他完成某种功能</p>
<p>print 打印一些信息</p>
<p>input  获取信息</p>
<p>a=1  为变量赋值</p>
<p>……</p>
<p>语句的执行一般来说都会对程序造成一定的影响</p>
<p>在交互模式中不一定会输出语句的结果</p>
<p>3、程序</p>
<p>程序是由一条一条的语句和一条条的表达式构成的</p>
<p>4、函数</p>
<p>函数也是一种语句，来完成特定的功能</p>
<p>函数：xx（）</p>
<p>函数的分类：</p>
<p>​    内置函数：</p>
<p>​        由解释器提供的函数：print（）</p>
<p>​    自定义函数：</p>
<p>​        由开发者自己创建的函数</p>
<p>函数有两个要素：参数（），括号中的内容就是参数</p>
<p>​        函数可以没有参数，也可以有很多个参数，多个参数用，隔开</p>
<p>​    返回值</p>
<p>​        返回值就是函数的返回结果，不是所有的函数都有返回值</p>
<span id="more"></span>

<p>5、字面量和变量</p>
<p>​    字面量就是一个一个的值，一个一个看得到的值，</p>
<p>​    1,2,3，asa，“dsd”</p>
<p>​    就是它表面上的值，在程序·中可以直接使用字面量</p>
<p>​    变量 变量可以用来保存字面量，而且保存的字面量是不一定的。</p>
<p>​    x=qwq</p>
<p>​    变量本身是没有任何意思的，他的意思根据字面量来表达</p>
<p>6、数据类型</p>
<p>​    数据类型就是变量的值的类型，也就是说可以为变量赋那些值，还可以说，变量可以等于那些东西</p>
<p>​    数值（整型（整数）、浮点型（浮点数）、布尔（就是是或者否，true or false 1或者0）、字符串、空值）</p>
<p>7、对象</p>
<p>python是一门面向对象的语言</p>
<p>一切都是对象（一切都是函数）</p>
<p>程序运行当中，所有的数据都要储存到内存当中然后运行，对象实际上就是一个在内存中用来存储数据的一块区域，他就是一个容器，用来存储数据。</p>
<p>对象的结构</p>
<p>id（标识）</p>
<p>用来确定对象的唯一性</p>
<p>id是由解析器生成的，cpython中，id就是对象的内存地址。</p>
<p>id（）函数可以查看id</p>
<p>对象一旦创建。他的id永远不能改变。</p>
<p>type（类型）</p>
<p>int float bool str</p>
<p>类型决定了对象的功能</p>
<p>type（）函数可以查看对象类型</p>
<p>python是一门强类型的语言，java也是，但是js，JavaScript他不是，对象一旦创建就是更改类型</p>
<p>value（值）</p>
<p>值就是对象里存储的数据</p>
<p>对于值有些对象是可以改变的</p>
<p>对象又分为两个大类，一个是可变的，一个是不可变的。</p>
<p>8、变量和对象</p>
<p>对象其实没有存储到变量中，在Python中，变量更加像是给对象取了一个名字（别名）</p>
<p>变量中存储的不是对象的值，而是对象的id（内存地址）</p>
<p>使用变量，实际上就是通过id来查找对象</p>
<p>变量中保存的对象，只有在再一次赋值的时候才会改变</p>
<p>变量与变量是独立的，修改一个变量不会影响到下一个变量</p>
<p>9、类型转换</p>
<p>一个类型的对象转换为其他对象（不是改变对象本身，而是根据对象的值来创建一个新对象）</p>
<p>10、运算符</p>
<p><strong>+</strong>  <strong>-</strong> ***** <strong>/</strong> </p>
<p>算术运算符 </p>
<p>= 赋值运算符</p>
<p>== &lt;= &gt;= ! 比较运算符（关系运算符）</p>
<p>条件运算符（三元运算符）</p>
<p>逻辑运算符 and or</p>
<p>11、基本语法</p>
<p>1、python严格区分大小写</p>
<p>2、每一行就是一条语句</p>
<p>3、一行语句不要过长</p>
<p>4、一条语句可以多行写，后面\（转义字符）结尾</p>
<p>5、严格缩进（在python里不要随便写缩进）</p>
<p>6、#这是单行注释，严格养成写注释的习惯，而且一般来说，#后面加一个空格</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2021/07/20/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>异常</p>
<p>程序在运行当中，不可避免的会产生一些错误。</p>
<p>​    使用了没有赋值的变量，使用了不存在的索引、使用了过深的递归、传入了无效的参数…</p>
<p>一旦出现异常，程序会立即停止。</p>
<p>处理异常</p>
<p>python是希望在出现异常的时候，程序不停，可以编写代码来对异常进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">	代码块（可能出现异常的语句）</span><br><span class="line">except 异常类型 as 异常名（可以自定义）:</span><br><span class="line">	代码块（程序出错了的处理方式）</span><br><span class="line">else:</span><br><span class="line">	代码块（没出错要执行的语句）</span><br><span class="line">finally:</span><br><span class="line">	代码块（一定会执行，无论是否出错的语句）</span><br></pre></td></tr></table></figure>

<p>try语句是必须的，else则不是，except和finally至少要有一股</p>
<p>raise语句 抛出异常</p>
<p>常见的异常对象</p>
<p>nameerror（你的变量名称为找到，函数名称，类名称。变量没有定义）</p>
<p>recursionerror（超过最大递归深度）</p>
<p>syntaxerror 语法错误</p>
<p>timeoueerror 超时</p>
<p>typeerror 类型错误（print（1+“sasda”））</p>
<p>valueerror   int（”12.2月”）</p>
<p>keyerror </p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建java开发环境</title>
    <url>/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Java语言执行需要经过编译器编译，而后才可以在jvm上解释字节码程序，这些操作都需要jdk的支持才可以正常完成。</p>
<p>jdk java开发工具包，java专属的开发工具，也是最底层的技术支持。</p>
<p>开发者可以直接通过oracle官网（<a href="https://www.oracle.com/cn/java/">Java 软件 | Oracle 中国</a>）获取jdk工具。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224057138.png" alt="image-20210723224057138"></p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224120031.png" alt="image-20210723224120031"></p>
<p>进入java se的下载页面时会展示我们下载的jdk类型。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224213603.png" alt="image-20210723224213603"></p>
<p>同时，除了jdk，也提供了jre的下载。</p>
<p>jre java运行时环境，jdk自带。（分两类，一个是server 一个是client），jre本身不支持开发。</p>
<p>注意选择自己适合的系统版本。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224534162.png" alt="image-20210723224534162"></p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224859826.png" alt="image-20210723224859826"></p>
<p>x86 32位，x64 64位。注意根据自己的电脑系统合理选择。</p>
<p>jdk的安装与配置</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225353570.png" alt="image-20210723225353570"></p>
<p>打开我们下载的一个Windows的程序安装包，双击运行即可安装，并出现以上的界面。点击下一步。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225450635.png" alt="image-20210723225450635"></p>
<p>选择安装目录，不要带有中文的目录。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225543007.png" alt="image-20210723225543007"></p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225554851.png" alt="image-20210723225554851"></p>
<p>显示成功安装。</p>
<p>打开目录</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225655107.png" alt="image-20210723225655107"></p>
<p>打开bin目录。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225716346.png" alt="image-20210723225716346"></p>
<p>在这个目录里，有两个核心的命令，java.exe and javac.exe</p>
<p>这两个命令本身不属于Windows本身，如果要在命令行（cmd）里直接使用，那么就必须在Windows系统中进行可执行程序的路径配置，也就是环境变量。</p>
<p>计算机——属性——高级系统设置</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225913817.png" alt="image-20210723225913817"></p>
<p>高级——环境变量——系统变量——path</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225943116.png" alt="image-20210723225943116"></p>
<p>添加jdk下bin的目录</p>
<p>E:\Program Files\java-13\bin</p>
<p>打开cmd窗口。</p>
<p>输入 java -version</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723230140245.png" alt="image-20210723230140245"></p>
<p>出现以上内容，表示安装成功。</p>
<p>Windows命令行</p>
<p>可以直接在搜索cmd，dos，命令提示符等，</p>
<p>也可以win +R 打开运行</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723230310972.png" alt="image-20210723230310972"></p>
<p>搜索cmd。</p>
<p>如果配置了环境变量，必须重新启动命令行才能加载到最新的环境变量配置。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（1）</title>
    <url>/2021/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>编程就是在跟数据打交道，计算机程序总是在接受数据、操作数据或者返回数据。</strong></p>
<p>数据：其实就是指很多的信息（数字、字符串）</p>
<p>无论多复杂的数据结构，我们都可以拆成最简单的数字和字符串来看。</p>
<p>数据结构则是数据的组织形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=&quot;hello&quot;</span><br><span class="line">b=&quot;liupeng&quot;</span><br><span class="line">print(a+b)</span><br></pre></td></tr></table></figure>

<p>这个程序就把两条数据连成了一句话，如果要描述该程序中的数据结构。</p>
<p>（这个有两个独立的变量，分别引用了两个独立的字符串）</p>
<p>数据结构：不只是用来组织数据，他影响了代码的运行速度。</p>
<p>数据结构和算法不同，对程序的影响也不同。</p>
<p><strong>时间复杂度、空间复杂度。</strong></p>
<p>时间复杂度</p>
<p>list（列表）python []</p>
<p>[1,2,3,4,5,6]</p>
<p>python中的列表</p>
<p>索引：标识数据的位置的，从0开始计算。</p>
<p>数据结构：一般数据结构有4种操作（用法）</p>
<p>1、读取：查看数据结构中某一个位置的数据</p>
<p>2、查找：从数据结构中找出某一个数据的所在</p>
<p>3、插入：给数据结构增加一个数据值</p>
<p>4、删除：从数据结构中移走一个数据值</p>
<p>操作的速度：在程序中，操作的速度不是按照时间来计算的，而是按照<strong>步数</strong>来计算。</p>
<p>因为，影响程序运行的一个很关键的因素是硬件。受硬件而影响的计时方法，非常不可靠。</p>
<p>步数</p>
<p>a操作需要5步，b操作需要500步。</p>
<p>步数作为衡量程序快慢的标准（时间复杂度、速度、效率、性能、步数）</p>
<p>1、读取：查看列表中某一个索引所指的数据</p>
<p>一步，计算机本身就有跳到任何一个索引位置的能力</p>
<p>list=[]</p>
<p><strong>所以，列表的读取是一种十分高效的操作，无论他有多长，一步就可以完成操作</strong></p>
<p>2、查找：检查它是否包含某个值</p>
<p>如果包含，需要给出索引</p>
<p>（计算机没有眼睛，他只能一步一步走）</p>
<p>这种逐一去检查的做法，就叫做<strong>线性查找</strong></p>
<p>我们需要多少步？</p>
<p>最多6步（长度只有索引5的列表）</p>
<p>以此类推，一个长度为n的列表，线性查找的步数最多就是n（自然数）</p>
<p>3、插入</p>
<p>从列表里插入一个新元素，取决于插入的位置。</p>
<p>末尾插入：一步</p>
<p>开头插入：一步是真正的插入，六步是在移动数据。</p>
<p>类推，一个n长度的列表，最坏的情况，插入需要n+1步，n次移动，一次插入（开头插入）</p>
<p>4、删除：</p>
<p>末尾删除：一步</p>
<p>开头删除：一步删除，5步时移动元素</p>
<p>类推·，一个长度n的列表，删除，最坏情况，n步（n-1（移动元素）+1（删除元素））</p>
<p><strong>集合：set （不允许元素重复）</strong></p>
<p>比如说，我们现在需要一个电话本来存储一万个电话，我们需要选择一个数据结构（一个电话不应该出现两次）</p>
<p>1、读取：一步</p>
<p>2、查找：n步</p>
<p>3、插入：</p>
<p>末尾插入：（需要先确定插入的值在不在集合中间）检查元素6步，插入一步</p>
<p>类推，n长度的集合，末尾插入，n+1（n步检查元素，1步用来插入元素）</p>
<p>开头插入，n步（检查元素），1步（插入），n步（移动元素）</p>
<p>那么，最坏的情况 ，插入需要2n+1步</p>
<p><strong>数据结构的的性能（理解），关键在于步数。</strong></p>
<p>算法，不高级。</p>
<p>某种操作的过程。</p>
<p>读取、查找、插入、删除</p>
<p>有序列表</p>
<p>二分查找（5，线性：5步。二分需要：2步）</p>
<p>python</p>
<p><strong>1、将序列分解为单独的变量，序列（数据结构）</strong></p>
<p>问题：我们有一个包含n个元素的元组或者序列，现在想把它分解成n个单独的变量</p>
<p>解决方案：任何的序列都可以通过一个简单的赋值操作来分解为单独的变量，唯一的要求是变量的总数和结构要与序列一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tuple=(1,2,3)</span><br><span class="line">x,y,z=tuple</span><br><span class="line">print(x,y,z)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tuple=(1,2,3,4)</span><br><span class="line">x,y,z=tuple</span><br><span class="line">print(x,y,z)</span><br></pre></td></tr></table></figure>

<p>ValueError: too many values to unpack (expected 3)</p>
<p>元素的数量不匹配，就会得到错误提示。</p>
<p>讨论：上面是元组。来看一下其他的序列（可以迭代的对象），比如：字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str=&quot;hello&quot;</span><br><span class="line">_,a,_ ,_  ,_   =str</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p><strong>2、从任意长度的可迭代对象中分解元素</strong></p>
<p>问题：需要从某个可迭代对象（字符串、列表、集合、字典）分解出n个元素，但是这个可迭代对象的长度可能超过了n，这就会出现分解的值过多的情况。</p>
<p>解决方案：python中的*表达式可以解决这个问题。</p>
<p>比如：我开了一门课，并且决定在期末成绩中去掉一个最高分，去掉一个最低分，接下来求平均数。</p>
<p>*，用在两个字面量或者变量中间，乘号</p>
<p>单一的* ，*是用来接受多个参数，并且放到一个元组里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def demo(*p):</span><br><span class="line">    print(p)</span><br><span class="line">demo(1,2)</span><br></pre></td></tr></table></figure>

<p>函数在调用多个参数的时候，在可迭代对象作为实参，并在前面加*</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def d(a,b,c):</span><br><span class="line">    print(a,b,c)</span><br><span class="line"></span><br><span class="line">a=[1,2,3]</span><br><span class="line">b=[1,2,3]</span><br><span class="line">c=[1,2,3]</span><br><span class="line"></span><br><span class="line">d(*a)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=(&quot;liupeng&quot;,&quot;liupeng@qq.com&quot;,&quot;110&quot;,&quot;119&quot;)</span><br><span class="line">name,email,*phone = list</span><br><span class="line">print(phone)</span><br><span class="line">print(name)</span><br><span class="line">print(email)</span><br></pre></td></tr></table></figure>

<p>不管需要分解出多少个电话号码（甚至说没有电话号码），变量phone都一直是一个列表，而这时毫无意义的，如此一来，任何使用了变量phone的代码（万一这些代码默认phone是一个字符串，那么如果出错了，这些代码就不负责任。）</p>
<p>由*修饰的变量也可以位于列表最开始，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=(&quot;liupeng&quot;,&quot;liuxiaopen&quot;,&quot;liupeng@qq.com&quot;)</span><br><span class="line">*name,email=list</span><br><span class="line">print(name)</span><br><span class="line">print(email)</span><br></pre></td></tr></table></figure>

<p>讨论：分解未知或者任意长度的可迭代对象，这种扩展式的操作可谓是是量身定做的工作，通常，这类可迭代对象中会有一些已知的组件或者模式，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line=&quot;E:\qq\3179623450\FileRecv\MobileFile&quot;</span><br><span class="line"></span><br><span class="line">panfu,*dir=line.split(&quot;:&quot;)</span><br><span class="line">print(panfu)</span><br><span class="line">print(dir)</span><br></pre></td></tr></table></figure>

<p>用这种*式的语法所支持的分解操作非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=[&#x27;acme&#x27;,50,39,343,54,232,(12,3,54,2021)]</span><br><span class="line">name,*_,(*_,year)=list</span><br><span class="line">print(name)</span><br><span class="line">print(year)</span><br></pre></td></tr></table></figure>

<p>这个就是说，有时候想分解出某些值然后丢弃他们，在分解的时候，不能只是一个单独的*，可以使用激光常用的来表示要丢掉的变量名。</p>
<p>递归不是python的强项。</p>
<p>递归深度过深（1000），RecursionError: maximum recursion depth exceeded</p>
<p>电脑不同，栈空间或许不同</p>
<p>python为什么对递归有限制，是为了害怕内存溢出。递归有限制，效率低，而且有大量重复计算，时间复杂度搞。默认最大深度1000。</p>
<p><strong>3、保存最后n个元素</strong></p>
<p>问题：我们希望在迭代或者是其他的形式的处理过程中对最后迹象记录做一个有限的历史记录。</p>
<p>解决方案：from collections import deque</p>
<p>讨论：编写搜索某项记录的代码时，通常会用到含有id的生成器。</p>
<p>deque（maxlen=n）创建一个固定长度的队列，当有新纪录加入而队列满了的时候回自动转移那一条最老的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections import deque  # 内部库,内库</span><br><span class="line">q=deque(maxlen=3)</span><br><span class="line">q.append(1)</span><br><span class="line">q.append(2)</span><br><span class="line">q.append(3)</span><br><span class="line">print(q)</span><br><span class="line">q.append(4)</span><br><span class="line">print(q)</span><br></pre></td></tr></table></figure>

<p>尽管在列表中可以使用append与del手动完成这些操作，但是我们使用队列这种解决方法会优雅并且运行速度会快得多。</p>
<p>更普遍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q=deque()</span><br><span class="line">q.append(1)</span><br><span class="line">q.append(2)</span><br><span class="line">q.append(3)</span><br><span class="line">q.append(4)</span><br><span class="line">print(q)</span><br><span class="line">q.appendleft(5)</span><br><span class="line">print(q)</span><br><span class="line">print(q.pop())</span><br></pre></td></tr></table></figure>

<p>从队列两端添加或者弹出元素的步数，1步。O(1)</p>
<p>列表从开始插入或者删除元素，n步，O（n）</p>
<p><strong>4、找到最大或者最小的n个元素</strong></p>
<p>问题：我们想在某个集合中找出最大或者最小的n个元素</p>
<p>解决方案：heapq模块（内库）中有两个函数，nlargest（）和nsmallest（）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line">nums=[1,3,5,65,-1,453,121,-65]</span><br><span class="line">print(heapq.nlargest(2,nums))</span><br><span class="line">print(heapq.nsmallest(2,nums))</span><br></pre></td></tr></table></figure>

<p>这正是我们需要的，这两个函数都可以接受一个参数key，从而允许他们工作在更加复杂的数据结构之下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line">list=[</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng&#x27;,&quot;age&quot;:18,&#x27;class&#x27;:12&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng1&#x27;,&quot;age&quot;:23,&#x27;class&#x27;:45&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng2&#x27;,&quot;age&quot;:43,&#x27;class&#x27;:2&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng3&#x27;,&quot;age&quot;:21,&#x27;class&#x27;:22&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng4&#x27;,&quot;age&quot;:54,&#x27;class&#x27;:62&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng5&#x27;,&quot;age&quot;:23,&#x27;class&#x27;:212&#125;</span><br><span class="line">]</span><br><span class="line">forclass=heapq.nsmallest(3,list,key=lambda s :s[&quot;class&quot;])</span><br><span class="line">minage=heapq.nlargest(3,list,key=lambda s:s[&quot;age&quot;])</span><br><span class="line">print(forclass)</span><br><span class="line">print(minage)</span><br></pre></td></tr></table></figure>

<p>讨论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line">nums=[1,2,3,54,12,546,-324,-54,67512,45,34321,54534,34,53453,465,4645]</span><br><span class="line">heap=list(nums)</span><br><span class="line">heapq.heapify(heap)</span><br><span class="line">print(heapq.heappop(heap))</span><br><span class="line">print(heapq.heappop(heap))</span><br></pre></td></tr></table></figure>

<p>heapify这个方法，排序，从小到大。</p>
<p>那么heap[0]总是最小的那个元素，此外接下来的元素就可以通过headpop方法轻松找到，这个方法将第一个元素（最小的）弹出，然后用第二个元素代替第一个元素。</p>
<p>当所要找的元素相对较小是，nlargest（）和nsmallest（）这个最适合，如果只是想找最大和最小（n=1），min（）和max（）这两个函数更加方便和快捷。如果说n和序列本身的大小差不多。通常先对序列排序，然后做切片。（堆数据结构）</p>
<p><strong>5、实现优先级队列</strong></p>
<p>问题：我们要一个队列，能使用给定的优先级对元素排序，每次pop，都会返回优先级高的元素。</p>
<p>解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"></span><br><span class="line">class Queue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._queue=[]</span><br><span class="line">        self._index=0</span><br><span class="line">    def push(self,item,p):</span><br><span class="line">        heapq.heappush(self._queue,(p,self._index,item))</span><br><span class="line">        self._index+=1</span><br><span class="line">    def pop(self):</span><br><span class="line">        return heapq.heappop(self._queue)[-1]</span><br><span class="line"></span><br><span class="line">class Item:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#x27;Item(&#123;!r&#125;)&#x27;.format(self.name)</span><br><span class="line"></span><br><span class="line">q=Queue()</span><br><span class="line">q.push(Item(&#x27;liupeng&#x27;),1)</span><br><span class="line">q.push(Item(&#x27;liupeng1&#x27;),5)</span><br><span class="line">q.push(Item(&#x27;liupeng2&#x27;),3)</span><br><span class="line">q.push(Item(&#x27;liupeng3&#x27;),8)</span><br><span class="line">q.push(Item(&#x27;liupeng4&#x27;),12)</span><br><span class="line">q.push(Item(&#x27;liupeng5&#x27;),45)</span><br><span class="line">print(q.pop())</span><br><span class="line">print(q.pop())</span><br><span class="line">print(q.pop())</span><br></pre></td></tr></table></figure>

<p><strong>6、在字典中将键映射到多个值上</strong></p>
<p>问题：我们想要一个能将键映射到多个值的字典，一键多值</p>
<p>解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=&#123;</span><br><span class="line">    &quot;a&quot;:[1,2,3],</span><br><span class="line">    &quot;b&quot;:(1,6)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line"># a=defaultdict(list)</span><br><span class="line"># a[&quot;a&quot;].append(1)</span><br><span class="line"># a[&quot;a&quot;].append(2)</span><br><span class="line"># a[&quot;a&quot;].append(3)</span><br><span class="line"># q=&#123;&#125;</span><br><span class="line"># q.setdefault(&#x27;a&#x27;,[]).append(1)</span><br><span class="line"></span><br><span class="line">d=&#123;&#125;</span><br><span class="line">for key,value in pairs:</span><br><span class="line">    if key not in d:</span><br><span class="line">        d[key]=[]</span><br><span class="line">    d[key].append(value)</span><br><span class="line"></span><br><span class="line">w=defaultdict(list)</span><br><span class="line">for jey,value in pairs1:</span><br><span class="line">    d[key].append(value)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构算法</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制语句</title>
    <url>/2021/07/20/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="流程控制语句（练习）"><a href="#流程控制语句（练习）" class="headerlink" title="流程控制语句（练习）"></a>流程控制语句（练习）</h2><h2 id="1、获取用户输入，判断奇数还是偶数"><a href="#1、获取用户输入，判断奇数还是偶数" class="headerlink" title="1、获取用户输入，判断奇数还是偶数"></a>1、获取用户输入，判断奇数还是偶数</h2><p>​    input函数的返回值默认是字符串类型，而字符串类型是无法直接用整形的运算符的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num=int（input(&quot;请输入一个任意的整数：&quot;)）</span><br><span class="line">if num%2==0:</span><br><span class="line">    print(&quot;偶数！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;奇数&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="2、检查一个年份是否是闰年"><a href="#2、检查一个年份是否是闰年" class="headerlink" title="2、检查一个年份是否是闰年"></a>2、检查一个年份是否是闰年</h2><p>​    闰年：年份可以被4整除并且不能被100整除，或者可以被400整除，这个年份刚好就是闰年</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">year=int(input(&quot;请输入一个任意的年份：&quot;))</span><br><span class="line">if year %4==0 and year % 100==0 or year % 400 ==0:</span><br><span class="line">    print(year,&quot;是闰年&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(year,&quot;不是闰年！&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="3、我有一条狗，他叫大鹏，他今年五岁了，他相当于人类多大年龄？"><a href="#3、我有一条狗，他叫大鹏，他今年五岁了，他相当于人类多大年龄？" class="headerlink" title="3、我有一条狗，他叫大鹏，他今年五岁了，他相当于人类多大年龄？"></a>3、我有一条狗，他叫大鹏，他今年五岁了，他相当于人类多大年龄？</h2><p>​    狗的年纪：狗的前两年的每一年相当于人类的10.5岁，然后每一年增加四岁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dog_age=float(input(&quot;请输入狗的年龄：&quot;))</span><br><span class="line">like_person_age=0</span><br><span class="line">if dog_age&gt;0:</span><br><span class="line">    if dog_age&lt;=2:</span><br><span class="line">        like_person_age=dog_age*10.5</span><br><span class="line">    else:</span><br><span class="line">        like_person_age=2*10.5</span><br><span class="line">        like_person_age+=(dog_age-2)*4</span><br><span class="line">    print(dog_age,&quot;岁的狗，相当于人类年龄的&quot;,like_person_age,&#x27;岁&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;请输入一个合法的年龄！&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="4、小鹏的期末成绩"><a href="#4、小鹏的期末成绩" class="headerlink" title="4、小鹏的期末成绩"></a>4、小鹏的期末成绩</h2><p>​    当成绩为100的时候，奖励一台手机</p>
<p>​    当成绩为80到99的时候，奖励一台ps4</p>
<p>​    当成绩为60到79的时候，奖励他一本参考书</p>
<p>​    其他，奖励他一个大嘴巴子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">score=int(input(&quot;请输入小鹏的成绩：&quot;))</span><br><span class="line"># 来一条华丽的分割线</span><br><span class="line">print(&quot;==&quot;*40)</span><br><span class="line"># 检查用户的输入</span><br><span class="line">if 0 &lt;= score &lt;= 100:</span><br><span class="line">    # 判断奖励</span><br><span class="line">    if score == 100:</span><br><span class="line">        print(&quot;奖励一台手机&quot;)</span><br><span class="line">    elif score &gt;= 80:</span><br><span class="line">        print(&quot;ps4，拿去玩吧！&quot;)</span><br><span class="line">    elif score &gt;= 60:</span><br><span class="line">        print(&quot;参考书！拿去！&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;大嘴巴子！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;你的输入内容不合法！&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="5、高富帅问题，小鹏要结婚了，要娶一个女孩子，但是女方家里有条件"><a href="#5、高富帅问题，小鹏要结婚了，要娶一个女孩子，但是女方家里有条件" class="headerlink" title="5、高富帅问题，小鹏要结婚了，要娶一个女孩子，但是女方家里有条件"></a>5、高富帅问题，小鹏要结婚了，要娶一个女孩子，但是女方家里有条件</h2><p>​    高：180dm以上，富：1000块以上，帅：颜值分250以上</p>
<p>​    如果三个条件都满足，“一定能娶到老婆”</p>
<p>​    如果三个条件有一个满足，“有可能娶到老婆”</p>
<p>​    如果三个条件都不满足，“一定娶不到”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">height=int(input(&quot;请输入你的身高！&quot;))</span><br><span class="line">money=int(input(&quot;请输入你的余额！&quot;))</span><br><span class="line">face=int(input(&quot;你觉得你这张脸能打多少分！&quot;))</span><br><span class="line">if height &gt;180 and money &gt;1000 and fcae &gt; 250:</span><br><span class="line">    print(&quot;一定能娶到老婆&quot;)</span><br><span class="line">elif height &gt;180 or money &gt;1000 or face &gt; 250:</span><br><span class="line">    print(&quot;有可能娶到老婆&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;不嫁给你！&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="6、大鹏大战白骨精"><a href="#6、大鹏大战白骨精" class="headerlink" title="6、大鹏大战白骨精"></a>6、大鹏大战白骨精</h2><p>​    首先，你可以有两个身份，大鹏和白骨精</p>
<p>​    其次，你有生命值和攻击力，生命值归0，那一方输了，另一方胜利。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示欢迎信息</span><br><span class="line"></span><br><span class="line">print(&quot;+&quot;*40)</span><br><span class="line">print(&quot;欢迎来到大鹏大战白骨精&quot;)</span><br><span class="line">print(&quot;+&quot;*40)</span><br><span class="line"></span><br><span class="line"># 身份选择</span><br><span class="line"></span><br><span class="line">print(&quot;请选择你的身份！&quot;)</span><br><span class="line">print(&quot;\t 1.大鹏&quot;)</span><br><span class="line">print(&quot;\t 2.白骨精&quot;)</span><br><span class="line">player_choose=input(&quot;请选择[1|2]&quot;)</span><br><span class="line"></span><br><span class="line"># 华丽的分割线</span><br><span class="line"></span><br><span class="line">print(&quot;+&quot;*40)</span><br><span class="line"></span><br><span class="line"># 提示信息</span><br><span class="line"></span><br><span class="line">if player_choose==&quot;1&quot;:</span><br><span class="line">    print(&quot;你已经选择了1，你将会用大鹏的身份来进行游戏！&quot;)</span><br><span class="line">elif player_choose==&quot;2&quot;:</span><br><span class="line">    print(&quot;你居然选了白骨精！你还是会用大鹏的身份进行游戏！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;你的输入有问题！系统将自动分配身份！你将成为不要脸的大鹏！&quot;)</span><br><span class="line"></span><br><span class="line"># 进行游戏</span><br><span class="line"></span><br><span class="line">player_life=100</span><br><span class="line">player_attack=1000</span><br><span class="line"></span><br><span class="line">boss_life=10000</span><br><span class="line">boss_attack=10</span><br><span class="line"></span><br><span class="line"># 华丽的分割线</span><br><span class="line"></span><br><span class="line">print(&quot;+&quot;*40)</span><br><span class="line">print(f&#x27;大鹏，你的生命值是&#123;player_life&#125;,你的攻击力是&#123;player_attack&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(&quot;请选择你要做的操作！&quot;)</span><br><span class="line">    print(&#x27;\t 1.练级&#x27;)</span><br><span class="line">    print(&#x27;\t 2.打boss&#x27;)</span><br><span class="line">    print(&#x27;\t 3.逃跑&#x27;)</span><br><span class="line">    game_choose=input(&quot;请选择要做的操作！&quot;)</span><br><span class="line">   if game_choose==&#x27;1&#x27;:</span><br><span class="line">    player_life+=1</span><br><span class="line">    player_attack+=1</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(f&quot;恭喜你升级了，你现在的生命值是&#123;player_life&#125;,你的攻击力是&#123;player_attack&#125;&quot;)</span><br><span class="line"></span><br><span class="line">elif game_choose==&#x27;2&#x27;:</span><br><span class="line">    boss_life-=player_attack</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(&#x27;大鹏偷袭了白骨精！不讲武德！&#x27;)</span><br><span class="line">    if boss_life &lt;=0:</span><br><span class="line">        print(f&#x27;白骨精受到了&#123;player_attack&#125;点伤害，重伤不治，最终还是死了，大鹏获得了胜利！&#x27;)</span><br><span class="line">        break</span><br><span class="line">    </span><br><span class="line">    player_life-=boss_attack</span><br><span class="line">    print(&#x27;白骨精攻击了大鹏，大快人心！&#x27;)</span><br><span class="line">    if player_life &lt;=0:</span><br><span class="line">        print(f&#x27;大鹏受到了&#123;boss_attack&#125;点伤害，重伤不治，最后死了！game over!&#x27;)</span><br><span class="line">        break</span><br><span class="line">elif game_choose==&#x27;3&#x27;:</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(&#x27;大鹏扭头就跑！，撒腿就跑！game over!&#x27;)</span><br><span class="line">    break</span><br><span class="line">else:</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(&quot;你的输入有问题&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="7、求1000以内的所有的质数"><a href="#7、求1000以内的所有的质数" class="headerlink" title="7、求1000以内的所有的质数"></a>7、求1000以内的所有的质数</h2><p>（质数就是除了1和他本身，不能被其他数整除的数，除数，被除数）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个循环，求1-1000以内的质数</span><br><span class="line">i=2</span><br><span class="line">while i&lt;=1000:</span><br><span class="line">    # 创建一个变量，储存一下i的状态</span><br><span class="line">    flag=True</span><br><span class="line">    # 判断i是否为质数</span><br><span class="line">    j=2</span><br><span class="line">    while j &lt; i:</span><br><span class="line">        if i % j == 0:</span><br><span class="line">            flag=False</span><br><span class="line">        j += 1</span><br><span class="line">    if flag:</span><br><span class="line">        print(i)</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure>

<h2 id="8、求1000以内的水仙花数"><a href="#8、求1000以内的水仙花数" class="headerlink" title="8、求1000以内的水仙花数"></a>8、求1000以内的水仙花数</h2><p>水仙花数：是一个n位数（n&gt;=3），他的每一个位上的数字的n次幂之和等于它本身<br>$$<br>153=1<strong>3+5</strong>3+3**3<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 求1000以内的水仙花数</span><br><span class="line">i = 100</span><br><span class="line">while i &lt; 1000 :</span><br><span class="line">    # 假设 i的百位数是a，十位数是b，个位数是c</span><br><span class="line">    a = i // 100</span><br><span class="line">    # b = i // 10 % 10</span><br><span class="line">    b = ( i- a * 100 ) // 10</span><br><span class="line">    c = i % 10</span><br><span class="line">    if a ** 3 + b ** 3 + c ** 3 == i:</span><br><span class="line">        print(i)</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure>

<h2 id="9、打印99乘法表"><a href="#9、打印99乘法表" class="headerlink" title="9、打印99乘法表"></a>9、打印99乘法表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个循环，来控制高度</span><br><span class="line">i = 0</span><br><span class="line">while i &lt; 9:</span><br><span class="line">    i += 1</span><br><span class="line">    # 创建一个循环，来控制宽度</span><br><span class="line">    j = 0</span><br><span class="line">    while j &lt; i:</span><br><span class="line">        j += 1</span><br><span class="line">        print(f&quot;&#123;j&#125;*&#123;i&#125;=&#123;i*j&#125; &quot;,end=&quot;&quot;)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>真正的看python（1）</title>
    <url>/2021/07/20/%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%9C%8Bpython%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="真正的看python（1）"><a href="#真正的看python（1）" class="headerlink" title="真正的看python（1）"></a>真正的看python（1）</h1><h2 id="1、python是一门解释性语言嘛？"><a href="#1、python是一门解释性语言嘛？" class="headerlink" title="1、python是一门解释性语言嘛？"></a>1、python是一门解释性语言嘛？</h2><p>是但不完全是，python其实是一门基于虚拟机的语言，首先他有三门主要的解释器，他利用这个解释器，来解释并且执行自己定义的语法来生成代码执行。解释性语言并不需要编译。</p>
<p>再说的清楚一点、计算机并不能直接理解我们的语言，他只能理解机器语言，也就是0和1，因此，我们需要进行翻译。</p>
<p>而翻译，有两种，一种就是解释、一种就是编译。</p>
<p>编译型语言、在我们的程序执行之前，会通过编译器编译为机器语言</p>
<p>，那么在运行的时候，就不需要翻译，直接执行就可以了，最典型的例子就是c。</p>
<p>解释型语言、没有提前编译的过程，在程序运行的时候，通过解释器对程序逐行做出解释，然后执行。</p>
<p>可以发现，从效率上来说，势必的，编译型语言的效率绝对是要比解释型语言要强的，但是现在的热门语言其实已经脱离了单纯的编译和解释的差别。</p>
<p>例如，java，java先通过编译器编译成字节码文件，然后运行时通过解释器解释成机器文件，可以说java是先编译再解释的语言。</p>
<p>python，其实和java一样，都是基于虚拟机的，同样也是先编译再解释的语言。</p>
<p>py文件，pyc文件，pycodeobject文件。</p>
<p>py文件不用说，就是我们写的，pyc我们也能在硬盘上看到。</p>
<p>pycodeobject其实是python编译器真正编译成的结果，只不过当程序运行时，这个文件被保存在内存中，运行完了后，解释器会把这个文件写到pyc文件中，当程序第二次运行时，首先会寻找pyc文件，然后对py和pyc的时间戳判断，是否修改过，没有的话，就直接载入pyc。</p>
<p>那么就很清晰了，pyc其实就是pyo的持久化存储方式。</p>
<h2 id="2、python的面向对象"><a href="#2、python的面向对象" class="headerlink" title="2、python的面向对象"></a>2、python的面向对象</h2><p>首先，要明白，面向对象是一种编程方式、基于的是类和对象的使用。</p>
<p>类是一个模板，封装了多个函数和变量。对象就是根据模板创建的实例。</p>
<p>面向对象有三大特性，封装、继承、多态。</p>
<p>来看看类。</p>
<span id="more"></span>

<p>类有成员，即字段、方法和属性。</p>
<p>java中static修饰了静态的变量和方法。而静态变量被储存在方法区里，实际上，static修饰的变量已经成为了类的成员。（没学过java的可以略过这一段）</p>
<p>在python里，字段分为两种类型，一种是在函数外定义的普通字段，这一类字段，只需要声明变量名和初始值就可以，同时这一类的字段属于类的成员，在实例化为对象的时候，是保存在内存中的、访问也是类型变量名的形式去访问，而另外一种，则是写在init初始化函数的变量，这一类的我们称之为静态字段，静态字段不同的是，这是保存在对象中的内容。</p>
<p>简明一点来说，普通字段定义在函数体外，同时属于对象。静态字段定义在init初始化函数体内，属于类。</p>
<p>那么在访问方式上的差别也就比较明显了，普通字段是通过对象访问的，静态字段则是由类去访问的。</p>
<p>再推导开去，静态字段在类中，那么在内存中，只保存一份，但是普通字段属于对象，那么就意味着每初始化一次对象、就会保存一份普通字段。</p>
<p>那么回到场景之中，如果说每个对象都有相同的字段时，那么就可以静态字段了。</p>
<p>方法，不存在属于类或者对象的差异，因为无论是类方法还是静态方法还是普通的方法，这三种方法在内存中都归属于类，区别仅仅是调用方式的差异罢了。</p>
<p>普通方法：由对象来调用，至少要有一个self参数，执行普通方法时，自动将调用方法的对象赋值个self。</p>
<p>类方法：由类来调用，至少一个cls参数，执行类方法是，自动将调用该方法的类赋值给cls。</p>
<p>静态方法：由类来调用，没有默认的参数</p>
<p>其实对于方法而言，都属于类，在内存当中只保存一份，只是在调用的时候，调用者不同，那么自动传入的参数也不同罢了。</p>
<p>属性，属性其实严格意义上说是一种特殊的普通方法。</p>
<p>定义时，使用装饰器定义，只有一个self参数，调用的时候，不用括号。</p>
<p>属性存在的意义是，访问属性时可以制造出和访问字段完全相同的假象，它由方法变种而来，如果没有属性，那么方法可以完全代替他。</p>
<p>那么属性的功能其实就很清楚了，内部进行一系列的逻辑计算，最红返回一个计算结果。</p>
<p>python的类是分为经典类和新式类的，其中新式类的属性比经典类的属性要丰富一些（两者的区别，就是是否继承了object，继承了就是新式类）</p>
<p>经典类中，具有一种装饰器。</p>
<p>新式类中，具有三种装饰器定义属性。</p>
<p>经典类中的属性只有一种访问方式，其对应被 <code>@property</code> 修饰的方法</p>
<p>新式类中的属性有三种访问方式，并分别对应了三个被<code>@property</code>、<code>@方法名.setter</code>、<code>@方法名.deleter</code>修饰的方法</p>
<p>由于新式类中具有三种访问方式，我们可以根据他们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p>
<p>静态字段方式，创建值为property对象的静态字段</p>
<p>当使用静态字段的方式创建属性时，经典类和新式类无区别</p>
<p>property的构造方法中有个四个参数</p>
<ul>
<li>第一个参数是方法名，调用 <code>对象.属性</code> 时自动触发执行方法</li>
<li>第二个参数是方法名，调用 <code>对象.属性 ＝ XXX</code> 时自动触发执行方法</li>
<li>第三个参数是方法名，调用 <code>del 对象.属性</code> 时自动触发执行方法</li>
<li>第四个参数是字符串，调用 <code>对象.属性.__doc__</code> ，此参数是该属性的描述信息</li>
</ul>
<p>由于静态字段方式创建属性具有三种访问方式，我们可以根据他们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p>
<p>所以，定义属性共有两种方式，分别是【装饰器】和【静态字段】，而【装饰器】方式针对经典类和新式类又有所不同。</p>
<p><strong>类成员的修饰符</strong></p>
<p>类的所有成员在上一步骤中已经做了详细的介绍，对于每一个类的成员而言都有两种形式：</p>
<ul>
<li>公有成员，在任何地方都能访问</li>
<li>私有成员，只有在类的内部才能方法</li>
</ul>
<p><strong>私有成员和公有成员的定义不同：</strong>私有成员命名时，前两个字符是下划线。（特殊成员除外，例如：<strong>init</strong>、<strong>call</strong>、<strong>dict</strong>等）</p>
<p><strong>私有成员和公有成员的访问限制不同：</strong></p>
<p><strong>静态字段</strong></p>
<ul>
<li>公有静态字段：类可以访问；类内部可以访问；派生类中可以访问</li>
<li>私有静态字段：仅类内部可以访问</li>
</ul>
<p><strong>普通字段</strong></p>
<ul>
<li>公有普通字段：对象可以访问；类内部可以访问；派生类中可以访问</li>
<li>私有普通字段：仅类内部可以访问；</li>
</ul>
<p>ps：如果想要强制访问私有字段，可以通过 【对象._类名__私有字段明 】访问（如：obj._C__foo），不建议强制访问私有成员。</p>
<p>方法、属性的访问于上述方式相似，即：私有成员只能在类内部使用</p>
<p><em>ps：非要访问私有属性的话，可以通过</em> <em><code>对象._类__属性名</code></em></p>
<p><strong>类的特殊成员</strong></p>
<p>上文介绍了Python的类成员以及成员修饰符，从而了解到类中有字段、方法和属性三大类成员，并且成员名前如果有两个下划线，则表示该成员是私有成员，私有成员只能由类内部调用。无论人或事物往往都有不按套路出牌的情况，Python的类成员也是如此，存在着一些具有特殊含义的成员，详情如下：</p>
<p><strong>1.</strong> <strong>doc</strong></p>
<p>表示类的描述信息</p>
<p><strong>2.</strong> <strong>module</strong> <strong>和</strong> <strong>class</strong></p>
<ul>
<li><strong>module</strong> 表示当前操作的对象在那个模块</li>
<li><strong>class</strong> 表示当前操作的对象的类是什么</li>
</ul>
<p><strong>3.</strong> <strong>init</strong></p>
<p>构造方法，通过类创建对象时，自动触发执行。</p>
<p><strong>4.</strong> <strong>del</strong></p>
<p>析构方法，当对象在内存中被释放时，自动触发执行。</p>
<p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p>
<p><strong>5.</strong> <strong>call</strong></p>
<p>对象后面加括号，触发执行。</p>
<p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p>
<p><strong>6.</strong> <strong>dict</strong></p>
<p>类或对象中的所有成员</p>
<p>上文中我们知道：类的普通字段属于对象；类中的静态字段和方法等属于类.</p>
<p><strong>7.</strong> <strong>str</strong></p>
<p>如果一个类中定义了<strong>str</strong>方法，那么在打印 对象 时，默认输出该方法的返回值。</p>
<p><strong>8、getitem、setitem、delitem</strong></p>
<p>用于索引操作，如字典。以上分别表示获取、设置、删除数据</p>
<p><strong>9、getslice、setslice、delslice</strong></p>
<p>该三个方法用于分片操作</p>
<p><strong>10.</strong> <strong>iter</strong></p>
<p>用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了 <strong>iter</strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>笔趣阁爬虫—scrapy小实例</title>
    <url>/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="笔趣阁爬虫—scrapy小实例"><a href="#笔趣阁爬虫—scrapy小实例" class="headerlink" title="笔趣阁爬虫—scrapy小实例"></a>笔趣阁爬虫—scrapy小实例</h1><h2 id="项目环境："><a href="#项目环境：" class="headerlink" title="项目环境："></a>项目环境：</h2><h3 id="基础环境："><a href="#基础环境：" class="headerlink" title="基础环境："></a>基础环境：</h3><p>Windows10主机</p>
<p>Python 3.9（版本不一，可能写法不同）</p>
<p>Pycharm 2021.1.3</p>
<h3 id="外部库："><a href="#外部库：" class="headerlink" title="外部库："></a>外部库：</h3><p>scrapy（注意scrapy基于c语言的异步组件twisted，自行下载）</p>
<p>Pymysql，连接数据库。</p>
<h2 id="下载与安装（略）、"><a href="#下载与安装（略）、" class="headerlink" title="下载与安装（略）、"></a>下载与安装（略）、</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>与传统意义的爬虫一样，scrapy也是通过对目标url发起请求来获取响应信息，而后解析这些信息，来得到我们想要的数据，</p>
<p>但是与传统爬虫不一样的，scrapy使用了c语言编写的异步组件来实现异步请求，从而大大的提高了爬虫的效率，众所周知，python是没有真正的多线程的，因此纯python开发的爬虫在scrapy面前不堪一击。</p>
<p>异步往往意味着一些不好的事情发生，例如爬取小说网站中最为关注的顺序问题。</p>
<p>​    同时，scrapy作为一个框架，我们不需要编写全部的代码，同时我们也不能那么去做，就如同一个工厂，我们只需要在里面添加内容就可以了。</p>
<p>新笔趣阁，这是我们要爬取的目标网站，</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image002.png" alt="img"></p>
<p>与传统小说网站一样，我们需要首先对主页中的全部小说页面发起请求，之后在拿到每一本小说对应的url。</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image003.png" alt="img"></p>
<p>在拿到这样的数据之后，我们继续对这个url进行请求。</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image005.png" alt="img"></p>
<p>发起请求，网站给我们返回了一个章节列表，同样我们需要解析出url地址并且逐个访问。</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image007.png" alt="img"></p>
<p>来到正文页面解析，这里就是我们想要的数据了。</p>
<h2 id="编写items，确定字段"><a href="#编写items，确定字段" class="headerlink" title="编写items，确定字段"></a>编写items，确定字段</h2><p>这是scrapy中的关键文件之一，首先你要确定自己想要获取的信息，在本例中，设置了三个变量，在分别对应，小说名，章节名以及章节内容。</p>
<p>当然你也可以选择扩充，不过在这里要提醒你的是，无论我们如何去写，最终的结果都是，数以百万甚至更多的url摆在哪里，我们需要对每个url发送一次请求，要想保证效率，又想要数据的准确性，说实话，items里的数据，全部在最底层的网页中比较好。</p>
<p>观察如上的网页，我们确定好三个字段。</p>
<p>Items文件内容如下：</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image009.png" alt="img"></p>
<h2 id="Setting文件，设置编码以及是否遵循robot协议"><a href="#Setting文件，设置编码以及是否遵循robot协议" class="headerlink" title="Setting文件，设置编码以及是否遵循robot协议"></a>Setting文件，设置编码以及是否遵循robot协议</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image011.png" alt="img"></p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image013.png" alt="img"></p>
<h2 id="编写管道文件，连接数据库"><a href="#编写管道文件，连接数据库" class="headerlink" title="编写管道文件，连接数据库"></a>编写管道文件，连接数据库</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image015.png" alt="img"></p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image017.png" alt="img"></p>
<p>值得一提的是，在管道文件中，写入了异常处理语句，以及插入数据的时候添加的双引号，具体是针对于，某些章节特殊符号的出现，出现写入异常，从而终止了爬虫，添加双引号是为了贴合mysql的规范，避免1064错误。</p>
<h2 id="真正的爬虫，demo"><a href="#真正的爬虫，demo" class="headerlink" title="真正的爬虫，demo"></a>真正的爬虫，demo</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image019.png" alt="img"></p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image021.png" alt="img"></p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image023.png" alt="img"></p>
<p>这是真正的爬虫主体，我们需要先设置域名，然后确定第一个url，值得一提，我使用了yield这个生成器来逐个发起请求，但是这并不意味着一定的一致性，因为twisted的关系，同样可能会出现数据不一致的情况，所以尽量保证所有数据在最底层的url里。通过逐步解析url，最终得到数据，提交给管道储存。</p>
<h2 id="Start，编写启动脚本"><a href="#Start，编写启动脚本" class="headerlink" title="Start，编写启动脚本"></a>Start，编写启动脚本</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image024.png" alt="img"></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="item的数据只有最后一条"><a href="#item的数据只有最后一条" class="headerlink" title="item的数据只有最后一条"></a>item的数据只有最后一条</h3><p>出现这种情况一般存在是在需要进行遍历的时候，将item对象放在了for循环的外面，解决方法：直接放进去就可以了。</p>
<h3 id="item字段传递后混乱、错误"><a href="#item字段传递后混乱、错误" class="headerlink" title="item字段传递后混乱、错误"></a>item字段传递后混乱、错误</h3><p>有时候遇到这种情况，item传递几次之后，发现不同页面的数据被混乱的组合在了一起，这种情况一般出在item的传递过程中，解决方式可以像我那样，将所有要存放的数据全部放在最后一层里，但是这并不友好，因此，建议是使用深拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">def parse_base(self,response):</span><br><span class="line"></span><br><span class="line">  base_url = &#x27;https://www.base_url.com&#x27;</span><br><span class="line"></span><br><span class="line">  for result in result_list:</span><br><span class="line"></span><br><span class="line">​    item = ExampleItem()</span><br><span class="line"></span><br><span class="line">​    item[&#x27;name&#x27;] = result.css(&#x27;div a::text&#x27;).extract_first()</span><br><span class="line"></span><br><span class="line">​    item[&#x27;age&#x27;] = result.css(&#x27;div #id&#x27;).extract_first()</span><br><span class="line"></span><br><span class="line">​    yield scrapy.Request(url=base_url,meta=copy.deepcopy(&#123;&#x27;item&#x27;:item&#125;),callback=self.parse_detail) # 使用深拷贝将item存在meta中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">def parse_detail(self,response):</span><br><span class="line"></span><br><span class="line">  item = response.meta[&#x27;item&#x27;] # 取出之前传递的item</span><br><span class="line"></span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  do some thing</span><br><span class="line"></span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  yield item</span><br></pre></td></tr></table></figure>



<h3 id="对一个页面要进行多种的解析"><a href="#对一个页面要进行多种的解析" class="headerlink" title="对一个页面要进行多种的解析"></a>对一个页面要进行多种的解析</h3><p>出现这种情况的原因是，scrapy默认的对同一个url，相同的body以及相同的请求视为一个请求，但是如果我们想要对同一页面有不同的请求时，就会发现默认情况下只能得到第一个parse的结果。解决方式：设置参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def start_requests(self):</span><br><span class="line"></span><br><span class="line">  base_url = &#x27;https://www.base_url.com&#x27;</span><br><span class="line"></span><br><span class="line">  yield scrapy.Request(url=base_url,dont_filter=&#x27;True&#x27;,callback=self.parse_one)</span><br><span class="line"></span><br><span class="line">  yield scrapy.Request(url=base_url,dont_filter=&#x27;True&#x27;,callback=self.parse_two)</span><br></pre></td></tr></table></figure>



<h3 id="Xpath中contains的使用"><a href="#Xpath中contains的使用" class="headerlink" title="Xpath中contains的使用"></a>Xpath中contains的使用</h3><p>这种情况出现在标签没有特定属性值但是文本中又包含了特定的汉字的时候，当然也可以包含特定的属性值来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def parse(self,response):</span><br><span class="line"></span><br><span class="line">  item = BookItem()</span><br><span class="line"></span><br><span class="line">  item[&#x27;author&#x27;] = response.xpath(&#x27;//span[contains(.//text(),&quot;作者：&quot;)]//text()&#x27;).split(&#x27;作者：&#x27;)[-1] # 先用contains限定好特定的span标签，然后取出文本字符串并进行字符串切片得到需要的信息。下同</span><br><span class="line"></span><br><span class="line">  item[&#x27;book_name&#x27;] = response.xpath(&#x27;//span[contains(.//text(),&quot;书名：&quot;)]//text()&#x27;).split(&#x27;书名：&#x27;)[-1]</span><br><span class="line"></span><br><span class="line">  yield item</span><br><span class="line"></span><br><span class="line">### 提取不在</span><br></pre></td></tr></table></figure>

<h3 id="标签的文本内容"><a href="#标签的文本内容" class="headerlink" title="标签的文本内容"></a>标签的文本内容</h3><p>这种情况也会出现，加入文本在两个标签中间，但是不属于任何一个，此时可以用xpath或者正则来解决这个问题。</p>
<h3 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h3><p>当页面数据需要登陆进行抓取时，就需要模拟登陆了。常见的方式有：使用登陆后的cookie来抓取数据；发送表单数据进行登陆；使用自动化测试工具登陆，比如selenium配合chrome、firefox等，不过听说selenium不再更新，也可以使用chrome的无头模式。鉴于自动化测试的抓取效率比较低，而且我确实很久没使用过这个了。本次只讨论使用cookie和发送表单两种方式来模拟登陆。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/2021/07/20/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>函数</p>
<p>python是一门面向对象的语言，万物皆是对象（一切其实皆函数（不准确，不正确））</p>
<p>函数也是一种对象（内存中专门用来储存数据的一块区域）</p>
<p>函数可以保存一些可执行的代码，并且，在需要的时候，这一部分代码可以重复的使用。</p>
<p>创建函数：</p>
<p>def 函数名（形参1，形参2…..）：</p>
<p>​    代码块</p>
<p>函数名的命名规范，（不能占用保留字符，可以包含字母、数字、下划线，但是不能用数字开头）</p>
<p>函数中保存的代码不会立即执行，而是要调用才会执行（注意函数的参数）</p>
<p>调用函数</p>
<p>函数名（参数）</p>
<p>函数可以没有参数，也可以有多个参数，调用时必须要符合定义的规范</p>
<p>参数</p>
<p>形参（就相当于在函数内部声明了一个变量），多个形参用逗号隔开</p>
<p>实参（实际参数）调用函数的时候，传递进来的参数，实参会赋值给形参</p>
<p>有几个形参就要几个实参</p>
<p>函数式的编程</p>
<p>在python中，函数式一等对象</p>
<p>一等对象，如下特点</p>
<p>1、对象是在运行时创建的</p>
<p>2、能赋值给变量或者作为数据结构中的元素</p>
<p>3、能作为参数转递</p>
<p>4、能作为返回值返回</p>
<p>高阶函数</p>
<p>第一、接受一个或者多个函数作为参数</p>
<p>第二、将函数作为返回值返回</p>
<p>第三、装饰器</p>
<p>类与对象</p>
<p>面向对象</p>
<p>所谓的面向对象、简单来说就是所有操作都可以通过对象来实现</p>
<p>面向过程、将程序拆解成一个个的步骤</p>
<p>大鹏上学记</p>
<p>​    1、妈妈起床</p>
<p>​    2、妈妈上厕所</p>
<p>​    3、妈妈洗漱</p>
<p>​    4、妈妈做早饭</p>
<p>​    5、妈妈叫大鹏</p>
<p>​    6、大鹏上厕所</p>
<p>​    7、大鹏洗漱</p>
<p>​    8、大鹏吃早饭</p>
<p>​    9、背上书包</p>
<p>​    10、上学校‘</p>
<p>编程思想（面向过程）：将一个功能拆分成许多的小步骤</p>
<p>只适用于一个功能，如果要实现另外一个功能，即使两个功能相差很小，但是依旧要重新写代码</p>
<p>复用性比较低，难于维护</p>
<p>面向对象：关注的不是过程，关注的是对象</p>
<p>大鹏上学记</p>
<p>​    1、大鹏妈妈叫大鹏上学</p>
<p>编程思想（面向对象），将所有的功能保存到一个对象里</p>
<p>比如，妈妈的功能保存到妈妈对象里，大鹏的功能保存到大鹏的对象里，要使用这个功能，直接来找对象。</p>
<p>（要值得一提的是，作为一个功能来讲，（中小功能），面向过程写起来比较酣畅淋漓，同时比较快）</p>
<p>简单归纳一下，面向对象的思想：1、找对象、2、搞对象（设计对象，做对象）、调用对象</p>
<p>类（class）</p>
<p>类和对象是什么关系</p>
<p>类就是对象的图纸！</p>
<p>对象是类的实例</p>
<p>类也是一个对象（一个用来创建对象的对象）</p>
<p>类：</p>
<p>生活中所有的事物都可以抽象出来</p>
<p>1、数据（属性） 变量</p>
<p>2、行为（方法） 函数</p>
<p>所有的这个类的实例都可以对象.属性来访问这个变量，对象.方法（）都可以来调用这个方法</p>
<p>定义一个类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 类名（）:</span><br><span class="line">	公共的一些属性</span><br><span class="line">	a=1</span><br><span class="line">	b=2</span><br><span class="line">	</span><br><span class="line">	对象的初始化方法</span><br><span class="line">	def __init__(self,...):</span><br><span class="line">		...</span><br><span class="line">	其他的方法</span><br><span class="line">	def method():</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<p>p1=类名（）（创建了一个对象，根据类名的那个类）然后，初始化方法就会自动调用，其他方法需要手动调用。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器、生成器与装饰器</title>
    <url>/2021/07/21/%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p>迭代器、生成器与装饰器</p>
<p>迭代器</p>
<p>迭代几乎是python最强的功能之一，是访问集合元素的一种方式</p>
<p>for i in rang(1,101)</p>
<p>迭代器是一个可以记住遍历的位置的<strong>对象</strong></p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完，结束</p>
<p>迭代器<strong>只能前进，不能后退</strong>。</p>
<p>迭代器基本方法：iter（）和next（）</p>
<p>迭代器用在哪儿？（字符串、列表、元组等对象都可以创建迭代器）（序列）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=[1,2,3,4,5]</span><br><span class="line">it=iter(list)</span><br></pre></td></tr></table></figure>

<p>for语句遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=[1,2,3,4,5]</span><br><span class="line">it =iter(list)</span><br><span class="line">for i in it:</span><br><span class="line">	print(i,end=&#x27; &#x27;)</span><br></pre></td></tr></table></figure>

<p>next()函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">list=[1,2,3,4,5]</span><br><span class="line">it =iter(list)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">	try:</span><br><span class="line">		print(next(it))</span><br><span class="line">	except StopIteration:</span><br><span class="line">		sys.exit()</span><br></pre></td></tr></table></figure>

<p>创建一个迭代器</p>
<p>类有一个构造函数，python中，他会在对象初始化的时候执行</p>
<p>迭代器类里，iter()方法返回一个特殊的迭代器对象，这个迭代器对象实现了next（）并且通过StopIteration</p>
<p>异常的标识来判断迭代是否完成</p>
<p>next（）方法返回下一个迭代器的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        self.a=1</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        x = self.a</span><br><span class="line">        self.a+=1</span><br><span class="line">        return x</span><br><span class="line">myclass=MyNumbers()</span><br><span class="line">myiter=iter(myclass)</span><br><span class="line"></span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>

<p>以上的代码把一个类当做了迭代器，我们不难发现，需要至少实现两个方法，iter和next。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        self.a=1</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.a &lt;= 3:</span><br><span class="line">            x = self.a</span><br><span class="line">            self.a+=1</span><br><span class="line">            return x</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration</span><br><span class="line">myclass=MyNumbers()</span><br><span class="line">myiter=iter(myclass)</span><br><span class="line"></span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>

<p>以上代码，使用了stopiteration异常来限制了循环的次数（迭代的次数）</p>
<p>所有的技术都要根据使用场景来。</p>
<span id="more"></span>

<p>生成器</p>
<p>python中，使用了yield的函数被成为生成器</p>
<p>跟普通函数不同，生成器是一个返回迭代器的函数，只能用于迭代操作，简单理解，生成器就是一个迭代器</p>
<p>在调用生成器，运行的过程中，遇到yield函数会暂停并且保存当前所有的运行信息，返回yield的值</p>
<p>在下一次执行next方法时继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象</p>
<p>yield来实现斐波那契数列(从第三项开始，每一项等于前面两项之和的数列)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def fibonaqi(n):# 生成器函数</span><br><span class="line">    a,b,counter=0,1,0</span><br><span class="line">    while True:</span><br><span class="line">        if (counter &gt; n):</span><br><span class="line">            return</span><br><span class="line">        yield a</span><br><span class="line">        a,b=b,a+b</span><br><span class="line">        counter+=1</span><br><span class="line">f=fibonaqi(10) # f是一个迭代器，由生成器返回生成</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print(next(f),end=&#x27; &#x27;)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<p>装饰器</p>
<p>装饰器之前，先来理解一个概念（闭包）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a():</span><br><span class="line">    s=&#x27;i am liupeng!&#x27;</span><br><span class="line"></span><br><span class="line">    # p是一个嵌套函数</span><br><span class="line">    def p():</span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line">    return p</span><br><span class="line"># 把a函数赋值给变量myclass的时候，这个就获得了一个闭包</span><br><span class="line"># s是一个局部变量，在a函数结束之后就不会存在了。</span><br><span class="line"># 但是现在我们使用了一个嵌套函数，把这个局部变量封闭在了嵌套函数中</span><br><span class="line"># 这样子就形成了一个闭包</span><br><span class="line">myclass=a()</span><br><span class="line">myclass()</span><br><span class="line"># 闭包其实就是一个引用了自有变量的函数</span><br><span class="line"># 函数保存了执行的上下文，可以脱离原本的作用域而存在。</span><br></pre></td></tr></table></figure>

<p>装饰器是python一个重要部分，他是一个函数（修改其他函数功能的函数）有助于让代码更短</p>
<p>父类与子类。</p>
<p>一切皆可对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a(name=&#x27;liupeng&#x27;):</span><br><span class="line">    return &quot;hello  &quot; + name</span><br><span class="line"># print(a())</span><br><span class="line">b=a</span><br><span class="line"># 为什么我不用小括号呐？因为我并不是在调用函数，而是把这个函数放在变量里面</span><br><span class="line"># print(b())</span><br><span class="line">del a</span><br><span class="line"># print(a())</span><br><span class="line">print(b())</span><br></pre></td></tr></table></figure>

<p>函数的嵌套</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a(name=&#x27;liupeng&#x27;):</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">    def b():</span><br><span class="line">        return &#x27;2&#x27;</span><br><span class="line">    def c():</span><br><span class="line">        return &quot;3&quot;</span><br><span class="line"></span><br><span class="line">    print(b())</span><br><span class="line">    print(c())</span><br><span class="line">    print(&quot;4&quot;)</span><br><span class="line"></span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<p>函数中返回函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a(name=&#x27;liupeng&#x27;):</span><br><span class="line">    def b():</span><br><span class="line">        return 1</span><br><span class="line">    def c():</span><br><span class="line">        return 2</span><br><span class="line">    if True:</span><br><span class="line">        return b</span><br><span class="line">    else:</span><br><span class="line">        return c</span><br><span class="line">x=a()</span><br><span class="line">print(x)</span><br><span class="line">print(x())</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># x=a() a函数会被执行，而由于判断条件时true，那么b会被返回，如果是flase，那么c会被返回</span><br><span class="line"># 我们还可以打印出a（）（）</span><br></pre></td></tr></table></figure>

<p>把函数作为参数传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a():</span><br><span class="line">	return 1</span><br><span class="line">def b(func):</span><br><span class="line">	print(2)</span><br><span class="line">	print(func())</span><br><span class="line">b(a)</span><br></pre></td></tr></table></figure>

<p>装饰器（最简单的装饰器）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a(a_func):</span><br><span class="line">    def b():</span><br><span class="line">        print(1)</span><br><span class="line"></span><br><span class="line">        a_func()  # c（）</span><br><span class="line"></span><br><span class="line">        print(2)</span><br><span class="line">    return b</span><br><span class="line">def c():</span><br><span class="line">    print(3)</span><br><span class="line"># c()</span><br><span class="line">c=a(c)</span><br><span class="line">c()</span><br></pre></td></tr></table></figure>

<p>装饰器：封装一个函数，并且用不同的方式去修改它的行为，@是一个简短的方式来生成一个被装饰的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@a</span><br><span class="line">def c():</span><br><span class="line">	print(3)</span><br><span class="line">c()</span><br><span class="line">c=a(c)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line">def a_name(f):</span><br><span class="line">    @wraps(f)</span><br><span class="line">    def b(*args,**kwargs):</span><br><span class="line">        if not can_run:</span><br><span class="line">            return &quot;函数不会运行&quot;</span><br><span class="line">        return f(*args,**kwargs)</span><br><span class="line">    return b</span><br><span class="line"></span><br><span class="line">@a_name</span><br><span class="line">def func():</span><br><span class="line">    return &quot;函数正在运行&quot;</span><br><span class="line"></span><br><span class="line"># can_run=True</span><br><span class="line"># print(func())</span><br><span class="line"></span><br><span class="line">can_run=False</span><br><span class="line">print(func())</span><br></pre></td></tr></table></figure>

<p>以上就是装饰器的一个简单的应用场景，@wraps 接受一个函数进行装饰，并且加入了函数的一些功能，函数名称、参数列表、注释文档等等，这可以让我们在装饰器里访问装饰之前的函数的属性</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
