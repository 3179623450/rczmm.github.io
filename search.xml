<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++自学笔记（1）</title>
    <url>//post/C-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89.html</url>
    <content><![CDATA[<p>C++很重要，很重要，很重要。</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 头文件引入
#include &lt;iostream&gt;
&#x2F;&#x2F; 使用名为std的命名空间
using namespace std;
&#x2F;&#x2F; main方法，程序开始的地方，返回值为整形
int main()&#123;
    &#x2F;&#x2F; 打印消息hello！
    cout&lt;&lt;&quot;hello!&quot;;
    &#x2F;&#x2F; 返回0，终止main函数，并且向调用进程返回0
    return 0;
&#125;</code></pre>

<p>分号 &amp; 语句块</p>
<p>在c++里，分号是语句的结束符，并且每一条语句都必须以分号结尾。</p>
<p>语句块是一组用大括号包含起来的语句。</p>
<p>c++里，你可以在一行里写多条语句，只要他们在结尾时使用分号。</p>
<p>标识符 &amp; 关键字</p>
<p>标识符用来标识变量、函数、类、模块或者其他的自定义的名称，标识符的组成是大小写字母、数字以及下划线，但是要注意的是，数字不能开头。</p>
<p>同时，c++内严格区分大小写。</p>
<p>关键字是c++的保留字，这些保留字无法作为常量名、变量、函数等其他标识符的名称。</p>
<p>三字符序列 &amp; 空格</p>
<p>三字符序列，用于表示另一个字符的三个字符组成的序列，这些序列总是以两个问号开头。</p>
<p>这并不常见，但是c++允许这样的表示，为了表示键盘上没有的字符。值得注意的是，三字符序列可以出现在任何的地方，包括字符串、字符序列、注释和预处理指令。</p>
<p>当然如果希望在源码中有两个连续的问号，并且不希望他们被替换掉，可以使用转义字符或者是字符串自动拼接。</p>
<p>空格也是必要的符号，空格用于描述空白符、制表符、换行符和注释，同时它也起到了分割语句各个部分的作用。有时候，为了增加一些可读性，我们也会主动的添加一些不是必要的空格。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>c++的注释是解释性的语句，在c++中支持单行和多行两种注释。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 我是单行注释

&#x2F;*
  
  我是多行注释内的内容！！
&#x2F;&#x2F;  我是单行注释
  
*&#x2F; </code></pre>

<p>单行注释，从&#x2F;&#x2F;开始，直到一行结束</p>
<p>多行注释，在&#x2F;* 到 *&#x2F;的内容都是多行注释的内容，并且可以在其中添加单行注释，实现注释的嵌套。</p>
<p>注意的是，多行中无法嵌套多行。</p>
<p>除此之外，还可以通过条件编译在实现注释：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#if 0
cout&lt;&lt;&quot;hello&quot;;
#endif</code></pre>



<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>c++为程序员提供了七种基本数据类型。</p>
<p>布尔（bool）、字符（char）、整形（int）、浮点（float）、双浮点（double）、宽字符（wchar_1）、无类型（void）。</p>
<p>一些基本类型可以使用一个或者多个卡类型修饰符进行修饰。</p>
<p>signed、unsigned、short、long</p>
<p>这些修饰符可以改变数据类型所能存储的最大值和最小值。</p>
<p>其中，各个类型的大小和系统的位数有关。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;limits&gt;

using namespace std;

int main() &#123;
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;bool: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(bool);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;char: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;signed char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(signed char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned char);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;wchar_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(wchar_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;short: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(short);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::max)();
    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;int: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(int);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;unsigned long: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned long);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;long double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long double);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;float: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(float);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;size_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(size_t);
    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::max)();
    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::min)() &lt;&lt; endl;
    cout &lt;&lt; &quot;string: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(string) &lt;&lt; endl;
    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot; &lt;&lt; endl;
    return 0;
&#125;</code></pre>

<p>变量的大小会编译器所在的系统有所不同，上面的实例会输出你实际电脑上各种类型的大小。</p>
<p>其中，endl，这会在每一行后插入换行符，&lt;&lt;运算度可以向平复传送多个值，sizeof（）可以获取各个数据类型的大小。</p>
<p>typedef声明 &amp; 枚举类型</p>
<p>可以使用typedef为一个已有的类型取一个新的名字。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef int id;
id student_id;</code></pre>

<p>如上的声明就完全合法。</p>
<p>枚举是一种派生的数据类型，他是由用户定义的若干枚举类型常量的集合。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum sex&#123;man&#x3D;1,woman&#x3D;0&#125; xiaoming;
xiaoming &#x3D; man;</code></pre>

<p>默认的，如果不设置整形常数，他会根据顺序赋值，从0开始，但是可以给一些特殊的值，默认的，每个名称都会比前一个名称大一，因此如果你设置了man等于3，那么woman等于4。</p>
<p>变量类型 &amp; 作用域</p>
<p>变量是程序可操作的存储区的名称，每一个变量都应该有指定的类型，类型决定了变量的大小和布局，这个范围内的值都可以存储在内存中。</p>
<p>变量名称遵循标识符的命名规范，由字母、数字、下划线组成，数字不能开头。</p>
<p>变量定义</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int age &#x3D; 10;</code></pre>

<p>如上的语句就可以声明一个变量，并且赋值为10。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">extern int age;</code></pre>

<p>extern关键字可以任何一个地方声明变量，当使用多个文件，但是只在一个文件内定义变量的时候，就可以使用它。</p>
<p>当然，虽然可以在c++中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int age;
char age;</code></pre>

<p>如上，即使类型不一样，但依旧无法被定义，并且编译器报错。</p>
<p>左值和右值</p>
<p>C ++ 有两种类型的表达式：</p>
<p>左值：指向内存位置的表达式</p>
<p>右值：存储在内存中某些地址的数值</p>
<p>其中右值表达式无法进行赋值的操作。</p>
<p>作用域</p>
<p>程序的一个区域，一般来说有三个地方可以定义变量</p>
<p>在函数或者代码块中，局部变量。</p>
<p>在函数参数定义中声明，形式参数。</p>
<p>在所有函数外部声明的变量，全局变量。它通常在程序的头部。</p>
<p>其中局部变量和全局变量的名称可以相同，但是在区域内使用是，局部变量会覆盖全局变量的值。</p>
<p>局部变量定义时，不会初始化，但是全局变量定义系统会自动初始化。</p>
<p>常量</p>
<p>固定值，在程序执行期间不会发生改变的值，又叫做字面量。常量就像是特殊的变量，只是他的值在定义后无法修改而已。</p>
<p>其中，整数常量的表示可以是无符号与长整数，在常量后加后缀U或者L。</p>
<p>也可以表示为，二进制、十进制、八进制、十六进制。由前缀指定，0x指定十六进制，0表示八进制，0b表示二进制，什么都不带表示十进制。</p>
<p>浮点常量，可以带小数点，也可以使用指数形式表达。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double a &#x3D; 31415956e-6;
cout &lt;&lt; a &lt;&lt; endl;</code></pre>

<p>其中e-6代表10的-6次方，如果是float单精度浮点类型，可以在末尾加l。</p>
<p>输出后，自动保留三位小数，对于这样的精度设置问题，解决方案如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double a &#x3D; 31415956e-6;

cout &lt;&lt; setprecision(8) &lt;&lt; a &lt;&lt; endl;

cout &lt;&lt; setiosflags(ios::fixed|ios::showpoint)&lt;&lt;setprecision(10)&lt;&lt; a &lt;&lt; endl;</code></pre>

<p>其中，范例中用到的函数都需要引入头文件</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;</code></pre>

<p>其中，setprecision用来设置精度，也就是控制输出的位数，自动四舍五入，且不保留小数后的不影响大小的0。setiosflags是一个格式控制函数，此处用到的fixed、以定点方式显示实数，也就是整数部分，搭配setprecision使用，此时后者就用来只控制小数位数了，但是他依旧不能保留0，于是引入showpoint。</p>
<p>布尔常量</p>
<p>true false</p>
<p>值得注意的是，不应该把他们看成是0和1.</p>
<p>字符常量</p>
<p>字符常量在单引号中，如果它以大写L开头（在单引号外），表示他是一个宽字符常量，此时他必须存在wchar_t类型的变量中。</p>
<p>字符常量也可以是一个转义序列，例如常用的换行、制表等等。</p>
<p>字符串常量</p>
<p>字符串的字面值或常量是在双引号里的，其中\可以用来换行分隔。</p>
<p>常量定义</p>
<p>常量的定义，有两种方式。</p>
<p>使用 <strong>#define</strong> 预处理器。</p>
<p>使用 <strong>const</strong> 关键字</p>
<p><img src="/post/C-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/image-20220905133619556.png" class="lazyload" data-srcset="/post/C-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/image-20220905133619556.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220905133619556"></p>
<p>最好的，将常量定义为大写字母形式。</p>
<p>修饰符类型</p>
<p>修饰符用来改变基本类型的含义，c++允许在char、int和double面前使用修饰符。</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>long</li>
<li>short</li>
</ul>
<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>
<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>
<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>long</strong>，<strong>int</strong> 是隐含的。</p>
<p>例如：</p>
<p><img src="/post/C-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/image-20220905133858789.png" class="lazyload" data-srcset="/post/C-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/image-20220905133858789.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220905133858789"></p>
<p>以上都表示声明了一个无符号短整数。</p>
<p>其中无符号数表示，所有的位都用来表示大小，因此无符号数只能是正数。</p>
<p>对于二者的转换，主要看转换数第一位是否为1，为1，直接取原数，不为1取补码。</p>
<p>类型限定符</p>
<p>const ： 声明常量，表示对象在程序执行期间不能被修改</p>
<p>volatile： 不需要优化，传统的变量，编译器对其优化后，会把值放在寄存器里加快读写，但是这个关键字让程序直接在内存中读取变量。</p>
<p>restrict：指针修饰符，表示该指针是唯一一种访问对象的方式。（只有C99才用）</p>
<p>存储类</p>
<p>某种程度上说，这也是限定符，他定义了变量或者函数的范围和生命周期。</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
<p>auto，c++17中删除，自动推断变量类型，声明函数返回值。</p>
<p>register 存储类用于定义存储在寄存器中而不是内存中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。</p>
<p><strong>mutable</strong> 说明符仅适用于类的对象。它允许对象的成员替代常量。</p>
<p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
<p>thread_local 说明符可以与 static 或 extern 合并。</p>
<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>
<p>运算符</p>
<ul>
<li>算术运算符（+、-、*、\、%、++、–）</li>
<li>关系运算符（&#x3D;&#x3D;、!&#x3D;、 &gt; 、&lt;、 &gt;&#x3D; 、&lt;&#x3D;）</li>
<li>逻辑运算符（&amp;&amp; 、||、 !）</li>
<li>位运算符（&amp; | ^）</li>
<li>赋值运算符(除了&#x3D;&#x3D;，其余带有&#x3D;的。)</li>
<li>杂项运算符（sizeof , &amp; * Cast Condition ? x:y）</li>
</ul>
<p>循环</p>
<p>while</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(condition)
&#123;
   statement(s);
&#125;</code></pre>

<p>for</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for ( init; condition; increment )
&#123;
   statement(s);
&#125;</code></pre>

<p>do while</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">do
&#123;
   statement(s);

&#125;while( condition );</code></pre>

<p>循环控制语句</p>
<p>break</p>
<p>跳出循环</p>
<p>continue</p>
<p>跳过剩余部分，开始下次循环</p>
<p>goto</p>
<p>允许把控制无条件转移到同一函数内的被标记的语句。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">goto label;
..
.
label: statement;</code></pre>

<p>分支</p>
<p>if</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(boolean_expression)
&#123;
   &#x2F;&#x2F; 如果布尔表达式为真将执行的语句
&#125;</code></pre>

<p>if else</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(boolean_expression)
&#123;
   &#x2F;&#x2F; 如果布尔表达式为真将执行的语句
&#125;
else
&#123;
   &#x2F;&#x2F; 如果布尔表达式为假将执行的语句
&#125;</code></pre>

<p>switch case</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">switch(expression)&#123;
    case constant-expression  :
       statement(s);
       break; &#x2F;&#x2F; 可选的
    case constant-expression  :
       statement(s);
       break; &#x2F;&#x2F; 可选的
  
    &#x2F;&#x2F; 您可以有任意数量的 case 语句
    default : &#x2F;&#x2F; 可选的
       statement(s);
&#125;</code></pre>

<p><strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量</p>
<p>条件运算符</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Exp1 ? Exp2 : Exp3;</code></pre>

<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>
<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>
<p>函数</p>
<p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>
<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>
<p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>
<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>
<p>函数定义</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">return_type function_name( parameter list )
&#123;
   body of the function
&#125;</code></pre>

<ul>
<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<p>创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</p>
<p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
<p>函数参数</p>
<p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。</p>
<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有三种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">传值调用</td>
<td align="left">该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>
</tr>
<tr>
<td align="left">指针调用</td>
<td align="left">该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
<tr>
<td align="left">引用调用</td>
<td align="left">该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
</tbody></table>
<p>默认情况下，C++ 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。</p>
<p>Lambda 函数与表达式</p>
<p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>
<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[capture](parameters)-&gt;return-type&#123;body&#125;</code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto m &#x3D; [](int m,int n)-&gt;int &#123; int z &#x3D; m +n;return z;&#125;;

int a11 &#x3D; m(2,7);
cout &lt;&lt; a11 &lt;&lt;endl;</code></pre>

<p>数组</p>
<p>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double balance[5] &#x3D; &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;</code></pre>

<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>
<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double balance[] &#x3D; &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;</code></pre>

<p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double salary &#x3D; balance[9];</code></pre>

<p>字符串</p>
<p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 <strong>null</strong> 字符 <strong>\0</strong> 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char site[] &#x3D; &quot;RUNOOB&quot;;</code></pre>

<p>C++ 标准库提供了 <strong>string</strong> 类类型</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str1 &#x3D; &quot;runoob&quot;;</code></pre>

<p>指针 </p>
<p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。</p>
<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。</p>
<p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">type *var-name;</code></pre>

<p>引用</p>
<p>本质是个别名。</p>
<p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p>变量名称是变量附属在内存位置中的标签，可以把引用当成是变量附属在内存位置中的第二个标签。因此，可以通过原始变量名称或引用来访问变量的内容。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 17;
int&amp;  r &#x3D; i;
double&amp; s &#x3D; d;</code></pre>

<p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *i;
int j &#x3D; 1000;
i &#x3D; &amp;j;
cout &lt;&lt; i &lt;&lt;endl;

int var1 &#x3D; 100;
int&amp; var2 &#x3D; var1;
cout &lt;&lt; var2 &lt;&lt; endl;</code></pre>

<p>日期与时间</p>
<p>C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</ctime></p>
<p>有四个与时间相关的类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong>。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">time_t now &#x3D; time(0);
cout &lt;&lt; now &lt;&lt; endl;
char *dt &#x3D; ctime(&amp;now);
cout &lt;&lt; dt;
tm *gmtm &#x3D; gmtime(&amp;now);
dt &#x3D; asctime(gmtm);
cout &lt;&lt; dt;
cout &lt;&lt;  &quot;年：&quot; &lt;&lt;gmtm -&gt;tm_year + 1900;</code></pre>

<p>基本的IO</p>
<p>C++ 标准库提供了一组丰富的输入&#x2F;输出功能。</p>
<p>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>
<p>cout</p>
<p>预定义的对象 <strong>cout</strong> 是 <strong>iostream</strong> 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>
<p>流插入运算符 &lt;&lt; 在一个语句中可以多次使用，endl** 用于在行末添加一个换行符。</p>
<p>cin</p>
<p>预定义的对象 <strong>cin</strong> 是 <strong>iostream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与流提取运算符 &gt;&gt; 结合使用的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char name[10];
cin &gt;&gt; name;
cout &lt;&lt; name &lt;&lt; endl;</code></pre>

<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用。</p>
<p>cerr</p>
<p>预定义的对象 <strong>cerr</strong> 是 <strong>iostream</strong> 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>
<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p>clog</p>
<p>预定义的对象 <strong>clog</strong> 是 <strong>iostream</strong> 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</p>
<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的。</p>
<p>通过小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。 </p>
<p>数据结构</p>
<p>C&#x2F;C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">struct type_name &#123;
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
&#125; object_names;</code></pre>

<p><strong>type_name</strong> 是结构体类型的名称，<strong>member_type1 member_name1</strong> 是标准的变量定义，比如 <strong>int i;</strong> 或者 <strong>float f;</strong> 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。</p>
<p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p>
<p>类 &amp; 对象</p>
<p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>
<p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p>
<p>类定义</p>
<p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 <strong>class</strong> 定义 Box 数据类型。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Book &#123;
public :
    int id;
    string name;
    double price;
&#125;;</code></pre>

<p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>。</p>
<p>定义对象</p>
<p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。</p>
<p>数据成员访问</p>
<p>类的对象的公共数据成员可以使用直接成员访问运算符 <strong>.</strong> 来访问。</p>
<p>构造函数 &amp; 析构函数</p>
<p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<p>类的<strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>
<p>继承</p>
<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 基类
class Animal &#123;
    &#x2F;&#x2F; eat() 函数
    &#x2F;&#x2F; sleep() 函数
&#125;;


&#x2F;&#x2F;派生类
class Dog : public Animal &#123;
    &#x2F;&#x2F; bark() 函数
&#125;;</code></pre>

<p>重载运算符 &amp; 重载函数</p>
<p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>
<p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Box operator+(const Box&amp;);</code></pre>

<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数。</p>
<p>多态</p>
<p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>
<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>虚函数</p>
<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>
<p>数据抽象</p>
<p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
<p>数据抽象是一种依赖于接口和实现分离的编程（设计）技术。</p>
<p>让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。</p>
<p>因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。</p>
<p>现在，让我们言归正传，就 C++ 编程而言，C++ 类为<strong>数据抽象</strong>提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p>
<p>例如，您的程序可以调用 <strong>sort()</strong> 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p>
<p>在 C++ 中，我们使用<strong>类</strong>来定义我们自己的抽象数据类型（ADT）。您可以使用类 <strong>iostream</strong> 的 <strong>cout</strong> 对象来输出数据到标准输出。</p>
<p>接口</p>
<p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>
<p>C++ 接口是使用<strong>抽象类</strong>来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。</p>
<p>文件和流</p>
<p>C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ofstream</td>
<td align="left">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>
</tr>
<tr>
<td align="left">ifstream</td>
<td align="left">该数据类型表示输入文件流，用于从文件读取信息。</td>
</tr>
<tr>
<td align="left">fstream</td>
<td align="left">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>
</tr>
</tbody></table>
<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</fstream></iostream></p>
<p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void open(const char *filename, ios::openmode mode);</code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;fstream&gt;
#include &lt;iostream&gt;
using namespace std;
 
int main ()
&#123;
    
   char data[100];
 
   &#x2F;&#x2F; 以写模式打开文件
   ofstream outfile;
   outfile.open(&quot;afile.dat&quot;);
 
   cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;Enter your name: &quot;; 
   cin.getline(data, 100);
 
   &#x2F;&#x2F; 向文件写入用户输入的数据
   outfile &lt;&lt; data &lt;&lt; endl;
 
   cout &lt;&lt; &quot;Enter your age: &quot;; 
   cin &gt;&gt; data;
   cin.ignore();
   
   &#x2F;&#x2F; 再次向文件写入用户输入的数据
   outfile &lt;&lt; data &lt;&lt; endl;
 
   &#x2F;&#x2F; 关闭打开的文件
   outfile.close();
 
   &#x2F;&#x2F; 以读模式打开文件
   ifstream infile; 
   infile.open(&quot;afile.dat&quot;); 
 
   cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; 
   infile &gt;&gt; data; 
 
   &#x2F;&#x2F; 在屏幕上写入数据
   cout &lt;&lt; data &lt;&lt; endl;
   
   &#x2F;&#x2F; 再次从文件读取数据，并显示它
   infile &gt;&gt; data; 
   cout &lt;&lt; data &lt;&lt; endl; 
 
   &#x2F;&#x2F; 关闭打开的文件
   infile.close();
 
   return 0;
&#125;</code></pre>

<p>异常处理</p>
<p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。</p>
<p>动态内存</p>
<p>C++ 程序中的内存分为两个部分：</p>
<ul>
<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>
<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>
<p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 <strong>new</strong> 运算符。</p>
<p>如果您不再需要动态分配的内存空间，可以使用 <strong>delete</strong> 运算符，删除之前由 new 运算符分配的内存。</p>
<p>命名空间</p>
<p>假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。</p>
<p>同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。</p>
<p>因此，引入了<strong>命名空间</strong>这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p>
<p>我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。</p>
<p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称。</p>
<pre class="line-numbers language-none"><code class="language-none">namespace namespace_name &#123;
   &#x2F;&#x2F; 代码声明
&#125;
name::code;  &#x2F;&#x2F; code 可以是变量或函数</code></pre>

<p>预处理器</p>
<p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>
<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</p>
<p>我们已经看到，之前所有的实例中都有 <strong>#include</strong> 指令。这个宏用于把头文件包含到源文件中。</p>
<p>C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等。</p>
<p>#define 预处理指令用于创建符号常量。该符号常量通常称为<strong>宏</strong>。</p>
<p>有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。</p>
<p>条件预处理器的结构与 if 选择结构很像。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifdef NULL
   #define NULL 0
#endif</code></pre>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>CLion中配置CMake运行多个main函数</title>
    <url>//post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<p>CLion中配置CMake运行多个main函数</p>
<p>简答的说，配置CMakeLists.txt文件，添加目录以及运行程序就可以实现，为了简化，添加了一个插件。</p>
<p>项目目录</p>
<p><img src="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007202631044.png" class="lazyload" data-srcset="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007202631044.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221007202631044"></p>
<p>添加我们新建的目录src，在src下新建CMakeLists.txt文件。</p>
<p><img src="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007202727079.png" class="lazyload" data-srcset="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007202727079.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221007202727079"></p>
<p>添加信息。</p>
<p>但是一般的，我们都是先创建好文件，再去配置，这样的话显然有一些不愉快了。</p>
<p><img src="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007202835314.png" class="lazyload" data-srcset="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007202835314.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221007202835314"></p>
<p>这个插件可以帮助我们自动的更新CMakeLists.txt文件，但是值得一提的是，他并不强大，因为在涉及到目录时，他无法解决，依然需要手动配置。</p>
<p>对于配置好目录信息后，就可以直接创建文件，右键直接添加执行文件了。</p>
<p><img src="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007203125621.png" class="lazyload" data-srcset="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007203125621.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221007203125621"></p>
<p>最终效果</p>
<p><img src="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007203213953.png" class="lazyload" data-srcset="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221007203213953.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221007203213953"></p>
<p>值得一提的是，其实不需要在src目录中配置CMakeLists文件。</p>
<p><img src="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221008145425011.png" class="lazyload" data-srcset="/post/CLion%E4%B8%AD%E9%85%8D%E7%BD%AECMake%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAmain%E5%87%BD%E6%95%B0/image-20221008145425011.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221008145425011"></p>
<p>在最外层的CMakeLists文件中这样描述就可以了。</p>
]]></content>
  </entry>
  <entry>
    <title>Oracle19C+PLSQL安装和配置详细教程</title>
    <url>//post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<p>解压下载的压缩包启动安装，注意解压的包名字中不能含有中文。</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211402868.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211402868.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>选择创建单实例数据库</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211717377.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211717377.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>选择桌面类下一步</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211841511.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211841511.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>创建一个新的oracle用户并设置密码</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211854956.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211854956.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>选择一个Oracle安装的基础目录</p>
<p><strong>不选择容器数据库，容器数据库是从12C出现的新特性</strong></p>
<p>设置密码可能不符合Oracle的建议标准点击是即可</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211934943.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211934943.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>先决条件检查，结束后会列出一个清单</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211951263.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109211951263.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>列出清单，可以保存为响应文件进行静默安装，点击安装，执行时间约15分钟左右</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212008892.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212008892.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212049311.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212049311.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>安装完成</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212104073.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212104073.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>测试安装是否成功</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212138420.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212138420.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>登陆<a href="https://localhost:5500/em/login">https://localhost:5500/em/login</a></p>
<p>登陆用户为sys密码为之前创建的</p>
<p><img src="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212234923.png" class="lazyload" data-srcset="/post/Oracle19C-PLSQL%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/image-20221109212234923.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>安装成功。</p>
]]></content>
  </entry>
  <entry>
    <title>MatLab笔记</title>
    <url>//post/MatLab%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x&#x3D;linspace(0,6);%createavectorxbetween0and6
y1&#x3D;sin(2*x);
y2&#x3D;sin(x.^2);
y3&#x3D;(sin(x)).^2;
plot(x,y1)</code></pre>

<p>matlab很强大，很强大。</p>
<pre class="line-numbers language-none"><code class="language-none">退出和中断

exit、quit结束matlab会话，程序完成，如果没有明确的保存，则变量中的数据会丢失。

Ctrl+C中断一个matlab任务</code></pre>

<p>在matlab中，矩阵是数据的基本格式。</p>
<p>二维矩阵是一个以行列排列的矩形表，例如一个m行、n列的矩阵大小就是m<em>n，多维矩阵的维数大于2，就是说大小为m</em>n*…p</p>
<p>当行列为1时，此时只有一个量，也就是标量，只有一个数。</p>
<p>一个变量可以通过分配一个值来定义他。</p>
<p>二维矩阵的实现</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A&#x3D;[1 2 3;4 5 6];

B&#x3D;[1 2 3
4 5 6];</code></pre>

<p>简单的两种方式，前者用分号作为一行的结束，后者直接写出来。</p>
<p>定义行向量与列向量</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">row_l&#x3D;[1 2 3];
column_l&#x3D;[1;2;3];</code></pre>

<p>逐个元素的分配矩阵：</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">C(1,1)&#x3D;1;
C(1,2)&#x3D;2;
C(1,3)&#x3D;3;
C(2,1)&#x3D;4;
C(2,2)&#x3D;5;
C(2,3)&#x3D;6;
C</code></pre>

<p>对于三维矩阵，一般的理解为在自变量中依次使用行、列和页维数次序，对于多维矩阵有两个索引原理，最自然的就是矩阵索引，他给出了每个元素在每一维的一个位置。</p>
<p>另外一个索引原理是线性索引，一些命令把整个索引说明为一个长列元素，如果所有元素都在一行上，那么对于各个元素给定的一个线性索引号说明了一个指定矩阵的索引给出的某个位置。</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">D&#x3D;[1 2 3;4 5 6];
E&#x3D;[1 2 3;4 5 6];
F(:,:,1)&#x3D;A;
F(:,:,2)&#x3D;B;
F
F(1,1,1)&#x3D;10;
F</code></pre>

<p>用两个二维矩阵构建一个三维矩阵，再修改一下三维矩阵内一个元素。</p>
<p>matlab允许在一行上定义多个变量，也可以在换行时使用三个点来在下一行继续输入。</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">m&#x3D;1;n&#x3D;2;z&#x3D;0.1212121312;
A_1&#x3D;[1 2 3 4 5 6 7;2 3 4 5 6 7 8;...
2 3 4 5 7 8 6];</code></pre>

<p>为了获取变量的维数，可以使用size和length。</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">size(A_1)
length(A_1)</code></pre>

<p>size，输出顺序为行数、列数、页数等。</p>
<p>（3，7）</p>
<p>length，给出一个向量的长度。行向量就给出列数，列向量就给出行数。</p>
<p>（7）</p>
<p>如果此时，简单的嵌套：</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">length(size(A_1))
ndims(A_1)</code></pre>

<p>（2）</p>
<p>就能顺利的得到维数。当然使用ndims函数也能快速的得到维数。</p>
<p>sub2ind()特殊的函数，首先在matlab之中，数据有索引，即使是矩阵。</p>
<p>但是数据是按列的方式存储，所以是按照列来计算索引的。</p>
<p>sub2ind就是把下标转化为索引。</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sub2ind(size(A_1),2,3)</code></pre>

<p>如图，A_1是一个3<em>7的矩阵，那么这段语句的含义就是求一个3</em>7矩阵的第2行第3列的索引。</p>
<p>ind2sub()将线性索引转化为下标。</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">[i,j]&#x3D;ind2sub(size(A_1),2);</code></pre>

<p>也就是，求一个3*7矩阵索引为2的元素在第几行第几列。</p>
<p>多维矩阵的转换：</p>
<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sub2ind([3 3 2],1,2,2)</code></pre>

<p>将一个三行、三列、两页的矩阵的第一行、第二列、第二页的元素转化为索引：13。</p>
<p>变量</p>
<p>变量名可以有19个字符，由字母大小写、下划线和数字作为变量名，但只能由字母开头。</p>
<p>matlab是区分大小写的。在变量使用之前，不需要指定变量的数据类型，也不需要声明变量。</p>
<pre class="line-numbers language-none"><code class="language-none">double是一个双精度浮点数，每个存储的双精度数用64位。

char用于存储字符，每个存储的字符用16位。

sparse用于存储稀疏矩阵，由一个sparse使用的内存是4+(非零元素数*16)。

unit8是一个无符号的8位整型数。数学函数并不对使用到的这种数据类型进行定义，如存储图像。</code></pre>

<p>逻辑函数</p>
<pre class="line-numbers language-none"><code class="language-none">iscell(x)如果x是一个细胞矩阵，返回1；否则为0。

isfield(x)如果x在一个结构中是一个域，返回1；否则为0。可参见第12.5节。

isfinite(x)返回一个与x相同大小的向量，这个x包含有限元的位置为1，其他位置为0。

islogical(x)如果x是一个逻辑向量，返回1；否则为0。

isnumeric(x)如果x是一个数值向量，返回1；否则为0。

isstr(x)如果x是一个字符串，返回1；否则为0。

isstruct(x)如果x是一个结构，返回1；否则为0。

isobject(x)如果x是一个对象，返回1；否则为0。

logical(x)返回一个可以使用的逻辑向量，例如逻辑索引或逻辑测试。</code></pre>

<p>预定义变量</p>
<pre class="line-numbers language-none"><code class="language-none">ans分配最新计算表达式的值，这个表达式并没有给定一个名字。

eps返回机器精度，定义1与最接近可代表的浮点数之间的差。eps数在一些命令中用作偏差。用户可以设定一个新的eps值，但要注意这个eps值不能由命令clear恢复。realmax返回计算机能处理的最大浮点数。

realmin返回计算机能处理的最小的非零浮点数。

pi返回p，即3.141592653589793，如果eps足够小，那么用16位十进制数来表示其精度。

inf定义为1&#x2F;0。当出现被零除时，MATLAB就返回inf，并不中断执行而继续计算。NaN定义为“NotaNumber”，这个非数值要么是％类型，要么是inf&#x2F;inf。

i，j定义为（-1）的1&#x2F;2次方，虚数单位。可以为i和j分配其他值，它们将不再是预定义常数。可以由clear命令恢复。

nargin给出在一个函数调用中输入自变量的个数。

nargout给出在一个函数调用中输出自变量的个数。</code></pre>

<p>变量列表</p>
<pre class="line-numbers language-none"><code class="language-none">who列出已定义的变量。

Whoglobal与who相同，但仅列出全局变量。

whoa*给出所有以a开头的变量的一个列表。

whos给出比命令who更详细的列表，如显示矩阵的维数。

whosglobal与whos相同，但仅列出全局变量。

exist(namestr)根据在字符串namestr中的变量的定义，返回不同的值。这里要注意的重要的一点是变量名应在引号‘’之间给出。函数返回值的情况是：

1）表示namestr是一个变量名；2)表示namestr是一个M文件名；3)表示namestr是一个MEX文件名；4)表示namestr是一个编译的SIMULINK函数；5)表示namestr是一个预定义的MATLAB函数名。

inmem返回一个带字符串的细胞向量，这个字符串包含目前在内存中的函数、M文件。如果给出两个输出参数，则第二个包含了一个目前在内存中的MEX文件的列表。

workspace对由whos得到的信息给出一个图形界面。命令clear被集成在这个环境中。由helpworkspace给出的信息，也在UNIX下工作。</code></pre>

<p>删除变量和合并</p>
<pre class="line-numbers language-none"><code class="language-none">clear删除所有变量并恢复除eps外的所有预定义变量。当运行文件时的clear。

clearname仅删除变量name。

clearname1name2删除变量name1、name2、……

cleara*删除所有a开头的变量。

clearvalue根据value给出不同的结果。键入helpclear可得到更多的细节。

pack重组和压缩已分配的内存碎块。当MATLAB的内存满后，可以使用命令pack而不是清除任何变量来得到更多的空间。将会产生如下情况：•所有变量都会保存在磁盘上的一个临时文件pack.tmp中；•删除主内存中的内容；•所有变量将从pack.tmp加载到主内存中；•删除文件pack.tmp。

packfilename用文件filename作临时文件，重组和压缩已分配内存。</code></pre>

<p>算数运算符扩展集</p>
<p>“^”幂</p>
<p>“*”乘<br>“&#x2F;”右除(正常除)<br>“\”左除<br>“+”加<br>“－”减</p>
<p>优先级从上到下降低。</p>
<p>其中右除和左除表示的为分数，区别在于右除为分母在后，左除为分母在前。</p>
<p>数学函数</p>
<pre class="line-numbers language-none"><code class="language-none">abs(x)求x的绝对值，即|x|。

sign(x)求x的符号，如果是正的得1；负的得－1；零得0。

sqrt(x)求x的平方根。

pow2(x,f)求x*2&lt;sub&gt;f&lt;&#x2F;sub&gt;。把f加到x的浮点格式下的指数上计算是一种十分有效的运算。

exp(x)求x的指数函数，即e&lt;sub&gt;x&lt;&#x2F;sub&gt;。log(x)求x的自然对数，即lnx。

log&lt;sup&gt;10&lt;&#x2F;sup&gt;(x)求x以10为底的对数，即log&lt;sup&gt;10&lt;&#x2F;sup&gt;x。

log&lt;sup&gt;2&lt;&#x2F;sup&gt;(x)求x以2为底的对数，即log&lt;sup&gt;2&lt;&#x2F;sup&gt;x。

sin(x)求正弦x，x为弧度。

cos(x)求余弦x，x为弧度。

tan(x)求正切x，x为弧度。

cot(x)求余切x，即1&#x2F;(tanx)，x为弧度。

asin(x)求反正弦，即sin&lt;sub&gt;－1&lt;&#x2F;sub&gt;x。

acos(x)求反余弦，即cos&lt;sub&gt;－1&lt;&#x2F;sub&gt;x。

atan(x)求反正切，即tan&lt;sub&gt;－1&lt;&#x2F;sub&gt;x。

atan2(x,y)求四象限反正切(x&#x2F;y)，其结果在[－pi，pi]区间内。

acot(x)求反余切x&#x3D;四象限反正切(1&#x2F;x)。

sec(x)求正割x，即1&#x2F;(cosx)。

csc(x)求余割x，即1&#x2F;(sinx)。

asec(x)求sec&lt;sub&gt;－1&lt;&#x2F;sub&gt;x&#x3D;arccos(1&#x2F;x)。acsc(x)求csc&lt;sub&gt;－1&lt;&#x2F;sub&gt;x&#x3D;arcsin(1&#x2F;x)。

sinh(x)求双曲正弦x。

cosh(x)求双曲余弦x。

tanh(x)求双曲正切x

coth(x)求双曲余切x，即1&#x2F;(tanhx)。asinh(x)求sinh的反函数

acosh(x)求cosh的反函数

atanh(x)求tanhx的反函数

acoth(x)求cothx的反函数

sech(x)求双曲正割x，即1&#x2F;(coshx)。csch(x)求双曲余割x，即1&#x2F;(sinhx)。asech(x)求sechx的反函数

acsch(x)求cschx的反函数</code></pre>

<p>取整命令和有关命令</p>
<pre class="line-numbers language-none"><code class="language-none">round(x)求最接近x的整数。如果x是一个向量，则适用于所有元素。

fix(x)求0方向最接近x的整数。即负x向上四舍五入，正x向下四舍五入。

floor(x)求小于或等于x的最接近的整数。

ceil(x)求大于或等于x的最接近的整数。rem(x,y)求整除x&#x2F;y的余数。

gcd(x,y)求整数x和y的最大公因子。[g,c,d]&#x3D;gcd(x，y)求g，c，d，满足g&#x3D;xc+yd。

lcm(x，y)求正整数x和y的最小公倍数，也能用于决定最小公因子。

[t，n]&#x3D;rat(x)由有理数t&#x2F;n求x的近似值，这里的t和n是整数，相对误差小于10－6。它给出了对应的字符串。[t，n]&#x3D;rat(x，tol)与上相同，但相对误差小于tol。

rat(x)求x的连续的分数表达式。

rat(x，tol)求带相对误差tol的x的连续的分数表达式。</code></pre>

<p>有关复数的函数</p>
<pre class="line-numbers language-none"><code class="language-none">real(z)求z的实部。

imag(z)求z的虚部。

abs(z)求z的绝对值，即|z|。

conj(z)求z的复数共扼。

angle(z)求z的相角，即z&#x3D;x+iy&#x3D;rei中的。

unwrap(v)求与v相同长度的向量。这里，两个相邻元素间的相角差已经改变，因此，差最大为pi。

unwrap(v,k)求出如上的一个向量，但用转移偏差k代替pi。

cplxpair(v)给出一个v中各元素按实部递增排序，并使其复数组合成复数共扼对的一个向量。在一个共扼对中，负虚部在前，实元素排在向量的后部。如果v的一个元素在v中没有它自己的复数共扼，则显示一个错误信息。</code></pre>

<p>坐标转换</p>
<p><img src="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020209529.png" class="lazyload" data-srcset="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020209529.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020220778.png" class="lazyload" data-srcset="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020220778.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>特殊的数学函数</p>
<p><img src="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020239760.png" class="lazyload" data-srcset="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020239760.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020252000-16620556025935.png" class="lazyload" data-srcset="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020252000-16620556025935.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>浮点运算计数器</p>
<p><img src="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020819799.png" class="lazyload" data-srcset="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020819799.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>时间和日期</p>
<p><img src="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020930265.png" class="lazyload" data-srcset="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020930265.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020943297.png" class="lazyload" data-srcset="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902020943297.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902021005621.png" class="lazyload" data-srcset="/post/MatLab%E7%AC%94%E8%AE%B0/image-20220902021005621.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
]]></content>
      <tags>
        <tag>MatLab</tag>
      </tags>
  </entry>
  <entry>
    <title>Python装饰器</title>
    <url>//post/Python%E8%A3%85%E9%A5%B0%E5%99%A8.html</url>
    <content><![CDATA[<h1 id="Python-装饰器"><a href="#Python-装饰器" class="headerlink" title="Python 装饰器"></a>Python 装饰器</h1><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在Python中，函数也是一个对象，可以被当做参数传递，可以在另一个函数中调用，也可以实现函数的嵌套。</p>
<p>所以，利用这个特性，我们可以写出一段测试功能运行时长的代码。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time


def function():
    print(&quot;I am function!&quot;)
    time.sleep(3)
    print(&quot;I have finished my work!&quot;)


def index(func):
    startTime &#x3D; time.time()
    func()
    enfTime &#x3D; time.time()
    print(&quot;script spend time is&quot;, enfTime - startTime)


index(function)</code></pre>

<p>这样的想法乍一看很好，但其实这从本质上看，不是改变了function函数的功能，而是创建了一个新的函数，而后将function融合进了这个函数里，最终实际上对function函数的一个包装，使它成为了一个新的函数，来实现功能。</p>
<p>那么，如果我们想要直接调用function函数就能实现像程序计时这样的功能呐？（要注意，我们做的一切都要建立在不更改function函数任何代码的前提之下。）</p>
<p>Python中有装饰器可以帮助我们更好的实现这样的功能。</p>
<p>装饰器的本质还是函数，他的作用是去装饰另外一个函数，而在程序计时这样的场景里，我们就需要根据我们要计时的程序，去编写一个计时的函数，这个计时的函数就是装饰器。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time


def index(func):
    def test_time():
        print(&quot;I doing some work&quot;)
        func()
        print(&quot;I am end!&quot;)

    return test_time


@index
def function():
    print(&quot;I am function!&quot;)
    time.sleep(3)
    print(&quot;I have finished my work!&quot;)


function()</code></pre>

<p>我们使用了装饰器的语法糖，@加函数名的形式，这其实就相当于一个index(function)，但是因为他的本质是装饰，因此在function不执行的情况下，程序也不会执行。</p>
<p>最后我们直接调用function函数，就能顺利的完成程序计时的功能。</p>
<p>这看起来似乎还有一点问题，但其实是因为此处应用的场景有一点点问题，作为程序计时来说，并不需要把这个功能焊死在函数里，但是这样的使用，似乎把计时焊死在了原来的函数内部。</p>
<p>其实换一个应用场景就好了，例如在flask等web框架里，我们针对用户授权的时候，一个小小的装饰器就能解决。</p>
<h2 id="装饰器带参数"><a href="#装饰器带参数" class="headerlink" title="装饰器带参数"></a>装饰器带参数</h2><p>首先是，装饰的对象带参数。</p>
<p><img src="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826120832286.png" class="lazyload" data-srcset="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826120832286.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826120832286"></p>
<p>如图，尽管我已经在调用的时候加入了参数，但是最终依然报错了。</p>
<p><img src="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826120904793.png" class="lazyload" data-srcset="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826120904793.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826120904793"></p>
<p>因为在装饰器中，我运行了这个函数，但是此时我是没有带参数的。</p>
<p><img src="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826120944616.png" class="lazyload" data-srcset="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826120944616.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826120944616"></p>
<p>并且值得注意的是，函数的参数可以很长，因为如果我们直接写参数的话，好像有点不对劲。</p>
<p>于是我们简单的使用一样python中的动态参数。</p>
<p><img src="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826121202910.png" class="lazyload" data-srcset="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826121202910.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826121202910"></p>
<p>这其实很简单，不用动态参数，你手动加入参数也可以。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time


def index(func):
    def test_time(*args, **kwargs):
        print(&quot;I doing some work&quot;)
        func(*args, **kwargs)
        print(&quot;I am end!&quot;)

    return test_time


@index
def function(x, y):
    print(&quot;I am function!&quot;)
    time.sleep(3)
    print(&quot;I have finished my work!&quot;)
    print(x + y)


function(2, 3)</code></pre>

<p>装饰器带参数</p>
<p>这是另外一个问题，我们希望给装饰器带上参数，使得它使用起来更加的灵活，如果你见过flask的代码，那么就应该见过装饰器带参数的情况。、</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time


def index(url):
    def test_time(func):
        def Timer(*args, **kwargs):
            print(&quot;I doing some work&quot;)
            func(*args, **kwargs)
            print(&quot;I request the &quot;, url)
            print(&quot;I am end!&quot;)

        return Timer
    return test_time


@index(&quot;&#x2F;home&quot;)
def function(x, y):
    print(&quot;I am function!&quot;)
    time.sleep(3)
    print(&quot;I have finished my work!&quot;)
    print(x + y)


function(2, 4)</code></pre>

<p>如上，这就是一个带参数的装饰器。</p>
<p>你可能发现了装饰器上三层的函数嵌套，并且写出了内两层的返回值，这是不可缺少的。</p>
<p>我们将它写成最开始的形式;</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time


def function(x, y):
    print(&quot;I am function!&quot;)
    time.sleep(3)
    print(&quot;I have finished my work!&quot;)
    print(x + y)


def index(url, func, *args, **kwargs):
    startTime &#x3D; time.time()
    func(*args, **kwargs)
    enfTime &#x3D; time.time()
    print(&quot;script spend time is&quot;, enfTime - startTime)
    print(&quot;I request the &quot;, url)
    return index


index(&quot;home&quot;, function, 2, 5)</code></pre>

<p>可以发现此时再使用这种形式，整个函数的调用就变得异常的繁琐和麻烦了起来。</p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>或许叫他装饰器类更加合适，比起一般的函数形式的装饰器，</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import time


class Foo(object):
    def __init__(self, url):
        self._url &#x3D; url

    def __call__(self, func):
        def wrap(*args,**kwargs):
            print(&quot;func is starting!&quot;)
            func(*args, **kwargs)
            print(&quot;I request the &quot; + self._url)
            print(&quot;func is ending!&quot;)
        return wrap


@Foo(&quot;home&quot;)
def function(x, y):
    print(&quot;I am function!&quot;)
    time.sleep(3)
    print(&quot;I have finished my work!&quot;)
    print(x+y)


function(4, 6)</code></pre>

<h2 id="装饰器嵌套"><a href="#装饰器嵌套" class="headerlink" title="装饰器嵌套"></a>装饰器嵌套</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Foo01(object):
    def __init__(self, url):
        self._url &#x3D; url

    def __call__(self, func):
        def wrap(*args, **kwargs):

            func(*args, **kwargs)
            print(&quot;I request the &quot; + self._url)


        return wrap


class Foo02(object):
    def __init__(self, url):
        self._url &#x3D; url

    def __call__(self, func):
        def wrap(*args, **kwargs):

            func(*args, **kwargs)
            print(&quot;The IP&quot; + self._url)


        return wrap


class Foo03(object):
    def __init__(self, url):
        self._url &#x3D; url

    def __call__(self, func):
        def wrap(*args, **kwargs):

            func(*args, **kwargs)
            print(&quot;The UA&quot; + self._url)


        return wrap


@Foo03(&quot;&#123;&#39;User_Agent&#39;:&#39;*****&#39;&#125;&quot;)
@Foo02(&quot;192.168.121.130&quot;)
@Foo01(&quot;home&quot;)
def function(x, y):
    print(x + y)


function(4, 6)</code></pre>

<p><img src="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826125058086.png" class="lazyload" data-srcset="/post/Python%E8%A3%85%E9%A5%B0%E5%99%A8/image-20220826125058086.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826125058086"></p>
<p>由此可以发现，装饰器的运行是按照和函数的距离来决定的，越近就越先执行。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Sql笔记</title>
    <url>//post/Sql%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="Sql笔记"><a href="#Sql笔记" class="headerlink" title="Sql笔记"></a>Sql笔记</h1><p>1、查询表中记录条数</p>
<pre class="line-numbers language-none"><code class="language-none">SELECT COUNT(*) FROM USER;
SELECT COUNT(1) FROM USER;
SELECT COUNT(id) FROM USER;</code></pre>

<p>COUNT能聚合记录条数。</p>
<p>以上三条sql语句在运行速度上几乎没有差别，但是对于其中的内容来说，count（1）会包含null的记录。</p>
<p>但是对于Innodb引擎来说，这个开窗会十分的慢，</p>
<p>因为Innodb是索引组织表，主键索引树的叶子结点是数据，而普通索引树的叶子结点是主键值，因此普通索引树比主键索引树小很多。</p>
]]></content>
  </entry>
  <entry>
    <title>springboot+vue（1）</title>
    <url>//post/springboot-vue%EF%BC%881%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>JavaEE：Springboot+MybatisPlus</p>
<p>Web前端：Vue+ELementUi</p>
<h2 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h2><p>主要的软件架构模式：BS（浏览器|服务器） 与 CS（客户端|服务器）</p>
<p>Web主要的架构模式：BS（维护方便，开发简单、成本低、更新快等）</p>
<p>程序的逻辑和数据都在服务端，浏览器求请求服务器，获取web页面，并把web页面展示给用户。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>JDK 1.8以上就可以（环境变量配置）</p>
<p>IDEA 什么版本都可以</p>
<p>Maven（项目管理工具）处理java项目的自动化构建（编译、运行、打包、文档）和依赖的管理。</p>
<h2 id="Springboot介绍"><a href="#Springboot介绍" class="headerlink" title="Springboot介绍"></a>Springboot介绍</h2><p>基于Spring的全新框架，简化spring的搭建和开发，比ssm的配置简单了很多，省略了很多xml文档。</p>
<p>约定优于配置，默认配置较多，只需要很少的配置。</p>
<p>内嵌了tomcat、jetty，不需要war包。</p>
<p>提供了定制化的启动器Starters，简化了maven（定制了maven的配置，帮助我们简化了配置），开箱就用。</p>
<p>纯java、没有xml和代码生成。</p>
<p>提供了监控方案，安全、服务健康等。</p>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824210539414.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824210539414.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220824210539414"></p>
<p>在idea中选择的时候，注意jdk的版本等信息。</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824210802751.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824210802751.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220824210802751"></p>
<p>此处可选择springboot的版本信息，以及要导入的依赖。</p>
<p>此时等待一段时间即可。</p>
<p>目录结构：</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824211339566.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824211339566.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220824211339566"></p>
<p>java下存放java代码，resource下的static和template用来存放公共资源，一般的，我们把js、css、图片等信息存放到static下，将页面放到template下，访问时，static的优先级是要大于template的，并且template下的页面不用thymeleaf映射和controller是无法直接url访问的。</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824211737361.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824211737361.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220824211737361"></p>
<p>写一个Controller，注解声明一下，这个类就可以去接受请求，而后写一个方法，加一个注解getmapping，这表明浏览器发一个get请求，字符串内的内容是url。</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824212119510.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824212119510.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220824212119510"></p>
<p>此时，运行启动器，打开网页，访问hello，就可以看到我们定义的返回值。</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824212210339.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824212210339.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220824212210339"></p>
<p>一般的，默认的端口是8080，可自定义。</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824212243749.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824212243749.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220824212243749"></p>
<h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>在实际开发中，我们会经常的修改后台文件，导致重新编译、启动等，非常麻烦。</p>
<p>springboot提供了devtools组件，让我们不用手动重启应用也可以重新编译、启动。</p>
<p>devtools会监控classpath下的文件，触发restart类加载器重新加载这个类，从而实现类文件和属性文件的热部署。</p>
<p>注意的是，也不是什么都需要重启应用，可以通过设置属性来制定一些目录或文件的修改不用重启。</p>
<p>引入依赖</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220826222051160.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220826222051160.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826222051160"></p>
<p>其中optional的含义是，依赖不会传递，也就是其他项目如果引入这个项目的jar包，不会包含这个devtools。</p>
<p>引入依赖后，记得刷一下maven。</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824212809166.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824212809166.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220824212809166"></p>
<p>如果你找不到这个按钮。</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824213521794.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220824213521794.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220824213521794"></p>
<p>在引入了依赖之后，我们需要在idea中手动配置。</p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220826220434604.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220826220434604.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826220434604"></p>
<p><img src="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220826220943295.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%881%EF%BC%89/image-20220826220943295.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826220943295"></p>
<p>重启idea后生效。</p>
<p>但是这其实并不是真正的热部署，但是好在他可以实现快速重启。</p>
<p>如果你觉得这不够快，你可以使用**<a href="https://link.zhihu.com/?target=https://jrebel.com/software/jrebel/">JRebel</a>**插件，只是说它要收费。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot+vue（2）</title>
    <url>//post/springboot-vue%EF%BC%882%EF%BC%89.html</url>
    <content><![CDATA[<p>写点基础的东西。</p>
<h2 id="Web入门"><a href="#Web入门" class="headerlink" title="Web入门"></a>Web入门</h2><p>Spring Boot是把传统的mvc、json、tomcat等框架结合起来，提供了start-web等组件，简化了应用配置。</p>
<p>创建项目时，选择SpringWeb，会自动把启动器加入到项目中，其中mvc、json、Tomcat包含在启动器类。</p>
<p>mvc作为开发的基础框架、json作为数据解析组件、tomcat作为自带容器。</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>Spring Boot中提供了两种注解来标识这个类负责接收和处理HTTP请求。</p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826224548498.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826224548498.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826224548498"></p>
<p>其中这两种注解，RestController默认的情况下，会将返回的对象转为JSON格式。</p>
<p>Controller用于请求页面和数据中，一般的和Thymeleaf模板引擎配合使用。</p>
<h3 id="路由映射"><a href="#路由映射" class="headerlink" title="路由映射"></a>路由映射</h3><p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826225000008.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826225000008.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826225000008"></p>
<p>该注解主要负责URL的路由映射，他可以添加在Controller类或者具体的方法上。</p>
<p>如果是在Controller类上，那么类中的所有路由映射都带有这个映射规则，如果在方法上，那么只对方法生效。</p>
<p>该注解包含很多属性参数来定义HTTP的请求映射规则，常用的属性参数有：value（URl路径，支持正则）、method（请求方法，GET、POST）、consumes（请求的媒体类型、Content-TYPE、json）、produces（响应的媒体类型）、params、headers（请求参数和请求头）。</p>
<p>其中，对于method的匹配，可以使用</p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826225543824.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826225543824.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826225543824"></p>
<p>以下的注解来替代，DELETE也可以。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>是指前端传递参数。</p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233231779.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233231779.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826233231779"></p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233253766.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233253766.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826233253766"></p>
<p>@RequestParam将请求参数绑定到控制器的方法参数上，接收的参数来自HTTP请求体或请求url的QueryString。当请求的参数名称与Controller的业务方法参数名称一致时,@RequestParam可以省略。</p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233620168.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233620168.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826233620168"></p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233625631.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233625631.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826233625631"></p>
<p>此时，明显的，参数名称与方法内名称不一致，但是由于使用了注解@RequestParam的关系，使得正常运行，这相当于一个参数映射，使得两者绑定。</p>
<p>但是要注意的是，使用了该注解之后，就必须传递该参数，否则将出现错误。</p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233934434.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826233934434.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826233934434"></p>
<p>想要解决，只需要在注解内加上参数。</p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826234010887.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826234010887.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826234010887"></p>
<p>如果参数很多的话，我们可以把参数封装到对象内。</p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826234659659.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826234659659.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826234659659"></p>
<p>一般的，可以选择使用json来封装数据，但是此时就需要使用如下的注解。</p>
<p><img src="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826234642746.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%882%EF%BC%89/image-20220826234642746.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220826234642746"></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot+vue（3）</title>
    <url>//post/springboot-vue%EF%BC%883%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><p>如果你使用的是IDEA创建项目，那么会默认创建出static目录。静态资源一般来说放在这个目录下。</p>
<p><img src="/post/springboot-vue%EF%BC%883%EF%BC%89/image-20220827201530131.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%883%EF%BC%89/image-20220827201530131.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220827201530131"></p>
<p>如果默认的的策略无法满足开发需求，也可以在application.properties中自定义</p>
<p><img src="/post/springboot-vue%EF%BC%883%EF%BC%89/image-20220827201701938.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%883%EF%BC%89/image-20220827201701938.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220827201701938"></p>
<p>前者为过滤规则，或者为静态资源位置。</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>表单的enctype属性规定在发送到服务器之前应该如何对表单数据进行编码。</p>
<p>不设置这个属性，即这个属性保持默认值，此时form表单内的数据格式为：key&#x3D;value&amp;key&#x3D;value</p>
<p>在Springboot工程中，嵌入的tomcat限制了请求的文件大小，每个文件的配置最大1Mb，单次请求文件总数不能大于10Mb，要更改这个默认值，在application.properties中加入配置：</p>
<p><img src="/post/springboot-vue%EF%BC%883%EF%BC%89/image-20220827202246300.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%883%EF%BC%89/image-20220827202246300.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220827202246300"></p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器在Web中很常见，对于一些全局统一的操作，放到拦截器里实现。</p>
<p>权限检查、性能监控、通用行为（读cookie等只要是多个程序需要的）</p>
<p>Spring Boot定义了HandlerInterceptor接口来实现自定义拦截器的功能</p>
<p>HandlerInterceptor接口定义了preHandle、postHandle、afterCompletion三种方法，通过重写这三种方法实现请求前、请求后等操作。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.springboot1;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Handler implements HandlerInterceptor &#123;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        if (true) &#123;
            return true;
        &#125; else &#123;
            return false;
        &#125;
    &#125;
&#125;</code></pre>

<p>拦截器注册</p>
<p>addPathPatterns方法定义拦截的地址</p>
<p>excludePathPatterns定义排除某些地址不被拦截</p>
<p>添加的一个拦截器没有addPathPattern任何一个url则默认拦截所有请求</p>
<p>如果没有excludePathPatterns任何一个请求，则默认不放过任何一个请求。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.springboot1.configuration;

import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import top.rczmm.springboot1.Handler;

public class WebConfiger implements WebMvcConfigurer &#123;
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(new Handler()).addPathPatterns(&quot;&#x2F;user&#x2F;**&quot;);
    &#125;
&#125;</code></pre>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot+vue（4）</title>
    <url>//post/springboot-vue%EF%BC%884%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>这是目前比较流行的互联网软件服务架构设计风格。</p>
<p>REST并不是一个标准，它更像一组客户端和服务端交互时的架构理念和设计原则，基于这种架构理念和设计原则的Web API更加简洁，更有层次。</p>
<p><strong>每一个URI代表一种资源</strong></p>
<p>客户端使用GET、POST、PUT、DELETE四种表示操作方式的动词对服务端资源进行操作：GET用于获取资源，POST用于新建资源（也可以用于更新资源），PUT用于更新资源，DELETE用于删除资源。</p>
<p>通过操作资源的表现形式来实现服务端请求操作。</p>
<p>资源的表现形式是JSON或者HTML。</p>
<p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都包含必需的信息。</p>
<p>符合RESTful规范的Web API需要具备如下两个关键特性：</p>
<p>安全性：安全的方法被期望不会产生任何副作用，当我们使用GET操作获取资源时，不会引起资源本身的改变，也不会引起服务器状态的改变。</p>
<p>幂等性：幂等的方法保证了重复进行一个请求和一次请求的效果相同（并不是指响应总是相同的，而是指服务器上资源的状态从第一次请求后就不再改变了），在数学上幂等性是指N次变换和一次变换相同。</p>
<h2 id="HTTP-Method"><a href="#HTTP-Method" class="headerlink" title="HTTP Method"></a>HTTP Method</h2><p><img src="/post/springboot-vue%EF%BC%884%EF%BC%89/image-20220827203852479.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%884%EF%BC%89/image-20220827203852479.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220827203852479"></p>
<p>状态码</p>
<p>HTTP状态码就是服务向用户返回的状态码和提示信息，客户端的每一次请求，服务都必须给出回应，回应包括HTTP状态码和数据两部分。</p>
<p>HTTP定义了40个标准状态码，可用于传达客户端请求的结果。状态码分为以下5个类别：</p>
<p>1xx：信息，通信传输协议级信息</p>
<p>2xx：成功，表示客户端的请求已成功接受</p>
<p>3xx：重定向，表示客户端必须执行一些其他操作才能完成其请求</p>
<p>4xx：客户端错误，此类错误状态码指向客户端</p>
<p>5xx：服务器错误，服务器负责这写错误状态码</p>
<p><img src="/post/springboot-vue%EF%BC%884%EF%BC%89/image-20220827204045162.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%884%EF%BC%89/image-20220827204045162.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220827204045162"></p>
<h2 id="Spring-Boot实现RESTful-API"><a href="#Spring-Boot实现RESTful-API" class="headerlink" title="Spring Boot实现RESTful API"></a>Spring Boot实现RESTful API</h2><p>Spring Boot提供的spring-boot-starter-web组件完全支持开发RESTful API，提供了与REST操作方式（GET、POST、PUT、DELETE）对应的注解。</p>
<p>@GetMapping：处理GET请求，获取资源。</p>
<p>@PostMapping：处理POST请求，新增资源。</p>
<p>@PutMapping：处理PUT请求，更新资源。</p>
<p>@DeleteMapping：处理DELETE请求，删除资源。</p>
<p>@PatchMapping：处理PATCH请求，用于部分更新资源。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.springboot1.Controller;

import org.springframework.web.bind.annotation.*;
import top.rczmm.springboot1.poji.User;


@RestController
public class HelloWorld &#123;
    @GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)
    public String getUserId(@PathVariable int id)&#123;
        return &quot;user&#39;s id&quot;;
    &#125;

    @PostMapping(&quot;&#x2F;user&quot;)
    public String saveUser(User user)&#123;
        return &quot;add user&quot;;
    &#125;

    @PutMapping(&quot;&#x2F;user&quot;)
    public String updateUser(User user)&#123;
        return &quot;update user&quot;;
    &#125;

    @DeleteMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)
    public String deleteUser(@PathVariable int id)&#123;
        return &quot;delete user&quot;;
    &#125;
&#125;</code></pre>

<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><p>Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务，是非常流行的API表达工具。</p>
<p>Swagger能够自动生成完善的RESTful API文档，，同时并根据后台代码的修改同步更新，同时提供完整的测试页面来调试API。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--        swagger--&gt;
         &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;springfox-boot-starter&lt;&#x2F;artifactId&gt;
            &lt;version&gt;3.0.0&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.springboot1.configuration;


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

@Configuration
public class SwaggerConfiger &#123;

    @Bean
    public Docket creatRestApiDocket() &#123;
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage(&quot;top&quot;))
                .paths(PathSelectors.any()).build();

    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder().title(&quot;XXAPI&quot;).description(&quot;study swagger2&quot;).build();
    &#125;
&#125;</code></pre>

<p>要注意的是，springboot 2.6 之后和swagger有冲突。</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.mvc.pathmatch.matching-strategy&#x3D;ant_path_matcher</code></pre>

<p>此时访问路径为：<a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a></p>
<p>注意，文档中Swagger为3.0。</p>
<p><img src="/post/springboot-vue%EF%BC%884%EF%BC%89/image-20220827214240354.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%884%EF%BC%89/image-20220827214240354.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220827214240354"></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot+vue（5）</title>
    <url>//post/springboot-vue%EF%BC%885%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h2><p>ORM:对象关系映射，解决的是数据库和面向对象不匹配的问题，它的本质是简化操作数据库的编码。</p>
<p>MyBatis是一款优秀的数据持久层ORM框架，被广泛地应用于应用系统。</p>
<p>MyBatis能够非常灵活地实现动态SQL，可以使用XML或注解来配置和映射原生信息，能够轻松地将Java的POJO（Plain Ordinary Java Object，普通的Java对象）与数据库中的表和字段进行映射关联。</p>
<p>MyBatis-Plus是一个 MyBatis 的增强工具，在 MyBatis 的基础上做了增强，简化了开发。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--        mybatis plus--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;
            &lt;version&gt;3.5.2&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
&lt;!--        mysql driver--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;
        &lt;&#x2F;dependency&gt;</code></pre>

<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.datasource.driver-class-name&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;
spring.datasource.url&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;milk?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&quot;
spring.datasource.name&#x3D;&quot;root&quot;
spring.datasource.password&#x3D;&quot;root&quot;</code></pre>

<p>配置数据库信息之后，在启动类上添加MapperScan注解，参数为Mapper包。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.springboot1;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication
@MapperScan(&quot;top.rczmm.springboot1.Mapper&quot;)
public class Springboot1Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Springboot1Application.class, args);
    &#125;

&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.springboot1.Mapper;

import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import top.rczmm.springboot1.poji.User;

@Mapper
public interface UserMapper &#123;
    @Insert(&quot;insert into users values(#&#123;id&#125;,#&#123;name&#125;) &quot;)
    int add(User user);
&#125;</code></pre>

<p>CRUD，可以通过注释来写，也可以配置xml文件。</p>
<p>除此之外，MybatisPLus也提供了一些注解：</p>
<p>@TableName，当表名与实体类名称不一致时，可以使用@TableName注解进行关联。</p>
<p>n@TableField，当表中字段名称与实体类属性不一致时，使用@TableField进行关联</p>
<p>@TableId，用于标记表中的主键字段，MybatisPlus也提供了主键生成策略</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot+vue（6）</title>
    <url>//post/springboot-vue%EF%BC%886%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="多表查询和分页查询"><a href="#多表查询和分页查询" class="headerlink" title="多表查询和分页查询"></a>多表查询和分页查询</h2><p>多表</p>
<p>实现复杂关系映射，可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置。</p>
<p><img src="/post/springboot-vue%EF%BC%886%EF%BC%89/image-20220828145912038.png" class="lazyload" data-srcset="/post/springboot-vue%EF%BC%886%EF%BC%89/image-20220828145912038.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220828145912038"></p>
<p>（MybatisPLus对多表无变化，以上为Mybatis的注解。）</p>
<p>测试</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Select(&quot;select * from t_user&quot;)
@Results(
        &#123;
                @Result(column &#x3D; &quot;id&quot;, property &#x3D; &quot;id&quot;),
                @Result(column &#x3D; &quot;name&quot;,property &#x3D; &quot;name&quot;),
                @Result(column &#x3D; &quot;password&quot;,property &#x3D; &quot;password&quot;),
                @Result(column &#x3D; &quot;id&quot;,property &#x3D; &quot;message&quot;,javaType &#x3D; List.class,
                many &#x3D; @Many(select&#x3D;&quot;top.rczmm.springboot1.Mapper.MessageMapper.selectById&quot;))
        &#125;
)
List&lt;User&gt; selectAllUsersMessage();</code></pre>

<p>分页</p>
<p>编写配置文件</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.springboot1.configuration;


import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisPlusConfig &#123;
    @Bean
    public MybatisPlusInterceptor paginationInterceptor() &#123;
        MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();
        PaginationInnerInterceptor paginationInnerInterceptor &#x3D; new PaginationInnerInterceptor(DbType.MYSQL);
        interceptor.addInnerInterceptor(paginationInnerInterceptor);
        return interceptor;
    &#125;
&#125;</code></pre>

<p>测试</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;findAll&quot;)
public IPage findAll() &#123;
    Page&lt;User&gt; page &#x3D; new Page&lt;&gt;(0,2);
    return userMapper.SelectPage(page);
&#125;</code></pre>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>入门项目——学生成绩管理系统（demo）</title>
    <url>//post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<h1 id="学生成绩管理系统"><a href="#学生成绩管理系统" class="headerlink" title="学生成绩管理系统"></a>学生成绩管理系统</h1><h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><p>jdk 1.8以上即可</p>
<p>maven 3.6.1以上</p>
<p>mysql 8</p>
<p>idea 2021</p>
<p>JQuery</p>
<h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><p>新建选择spring Initializr</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808191354776.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808191354776.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220808191354776"></p>
<p>指定项目名，路径，类型等信息。</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808191603691.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808191603691.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220808191603691"></p>
<p>指定导入的jar包，</p>
<p>spring web为前后端连接</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808191707878.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808191707878.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220808191707878"></p>
<p>在SQL下选择mybatis的jar包与sql的驱动，点击完成，等待一段时间，下载模板后，创建完成。</p>
<p>一般来说，idea会对每一个新建的项目进行一些类初始化的操作，例如依赖项等，因此我们往往需要等待一段时间，第一次可能会格外的慢。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>建一个简单表，以后扩展。</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808192526607.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808192526607.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220808192526607"></p>
<p>数据库连接，我选择新建一个yaml文件</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:
  datasource:
    username: root
    password: root
    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;milk?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre>

<p>测试数据库连接</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808193722466.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808193722466.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220808193722466"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import javax.sql.DataSource;
import java.sql.SQLException;

@SpringBootTest
class StudentManagerApplicationTests &#123;

    @Autowired
    DataSource dataSource;

    @Test
    void contextLoads() &#123;
    &#125;

    @Test
    void getConnection() throws SQLException &#123;
        System.out.println(dataSource.getConnection());
    &#125;

&#125;</code></pre>

<p>如果是idea可能在自动装配出报错，但是不用理他，直接运行，也可以在设置中将报错改为警告。</p>
<p>测试结果，输出连接池<img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808193850646.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808193850646.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220808193850646"></p>
<p>表示成功。</p>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>静态资源包括网页、js、css、图片等内容。</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808194009182.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808194009182.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220808194009182"></p>
<p>规定放在resources目录下（可以去看源码，但不建立此处个性化）。</p>
<p>其中，static为默认根目录，可以放任何资源，并且可以通过url直接访问（不用&#x2F;static&#x2F;）。</p>
<p>templates需要thymeleaf模板引擎，且无法直接被访问。</p>
<pre class="line-numbers language-maven" data-language="maven"><code class="language-maven">&lt;dependency&gt;
            &lt;groupId&gt;org.thymeleaf&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;thymeleaf&lt;&#x2F;artifactId&gt;
            &lt;version&gt;3.0.15.RELEASE&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;</code></pre>

<p>建立首页</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808194516411.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808194516411.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220808194516411"></p>
<p>启动项目</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808194540454.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220808194540454.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220808194540454"></p>
<p>springboot的启动最为简单，直接运行启动类即可，啥都交给自动装配。</p>
<p>运行后再访问静态资源时，idea有时候可能会出bug，这是因为idea对js代码兼容较差出现的情况，有时候js不能正常的加载，此时可以通过清理缓存，maven项目的clean与install重新部署依旧rebuild重新构建等三种方式解决，当然也可以重启电脑。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><h3 id="1、建立实体类（根据简单表）"><a href="#1、建立实体类（根据简单表）" class="headerlink" title="1、建立实体类（根据简单表）"></a>1、建立实体类（根据简单表）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student &#123;
    int id;
    String name;
    char sex;
&#125;</code></pre>

<p>此处使用了三个注解，分别表示get与set方法以及无参和有参构造的生成，使用注解前，需要先在pom.xml里引入lombok包。</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809101412761.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809101412761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809101412761"></p>
<p>要注意，student实体类是需要在网络中传输的，因此我们需要对它序列化，很简单，实现接口就可以。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student implements Serializable &#123;
    int id;
    String name;
    char sex;
&#125;</code></pre>

<h3 id="2、持久层"><a href="#2、持久层" class="headerlink" title="2、持久层"></a>2、持久层</h3><p>也就是mybatis来操作数据库</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Mapper;

import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import top.rczmm.studentmanager.pojo.Student;

@Mapper
public interface StudentMapper &#123;

    @Insert(&quot;insert into student (id,name,sex) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;sex&#125;)&quot;)
    Integer insert(Student student);

    @Select(&quot;select * from student&quot;)
    Student selectAll();

    @Select(&quot;select * from student where id &#x3D; #&#123;id&#125;&quot;)
    Student selectByID();
&#125;</code></pre>

<p>此处，在构建mapper接口时，我直接用注解写进sql语句，而不去编写xml映射文件，两种方式有利有弊，但是无疑，注解在写这种小demo时，更快。</p>
<h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><p>一般的，每一层写完我们都需要单元测试</p>
<p>这时候发现，表的字段设置有误，修改一下。</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809102848382.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809102848382.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809102848382"></p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809103049557.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809103049557.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809103049557"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Mapper;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import top.rczmm.studentmanager.pojo.Student;

@SpringBootTest
@RunWith(SpringRunner.class)
public class StudentMapperTest &#123;

    @Autowired
    StudentMapper studentMapper;

    @Test
    public void insertStudent() &#123;
        Student student &#x3D; new Student(20220809,&quot;小王八&quot;,&#39;男&#39;);
        Integer rows &#x3D; studentMapper.insert(student);
        System.out.println(rows);
    &#125;

    @Test
    public void selectAll()&#123;
        System.out.println(studentMapper.selectAll());
    &#125;

    @Test
    public void selectByID()&#123;
        System.out.println(studentMapper.selectByID(20200809));
    &#125;


&#125;</code></pre>

<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809103445768.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809103445768.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809103445768"></p>
<p>测试通过，要注意此处的变量rows是受改变的行数，也就是说，当行数小于1时，代表sql语句执行失败。</p>
<h3 id="4、业务层"><a href="#4、业务层" class="headerlink" title="4、业务层"></a>4、业务层</h3><p>接收前端数据</p>
<p>完成业务逻辑</p>
<h4 id="4-1-规划异常"><a href="#4-1-规划异常" class="headerlink" title="4.1 规划异常"></a>4.1 规划异常</h4><p>异常的出现很正常，注册时用户名被占用，输入不符合规范都是异常。</p>
<p>在处理异常时，不用笼统的用runtime运行时来定位，因此需要细分。</p>
<p>此处，建立一个业务异常基类，一个用户ID占用子类，一个插入异常子类，还可扩展，省略。</p>
<p>关于异常的定义也很简单，此处就是一个小demo，写一下构造就可以。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Service.ex;

public class ServiceException extends RuntimeException&#123;
    
    public ServiceException() &#123;
        super();
    &#125;

    public ServiceException(String message) &#123;
        super(message);
    &#125;

    public ServiceException(String message, Throwable cause) &#123;
        super(message, cause);
    &#125;

    public ServiceException(Throwable cause) &#123;
        super(cause);
    &#125;

    public ServiceException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123;
        super(message, cause, enableSuppression, writableStackTrace);
    &#125;
&#125;</code></pre>

<p>也可以用lombok，我是为了水字数。</p>
<p>再写两个异常，重写父类的构造就可以。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Service.ex;

public class IDDuplicationException extends ServiceException&#123;
    public IDDuplicationException() &#123;
    &#125;

    public IDDuplicationException(String message) &#123;
        super(message);
    &#125;

    public IDDuplicationException(String message, Throwable cause) &#123;
        super(message, cause);
    &#125;

    public IDDuplicationException(Throwable cause) &#123;
        super(cause);
    &#125;

    public IDDuplicationException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123;
        super(message, cause, enableSuppression, writableStackTrace);
    &#125;
&#125;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Service.ex;

public class InsertException extends ServiceException&#123;
    public InsertException() &#123;
    &#125;

    public InsertException(String message) &#123;
        super(message);
    &#125;

    public InsertException(String message, Throwable cause) &#123;
        super(message, cause);
    &#125;

    public InsertException(Throwable cause) &#123;
        super(cause);
    &#125;

    public InsertException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123;
        super(message, cause, enableSuppression, writableStackTrace);
    &#125;
&#125;</code></pre>

<h4 id="4-2-设计接口"><a href="#4-2-设计接口" class="headerlink" title="4.2 设计接口"></a>4.2 设计接口</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Service;

import top.rczmm.studentmanager.pojo.Student;

public interface StudentService &#123;
    void regiect(Student student);
&#125;</code></pre>

<p>小demo，功能就写一个注册就行。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import top.rczmm.studentmanager.Mapper.StudentMapper;
import top.rczmm.studentmanager.Service.ex.IDDuplicationException;
import top.rczmm.studentmanager.Service.ex.InsertException;
import top.rczmm.studentmanager.pojo.Student;


@Service
public class StudentServiceImpl implements StudentService&#123;
    @Autowired
    StudentMapper studentMapper;

    @Override
    public void regiect(Student student) &#123;
        Integer id &#x3D; student.getId();
        Student result &#x3D; studentMapper.selectByID(id);
        String name &#x3D; student.getName();
        char sex &#x3D; student.getSex();

        if (result !&#x3D; null)&#123;
            throw new IDDuplicationException(&quot;用户ID已经存在！&quot;);
        &#125;

        Integer rows &#x3D; studentMapper.insert(student);

        if (rows !&#x3D; 1) &#123;
            throw new InsertException(&quot;插入时出现未知异常！&quot;);
        &#125;

    &#125;
&#125;</code></pre>

<p>写上实现类，可以写在一个目录下，多了就可以拆分。</p>
<p>注意此处的实现类，因为要交给spring管理，因此必须加上service注解。</p>
<h4 id="4-3-测试"><a href="#4-3-测试" class="headerlink" title="4.3 测试"></a>4.3 测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Service;


import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import top.rczmm.studentmanager.Service.ex.ServiceException;
import top.rczmm.studentmanager.pojo.Student;

@SpringBootTest
@RunWith(SpringRunner.class)
public class StudentServiceTest &#123;
    @Autowired
    StudentService studentService;

    @Test
    public void regiect()&#123;
        try &#123;
            Student student &#x3D; new Student(20220802,&quot;小扒菜&quot;,&#39;女&#39;);
            studentService.regiect(student);
            System.out.println(&quot;OK&quot;);
        &#125;catch (ServiceException e)&#123;
            System.out.println(e.getClass().getName());
            System.out.println(e.getMessage());
        &#125;
    &#125;

&#125;</code></pre>

<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809110014533.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809110014533.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809110014533"></p>
<h3 id="5、控制层"><a href="#5、控制层" class="headerlink" title="5、控制层"></a>5、控制层</h3><h4 id="5-1-响应"><a href="#5-1-响应" class="headerlink" title="5.1 响应"></a>5.1 响应</h4><p>对于响应，一般的，我们都用状态码来描述，将这个功能封装到类里，将这个类作为方法的返回值给前端。</p>
<p>因为涉及到数据流，因此还是需要序列化。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class JsonResult&lt;E&gt; implements Serializable &#123;
    Integer state;
    String message;
    E data;
&#125;</code></pre>

<h4 id="5-2-请求"><a href="#5-2-请求" class="headerlink" title="5.2 请求"></a>5.2 请求</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Controller;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import top.rczmm.studentmanager.JsonResult;
import top.rczmm.studentmanager.Service.StudentService;
import top.rczmm.studentmanager.Service.ex.IDDuplicationException;
import top.rczmm.studentmanager.Service.ex.InsertException;
import top.rczmm.studentmanager.pojo.Student;

@RestController
@RequestMapping(&quot;student&quot;)
public class StudentController &#123;

    @Autowired
    StudentService studentService;


    @RequestMapping(&quot;reg&quot;)
    public JsonResult&lt;Void&gt; reg(Student student)&#123;
        JsonResult &lt;Void&gt; jsonResult &#x3D; new JsonResult&lt;&gt;();
        try &#123;
            studentService.regiect(student);
            jsonResult.setState(200);
            jsonResult.setMessage(&quot;注册成功&quot;);
        &#125;catch (IDDuplicationException e)&#123;
            jsonResult.setMessage(&quot;ID重复，无法注册&quot;);
            jsonResult.setState(2000);
        &#125;catch (InsertException w)&#123;
            jsonResult.setState(5000);
            jsonResult.setMessage(&quot;出现未知异常！&quot;);
        &#125;
        return jsonResult;
    &#125;

&#125;</code></pre>

<p>当然，对于控制层的业务，我们应该建立一个基类，针对不同业务做多态的扩展，但是此处只是一个小demo就不做了。</p>
<h3 id="6、前端页面"><a href="#6、前端页面" class="headerlink" title="6、前端页面"></a>6、前端页面</h3><p>前端页面，使用ajax来异步加载请求。</p>
<p>此处不用原生，使用JQuery。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html lang&#x3D;&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;&#x2F;title&gt;

    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.10.2&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;
&lt;form id&#x3D;&quot;form-reg&quot; class&#x3D;&quot;form-horizontal&quot; role&#x3D;&quot;form&quot;&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label class&#x3D;&quot;col-md-3 control-label&quot;&gt;ID ：&lt;&#x2F;label&gt;
        &lt;div class&#x3D;&quot;col-md-8&quot;&gt;
            &lt;input name&#x3D;&quot;id&quot; type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入ID&quot;&gt;
        &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label class&#x3D;&quot;col-md-3 control-label&quot;&gt; 姓名：&lt;&#x2F;label&gt;
        &lt;div class&#x3D;&quot;col-md-8&quot;&gt;
            &lt;input name&#x3D;&quot;name&quot; type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入姓名&quot;&gt;
        &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label class&#x3D;&quot;col-md-3 control-label&quot;&gt; 性别：&lt;&#x2F;label&gt;
        &lt;div class&#x3D;&quot;col-md-8&quot;&gt;
            &lt;input name&#x3D; &quot;sex&quot; type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入性别&quot;&gt;
        &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;

    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label class&#x3D;&quot;col-md-3 control-label&quot;&gt;&lt;&#x2F;label&gt;
        &lt;div class&#x3D;&quot;col-md-8&quot;&gt;
            &lt;input id&#x3D;&quot;btn-reg&quot; class&#x3D;&quot;btn btn-primary&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;立即注册&quot; &#x2F;&gt;
        &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;form&gt;
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;
    $(&quot;#btn-reg&quot;).click(function() &#123;
        $.ajax(&#123;
            url: &quot;&#x2F;student&#x2F;reg&quot;,
            type: &quot;POST&quot;,
            data: $(&quot;#form-reg&quot;).serialize(),
            dataType: &quot;json&quot;,
            success: function(json) &#123;
                if (json.state &#x3D;&#x3D; 200) &#123;
                    alert(&quot;注册成功！&quot;);
                &#125; else &#123;
                    alert(&quot;注册失败！&quot; + json.message);
                &#125;
            &#125;,
            error: function (xhr)&#123;
                alert(&quot;未知错误&quot;+xhr.status)
            &#125;
        &#125;);
    &#125;);

&lt;&#x2F;script&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>

<p>7、运行测试</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809111827983.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809111827983.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809111827983"></p>
<p>测试是否会重复ID</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809111856865.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809111856865.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809111856865"></p>
<p>注册功能完成。</p>
<p>完善一下。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html lang&#x3D;&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;&#x2F;title&gt;

    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.10.2&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;
&lt;form id&#x3D;&quot;form-reg&quot; class&#x3D;&quot;form-horizontal&quot; role&#x3D;&quot;form&quot;&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label class&#x3D;&quot;col-md-3 control-label&quot;&gt;ID ：&lt;&#x2F;label&gt;
        &lt;input id&#x3D;&quot;id&quot; type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入ID&quot;&gt;
    &lt;&#x2F;div&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label class&#x3D;&quot;col-md-3 control-label&quot;&gt; 姓名：&lt;&#x2F;label&gt;
        &lt;input id&#x3D;&quot;name&quot; type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入姓名&quot;&gt;
    &lt;&#x2F;div&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label class&#x3D;&quot;col-md-3 control-label&quot;&gt; 性别：&lt;&#x2F;label&gt;
        &lt;select id&#x3D;&quot;sex&quot;&gt;
            &lt;option value&#x3D;&quot;男&quot;&gt;男&lt;&#x2F;option&gt;
            &lt;option value&#x3D;&quot;女&quot;&gt;女&lt;&#x2F;option&gt;
        &lt;&#x2F;select&gt;
    &lt;&#x2F;div&gt;

    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label class&#x3D;&quot;col-md-3 control-label&quot;&gt;&lt;&#x2F;label&gt;
        &lt;input id&#x3D;&quot;btn-reg&quot; class&#x3D;&quot;btn btn-primary&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;立即注册&quot;&#x2F;&gt;

    &lt;&#x2F;div&gt;
&lt;&#x2F;form&gt;
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;
    $(&quot;#btn-reg&quot;).click(function (message) &#123;
        const id &#x3D; $(&quot;#id&quot;).val();
        const name &#x3D; $(&quot;#name&quot;).val();
        const sex &#x3D; $(&quot;#sex option:checked&quot;).val();
        if (id ！&#x3D;&#x3D; undefined || name ！&#x3D;&#x3D; undefined) &#123;
            alert(&quot;内容不能为空！&quot;)
        &#125; else &#123;
            console.log(sex,name,id)
            $.ajax(&#123;
                url: &quot;&#x2F;student&#x2F;reg&quot;,
                type: &quot;POST&quot;,
                data: &#123;&quot;name&quot;:name,&quot;sex&quot;:sex,&quot;id&quot;:id&#125;,
                dataType: &quot;json&quot;,
                success: function (json) &#123;
                    if (json.state &#x3D;&#x3D;&#x3D; 200) &#123;
                        alert(&quot;注册成功！&quot;);
                    &#125; else &#123;
                        alert(&quot;注册失败！&quot; + json.message);
                    &#125;
                &#125;,
                error: function (xhr) &#123;
                    alert(&quot;未知错误!&quot; + xhr.status)
                &#125;
            &#125;);
        &#125;
    &#125;);

&lt;&#x2F;script&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>

<p>接下来写登录</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><p>用户登录的本质是根据账号查询密码，因此我们在sql语句之前，再次更新最开始的简单表。</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809165525367.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809165525367.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809165525367"></p>
<p>sql语句开发，后台方法已经写完。</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809165629992.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809165629992.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809165629992"></p>
<p>此处使用注解，也无需配置xml映射。</p>
<h3 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h3><h4 id="规划异常"><a href="#规划异常" class="headerlink" title="规划异常"></a>规划异常</h4><p>登录时异常较多，其中针对这个小demo，主要为密码错误，此处略过。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>编写登录方法</p>
<p><img src="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809170235090.png" class="lazyload" data-srcset="/post/%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220809170235090.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220809170235090"></p>
<p>实现登录方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"> @Override
    public Student login(int id, int password) &#123;
        Student result &#x3D; studentMapper.selectByID(id);
        if (result &#x3D;&#x3D; null) &#123;
&#x2F;&#x2F;            此处应抛出异常
            System.out.println(&quot;用户不存在！&quot;);
        &#125;

        return result;
    &#125;</code></pre>

<p>登录时，密码等应加密，此处小demo，没用。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Test
public void loginTest() &#123;
    try &#123;
        int id &#x3D; 20220809;
        int password &#x3D; 11111;
        studentService.login(id, password);
        System.out.println(&quot;OK&quot;);
    &#125; catch (ServiceException e) &#123;
        System.out.println(&quot;111&quot;);
    &#125;
&#125;</code></pre>

<h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>首先处理登录功能，在业务层抛出的异常，此处未设置，略过。</p>
<h4 id="设计请求"><a href="#设计请求" class="headerlink" title="设计请求"></a>设计请求</h4><p>这一步是建立在注释内的一步，设计用户提交的请求，并且设计响应的方式。</p>
<p>包括但不限于，请求路径，请求参数，请求类型吗，相应结果等。</p>
<h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;login&quot;)
public JsonResult&lt;Student&gt; login(int id, int password)&#123;
    Student data &#x3D; studentService.login(id, password);
    return new JsonResult&lt;&gt;(data);
&#125;</code></pre>

<p>要注意的，此处返回值new的对象需要添加对应的构造方法。</p>
<h3 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form id&#x3D;&quot;form-login&quot; action&#x3D;&quot;index.html&quot; class&#x3D;&quot;form-horizontal&quot; role&#x3D;&quot;form&quot;&gt;
    &lt;!--用户名--&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label for&#x3D;&quot;username&quot; class&#x3D;&quot;col-md-3 control-label&quot;&gt;ID：&lt;&#x2F;label&gt;
        &lt;div class&#x3D;&quot;col-md-8&quot;&gt;
            &lt;input id&#x3D;&quot;id&quot; type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入ID&quot;&gt;
        &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
    &lt;!--密码--&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label for&#x3D;&quot;password&quot; class&#x3D;&quot;col-md-3 control-label&quot;&gt; 密码：&lt;&#x2F;label&gt;
        &lt;div class&#x3D;&quot;col-md-8&quot;&gt;
            &lt;input id&#x3D;&quot;password&quot; type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入密码&quot;&gt;
        &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;

    &lt;!--提交按钮--&gt;
    &lt;div class&#x3D;&quot;form-group&quot;&gt;
        &lt;label class&#x3D;&quot;col-md-3 control-label&quot;&gt;&lt;&#x2F;label&gt;
        &lt;div class&#x3D;&quot;col-md-8&quot;&gt;
            &lt;input id&#x3D;&quot;btn-login&quot; class&#x3D;&quot;btn btn-primary&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;登录&quot; &#x2F;&gt;
        &lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;form&gt;</code></pre>

<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$(&quot;#btn-login&quot;).click(function() &#123;
    $.ajax(&#123;
        url: &quot;&#x2F;student&#x2F;login&quot;,
        type: &quot;POST&quot;,
        data: $(&quot;#form-login&quot;).serialize(),
        dataType: &quot;json&quot;,
        success: function(json) &#123;
            if (json.state &#x3D;&#x3D; 200) &#123;
                alert(&quot;登录成功！&quot;);
                $.cookie(&quot;avatar&quot;, json.data.avatar, &#123;expires: 7&#125;);
                console.log(&quot;cookie中的avatar&#x3D;&quot; + $.cookie(&quot;avatar&quot;));
                location.href &#x3D; &quot;index.html&quot;;
            &#125; else &#123;
                alert(&quot;登录失败！&quot; + json.message);
            &#125;
        &#125;
    &#125;);
&#125;);</code></pre>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在MVC中，拦截请求是通过处理器拦截器器HandlerInterceptor来实现的，它拦截的目标是请求地址，即URL。在MVC在自定义一个拦截器，需要实现这个接口。</p>
<p>该拦截器有三大方法，在请求处理之前被调用的preHandle（）以及在当前请求进行处理之后被调用的postHandle（）和在整个请求结束之后的afterCompletion（）。</p>
<h4 id="添加拦截器"><a href="#添加拦截器" class="headerlink" title="添加拦截器"></a>添加拦截器</h4><p>项目中很多操作都需要登录后才可以直接执行，如果在每个请求前都去写检查session有没有登录信息，是非常不现实的。</p>
<p>创建拦截器类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.Interceptor;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class LoginInterceptor implements HandlerInterceptor &#123;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        if(request.getSession().getAttribute(&quot;id&quot;) &#x3D;&#x3D;null)&#123;
            response.sendRedirect(&quot;login.html&quot;);
            return false;
        &#125;
        return true;
    &#125;
&#125;</code></pre>

<p>要注意，在springboot项目中，自定义一些拦截器、分解器、转换器。在1.5版本之前，是依靠重写WebMvcConfigurerAdapter类的方法，2.0版本之后，该类过时，因此只能靠实现WebMvcConfigurer接口来实现。</p>
<p>创建拦截器的配置类并实现</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.config;


import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import top.rczmm.studentmanager.Interceptor.LoginInterceptor;

import java.util.*;

public class LoginInterceptorConfig implements WebMvcConfigurer &#123;

    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        HandlerInterceptor interceptor &#x3D; new LoginInterceptor();

        List&lt;String&gt; patterns &#x3D; new ArrayList&lt;String&gt;();

        patterns.add(&quot;&quot;);
        patterns.add(&quot;&quot;);
        patterns.add(&quot;&quot;);
        patterns.add(&quot;&quot;);
        patterns.add(&quot;&quot;);

        registry.addInterceptor(interceptor).addPathPatterns(&quot;&#x2F;**&quot;).excludePathPatterns(patterns);
    &#125;
&#125;</code></pre>

<p>此时，我们就可以重新构建login方法，在登录成功也就是账号和密码与数据库匹配之后，将id与password存入httpsession对象中。（注意将css、js、图片等公共资源加入白名单。）</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>spring很好的支持了AOP。</p>
<p>在处理业务时，假设存在一个切面，在切面中可以定义方法，那么就只需要配置好连接点，就可以在不修改原有数据处理流程的代码的基础之上，就可以使得若干个流程都执行相同的代码。</p>
<h3 id="切面方法"><a href="#切面方法" class="headerlink" title="切面方法"></a>切面方法</h3><p>访问是public、返回值类型任意，但是在使用@around时，必须使用Object类型，并且返回连接点方法的返回值，如果是@before或者@after等注解，就自定义。</p>
<h3 id="统计业务时长"><a href="#统计业务时长" class="headerlink" title="统计业务时长"></a>统计业务时长</h3><p>在使用AOP之前，需要先引入相关的包。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;
&lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;
&lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;
&lt;artifactId&gt;aspectjtools&lt;&#x2F;artifactId&gt;
&lt;&#x2F;dependency&gt;</code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java">package top.rczmm.studentmanager.aop;


import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class TimeAspect &#123;

    @Around(&quot;execution(* top.rczmm.studentmanager.Service.*.*(..))&quot;)
    public Object around(ProceedingJoinPoint point)throws Throwable &#123;

        long start &#x3D; System.currentTimeMillis();

        Object result &#x3D; point.proceed();

        long end &#x3D; System.currentTimeMillis();

        System.out.println(&quot;耗时：&quot;+(end - start) + &quot;毫秒！&quot;);

        return point.proceed();
    &#125;
&#125;</code></pre>

]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>博客开发日记</title>
    <url>//post/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="播客开发日记"><a href="#播客开发日记" class="headerlink" title="播客开发日记"></a>播客开发日记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>闲的没事干，用一下Django练练手。记录一下。</p>
<h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><ol>
<li>服务端：Django</li>
<li>数据库：MySQL 8.0</li>
<li>前端：原生JavaScript</li>
<li>CSS：原生CSS</li>
</ol>
<p>PyCharm</p>
<h2 id="项目步骤"><a href="#项目步骤" class="headerlink" title="项目步骤"></a>项目步骤</h2><p>新建django项目</p>
<p><img src="/post/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/image-20230215001945563.png" class="lazyload" data-srcset="/post/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/image-20230215001945563.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>注意新建填写应用程序名称，如果未填写，项目创建完成之后也可以创建。</p>
<ol>
<li><p>创建 Django 模型，用于存储博客内容。</p>
<p>在新建的app目录下，编辑models.py文件</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db import models


class Blog(models.Model):
    title &#x3D; models.CharField(max_length&#x3D;200)
    author &#x3D; models.CharField(max_length&#x3D;100)
    content &#x3D; models.TextField()
    created_at &#x3D; models.DateTimeField(auto_now_add&#x3D;True)
    updated_at &#x3D; models.DateTimeField(auto_now&#x3D;True)

    # 返回模型的标题，用于在Django的后台中显示。
    def __str__(self):
        return self.title</code></pre>
</li>
<li><p>创建 Django 视图，实现博客的增删改查功能。</p>
<p>在 Django  app中创建一个 views.py 文件</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.shortcuts import render, redirect
from django.views import View
from .models import Blog

class BlogListView(View):
    def get(self, request):
        blogs &#x3D; Blog.objects.all()
        return render(request, &#39;blog_list.html&#39;, &#123;&#39;blogs&#39;: blogs&#125;)</code></pre>

<p> 创建模板文件，例如 blog_list.html</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"># blog_list.html
&lt;h1&gt;Blog List&lt;&#x2F;h1&gt;
&lt;ul&gt;
  &#123;% for blog in blogs %&#125;
    &lt;li&gt;&#123;&#123; blog.title &#125;&#125; - &#123;&#123; blog.content &#125;&#125;&lt;&#x2F;li&gt;
  &#123;% endfor %&#125;
&lt;&#x2F;ul&gt;</code></pre>

<p>urls.py 文件中配置 URL 与视图的映射关系</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.urls import path
from .view import BlogListView

urlpatterns &#x3D; [
    path(&#39;my_blog&#x2F;&#39;, BlogListView.as_view(),name&#x3D;&#39;blog_list&#39;),
]</code></pre>

<p>文章详情页面</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def blog_detail(request,pk):
    blog &#x3D; Blog.objects.get(pk&#x3D;pk)
    return render(request, &#39;blog_detail.html&#39;,&#123;&#39;blog&#39;:blog&#125;)</code></pre>

<p>配置路由</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">path(&#39;blogs&#x2F;&lt;int:pk&gt;&#x2F;&#39;, blog_detail, name&#x3D;&#39;blog_detail&#39;),</code></pre>

<p>新建页面</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;
&lt;html lang&#x3D;&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;
    &lt;title&gt;&#123;&#123; blog.title &#125;&#125;&lt;&#x2F;title&gt;
&lt;&#x2F;head&gt;
&lt;body&gt;
&lt;h1&gt;
    &lt;a href&#x3D;&quot;&#123;% url &#39;blog_detail&#39; pk&#x3D;blog.pk %&#125;&quot;&gt;
        &#123;&#123; blog.title &#125;&#125;
    &lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;p&gt;&#123;&#123; blog.content &#125;&#125;&lt;&#x2F;p&gt;
&lt;p&gt;创建日期:&#123;&#123; blog.created_at &#125;&#125;&lt;&#x2F;p&gt;
&lt;p&gt;最后一次更新日期:&#123;&#123; blog.updated_at &#125;&#125;&lt;&#x2F;p&gt;
&lt;&#x2F;body&gt;
&lt;&#x2F;html&gt;</code></pre>

<p>创建forms.py文件(app目录内)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from django import forms
from .models import Blog

class BlogForm(forms.ModelForm):
    class Meta:
        model &#x3D; Blog
        fields &#x3D; [&#39;title&#39;, &#39;content&#39;]</code></pre>

<p>创建文章页面</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">class CreateBlogView(View):
    template_name &#x3D; &#39;create_blog.html&#39;

    def get(self, request):
        form &#x3D; BlogForm()
        return render(request, self.template_name,&#123;&#39;form&#39;:form&#125;)

    def post(self, request):
        form &#x3D; BlogForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect(&#39;blog_list&#39;)
        return render(request, self.template_name, &#123;&#39;form&#39;: form&#125;)</code></pre>

<p>配置路由</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">path(&#39;blogs&#x2F;create&#x2F;&#39;, CreateBlogView.as_view(), name&#x3D;&#39;create_blog&#39;),</code></pre>

<p>编写页面</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form method&#x3D;&quot;post&quot;&gt;
  &#123;% csrf_token %&#125;
  &#123;&#123; form.as_p &#125;&#125;
  &lt;button type&#x3D;&quot;submit&quot;&gt;Save&lt;&#x2F;button&gt;
&lt;&#x2F;form&gt;</code></pre>

<p>文章编辑</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def edit_blog(request, pk):
    blog &#x3D; Blog.objects.get(pk&#x3D;pk)
    if request.method &#x3D;&#x3D; &#39;POST&#39;:
        form &#x3D; BlogForm(request.POST, instance&#x3D;blog)
        if form.is_valid():
            form.save()
            return redirect(&#39;blog_detail&#39;, pk&#x3D;blog.pk)
    else:
        form &#x3D; BlogForm(instance&#x3D;blog)
    return render(request, &#39;edit_blog.html&#39;, &#123;&#39;form&#39;: form&#125;)</code></pre>

<p>配置路由</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">path(&#39;blogs&#x2F;&lt;int:pk&gt;&#x2F;edit&#x2F;&#39;, edit_blog, name&#x3D;&#39;edit_blog&#39;),</code></pre>

<p>编写页面</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form method&#x3D;&quot;post&quot;&gt;
    &#123;% csrf_token %&#125;
    &#123;&#123; form.as_p &#125;&#125;
    &lt;button type&#x3D;&quot;submit&quot;&gt;Save&lt;&#x2F;button&gt;
&lt;&#x2F;form&gt;</code></pre>
</li>
<li><p>创建 Django URL，实现页面路由功能。</p>
</li>
<li><p>编写 HTML 页面，实现博客页面的设计。</p>
</li>
<li><p>使用 CSS 完成页面样式设计。</p>
</li>
<li><p>使用 JavaScript 实现前端交互功能。</p>
</li>
<li><p>配置数据库连接。</p>
<p>在 Django 项目的 settings.py 文件中，你需要配置数据库连接：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">INSTALLED_APPS &#x3D; [
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;blog.apps.BlogConfig&#39;,
    &#39;django.db.backends.mysql&#39;
]</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">DATABASES &#x3D; &#123;
    &#39;default&#39;: &#123;
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;blog&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;: &#39;root&#39;,
        &#39;HOST&#39;: &#39;localhost&#39;,
        &#39;POST&#39;: &#39;3306&#39;,
        &#39;OPTION&#39;: &#123;
            &#39;charset&#39;: &#39;utf8mb4&#39;
        &#125;
    &#125;
&#125;</code></pre>

<p>其中 <code>NAME</code> 是数据库的名称，<code>USER</code> 是数据库用户的名称，<code>PASSWORD</code> 是数据库用户的密码，<code>HOST</code> 是数据库服务器的主机名，<code>PORT</code> 是数据库服务器的端口号。</p>
<p>然后你还需要安装 Django 的 MySQL 驱动，在你的项目的虚拟环境中执行以下命令：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install mysqlclient</code></pre>

<p>安装完驱动之后，你就可以使用 Django 的命令行工具进行数据库迁移：</p>
<pre class="line-numbers language-none"><code class="language-none">python manage.py makemigrations
python manage.py migrate</code></pre>

<pre class="line-numbers language-none"><code class="language-none">ImportError: Couldn&#39;t import Django. Are you sure it&#39;s installed and available on your PYTHONPATH environment variable? </code></pre>

<p>此错误通常表示 Django 在系统中没有正确安装或不在 Python 路径中。请确保已经安装了 Django，并在Python 路径中，可以在命令行或终端中运行以下命令来检查它是否已经正确安装：</p>
<pre class="line-numbers language-none"><code class="language-none">python -c &quot;import django; print(django.get_version())&quot;</code></pre>

<p>如果没有安装 Django，请使用以下命令安装它：</p>
<pre class="line-numbers language-none"><code class="language-none">pip install django</code></pre>

<pre class="line-numbers language-none"><code class="language-none">WARNING: You are using pip version 20.2.3; however, version 23.0 is available. You should consider upgrading via the &#39;d:\program files\python39\python.exe -m pip install --upgrade pip&#39; command.</code></pre>

<p>这是一个 pip 包管理器的警告，告诫您当前使用的 pip 版本已经过时，建议您升级到最新版本。您可以通过在命令行&#x2F;终端中运行以下命令升级 pip：</p>
<pre class="line-numbers language-none"><code class="language-none">*****\python39\python.exe -m pip install --upgrade pip</code></pre></li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">import MySQLdb as Database

ModuleNotFoundError: No module named &#39;MySQLdb&#39;</code></pre>

<p>MySQLdb 这个库已经不再维护了，建议使用 PyMySQL 作为替代方案。</p>
<ol>
<li>确认您的 Python 版本是否与您的数据库版本相匹配（例如，如果您使用的是 Python 3，则您需要选择 Python 3 版本的 MySQL 数据库驱动程序）。</li>
<li>确认您是否已安装 MySQLdb 模块。您可以在命令行中执行 “pip install mysqlclient” 来安装该模块。</li>
<li>如果仍然无法导入 MySQLdb，则请确保您的系统上安装了所需的编译器（例如 Visual Studio）以及其他需要的依赖项。</li>
<li>如果仍然无法解决，请检查您的 Django 设置文件（settings.py），确保您已正确配置了数据库连接，并且在 INSTALLED_APPS 列表中已添加了对数据库应用程序的支持。</li>
</ol>
<p>数据库迁移命令不报错，但是在数据库中未生成表。</p>
<ol>
<li>检查您是否正确配置了数据库，确保您的settings.py文件中的数据库设置正确。</li>
<li>检查是否在INSTALLED_APPS中正确配置了应用程序。</li>
<li>检查是否在数据库中已经有一个名为blog的数据库，如果有，请删除它。</li>
<li>检查模型是否正确，确保它包含了正确的字段和选项。</li>
</ol>
<p>pycharm的坑</p>
<p>在终端中pip之后，未加载到项目中，需要前往设置项目解释器，手动添加。</p>
<ol>
<li>配置 Django 的管理员站点，以便管理员进行博客内容的管理。</li>
<li>测试博客系统，修复发现的 bug。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>反射与注解</title>
    <url>//post/%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3.html</url>
    <content><![CDATA[<h1 id="反射与注解"><a href="#反射与注解" class="headerlink" title="反射与注解"></a>反射与注解</h1><p>jdk 1.5之后，java多了许多新的特性，其中一个很重要的机制，就是对元数据的支持，这种对元数据的支持，后来也被叫做注解。</p>
<p>注解的作用，使得开发者在改变原有逻辑的情况下，在源文件内嵌入一些补充的信息。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="认识反射机制"><a href="#认识反射机制" class="headerlink" title="认识反射机制"></a>认识反射机制</h3><p>这是java很重要的一项技术支持。</p>
<p>首先，很朴素的一点是，我们首先考虑的是“反”与“正”的操作。所谓的“正”，即我们使用一个类的时候，一定要先导入程序所在的包，而后根据类进行实例化，并且依靠得到的对象调用方法。</p>
<p>那么“反”，其实就是根据对象来反推出其类型。</p>
<p>其中，反射的根源，应当是Class类，可以通过Object类中所提供的方法来获取一个Class实例。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Date date &#x3D; new Date();   &#x2F;&#x2F; 正 获取对象
System.out.println(date.getClass());  &#x2F;&#x2F;  反 由对象获取类信息</code></pre>



<h3 id="Class-类对象实例化"><a href="#Class-类对象实例化" class="headerlink" title="Class 类对象实例化"></a>Class 类对象实例化</h3><p>Class类是反射的起源，为了应对不同的情况，java为其提供了三种不同的实例化对象方式。</p>
<p>1、利用Object类的getClass（）方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Date date &#x3D; new Date();   &#x2F;&#x2F; 正 获取对象
Class&lt;?&gt; a &#x3D; date.getClass();
System.out.println(a);  &#x2F;&#x2F;  反 由对象获取类信息</code></pre>

<p>2、使用类.class的形式，获取指定类或者接口的Class实例化对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Class&lt;?&gt; a &#x3D; Date.class;
System.out.println(a);</code></pre>

<p>要注意：直接通过一个类的完整名称可以获取class类实例，这就代表，要么import或者把类名写全，也就是要注意包名。</p>
<p>3、使用Class类内部提供的forName（）方法根据类的完整名称获取实例化对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Class&lt;?&gt; a &#x3D; Class.forName(&quot;java.util.Date&quot;);
System.out.println(a);</code></pre>

<p>第三种方法乍一看好像很麻烦，但实际上这种通过字符串获取class实力的方式，可以不适用import导入，并且由于字符串的支持较多并且拼接起来比较方便，十分的灵活。</p>
<p>当然，在使用forName的时候，请务必确保类存在。否则异常如下。</p>
<p><img src="/post/%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/image-20220618211522778.png" class="lazyload" data-srcset="/post/%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/image-20220618211522778.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220618211522778"></p>
<p>要注意，类存在更多指的是CLASSPATH环境属性中有该类。</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="认识注解"><a href="#认识注解" class="headerlink" title="认识注解"></a>认识注解</h3><p>注解是java对元数据的支持。</p>
<p>简单的来说，注解与注释相似，他们都不是程序本身，而是对程序做出解释，不同的是，注释是给开发者看的，而注解是用于编译器或者其他程序读取的。</p>
<p>javaSE中三类常见注解：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override&#x2F;&#x2F;重写注解
@Deprecated&#x2F;&#x2F;不推荐使用注解，可以使用但是有风险或者有更好的方式（被淘汰）
@SuppressWarnings &#x2F;&#x2F;“镇压”警告注解（不推介使用）</code></pre>

<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>除了系统定义的，如同以上三类注解之外，用户也可以自定义注解。</p>
<p>java中自定义注解，需要用@interface进行标记，同时也可以用@Target等元注解来对自定义的注解类型做说明。</p>
<ul>
<li>@Target：用于描述注解的使用范围</li>
<li>@Retention：用于表示需要在什么级别保存注解信息，用于描述注解的声明周期，（SOURCE&lt;CLASS&lt;RUNTIME）</li>
<li>@Document：说明该注解将被包含在javadoc中</li>
<li>@Inherited：说明子类可以继承父类中的该注解</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)
@interface Defaultannotion &#123;
    String title();

    String print() default &quot;1111111&quot;;
&#125;

class Message &#123;
    @Defaultannotion(title &#x3D; &quot;sss&quot;)
    public void send() &#123;
        System.out.println(&quot;1111&quot;);
    &#125;
&#125;</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>变治法</title>
    <url>//post/%E5%8F%98%E6%B2%BB%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="变治法"><a href="#变治法" class="headerlink" title="变治法"></a>变治法</h1><p>算法设计与分析方法之中的一种特殊的变换思想，严格意义上说，他并不想分治法、动态规划那样标准，它只是一种变换问题的思想。</p>
<p>变：将问题变得更加容易</p>
<p>治：求解容易的问题</p>
<h2 id="实例化简（预排序、高斯消元）"><a href="#实例化简（预排序、高斯消元）" class="headerlink" title="实例化简（预排序、高斯消元）"></a>实例化简（预排序、高斯消元）</h2><h3 id="预排序，一种简单的预处理技术（主要是意识）。"><a href="#预排序，一种简单的预处理技术（主要是意识）。" class="headerlink" title="预排序，一种简单的预处理技术（主要是意识）。"></a>预排序，一种简单的预处理技术（主要是意识）。</h3><p>检验数组元素唯一性</p>
<p>词频统计</p>
<p>元素查找</p>
<p>以上三种模式，都可以使用蛮力来做，但是明显的性能太差了。</p>
<p>将数组排序是一个解决方案，无论是唯一性还是词频都可以很好的得到答案，代价仅仅是遍历一次数组，而元素查找在适合的数组之中，也可以使用诸如二分的方式很快的得到结果。但是对于查找来说，遍历随便比较差，但是对于多次查找来说，这是值得的。</p>
<p>高斯消元法</p>
<p>求解线性方程组的方式，将系数矩阵化为上三角矩阵。（就是一种变治和化简的思想）</p>
<h2 id="改变问题（AVL、多路查找树）"><a href="#改变问题（AVL、多路查找树）" class="headerlink" title="改变问题（AVL、多路查找树）"></a>改变问题（AVL、多路查找树）</h2><p>AVL，为了改善二叉排序树的查找性能</p>
<h2 id="问题化简（堆排序）"><a href="#问题化简（堆排序）" class="headerlink" title="问题化简（堆排序）"></a>问题化简（堆排序）</h2><p>堆排序</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def heapsort2(arr):
    # 建立堆
    def heapify(arr, low, high):
        # 开始指向堆顶元素
        i &#x3D; low
        # 开始指向左节点
        j &#x3D; 2 * i + 1
        # 储存堆顶元素
        temp &#x3D; arr[low]
        # j位置有效
        while j &lt;&#x3D; high:
            # 右结点大于左结点
            if j + 1 &lt;&#x3D; high and arr[j + 1] &gt;&#x3D; arr[j]:
                # 指向右结点
                j &#x3D; j + 1
            # 子结点大于父节点
            if arr[j] &gt; temp:
                # 交换
                arr[i] &#x3D; arr[j]
                i &#x3D; j
                j &#x3D; 2 * i + 1
            else:
                # temp放入某一节父节点
                arr[i] &#x3D; temp
                break
        else:
            # temp放到叶子结点
            arr[i] &#x3D; temp

    # 排序
    def sort(nums):
        n &#x3D; len(nums)

        for i in range((n - 2) &#x2F;&#x2F; 2, -1, -1):
            heapify(nums, i, n - 1)

        for i in range(n - 1, -1, -1):
            nums[0], nums[i] &#x3D; nums[i], nums[0]
            heapify(nums, 0, i - 1)

    sort(arr)
    # print(&quot;结果数组：&quot;, arr)</code></pre>



<h2 id="霍纳法则"><a href="#霍纳法则" class="headerlink" title="霍纳法则"></a>霍纳法则</h2><p>P（x） &#x3D; an * x^n  + ……a1* x + a0</p>
<p>一项一项的计算很慢，如果改变表现形式，这样就只要进行迭代。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 霍纳法则
# arr（多项式，a1-an的数组）
# n（项数）
# x（x的值）
def Horner_rule(arr, n, x):
    i &#x3D; 0
    ans &#x3D; 0
    while i &lt; n:
        ans &#x3D; arr[i] + x * ans
        i+&#x3D;1
    print(ans)
    return ans

if __name__ &#x3D;&#x3D; &#39;__main__&#39;:
    arr &#x3D; [1 for i in range(0,10)]
    print(arr)
    x &#x3D; 4
    n &#x3D; 4
    Horner_rule(arr,4,4)</code></pre>

]]></content>
  </entry>
  <entry>
    <title>基于Python的QT（二）</title>
    <url>//post/%E5%9F%BA%E4%BA%8EPython%E7%9A%84QT%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p>首先，Qt原来是用C++写的一个框架，作为一个框架，Qt包含了很多的组件，这些组件是按照模块和组件来分布的。</p>
<p>qtbase就是大多数模块的基础组件，比例qtcore、qtgui、qtwidgets、qtnetworks，这些模块里当然都有一些直接可以实例化的类。</p>
<p>因此在编程中，我们可以直接使用他们，用他们来创建应用程序、处理文件、网络连接、正则表达式、文本编码等。</p>
<p>值得一提的是qtwidgets模块，该模块用于图形化程序，这在qt中是核心的部分。</p>
<p>当然还有一些其他的模块，在qt中，有着qml的存在，使得我们可以使用javascript来处理一些命令式的部分，官网是这样描述的，所谓的命令式，即计算机how的过程。之所以用到js，在我看来是为了更好的兼容与扩展，这一点在qt可以使用c++扩展和连接代码就可以看出。</p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>在qt中，除了py文件之外，还存在着用户界面定义文件ui文件，以及资源收集的qrc文件和qt建模语言文件qml。</p>
<p>当然还有项目文件pyproject。</p>
<h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>这其实直接放在helloworld后面会好一些。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import sys

from PySide6 import QtWidgets, QtCore,QtGui
from PySide6.QtCore import Slot


class MyWidget(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()

        self.hello &#x3D; &#39;hello Tom&#39;

        self.button &#x3D; QtWidgets.QPushButton(&#39;点我&#39;)

        self.text &#x3D; QtWidgets.QLabel(&#39;helloworld&#39;, alignment&#x3D;QtCore.Qt.AlignCenter)

        self.layout &#x3D; QtWidgets.QVBoxLayout(self)

        self.layout.addWidget(self.text)

        self.layout.addWidget(self.button)

        self.button.clicked.connect(self.say)

    @Slot()
    def magic(self):
        self.text.setText(self.hello)

    @Slot()
    def say(self):
        print(&quot;Button clicked&quot;)


if __name__ &#x3D;&#x3D; &quot;__main__&quot;:
    app &#x3D; QtWidgets.QApplication([])

    widget &#x3D; MyWidget()
    widget.resize(800, 600)
    widget.show()

    sys.exit(app.exec())</code></pre>

<p>这是helloworld的代码，我们忽略那些定义和创建的内容，我们会发现，程序本质上定义了一个按钮，并且在按钮按下的时候，调用了一个方法。</p>
<p>这看起来似乎很简单，但是在qt中，在按钮按下到执行对应内容的机制，被称为信号和槽，同时这也是qt的核心特性。</p>
<p>信号，在上述代码中，当我们单击按钮的时候，这就是一个信号，所谓的槽也就是信号传出时发生的情况，或者说信号的接收者。</p>
<p>信号和插槽不是按钮的专属，事实上所有继承了qobject的子类都可以包含信号和插槽，信号由对象发出。要注意的是，信号仅仅承担发出，并不关心接受的问题。这看起来似乎有点不负责任，但是封装的很好。</p>
<p>插槽用来接受信号，但实际上他们本质上只是最普通的函数，槽同样的只负责接受，他不知道有什么信号能连接到它。</p>
<p>这样的看起来紧密，却随时可以断开连接，互相连接就导致了qt可以创建真正的独立组件。</p>
<p>一个例子，我们可以创建很多的信号，这些信号都连接到一个插槽，或者多个插槽，甚至我们可以把一个信号连接到一个信号。</p>
<p>当然在qt中，有一些预定义的信号和插槽。</p>
<p>关于信号，在 Python 中编写类时，信号被声明为 class 的类级变量<code>QtCore.Signal()</code></p>
<p>关于槽，由装饰器指示 <code>@QtCore.Slot()</code>，<code>Slot()</code>也接受一个<code>name</code>和一个<code>result</code>关键字。<code>result</code>关键字定义将返回的类型，可以是 C 或 Python 类型。关键字的<code>name</code>行为方式与<code>Signal()</code>. 如果没有作为名称传递，则新插槽将与正在装饰的函数具有相同的名称。</p>
<p>在例子中，我们能发现，我们自定义了一个插槽，却没有定义信号，其实此处是利用了qt的预定义信号。</p>
<p>下面自定义信号，并且实现信号与槽的连接。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import sys


from PySide6 import QtWidgets, QtCore,QtGui
from PySide6.QtCore import Slot,Signal


class MyWidget(QtWidgets.QWidget):

    signal1 &#x3D; Signal()

    def __init__(self):
        super().__init__()

        self.hello &#x3D; &#39;hello Tom&#39;

        self.button &#x3D; QtWidgets.QPushButton(&#39;点我&#39;)

        self.text &#x3D; QtWidgets.QLabel(&#39;helloworld&#39;, alignment&#x3D;QtCore.Qt.AlignCenter)

        self.layout &#x3D; QtWidgets.QVBoxLayout(self)

        self.layout.addWidget(self.text)

        self.layout.addWidget(self.button)

        self.button.clicked.connect(self.magic)

        self.signal1.connect(self.say)

    @Slot()
    def magic(self):
        self.text.setText(self.hello)
        sign &#x3D; MyWidget()
        sign.signal1.emit()


    def say(self):
        print(&quot;Button clicked&quot;)


if __name__ &#x3D;&#x3D; &quot;__main__&quot;:
    app &#x3D; QtWidgets.QApplication([])

    widget &#x3D; MyWidget()
    widget.resize(800, 600)
    widget.show()

    sys.exit(app.exec())</code></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>基于python的QT（一）</title>
    <url>//post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>QT，一个跨平台的GUI编程框架，支持多种语言，java、c++、python。</p>
<p>此笔记基于python。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Qt，对于python而言，QT支持的版本最低是3.6，在官方文档中，建议使用虚拟环境，即venu，笔记中使用pycharm工具自动配置。</p>
<p>pycharm中，创建项目，软件自动配置虚拟环境。</p>
<p><img src="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819105050533.png" class="lazyload" data-srcset="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819105050533.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220819105050533"></p>
<p>当然也可以不使用pycharm。</p>
<p>以下为官网对创建和激活环境的描述：</p>
<pre class="line-numbers language-none"><code class="language-none">创建和激活环境 您可以通过在终端上运行以下命令来做到这一点：

python -m venv env，（您的 Python 可执行文件可能被调用&#96;python3&#96;）

用于 Linux 和 macOS 的源 env&#x2F;bin&#x2F;activate

适用于 Windows 的env\Scripts\activate.bat</code></pre>

<p>安装pyside6包，可使用pip，也可以在pycharm中搜索安装。</p>
<p><img src="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819104853500.png" class="lazyload" data-srcset="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819104853500.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220819104853500"></p>
<p>如上图，pycharm中直接安装即可。（安装可能会因为网速等问题过慢，可自行更换镜像）</p>
<p><img src="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819105817742.png" class="lazyload" data-srcset="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819105817742.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220819105817742"></p>
<p>此处添加即可。</p>
<p>pip命令如下：</p>
<hr>
<p><strong>pip install pyside6</strong>，用于最新版本。</p>
<p><strong>pip install pyside6&#x3D;&#x3D;6.0</strong>，专门针对版本<code>6.0</code></p>
<p>也可以从官方的服务器安装特定快照：</p>
<pre class="line-numbers language-none"><code class="language-none">pip install --index-url&#x3D;https:&#x2F;&#x2F;download.qt.io&#x2F;snapshots&#x2F;ci&#x2F;pyside&#x2F;6.0.0&#x2F;latest pyside6 --trusted-host download.qt.io</code></pre>

<p>测试</p>
<p><img src="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819105856465.png" class="lazyload" data-srcset="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819105856465.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220819105856465"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import PySide6.QtCore

print(PySide6.__version__)</code></pre>

<p>引入核心包，打印版本信息即可。</p>
<p>6.3.1（笔记版本）</p>
<h2 id="Helloworld"><a href="#Helloworld" class="headerlink" title="Helloworld"></a>Helloworld</h2><p>pyside6模块提供了一些子模块用来访问Qt的API。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">import sys

from PySide6 import QtWidgets, QtCore,QtGui


class MyWidget(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()

        self.hello &#x3D; &#39;hello Tom&#39;

        self.button &#x3D; QtWidgets.QPushButton(&#39;点我&#39;)

        self.text &#x3D; QtWidgets.QLabel(&#39;helloworld&#39;, alignment&#x3D;QtCore.Qt.AlignCenter)

        self.layout &#x3D; QtWidgets.QVBoxLayout(self)

        self.layout.addWidget(self.text)

        self.layout.addWidget(self.button)

        self.button.clicked.connect(self.magic)

    @QtCore.Slot()
    def magic(self):
        self.text.setText(self.hello)


if __name__ &#x3D;&#x3D; &quot;__main__&quot;:
    app &#x3D; QtWidgets.QApplication([])

    widget &#x3D; MyWidget()
    widget.resize(800, 600)
    widget.show()

    sys.exit(app.exec())</code></pre>

<p>这是官方文档中的例子，我只是取消了随机，让他变得更简单一点。</p>
<p>虽然他看起来十分的简单，但实际上这个例子包含了Qt的很多核心内容。</p>
<p>如果你尝试运行了这个代码，你会发现当你点击按钮的时候，屏幕上的文字会发生变化，这看起来似乎没什么了不起的，但实际上，这让我们的小部件和其他小部件进行了通信，它足以帮我们解决很多。</p>
<p>代码之中</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">self.button.clicked.connect(self.magic)</code></pre>

<p>其中clicked是<em>QPushButton</em>的一个预定义信号，在使用之中不会提示，甚至idea还有弹出警告，因为在<em>QPushButton</em>中找不到任何名为clicked的属性与方法。</p>
<p>但实际上，当我们观察<em>QPushButton</em>类，会发现他继承了父类QAbstractButton，而父类拥有此方法。</p>
<p><img src="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819112618328.png" class="lazyload" data-srcset="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819112618328.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220819112618328"></p>
<p>对于这个警告，直接选择忽略即可。</p>
<p>运行结果：</p>
<p><img src="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819112659956.png" class="lazyload" data-srcset="/post/%E5%9F%BA%E4%BA%8Epython%E7%9A%84QT%EF%BC%88%E4%B8%80%EF%BC%89/image-20220819112659956.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220819112659956"></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>//post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<p>操作系统</p>
<p>一个正在运行的程序是什么样的？</p>
<p>首先处理器从内存中读取指令，指令被读取，而后经过解码，开始执行。</p>
<p>这就是冯诺伊曼计算模型的基本概念。</p>
<p>事实上，因为操作系统的存在，使得程序的运行变得更加容易，甚至可以运行多个程序，当然现在这已经很常见了。</p>
<p>虚拟化</p>
<p>要想做到如上的描述，OS主要利用一种名为虚拟化的通用技术，OS将物理资源（处理器、磁盘、内存等）转换为更加通用更加容易使用的虚拟形式，因此OS有时候也叫作虚拟机。</p>
<p>为了让用户更方便的与OS进行交互，OS会提供很多的接口，让程序调用，从而更好的利用物理资源，因此有时候也说，OS为程序提供了一个标准库。</p>
<p>因为虚拟化，许多的程序可以同时运行，同时访问指令和数据，所以在很多时候，操作系统也被称之为资源管理器。</p>
<p>虚拟化CPU</p>
<p>当我们的电脑只有一个处理器，开始运行一个程序时，当程序本身没有错误时，我们大概率能得到我们所预期的结果。但是现在我们如果同时运行这一个程序的不同实例，这相当于调用四次函数，传入不同的参数，此时得到的结果很有趣，看起来就像是四个程序同时在执行一样，但是事实是我们只有一个处理器。</p>
<p>在硬件的帮助下，OS负责提供这种假象，也就是系统拥有非常多CPU的假象，把单个的CPU看成无限数量的CPU，从而让许多程序看似同时运行。</p>
<p>一次运行多个程序也会遇到很多问题，如果指定了多个程序运行的时间，并且时间都是一致的，那么到底在特定的时间里，运行那一个的问题就变得十分关键了，当然对此操作系统有自己对应的策略。</p>
<p>虚拟化内存</p>
<p>物理内存由机器提供，现代机器提供的模型十分简单，本质上就是一个字节数组，要读取内存，需要指定一个地址，就可以访问数据。</p>
<p>因此，程序在执行时，必须一直访问内存，程序将所有的数据结构都保存在内存里，并通过各种的指令来访问他。</p>
<p>如果我们此时再一次运行一个程序的多个实例，就会发现，每一个程序都在相同的内存地址分配了内存，但是每一个地址似乎都独立的更新了值，就好像每一个正在运行的程序都有自己的虚拟内存一样。</p>
<p>这就是虚拟内存的情况，每一个进程访问自己的私有虚拟地址空间，OS将他们映射到真实的物理内存上，一个正在运行的程序不影响其他进程或者操作系统本身的地址空间，对于正在运行的程序，他完全拥有自己的物理内存。</p>
<p>但实际上，物理内存是由操作系统管理的共享资源。</p>
<p>并发</p>
<p>操作系统首先运行一个进程，然后再运行一个进程，这实际上会导致一些问题。</p>
<p>并发并不局限于OS本身，多线程线程也存在相同的问题。</p>
<p>将线程看做是与其他函数在同一内存空间中运行的函数，并且每次都有多个线程处于活动的状态。</p>
<p>事实证明，当多线程程序执行时，出现的不同寻常的、奇怪的结果和指令的如何执行有关，指令从内存到寄存器，经过处理，重新回到内存，指令每次执行一条，但是我们的程序不可能只拥有一条指令，而指令的执行又是非原子性的，因此奇怪的事情会经常发生。</p>
<p>持久性</p>
<p>在OS内存中，数据是十分容易丢失的，因为像DRAM这样的设备是非常容易丢失数据的，其中除去断电之外，系统崩溃也会导致数据丢失。</p>
<p>因此，我们需要使用硬件和软件来持久化的存储数据，这样的存储对于所有的系统都很重要。</p>
<p>硬件主要是以IO设备的形式出现，硬盘驱动器是主要的存储库。</p>
<p>OS将管理磁盘的软件称之为文件系统，他可以以可靠和高效的方式，将创建的文件存储在物理内存上。</p>
<p>不像操作系统为CPU和内存提供的抽象，操作系统不会为应用程序创建专用的虚拟磁盘。因为用户经常需要共享文件中的信息。</p>
<p>例如，一个c文件的创建个运行，我们可能需要Emacs来创建一个c文件，而后我们需要使用编译器将源代码转化为可执行文件，然后我们运行这个可执行文件。</p>
<p>在这样的过程中，不难发现，一个文件经过了许多的进程。</p>
<p>OS为了实际写入磁盘：首先确定新数据将驻留在磁盘上的哪个位置，然后在文件系统所维护的各种结构中进行记录，这样做需要向底层存储设备发出IO请求，以读取现有结构或者更新他们。</p>
<p>当然还有很多的细节，出于性能上的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其分为较大的组，为了处理写入期间系统奔溃的问题，大多数文件系统都包含某种复杂的写入协议，如日志或写时赋值，仔细排序写入磁盘的操作，以确保如果写入序列期间发生故障，系统可以在之后恢复到合理的状态。为了使不同的通用操作更加高效，文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的B树。</p>
]]></content>
  </entry>
  <entry>
    <title>数据库原理与应用</title>
    <url>//post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="数据库原理与应用"><a href="#数据库原理与应用" class="headerlink" title="数据库原理与应用"></a>数据库原理与应用</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>数据（Data）</p>
<pre class="line-numbers language-none"><code class="language-none">数据是数据库中存储的基本对象
数据的定义：描述事物的符号记录
数据的种类：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等
数据的特点：数据与其语义是不可分的（说明：数据的含义称为数据的语义，数据与其语义是不可分的。）</code></pre>

<p>数据库（DataBase，简称 DB）</p>
<pre class="line-numbers language-none"><code class="language-none">数据库的定义：数据库（Database，简称 DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合。（一个大规模集成的数据集合。）
数据库的基本特征：
	数据按一定的数据模型组织、描述和储存
	可为各种用户共享
	冗余度较小
	数据独立性较高
	易扩展
数据库作用：
	一个数据库是对现实生活中一个企业或一个单位在计算机中的建模结果
	实体
	联系（实体间的关系）</code></pre>

<p>数据库管理系统（DataBase Management System，简称 DBMS）</p>
<pre class="line-numbers language-none"><code class="language-none">DBMS 的定义：是位于用户与操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是计算机的基础软件，也是一个大型复杂的软件系统。
DBMS 的用途：数据库管理系统的主要任务就是科学地组织和存储数据、高效地获取和维护数据
DBMS 的主要功能
    数据定义功能
        提供数据定义语言（DDL）
        定义数据库中的数据对象
    数据组织、存储和管理
        分类组织、存储和管理各种数据
        确定组织数据的文件结构和存取方式
        实现数据之间的联系
        提供多种存取方法提高存取效率
    数据操纵功能
        提供数据操纵语言（DML）
        实现对数据库的基本操作 CRUD (查询、插入、删除和修改)
    数据库的事务管理和运行管理
        数据库在建立、运行和维护时由 DBMS 统一管理和控制，保证事务的正确性
        保证数据的安全性、完整性、多用户对数据的并发使用
        发生故障后的系统恢复
    数据库的建立和维护功能（实用程序）
        数据库初始数据装载转换
        数据库转储
        介质故障恢复
        数据库的重组织
        性能监视分析等
    其它功能
        DBMS 与网络中其它软件系统的通信
        两个 DBMS 系统的数据转换
        异构数据库之间的互访和互操作</code></pre>

<p>数据库系统（Database System，简称 DBS）</p>
<pre class="line-numbers language-none"><code class="language-none">数据库系统的定义：在计算机系统中引入数据库后的系统构成数据库系统。
数据库系统的构成
	数据库
    数据库管理系统（及其开发工具）
    应用系统
    数据库管理员 (DBA)：是负责数据库的设计、规划、协调的专职人员。是全面负责建立、维护和管理数据库系统的人员。</code></pre>

<p>数据管理技术的产生和发展</p>
<p>数据管理是对数据进行分类、组织、编码、存储、检索和维护，也是数据处理的中心问题。</p>
<p>数据管理技术的发展过程</p>
<p>人工管理阶段（20 世纪 40 年代中 —— 50 年代中）</p>
<p>文件系统阶段（20 世纪 50 年代末 —— 60 年代中）</p>
<p>数据库系统阶段（20 世纪 60 年代末 —— 现在）</p>
<p>数据库系统的特点</p>
<pre class="line-numbers language-none"><code class="language-none">数据结构化
	数据库的主要特征之一，也是数据库系统与文件系统的本质区别
数据的共享性高，冗余度低，易扩充
	数据共享的好处：
		减少数据冗余，节约存储空间
		避免数据之间的不相容性与不一致性
		使系统易于扩充
数据独立性高
	物理独立性：指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。
	逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。
	数据独立性是由 DBMS 的二级映像功能来保证的
数据由 DBMS 统一管理和控制
	DBMS 提供以下几方面的数据控制功能
        数据的安全性（Security）保护：保护数据，以防止不合法的使用造成的数据的泄密和破坏。
    	数据的完整性（Integrity）检查：将数据控制在有效的范围内，或保证数据之间满足一定的关系。
    	并发（Concurrency）控制：对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。
    	数据库恢复（Recovery）：DBMS 必须具有将数据库从错误状态恢复到某一正确状态的功能
</code></pre>

<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型分为两类（分属两个不同的层次）</p>
<p>概念模型，也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</p>
<pre class="line-numbers language-none"><code class="language-none">实体（Entity）：客观存在并可相互区别的事物，比如一个学生，一门课，学生的一次选课
属性（Attribute）：实体所具有的某一特性，比如学生的身高，一个实体可以由若干个属性来刻画。
码（Key） ：唯一标识实体的属性集，比如学生的学号
域（Domain）：属性的取值范围称为该属性的域。
实体型（Entity Type）： 实体名 + 属性名，比如 学生（学号，姓名，性别）就是一个实体型
实体集（Entity Set）：同一类型的实体的集合，比如全体学生
联系（Relationship） ：现实世界中事物内部以及事物之间的联系在信息中反映为实体内部的联系和实体之间的联系。
实体内部的联系通常是指组成实体的各属性之间的联系
实体之间的联系通常是指不同实体集之间的联系，（有一对一，一对多，多对多等多种类型），实体之间的联系可用 E - R 图 表示</code></pre>

<p>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于 DBMS 实现。</p>
<p>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</p>
<p>关系模型是最重要的一种数据模型。</p>
<p>在用户观点下，关系模型由一组关系组成，每个关系的数据结构是一张规范化的二维表，它由行（元组）和列（属性）组成。</p>
<pre class="line-numbers language-none"><code class="language-none">关系（Relation）：一个关系对应一张表
元组（Tuple）：表中的一行即一个元组
属性（Attribute）：表中的一列即一个属性，给每一个属性起一个名称即属性名
主码（Key） ：表中的某个属性组，可以唯一确定一个元组，该属性组就称为主码。比如上表中的学号就就是该关系的主码
域（Domain）：域是一组具有相同数据类型的值的集合。比如人的年龄是1-120岁，属性的取值范围来自该属性对应的域
分量：元组中的一个属性值。
关系模式：对关系的描述，一般表示为 关系名（属性名1，属性名2....）。比如学生（学号，姓名，年龄，性别，系，年级）。关系模式必须是规范化的，不允许表中还有表，每个属性都应该是不可分的（即关系的每一个分量必须是一个不可分的数据项）</code></pre>

<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>关系 Relation</p>
<p>学生（学号，姓名，年级）就是一个关系</p>
<p>如果只有 1 个属性，则称为<strong>单元关系&#x2F;一元关系</strong></p>
<p>如果有 2 个属性，则称为<strong>二元关系</strong></p>
<p>主码 Primary Key</p>
<p>有一个或一组这样的属性，它的值能确定该关系中其他所有属性的值。</p>
<p>候选码 Candidate Key</p>
<p>能唯一标识元组的属性(组)，其中选择其一作为主码。</p>
<p>主属性 Prime Attribute</p>
<p>候选码中的诸属性。</p>
<p>非主属性 Non-Key Attribute</p>
<p>不出现在任何候选码中的属性。</p>
<p>关系的型与值</p>
<p>关系(表)的型：关系的结构(字段名、字段个数、域等)</p>
<p>关系(表)的值：关系中具体的元组，也称关系的实例(Instance)。</p>
<p>关系数据库</p>
<p>关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成。</p>
<p>（1）单一的数据结构—关系</p>
<p>关系模型的数据结构非常单一。在关系模型中，现实世界的实体以及实体间的各种联系均用关系来表示。在用户看来，关系模型中数据的逻辑结构是一张二维表。</p>
<p>（2）关系操作</p>
<p>关系模型中常用的关系操作包括：选择（Select）、投影（Project）、连接（Join）、除（Divide）、并（Union）、交(Intersection）、差（Difference）等和查询（Query）操作和增加（Insert）、删除（Delete）、修改（Update）操作两大部分。</p>
<p>（3）关系的三类完整牲约束</p>
<p>关系模型允许定义三类完整性约束：实体完整性、参照完整性和用户定义的完整性。<br>关系的完整性</p>
<p>关系模型中可以有三类完整性约束：实体完整性、参照完整性和用户定义完整性。</p>
<p>其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。</p>
<p>关系模型的完整性规则是对关系的某种约束条件。任何关系在任何时刻都要满足这些语义约束</p>
<p>实体完整性</p>
<p>关系数据库中的每个元组应该是可区分的、唯一的。这样的约束条件用实体完整性来保证</p>
<p>实体完整性规则：每个关系都应有至少一个主属性，且主属性不能为空值</p>
<p>例如：选修（学号，课程号，成绩）关系中，学号和课程号不能为空值</p>
<p> 实体完整性规则规定基本关系的所有主属性都不能取空值，而不仅是主码整体不能取空值。<br>参照完整性</p>
<p><strong>参照完整性规则：</strong>若属性 F 是基本关系R的外码，它与基本关系 S 的主码 Ks 相对应，则对于 R 中每个元组在 F 上的值必须为：</p>
<ul>
<li>或者取空值</li>
<li>或者等于 S 中某个元组的主码值</li>
</ul>
<p>用户定义完整性</p>
<p>任何关系数据库系统都应支持实体完整性和参照完整性。除此之外，用户还可以自定义完整性约束。</p>
<p>用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。</p>
<p>例：选修（学号，课程号，成绩）成绩的取值范围在 0~100 之间</p>
<p>关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能。<br>关系代数</p>
<p>关系代数是一种抽象的查询语言，是关系数据操纵语言的一种传统表达方式，它是用对关系的运算来表达查询的。</p>
<p>关系代数的运算对象是关系，运算结果亦是关系</p>
<p>关系代数用到的运算符包括两类：集合运算符和专门的关系运算符</p>
<p>传统的集合运算</p>
<p>传统的集合运算是二目运算，包括并、差、交、笛卡尔积 4 种运算</p>
<p>并 Union</p>
<p>关系 R 与关系 S 的并记作：<code>R ∪ S = &#123;t|t∈R ∨ t∈S&#125;</code></p>
<p>其结果仍为 n 目关系，由属于 R 或属于 S 的元组组成</p>
<p>差 Difference</p>
<p>系R与关系S的差记作：<code>R - S = &#123;t|t∈R ∧ tS&#125;</code></p>
<p>其结果关系仍为 n 目关系，由属于 R 而不属于 S 的所有元组组成。</p>
<p>交 Intersection</p>
<p>关系 R 与关系 S 的交记作：<code>R ∩ S = &#123;t|t∈R ∧ t∈S&#125;</code></p>
<p>其结果关系仍为 n 目关系，由既属于 R 又属于 S 的元组组成。关系的交可以用差来表示，即 <code>R ∩ S = R-(R-S)</code></p>
<p>笛卡尔积 Cartesian Product</p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20221129164932849.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20221129164932849.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>专门的关系运算</p>
<p>专门的关系运算包括选择、投影、连接、除运算等</p>
<p>选择 selection</p>
]]></content>
  </entry>
  <entry>
    <title>数据库恢复与安全性</title>
    <url>//post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7.html</url>
    <content><![CDATA[<h1 id="数据库恢复与安全性（Oracle）"><a href="#数据库恢复与安全性（Oracle）" class="headerlink" title="数据库恢复与安全性（Oracle）"></a>数据库恢复与安全性（Oracle）</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>（1）了解oracle的物理备份<br>（2）掌握oracle数据库逻辑备份方法<br>（3）掌握oracle数据库恢复的方法<br>（4）学会使用exp备份数据库、使用imp恢复数据库<br>（5）了解flashback 的使用<br>（6）学会完成SQL导入导出<br>（7）掌握ORACLE中有关用户创建的方法<br>（8）熟练掌握PL-SQL的数据控制语言，能通过自主存取控制进行权限管理<br>（9）熟悉用户资源文件的使用<br>（10）熟悉ORACLE中角色管理<br>（11）熟悉视图机制在自主存取控制上的应用</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>Oracle Database 12 home</p>
<h2 id="实验步骤、出现的问题及解决方案"><a href="#实验步骤、出现的问题及解决方案" class="headerlink" title="实验步骤、出现的问题及解决方案"></a>实验步骤、出现的问题及解决方案</h2><p>数据库用户、表空间、表</p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124145025551.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124145025551.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124145115615.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124145115615.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124144945430.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124144945430.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>逻辑备份</p>
<p>导出“预约”表</p>
<pre class="line-numbers language-oracle" data-language="oracle"><code class="language-oracle">exp userid&#x3D;ZS20220872&#x2F;123456@orcl tables&#x3D;TEST.预约 file&#x3D;C:\Users\Administrator\Desktop\西南科技大学\数据库原理\预约.dmp</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124145730196.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124145730196.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124151312923.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124151312923.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>删除”预约“表</p>
<pre class="line-numbers language-none"><code class="language-none">drop table 预约;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124150202433.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124150202433.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>导入“预约表”，恢复“预约表”</p>
<pre class="line-numbers language-none"><code class="language-none">imp userid&#x3D;ZS20220872&#x2F;123456@orcl fromuser&#x3D;test file&#x3D;C:\Users\Administrator\Desktop\西南科技大学\数据库原理\预约.dmp tables&#x3D;预约</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124150853581-16692737350081.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124150853581-16692737350081.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>查询预约表中信息</p>
<pre class="line-numbers language-none"><code class="language-none">select * from 预约;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124150933598.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124150933598.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>导出数据库</p>
<pre class="line-numbers language-none"><code class="language-none">exp userid&#x3D;ZS20220872&#x2F;123456@orcl full&#x3D;y inctype&#x3D;complete file&#x3D;C:\Users\Administrator\Desktop\西 南科技大学\数据库原理\all.dmp</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124151159985.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124151159985.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124151327016.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124151327016.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>使用闪回(flashback)</p>
<p>设置行可移动</p>
<pre class="line-numbers language-none"><code class="language-none">alter table 读者 enable row movement;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124152743635.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124152743635.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>在读者表中添加多条记录</p>
<pre class="line-numbers language-none"><code class="language-none">insert into 读者 values(&#39;20190325&#39;,&#39;张四&#39;,&#39;西科大应计学院&#39;,&#39;男&#39;,&#39;西山学院西100宿舍楼&#39;,&#39;1352659962&#39;,&#39;52182193213123&#39;);
insert into 读者 values(&#39;201903232&#39;,&#39;张七&#39;,&#39;西科大应计学院&#39;,&#39;男&#39;,&#39;西山学院西100宿舍楼&#39;,&#39;135262359962&#39;,&#39;522665445454564563&#39;);
select 姓名,性别 from 读者;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153029912.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153029912.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153117778.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153117778.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153425218.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153425218.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221124153425218"></p>
<p>闪回到改变之前</p>
<pre class="line-numbers language-none"><code class="language-none">flashback table 读者 to timestamp to_timestamp(&#39;2022&#x2F;11&#x2F;24 15:30:00&#39;,&#39;YYYY&#x2F;MM&#x2F;DDHH24:MI:SS&#39;);
 select 姓名,性别 from 读者;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153638827.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153638827.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>SQl导入导出</p>
<p>导出图书表</p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154258167.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154258167.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153840889.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124153840889.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>删除表</p>
<p>NULL</p>
<p>导入表</p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154336840.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154336840.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>以SYSTEM登录数据库，为自己帐号增加系统角色DBA</p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154609641.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154609641.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<pre class="line-numbers language-none"><code class="language-none">grant dba to ZS20220872;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154647214.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154647214.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>重新以自己的帐号登录，创建一个数据库用户，该用户拥有所有CONNECT, RESOURCE，DBA系统角色权限。</p>
<pre class="line-numbers language-none"><code class="language-none">create user Renchengzhen identified by 123456;
grant connect to renchengzhen;
grant resource to renchengzhen;
grant dba to renchengzhen;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154932902.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124154932902.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155023487.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155023487.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155114676.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155114676.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>(未定义函数，以下语句无效)</p>
<p>建立角色：renchengzhen_OPER，该角色拥有调用存储过程借书、还书、预约的权限，以及CONNECT系统角色权限。</p>
<pre class="line-numbers language-none"><code class="language-none">create role renchengzhen_role;
grant connect to renchengzhen_role;
grant execute on 借书 to renchengzhen_role;
grant execute on 还书 to renchengzhen_role;
grant execute on 预约 to renchengzhen_role;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155502229.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155502229.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>创建一个数据库用户：用户_oper（用户为“自己名字全拼”）为该用户授权角色：用户_role。以该用户登录，完成借书，还书功能。</p>
<pre class="line-numbers language-none"><code class="language-none">create role renchengzhen_oper;
grant renchengzhen_role to renchengzhen_oper;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155900990.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155900990.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<pre class="line-numbers language-none"><code class="language-none">call renchengzhen.借书();</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155939791.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124155939791.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>以自己的帐号登录，建立视图VIEW_READER, 该视图包含书目（ISBN, 书名，作者，出版单位，图书分类名称）</p>
<pre class="line-numbers language-none"><code class="language-none">CREATE VIEW VIEW_READER
AS
SELECT
	&quot;书目&quot;.&quot;iSBN&quot;, 
	&quot;书目&quot;.&quot;书名&quot;, 
	&quot;书目&quot;.&quot;作者&quot;, 
	&quot;书目&quot;.&quot;出版单位&quot;, 
	&quot;书目&quot;.&quot;图书分类号&quot;
FROM
	&quot;书目&quot;;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161138090.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161138090.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>创建一个数据库用户：renchengzhen_USER1，该用户具有对视图VIEW_READER查询的权限。</p>
<pre class="line-numbers language-none"><code class="language-none">create user renchengzhen_user1 identified by 123456;
grant connect to renchengzhen_user1;
grant select on view_reader to renchengzhen_user1;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161413536.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161413536.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>创建一个概要文件，如果renchengzhen_USER1连续3次登录失败，则锁定该账户，10天后该账户自动解锁。把创建的概要文件分配给该账号，然后以该用户登录进行权限测试。</p>
<pre class="line-numbers language-none"><code class="language-none">CREATE PROFILE LOCK_USER LIMIT
FAILED_LOGIN_ATTEMPTS 3
PASSWORD_LOCK_TIME 10;
ALTER USER renchengzhen_USER1 PROFILE LOCK_USER;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161605933.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161605933.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161636982.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161636982.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161711052.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161711052.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161729036.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161729036.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<pre class="line-numbers language-none"><code class="language-none">ALTER USER renchengzhen_USER1 ACCOUNT UNLOCK;</code></pre>

<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161834866.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161834866.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161844693.png" class="lazyload" data-srcset="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7/image-20221124161844693.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>//post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;
&#x2F;&#x2F; Created by Administrator on 2022&#x2F;10&#x2F;7.
&#x2F;&#x2F; 描述顺序线性表这种常用的数据结构
&#x2F;&#x2F;

#include &lt;stdio.h&gt;

#define MAXSIZE 100
#define ElemType int
#define OK 1
#define ERROR 0

typedef int Status;

&#x2F;&#x2F; 定义一个存储整形int的顺序表，最大长度为100，实际长度为length
typedef struct &#123;
    ElemType data[MAXSIZE];
    int length;
&#125; SqList;

&#x2F;&#x2F; 初始化线性表
int initSqList(SqList *L, ElemType a[], int n) &#123;
    if (n &gt; MAXSIZE) &#123;
        printf(&quot;failed!&quot;);
        return ERROR;
    &#125;
    for (int i &#x3D; 0; i &lt; n; i++)
        L-&gt;data[i] &#x3D; a[i];
    L-&gt;length &#x3D; n;
    return OK;
&#125;

&#x2F;&#x2F; 获取元素
&#x2F;&#x2F; 获取L的第i个元素，并用e返回值
Status GetElem(SqList L, int i, ElemType *e) &#123;
    if (L.length &#x3D;&#x3D; 0 || i &lt; 1 || i &gt; L.length)
        return ERROR;
    *e &#x3D; L.data[i - 1];
    return OK;
&#125;

&#x2F;&#x2F; 插入元素
&#x2F;&#x2F; 在L的第i个位置，插入元素e，L长度加一
Status InsertElem(SqList *L, int i, ElemType e) &#123;
    int k;
    if (L-&gt;length &#x3D;&#x3D; MAXSIZE)
        return ERROR;
    if (i &lt; 1 || i &gt; L-&gt;length + 1)
        return ERROR;
    if (i &lt;&#x3D; L-&gt;length) &#123;
        for (k &#x3D; L-&gt;length - 1; k &gt;&#x3D; i - 1; k--)
            L-&gt;data[k + 1] &#x3D; L-&gt;data[k];
    &#125;
    L-&gt;data[i - 1] &#x3D; e;
    L-&gt;length++;
    return OK;
&#125;

&#x2F;&#x2F; 打印线性表
void PrintElem(SqList *L) &#123;
    for (int i &#x3D; 0; i &lt; L-&gt;length; i++) &#123;
        printf(&quot;%d\t&quot;, L-&gt;data[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;

&#x2F;&#x2F; 删除元素
&#x2F;&#x2F; 删除L的第i个元素，并且e返回值，L的长度减1
Status DeleteElem(SqList *L, int i, ElemType *e) &#123;
    int k;
    if (L-&gt;length &#x3D;&#x3D; 0) &#123;
        return ERROR;
    &#125;
    if (i &gt; L-&gt;length || i &lt; 1) &#123;
        return ERROR;
    &#125;
    *e &#x3D; L-&gt;data[i - 1];
    if (i &lt; L-&gt;length) &#123;
        for (k &#x3D; i; k &lt; L-&gt;length; k++) &#123;
            L-&gt;data[k - 1] &#x3D; L-&gt;data[k];
        &#125;
    &#125;
    L-&gt;length--;
    return OK;
&#125;

&#x2F;&#x2F; 修改元素
&#x2F;&#x2F; 修改L的第i个元素为e
Status UpdateElem(SqList *L, int i, ElemType e) &#123;
    if (L-&gt;length &#x3D;&#x3D; 0)
        return ERROR;
    if (i &gt; L-&gt;length || i &lt; 1)
        return ERROR;
    L-&gt;data[i - 1] &#x3D; e;
    return OK;

&#125;

int main() &#123;
    SqList L;
    ElemType e;
    int data[] &#x3D; &#123;1, 10, 2, 3, 1, 5&#125;;
    initSqList(&amp;L, data, 6);
    PrintElem(&amp;L);
    GetElem(L, 3, &amp;e);
    printf(&quot;获取到了元素：%d\n&quot;, e);
    InsertElem(&amp;L, 5, 10);
    PrintElem(&amp;L);
    DeleteElem(&amp;L, 1, &amp;e);
    printf(&quot;删除了元素：%d\n&quot;, e);
    PrintElem(&amp;L);
    UpdateElem(&amp;L,2,100);
    PrintElem(&amp;L);
&#125;</code></pre>

<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;
&#x2F;&#x2F; Created by Administrator on 2022&#x2F;10&#x2F;9.
&#x2F;&#x2F;
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

#define OK 1
#define ERROR 0

typedef int DataType;
typedef int Status;

typedef struct Node &#123;
    DataType data;
    struct Node *next;
&#125; Node;

&#x2F;&#x2F; 初始化链表
Node *InitList() &#123;
    Node *first &#x3D; (Node *) malloc(sizeof(Node));
    first-&gt;next &#x3D; NULL;
    return first;
&#125;

&#x2F;&#x2F; 输出链表
void PrintNode(Node *first) &#123;
    Node *p &#x3D; first-&gt;next;
    printf(&quot;Node:&quot;);
    while (p !&#x3D; NULL) &#123;
        printf(&quot;%d-&gt;&quot;, p-&gt;data);
        p &#x3D; p-&gt;next;
    &#125;
    printf(&quot;\n&quot;);
&#125;

&#x2F;&#x2F; 求链表长度
int length(Node *first) &#123;
    Node *p &#x3D; first-&gt;next;
    int count &#x3D; 0;
    while (p !&#x3D; NULL) &#123;
        p &#x3D; p-&gt;next;
        count++;
    &#125;
    return count;
&#125;

&#x2F;&#x2F; 头插法建立单链表
Node *CreateList_head(DataType a[], int n) &#123;
    Node *s &#x3D; NULL;
    Node *first &#x3D; (Node *) malloc(sizeof(Node));
    first-&gt;next &#x3D; NULL; &#x2F;&#x2F; 初始化头结点
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        s &#x3D; (Node *) malloc(sizeof(Node)); &#x2F;&#x2F; 申请内存
        s-&gt;data &#x3D; a[i];
        s-&gt;next &#x3D; first-&gt;next; &#x2F;&#x2F; 将结点s插入头结点之后
        first-&gt;next &#x3D; s;
    &#125;
    return first;
&#125;

&#x2F;&#x2F; 尾插法建立单链表
Node *CreateList_end(DataType a[], int n) &#123;
    Node *s &#x3D; NULL;
    Node *r &#x3D; NULL;
    Node *first &#x3D; (Node *) malloc(sizeof(Node)); &#x2F;&#x2F; 生成头结点
    r &#x3D; first; &#x2F;&#x2F; 尾指针初始化
    for (int i &#x3D; 0; i &lt; n; i++) &#123;
        s &#x3D; (Node *) malloc(sizeof(Node));
        s-&gt;data &#x3D; a[i];
        r-&gt;next &#x3D; s; &#x2F;&#x2F; 将结点s插到尾指针之后
        r &#x3D; s;
    &#125;
    r-&gt;next &#x3D; NULL; &#x2F;&#x2F; 单链表建立完毕，将尾指针指针域置空
    return first;
&#125;

&#x2F;&#x2F; 插入元素
Status Insert(Node *first, int i, DataType x) &#123;
    Node *s &#x3D; NULL;
    Node *p &#x3D; first; &#x2F;&#x2F; 指针初始化，指向头结点
    int count &#x3D; 0;
    while (p !&#x3D; NULL &amp;&amp; count &lt; i) &#123; &#x2F;&#x2F; 查找第i-1个节点
        p &#x3D; p-&gt;next;
        count++;
    &#125;
    if (p &#x3D;&#x3D; NULL) &#123;
        printf(&quot;error location cannot insert!\n&quot;);\
        return 0;
    &#125; else &#123;
        s &#x3D; (Node *) malloc(sizeof(Node)); &#x2F;&#x2F; 创建一个新节点
        s-&gt;data &#x3D; x;
        s-&gt;next &#x3D; p-&gt;next; &#x2F;&#x2F; 将结点插入到p之后
        p-&gt;next &#x3D; s;
        return OK;
    &#125;
&#125;

&#x2F;&#x2F; 删除元素
Status Delete(Node *first, int i, DataType *ptr) &#123;
    Node *p &#x3D; first; &#x2F;&#x2F; 指针指向头结点
    Node *q &#x3D; NULL;
    int count &#x3D; 0;
    while (p !&#x3D; NULL &amp;&amp; count &lt; i - 1) &#123; &#x2F;&#x2F; 查找第i-1个节点
        p &#x3D; p-&gt;next;
        count++;
    &#125;
    if (p &#x3D;&#x3D; NULL || p-&gt;next &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F; p节点或者p的后置节点不存在
        printf(&quot;ERROR location!&quot;);
    &#125; else &#123; &#x2F;&#x2F; 找到i节点并删除，通过指针*ptr返回删除后的数据
        q &#x3D; p-&gt;next;
        *ptr &#x3D; q-&gt;data;
        p-&gt;next &#x3D; q-&gt;next;
        free(q);
        return OK;
    &#125;
&#125;

&#x2F;&#x2F; 删除单链表
Status Destory(Node *first) &#123;
    Node *p &#x3D; first;
    while (p !&#x3D; NULL) &#123;
        first &#x3D; first-&gt;next;
        free(p);
        p &#x3D; first;
    &#125;
&#125;

&#x2F;&#x2F; 判断链表是否为空
Status isEmpty(Node *first) &#123;
    if (first-&gt;next &#x3D;&#x3D; NULL) &#123;
        return OK;
    &#125; else &#123;
        return ERROR;
    &#125;
&#125;

&#x2F;&#x2F; 按值查找位置
int locate(Node *first, DataType x) &#123;
    Node *p &#x3D; first-&gt;next;
    int count &#x3D; 1;
    while (p !&#x3D; NULL) &#123;
        if (p-&gt;data &#x3D;&#x3D; x) &#123;
            return count;
        &#125;
        p &#x3D; p-&gt;next;
        count++;
    &#125;
    return 0;
&#125;

&#x2F;&#x2F; 按照位置查找
int Get(Node *first, int i, DataType *ptr) &#123;
    Node *p &#x3D; first-&gt;next;
    int count &#x3D; 1;
    while (p !&#x3D; NULL &amp;&amp; count &lt; i) &#123;
        p &#x3D; p-&gt;next;
        count++;
    &#125;
    if (p &#x3D;&#x3D; NULL) &#123;
        printf(&quot;error location!&quot;);
    &#125; else &#123;
        *ptr &#x3D; p-&gt;data;
        return OK;
    &#125;
&#125;

int main() &#123;
    DataType x;
    int data[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;
    Node *first &#x3D; CreateList_head(data, 5);
    Node *last &#x3D; CreateList_end(data, 5);
    PrintNode(first);
    printf(&quot;链表的长度为：%d\n&quot;, length(first));
    PrintNode(last);
    printf(&quot;链表的长度为：%d\n&quot;, length(last));
    Insert(first, 1, 10);
    PrintNode(first);
    Delete(first, 3, &amp;x);
    PrintNode(first);
    return 0;
&#125;</code></pre>

<p>循环链表</p>
<p>双向链表</p>
<p>队列</p>
<p>栈</p>
<p>二叉树</p>
<p>堆</p>
]]></content>
  </entry>
  <entry>
    <title>概率论笔记</title>
    <url>//post/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>罗素悖论</p>
<p>令 P(x) 表示 x ∉ x. 也就是说，对 x 而言，如果 P(x) 是真的， 那么 x 就不是自身的元素; 但如果 P(x) 为假，那么 x 就是 x 中的元素。</p>
<p>那么 R 是集合吗？如果是，它的元素是什么？</p>
<p>如果你在考虑 R ∉ R 是否正确， 那就开始走上正轨了。 </p>
<p>我们要用到表达式 x ∉ x， 这意味着要对 x 有所选择。</p>
<p>x &#x3D; R 很自然地成为一个被考察的候选对象， 因为它涉及我们要研究的东西 (并且在分析 中研究是很不错的尝试)。</p>
<p> 这里有两种可能的情况：</p>
<p>要么 R 在 R 中， 要么 R 不在 R 中. </p>
<p>• 首先， 假设 R 在 R 中. 由于我们假设 R ∉ R， 并且 R 是由那些不属于自身 的对象构成的， 所以由 R 的定义可知， R ∈ R. 但这是很荒谬的. R ∉ R 和 R ∈ R 怎么可能同时成立呢？因此， 假设 R 在 R 中是错误的. </p>
<p>• 唯一可能的情况是 R 不在 R 中。现在来讨论这种情况。 正如我们已经说过 的， R 是由全体不属于自身的东西构成的集合。我们现在假设 R ∉ R， 但是 从定义上来看， 这正是 R 中元素所满足的条件！同样地， 我们得到了荒谬的 结论， 即 R ∈ R 和 R ∉ R 同时成立. 换句话说， 在任何一种情况下， 我们都得到了奇怪的情形：当 R ∉ R 时恰有 R ∈ R. 这意味着什么呢？这意味着， 我们可以用集合做什么的观念 —— 更具体地说， 我们如何从旧集合中构造新集合的观念 —— 具有致命的缺陷。 这一悖论的解决为现代集合论奠定了基础。 从罗素悖论中可以推出一个结论， 那就是我们无法通过简单地收集具有给定性质的所有对象来形成集合。 </p>
<p>幸运的是， 我们在概率论中遇到的绝大多数集合都没有这个问题， 但重要的是意识到潜在的危险， 并且要正确、 认真地理解证明。 </p>
<p>事件的概率必然涉及大型集对子集指定概率的问题。但是，没有一种通用的方法可以将概率分配给每个子集，并且使得概率函数满足某些条件。这涉及到巴拿赫-塔尔斯基悖论。</p>
<p>为了防止不能把概率一致地分给所有可能的子集，必须留意要考察的事件。</p>
<p>笛卡尔积：全体A、B的有序集对（a，b）</p>
<p>幂集：集合所有子集的集合</p>
]]></content>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记</title>
    <url>//post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h2 id="算法部分"><a href="#算法部分" class="headerlink" title="算法部分"></a>算法部分</h2><h3 id="BFS与DFS"><a href="#BFS与DFS" class="headerlink" title="BFS与DFS"></a>BFS与DFS</h3><p>深度优先搜索（DFS）和广度优先搜索（BFS）是图遍历算法，也可以用于搜索树等数据结构。它们的主要区别在于遍历顺序和数据结构的不同。</p>
<p>深度优先搜索首先遍历一条路径直到它无法继续深入，然后回溯并尝试遍历另一条路径，重复此过程，直到所有路径都被遍历。可以使用递归或栈来实现深度优先搜索。</p>
<p>广度优先搜索从起始节点开始遍历，首先访问所有相邻节点，然后逐层向外扩展，直到找到目标节点或遍历完整个图。可以使用队列来实现广度优先搜索。</p>
<p>两者的主要区别在于遍历顺序和空间利用率。DFS会沿着一条路径尽可能远地探索，直到找到目标或无法继续。这通常导致DFS占用较少的空间，但可能导致它花费更长的时间，因为它可能需要搜索整个图或树。而BFS会逐层地遍历，可能需要更多的空间来存储每一层的节点，但是它通常会更快地找到目标节点。</p>
<p>一般来说，如果需要找到最短路径，或者需要遍历整个图或树，可以使用BFS。如果需要深入探索某一路径，或者需要找到任意一条路径，可以使用DFS。二叉树的遍历时间复杂度都是O(n)，其中n为树的节点数，因为需要访问树中的每个节点一次。</p>
<p>深度优先搜索的时间复杂度取决于遍历的节点数量。在最坏情况下，如果遍历整棵树，则时间复杂度为O(n)。在最好情况下，如果树是平衡的，时间复杂度为O(log n)。这是因为平衡二叉树的高度是对数级别的。在平均情况下，时间复杂度为O(n log n)。</p>
<p>广度优先搜索的时间复杂度同样取决于遍历的节点数量。在最坏情况下，如果遍历整棵树，则时间复杂度为O(n)。在最好情况下，如果树是满二叉树，时间复杂度为O(log n)。在平均情况下，时间复杂度为O(n)。</p>
<p>例题：</p>
<p><a href="./%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.html#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91">相同的树</a></p>
<h2 id="题目部分"><a href="#题目部分" class="headerlink" title="题目部分"></a>题目部分</h2><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>​	<strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9
输出：[0,1]
解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,2,4], target &#x3D; 6
输出：[1,2]</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,3], target &#x3D; 6
输出：[0,1]</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<p>Related Topics</p>
<p>数组</p>
<p>哈希表</p>
<p><strong>1、双重循环，暴力破解</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int *twoSum(int *nums, int numsSize, int target, int *returnSize) &#123;
    for (int i &#x3D; 0; i &lt; numsSize; ++i) &#123;
        for (int j &#x3D; i + 1; j &lt; numsSize; ++j) &#123;
            if (nums[i] + nums[j] &#x3D;&#x3D; target) &#123;
                int *ret &#x3D; malloc(sizeof(int) * 2);
                ret[0] &#x3D; i;
                ret[1] &#x3D; j;
                *returnSize &#x3D; 2;
                return ret;
            &#125;
        &#125;
    &#125;
    *returnSize &#x3D; 0;
    return NULL;
&#125;</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230203123355192.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230203123355192.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<p><strong>2、哈希表，一层循环</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">struct hashTable &#123;
    int key;
    int val;
    UT_hash_handle hh;
&#125;;

struct hashTable* hashtable;

struct hashTable* find(int ikey) &#123;
    struct hashTable* tmp;
    HASH_FIND_INT(hashtable, &amp;ikey, tmp);
    return tmp;
&#125;

void insert(int ikey, int ival) &#123;
    struct hashTable* it &#x3D; find(ikey);
    if (it &#x3D;&#x3D; NULL) &#123;
        struct hashTable* tmp &#x3D; malloc(sizeof(struct hashTable));
        tmp-&gt;key &#x3D; ikey, tmp-&gt;val &#x3D; ival;
        HASH_ADD_INT(hashtable, key, tmp);
    &#125; else &#123;
        it-&gt;val &#x3D; ival;
    &#125;
&#125;

int* twoSum(int* nums, int numsSize, int target, int* returnSize) &#123;
    hashtable &#x3D; NULL;
    for (int i &#x3D; 0; i &lt; numsSize; i++) &#123;
        struct hashTable* it &#x3D; find(target - nums[i]);
        if (it !&#x3D; NULL) &#123;
            int* ret &#x3D; malloc(sizeof(int) * 2);
            ret[0] &#x3D; it-&gt;val, ret[1] &#x3D; i;
            *returnSize &#x3D; 2;
            return ret;
        &#125;
        insert(nums[i], i);
    &#125;
    *returnSize &#x3D; 0;
    return NULL;
&#125;</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230203124807319.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230203124807319.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<h3 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h3><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：x &#x3D; 121
输出：true</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：x &#x3D; -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：x &#x3D; 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<p><strong>进阶：</strong>你能不将整数转为字符串来解决这个问题吗？</p>
<p>Related Topics</p>
<p>数学</p>
<p><strong>数学解法</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">bool isPalindrome(int x) &#123;
    double t &#x3D; 0;
    double n &#x3D; x;
    if (x &lt; 0) &#123;
        return false;
    &#125; else &#123;
        while (x) &#123;
            int temp;
            temp &#x3D; x % 10;
            t &#x3D; t * 10 + temp;
            x &#x2F;&#x3D; 10;
        &#125;
        return n &#x3D;&#x3D; t;
    &#125;
&#125;</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230203125904887.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230203125904887.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<h3 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h3><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</code></pre>

<p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。</p>
<p><strong>示例 1:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;III&quot;
输出: 3</code></pre>

<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;IV&quot;
输出: 4</code></pre>

<p><strong>示例 3:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;IX&quot;
输出: 9</code></pre>

<p><strong>示例 4:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;LVIII&quot;
输出: 58
解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</code></pre>

<p><strong>示例 5:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;MCMXCIV&quot;
输出: 1994
解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 15</code></li>
<li><code>s</code> 仅含字符 <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code></li>
<li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article">罗马数字 - Mathematics </a>。</li>
</ul>
<p>Related Topics</p>
<p>哈希表</p>
<p>数学</p>
<p>字符串</p>
<p>1、<strong>暴力解法</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">int romanToInt(char * s)&#123;
    int n&#x3D;strlen(s);
    int num&#x3D;0,i&#x3D;0,j&#x3D;0,k&#x3D;0;;
    int a[16];
    for(i&#x3D;0;i&lt;n;i++)&#123;
        switch(s[i])&#123;
            case &#39;I&#39;:a[i]&#x3D;1;break;
            case &#39;V&#39;:a[i]&#x3D;5;break;
            case &#39;X&#39;:a[i]&#x3D;10;break;
            case &#39;L&#39;:a[i]&#x3D;50;break;
            case &#39;C&#39;:a[i]&#x3D;100;break;
            case &#39;D&#39;:a[i]&#x3D;500;break;
            default :a[i]&#x3D;1000;break;
        &#125;                           &#x2F;&#x2F;按序存储字符对应10进制数字
    &#125;
    for(i&#x3D;0;i&lt;n-1;i++)&#123;
        if(a[i]&gt;&#x3D;a[i+1])&#123;
            num+&#x3D;a[i];
        &#125;
        else&#123;
            num+&#x3D;a[i+1]-a[i];
            i++;
        &#125;
    &#125;
    if(n&#x3D;&#x3D;1)return a[0];            &#x2F;&#x2F;一位罗马数情况
    if(a[n-1]&lt;&#x3D;a[n-2])
        num+&#x3D;a[n-1];                    &#x2F;&#x2F;末尾补位
    return num;
&#125;</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230204132101346.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230204132101346.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<p>2、<strong>哈希表</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">char roman[7] &#x3D; &quot;IVXLCDM&quot;;
int data[7] &#x3D; &#123; 1, 5, 10, 50, 100, 500, 1000 &#125;;

int map(char c)
&#123;
    int i &#x3D; 0;
    for (i &#x3D; 0; i &lt; 7; i++) &#123;
        if (roman[i] &#x3D;&#x3D; c)
            break;
    &#125;
    return i;
&#125;

int romanToInt(char * s)&#123;
    int num &#x3D; 0;

    for (int i &#x3D; 0; i &lt; strlen(s) - 1; i++) &#123;
        if (map(s[i]) &gt;&#x3D; map(s[i + 1]))
            num +&#x3D; data[map(s[i])];
        else
            num -&#x3D; data[map(s[i])];
    &#125;
    num +&#x3D; data[map(s[strlen(s) - 1])];
    return num;
&#125;</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230204132405927.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230204132405927.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出：&quot;fl&quot;</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出：&quot;&quot;
解释：输入不存在公共前缀。</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 200</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
<li><code>strs[i]</code> 仅由小写英文字母组成</li>
</ul>
<p>Related Topics</p>
<p>字符串</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">char *longestCommonPrefix(char **strs, int strsSize) &#123;
    int a &#x3D; strlen(strs[0]);
    int i &#x3D; 0;
    char *ptr &#x3D; strs[0];
    for (int j &#x3D; 1; j &lt; strsSize; j++) &#123;
        for (i &#x3D; 0; i &lt; a; i++) &#123;
            if (strs[j][i] &#x3D;&#x3D; ptr[i]); else break;
        &#125;
        a &#x3D; i;

    &#125;
    ptr[a] &#x3D; &#39;\0&#39;;
    return ptr;
&#125;</code></pre>

<h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;()&quot;
输出：true</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;
输出：true</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;(]&quot;
输出：false</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<p>Related Topics</p>
<p>栈</p>
<p>字符串</p>
<p><strong>1、暴力循环，字符串替换</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">class Solution(object):
    def isValid(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        length &#x3D; len(s)
        if length &lt; 2 or length % 2 !&#x3D; 0:
            if s &#x3D;&#x3D; &quot;&quot;:
                return True
            else:
                return False
        count &#x3D; 2
        while count &lt;&#x3D; length &#x2F; 2:
            s &#x3D; s.replace(&quot;&#123;&#125;&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;).replace(&quot;()&quot;, &quot;&quot;)
            count +&#x3D; 1
        if s &#x3D;&#x3D; &quot;&#123;&#125;&quot; or s &#x3D;&#x3D; &quot;[]&quot; or s &#x3D;&#x3D; &quot;()&quot; or s &#x3D;&#x3D; &quot;&quot;:
            return True
        else:
            return False</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230205122509053.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230205122509053.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<p>2、<strong>栈</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">from collections import deque

class Solution(object):
    def isValid(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        dict &#x3D; &#123;
            &#39;&#123;&#39;: &#39;&#125;&#39;,
            &#39;[&#39;: &#39;]&#39;,
            &#39;(&#39;: &#39;)&#39;,
            &quot;1&quot;: &quot;1&quot;
        &#125;
        if len(s) &lt; 2 and len(s) % 2 !&#x3D; 0:
            if s &#x3D;&#x3D; &quot;&quot;:
                return True
            else:
                return False
        if s[0] in dict.values():
            return False
        stack &#x3D; deque()
        stack.append(&quot;1&quot;)
        for i in s:
            if i in dict:
                stack.append(i)
            elif dict[stack.pop()] !&#x3D; i:
                return False
        return len(stack) &#x3D;&#x3D; 1</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230205123246617.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230205123246617.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<p><strong>3、栈，考虑其他情况</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isValid(s):
    &quot;&quot;&quot;
    :type s: str
    :rtype: bool
    &quot;&quot;&quot;
    dict &#x3D; &#123;
        &quot;)&quot;: &quot;(&quot;,
        &quot;&#125;&quot;: &quot;&#123;&quot;,
        &quot;]&quot;: &quot;[&quot;
    &#125;
    stack &#x3D; deque()
    for i in range(len(s)):
        # 如果右括号在前面
        if s[i] in dict:
            if len(stack) &#x3D;&#x3D; 0:
                return False
            else:
                temp &#x3D; stack.pop()
                if temp !&#x3D; dict[s[i]]:
                    return False
        else:
            stack.append(s[i])
    if len(stack) &#x3D;&#x3D; 0:
        return True
    else:
        return False</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230205192408367.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230205192408367.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230205193059944.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230205193059944.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20230205193059944"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]
输出：[1,1,2,3,4,4]</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [], l2 &#x3D; []
输出：[]</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：l1 &#x3D; [], l2 &#x3D; [0]
输出：[0]</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p>Related Topics</p>
<p>递归</p>
<p>链表</p>
<p>1、<strong>递归</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">                                         python
class Solution(object):
    def mergeTwoLists(self, list1, list2):
        &quot;&quot;&quot;
        :type list1: Optional[ListNode]
        :type list2: Optional[ListNode]
        :rtype: Optional[ListNode]
        &quot;&quot;&quot;
        if list1 and list2:
            if list1.val &gt; list2.val: list1, list2 &#x3D; list2, list1
            list1.next &#x3D; self.mergeTwoLists(list1.next, list2)
        return list1 or list2</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230207181646979.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230207181646979.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def mergeTwoLists(self, list1, list2):
    &quot;&quot;&quot;
    :type list1: Optional[ListNode]
    :type list2: Optional[ListNode]
    :rtype: Optional[ListNode]
    &quot;&quot;&quot;
    res &#x3D; ListNode(-1)
    tmp &#x3D; res
    while list1 and list2:
        if list1.val &lt;&#x3D; list2.val:
            tmp.next &#x3D; list1
            list1 &#x3D; list1.next
        else:
            tmp.next &#x3D; list2
            list2 &#x3D; list2.next
        tmp &#x3D; tmp.next
    if list1:
        tmp.next &#x3D; list1
    else:
        tmp.next &#x3D; list2
    return res.next</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230222200630502.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230222200630502.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h3><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 <code>k</code> 个元素，那么 <code>nums</code> 的前 <code>k</code> 个元素应该保存最终结果。</p>
<p>将最终结果插入 <code>nums</code> 的前 <code>k</code> 个位置后返回 <code>k</code> 。</p>
<p>不要使用额外的空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>判题标准:</strong></p>
<p>系统会用下面的代码来测试你的题解:</p>
<pre class="line-numbers language-none"><code class="language-none">int[] nums &#x3D; [...]; &#x2F;&#x2F; 输入数组
int[] expectedNums &#x3D; [...]; &#x2F;&#x2F; 长度正确的期望答案

int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用

assert k &#x3D;&#x3D; expectedNums.length;
for (int i &#x3D; 0; i &lt; k; i++) &#123;
    assert nums[i] &#x3D;&#x3D; expectedNums[i];
&#125;</code></pre>

<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,1,2]
输出：2, nums &#x3D; [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]
输出：5, nums &#x3D; [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>升序</strong> 排列</li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p><strong>1、双重循环，暴力求解</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">class Solution(object):
    def removeDuplicates(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        for i in range(1, len(nums)):
            for j in range(i, len(nums)):
                if nums[i] &#x3D;&#x3D; nums[i - 1]:
                    nums.pop(i)
        print(nums)
        return len(nums)</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206115029668.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206115029668.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<p>2、单层循环（冒泡）</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def removeDuplicates(nums):

    &quot;&quot;&quot;
    :type nums: List[int]
    :rtype: int
    &quot;&quot;&quot;
    i &#x3D; 1
    while (1):
        if i &gt;&#x3D; len(nums):
            break
        ptr1 &#x3D; nums[i]
        ptr2 &#x3D; nums[i - 1]
        if ptr1 &#x3D;&#x3D; ptr2:
            nums.pop(i)
        else:
            i +&#x3D; 1
    return len(nums)</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206121741835.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206121741835.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<p>3、单层循环（插入）</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def removeDuplicates(nums):
    &quot;&quot;&quot;
    :type nums: List[int]
    :rtype: int
    &quot;&quot;&quot;
    i &#x3D; 0
    while(1):
        if i &gt;&#x3D; len(nums):
            break
        temp &#x3D; nums.pop(i)
        if temp in nums:
            pass
        else:
            nums.insert(i,temp)
            i +&#x3D; 1
    return len(nums)</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206122856802.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206122856802.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<p>4、双指针</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def removeDuplicates(self, nums):
    &quot;&quot;&quot;
    :type nums: List[int]
    :rtype: int
    &quot;&quot;&quot;
    ptr1 &#x3D; 0
    ptr2 &#x3D; 1

    if len(nums) &#x3D;&#x3D; 0:
        return 0
    while ptr2 &lt; len(nums):
        if nums[ptr1] &#x3D;&#x3D; nums[ptr2]:
            ptr2 +&#x3D; 1
        else:
            ptr1 +&#x3D; 1
            nums[ptr1] &#x3D; nums[ptr2]
    nums &#x3D; nums[0:ptr1]
    return ptr1 + 1</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206125030399.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206125030399.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len &#x3D; removeElement(nums, val);

&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。
&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i &#x3D; 0; i &lt; len; i++) &#123;
    print(nums[i]);
&#125;</code></pre>



<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [3,2,2,3], val &#x3D; 3
输出：2, nums &#x3D; [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2
输出：5, nums &#x3D; [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p>1、<strong>循环</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def removeElement(self, nums, val):
    &quot;&quot;&quot;
    :type nums: List[int]
    :type val: int
    :rtype: int
    &quot;&quot;&quot;
    while val in nums:
        nums.pop(nums.index(val))
    return len(nums)</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206125523055.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206125523055.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<p><strong>2</strong>、<strong>双指针</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def removeElement(self, nums, val):
    &quot;&quot;&quot;
    :type nums: List[int]
    :type val: int
    :rtype: int
    &quot;&quot;&quot;
    fast &#x3D; 0
    slow &#x3D; 0
    while fast &lt; len(nums):
        if nums[fast] !&#x3D; val:
            nums[slow] &#x3D; nums[fast]
            slow +&#x3D; 1
        fast +&#x3D; 1
    return slow</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206133904066.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230206133904066.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<h3 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h3><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。</p>
<p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;Hello World&quot;
输出：5
解释：最后一个单词是“World”，长度为5。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;   fly me   to   the moon  &quot;
输出：4
解释：最后一个单词是“moon”，长度为4。</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;luffy is still joyboy&quot;
输出：6
解释：最后一个单词是长度为6的“joyboy”。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li>
<li><code>s</code> 中至少存在一个单词</li>
</ul>
<p>Related Topics</p>
<p>字符串</p>
<p><strong>1、麻瓜解法，倒序遍历</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def lengthOfLastWord(self, s):
    &quot;&quot;&quot;
    :type s: str
    :rtype: int
    &quot;&quot;&quot;
    rint &#x3D; 0

    for i in range(len(s) - 1, -1, -1):
        if s[i] !&#x3D; &quot; &quot;:
            rint +&#x3D; 1
            if s[i - 1] &#x3D;&#x3D; &quot; &quot;:
                break
    return rint</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230207170030642.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230207170030642.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<p><strong>2、凤雏解法</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def lengthOfLastWord(self, s):
    &quot;&quot;&quot;
    :type s: str
    :rtype: int
    &quot;&quot;&quot;
    return len(s.split()[-1])</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230207170503876.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230207170503876.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<h3 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h3><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：digits &#x3D; [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：digits &#x3D; [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：digits &#x3D; [0]
输出：[1]</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= digits.length &lt;= 100</code></li>
<li><code>0 &lt;= digits[i] &lt;= 9</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>数学</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def plusOne(digits):
    &quot;&quot;&quot;
    :type digits: List[int]
    :rtype: List[int]
    &quot;&quot;&quot;
    digits[-1] +&#x3D; 1
    for i in range(len(digits) - 1, -1, -1):
        if digits[i] &#x2F;&#x2F; 10 &#x3D;&#x3D; 1 and i !&#x3D; 0:
            digits[i - 1] +&#x3D; 1

    for i in range(len(digits) - 1, -1, -1):
        if digits[i] &gt;&#x3D; 10:
            if i &#x3D;&#x3D; 0:
                digits[i] &#x3D; 0
                digits.insert(0,1)
                break
            digits[i] &#x3D; 0
    return digits</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230207181543869.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230207181543869.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="解答成功"></p>
<h3 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h3><p>给你两个二进制字符串 <code>a</code> 和 <code>b</code> ，以二进制字符串的形式返回它们的和。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入:a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;
输出：&quot;100&quot;</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;
输出：&quot;10101&quot;</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= a.length, b.length &lt;= 104</code></li>
<li><code>a</code> 和 <code>b</code> 仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成</li>
<li>字符串如果不是 <code>&quot;0&quot;</code> ，就不含前导零</li>
</ul>
<p>Related Topics</p>
<p>位运算</p>
<p>数学</p>
<p>字符串</p>
<p>模拟</p>
<p><strong>1、数组处理</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def binary_sum(a, b):
    # 反转二进制字符串
    a &#x3D; a[::-1]
    b &#x3D; b[::-1]
    
    # 计算每一位的和
    res &#x3D; &#39;&#39;
    carry &#x3D; 0
    for i in range(max(len(a), len(b))):
        a_i &#x3D; int(a[i]) if i &lt; len(a) else 0
        b_i &#x3D; int(b[i]) if i &lt; len(b) else 0
        s &#x3D; a_i + b_i + carry
        res +&#x3D; str(s % 2)
        carry &#x3D; s &#x2F;&#x2F; 2
    
    if carry !&#x3D; 0:
        res +&#x3D; str(carry)
    
    return res[::-1]

print(binary_sum(&#39;11&#39;, &#39;1&#39;)) # 100</code></pre>

<p>在这个程序中，我们定义了一个名为<code>binary_sum</code>的函数，它接收两个二进制字符串作为输入，并返回它们的和。在函数内部，我们首先将二进制字符串反转，以便按位处理。然后，我们遍历字符串的每一位，并计算它们的和。如果某一位的和大于2，它会产生进位，并将其加到下一位。最后，如果有进位，它会加到结果字符串的开头。</p>
<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211182734349.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211182734349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><strong>2、位运算</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def addBinary(self, a, b):
    &quot;&quot;&quot;
    :type a: str
    :type b: str
    :rtype: str
    &quot;&quot;&quot;
    max_len &#x3D; max(len(a), len(b))
    a &#x3D; a.zfill(max_len)
    b &#x3D; b.zfill(max_len)
    result &#x3D; &#39;&#39;
    carry &#x3D; 0
    for i in range(max_len - 1, -1, -1):
        if a[i] &#x3D;&#x3D; &#39;1&#39; and b[i] &#x3D;&#x3D; &#39;1&#39;:
            result &#x3D; (&#39;1&#39; if carry else &#39;0&#39;) + result
            carry &#x3D; 1
        elif a[i] &#x3D;&#x3D; &#39;0&#39; and b[i] &#x3D;&#x3D; &#39;0&#39;:
            result &#x3D; (&#39;0&#39; if not carry else &#39;1&#39;) + result
            carry &#x3D; 0
        else:
            result &#x3D; (&#39;0&#39; if carry else &#39;1&#39;) + result
    if carry:
        result &#x3D; &#39;1&#39; + result
    return result</code></pre>

<p>这个代码采用了位运算来优化二进制相加的过程，使得复杂度更低。</p>
<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211184025906.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211184025906.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="x的平方根"><a href="#x的平方根" class="headerlink" title="x的平方根"></a>x的平方根</h3><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p>
<p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p>
<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：x &#x3D; 4
输出：2</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：x &#x3D; 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<p>Related Topics</p>
<p>数学</p>
<p>二分查找</p>
<p><strong>1、sqrt</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def mySqrt(self, x):
    &quot;&quot;&quot;
    :type x: int
    :rtype: int
    &quot;&quot;&quot;
    return int(sqrt(x))</code></pre>

<p>这段代码使用 Python 的 <code>math</code> 模块中的 <code>sqrt</code> 函数计算平方根。</p>
<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211185256535.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211185256535.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><strong>2、二分查找</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def mySqrt(self, x):
    &quot;&quot;&quot;
    :type x: int
    :rtype: int
    &quot;&quot;&quot;
    if x &lt; 0:
        return None
    left, right &#x3D; 0, x
    while left &lt;&#x3D; right:
        mid &#x3D; (left + right) &#x2F;&#x2F; 2
        if mid * mid &lt;&#x3D; x &lt; (mid + 1) * (mid + 1):
            return mid
        elif x &lt; mid * mid:
            right &#x3D; mid - 1
        else:
            left &#x3D; mid + 1
    return None</code></pre>

<p>这段代码实现了对平方根的二分查找。我们通过设定左右边界来确定平方根所在的范围，并通过取中间值，判断它的平方是否大于等于给定数字，来逐渐缩小搜索范围。最终，如果找到的话，返回的是平方根的整数部分。</p>
<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211185423200.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211185423200.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><strong>3、牛顿迭代</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def mySqrt( x):
    &quot;&quot;&quot;
    :type x: int
    :rtype: int
    &quot;&quot;&quot;
    if x &lt; 0:
        return None
    root &#x3D; x
    precision &#x3D; 0.00001
    while abs(root * root - x) &gt; precision:
        root &#x3D; (root + x &#x2F; root) &#x2F; 2
    return int(root)</code></pre>

<p>在这段代码中，我们通过牛顿迭代公式：<code>root = (root + x / root) / 2</code> 不断地更新<code>root</code>的值，直到误差小于预期的精度。最终，我们将<code>root</code>的值向下取整，以获得整数部分的平方根。</p>
<p><strong>4、牛顿迭代优化</strong></p>
<p>使用二分查找：您可以使用二分查找来确定平方根的区间，然后使用牛顿迭代法来逼近结果。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def mySqrt(self, x):
    &quot;&quot;&quot;
    :type x: int
    :rtype: int
    &quot;&quot;&quot;
    if x &lt; 0:
        return None
    left &#x3D; 0
    right &#x3D; x
    precision &#x3D; 0.00001
    while left &lt;&#x3D; right:
        mid &#x3D; (left + right) &#x2F;&#x2F; 2
        if mid * mid &lt;&#x3D; x &lt; (mid + 1) * (mid + 1):
            root &#x3D; mid
            break
        elif mid * mid &lt; x:
            left &#x3D; mid + 1
        else:
            right &#x3D; mid - 1
    root &#x3D; left
    while abs(root * root - x) &gt; precision:
        root &#x3D; (root + x &#x2F; root) &#x2F; 2
    return int(root)</code></pre>

<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<p>Related Topics</p>
<p>记忆化搜索</p>
<p>数学</p>
<p>动态规划</p>
<p><strong>1、迭代</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def climbStairs(self, n):
    &quot;&quot;&quot;
    :type n: int
    :rtype: int
    &quot;&quot;&quot;
    if n &#x3D;&#x3D; 1:
        return 1
    if n &#x3D;&#x3D; 2:
        return 2
    return self.climbStairs(n - 1) + self.climbStairs(n - 2)</code></pre>

<p><strong>2、循环</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def climbStairs(self, n):
    &quot;&quot;&quot;
    :type n: int
    :rtype: int
    &quot;&quot;&quot;
    if n &#x3D;&#x3D; 1:
        return 1
    if n &#x3D;&#x3D; 2:
        return 2
    a, b &#x3D; 1, 2
    for i in range(2, n):
        a, b &#x3D; b, a + b
    return b</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211191238036.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211191238036.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><strong>3、动态规划</strong></p>
<p>我们创建了一个数组<code>dp</code>来存储每个阶段的方案数。然后我们从第三个阶段开始循环，并使用前面两个阶段的结果来推导当前阶段的结果。最后，返回第<code>n</code>个阶段的结果即可。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def climbStairs(self, n):
    &quot;&quot;&quot;
    :type n: int
    :rtype: int
    &quot;&quot;&quot;
    if n &#x3D;&#x3D; 1:
        return 1
    dp &#x3D; [0] * (n + 1)
    dp[0] &#x3D; 0
    dp[1] &#x3D; 1
    dp[2] &#x3D; 2
    for i in range(3, n + 1):
        dp[i] &#x3D; dp[i - 1] + dp[i - 2]
    return dp[n]</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211192100282.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230211192100282.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">输入：head &#x3D; [1,1,2]
输出：[1,2]</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">输入：head &#x3D; [1,1,2,3,3]
输出：[1,2,3]</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>题目数据保证链表已经按升序 <strong>排列</strong></li>
</ul>
<p>Related Topics</p>
<p>链表</p>
<p>python的链表</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">class ListNode(object):
     def __init__(self, val&#x3D;0, next&#x3D;None):
         self.val &#x3D; val
         self.next &#x3D; next</code></pre>

<p>1、遍历，中间指针</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def deleteDuplicates(self, head):
    &quot;&quot;&quot;
    :type head: ListNode
    :rtype: ListNode
    &quot;&quot;&quot;
    if not head:
        return head
    p &#x3D; head
    while p is not None and p.next is not None:
        if p.val &#x3D;&#x3D; p.next.val:
            p.next &#x3D; p.next.next
        else:
            p &#x3D; p.next
    return head</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217021640249.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217021640249.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>测试代码</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"># 创建一个有序链表 1-&gt;1-&gt;2-&gt;3-&gt;3
head &#x3D; ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(3)))))
result &#x3D; deleteDuplicates(head)
# 打印链表
while result is not None:
    print(result.val, end&#x3D;&quot; &quot;)
    result &#x3D; result.next
# 输出：1 2 3</code></pre>

<p>2、字典加速删除过程</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def deleteDuplicates(self, head):
    &quot;&quot;&quot;
    :type head: ListNode
    :rtype: ListNode
    &quot;&quot;&quot;
    if not head:
        return head
    val_dict &#x3D; &#123;head.val: True&#125;

    p &#x3D; head
    while p.next:
        if p.next.val in val_dict:
            p.next &#x3D; p.next.next
        else:
            val_dict[p.next.val]&#x3D;True
            p &#x3D; p.next
    return head</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217022103585.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217022103585.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>3、集合加速，（python中集合的查找为O（1））字典的查找时间复杂度其实也为1</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def deleteDuplicates(self, head):
    &quot;&quot;&quot;
    :type head: ListNode
    :rtype: ListNode
    &quot;&quot;&quot;
    if not head:
        return head
    val_set &#x3D; set()
    val_set.add(head.val)

    p &#x3D; head
    while p.next:
        if p.next.val in val_set:
            p.next &#x3D; p.next.next
        else:
            val_set.add(p.next.val)
            p &#x3D; p.next
    return head</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217022854687.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217022854687.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m + n</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m, n &lt;= 200</code></li>
<li><code>1 &lt;= m + n &lt;= 200</code></li>
<li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li>
</ul>
<p><strong>进阶：</strong>你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p>排序</p>
<p>1、双指针</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def merge(self, nums1, m, nums2, n):
    &quot;&quot;&quot;
    :type nums1: List[int]
    :type m: int
    :type nums2: List[int]
    :type n: int
    :rtype: None Do not return anything, modify nums1 in-place instead.
    &quot;&quot;&quot;
    i, j, k &#x3D; m - 1, n - 1, m + n - 1
    while i &gt;&#x3D; 0 and j &gt;&#x3D; 0:
        if nums1[i] &gt; nums2[j]:
            nums1[k] &#x3D; nums1[i]
            i -&#x3D; 1
        else:
            nums1[k] &#x3D; nums2[j]
            j -&#x3D; 1
        k -&#x3D; 1

    while j &gt;&#x3D; 0 and k &gt;&#x3D; 0:
        nums1[k] &#x3D; nums2[j]
        j -&#x3D; 1
        k -&#x3D; 1</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217031535971.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217031535971.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]
输出：[1,3,2]</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; []
输出：[]</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1]
输出：[1]</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>Related Topics</p>
<p>栈</p>
<p>树</p>
<p>深度优先搜索</p>
<p>二叉树</p>
<p>1、递归</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def inorderTraversal(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: List[int]
    &quot;&quot;&quot;
    res &#x3D; []
    if not root:
        return res
    self.inorder(root,res)
    return res

def inorder(self, node, res):
    if node.left:
        self.inorder(node.left, res)
    res.append(node.val)
    if node.right:
        self.inorder(node.right, res)</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217032011034.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217032011034.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>2、循环</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def inorderTraversal(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: List[int]
    &quot;&quot;&quot;
    stack &#x3D; []
    res &#x3D; []
    while root or stack:
        while root:
            stack.append(root)
            root &#x3D; root.left
        node &#x3D; stack.pop()
        res.append(node.val)
        root &#x3D; node.right
    return res</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217032346600.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217032346600.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：p &#x3D; [1,2,3], q &#x3D; [1,2,3]
输出：true</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：p &#x3D; [1,2], q &#x3D; [1,null,2]
输出：false</code></pre>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：p &#x3D; [1,2,1], q &#x3D; [1,1,2]
输出：false</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>1、DFS</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isSameTree(self, p, q):
    &quot;&quot;&quot;
    :type p: TreeNode
    :type q: TreeNode
    :rtype: bool
    &quot;&quot;&quot;
    if not p and not q:
        return True
    if not p or not q:
        return False
    if p.val !&#x3D; q.val:
        return False
    return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217035430184.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217035430184.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>2、BFS</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isSameTree(self, p, q):
    &quot;&quot;&quot;
    :type p: TreeNode
    :type q: TreeNode
    :rtype: bool
    &quot;&quot;&quot;
    queue &#x3D; [(p, q)]
    while queue:
        node1, node2 &#x3D; queue.pop(0)
        if not node1 and not node2:
            continue
        if not node1 or not node2 or node1.val !&#x3D; node2.val:
            return False
        queue.append((node1.left, node2.left))
        queue.append((node1.right, node2.right))
    return True</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217035948029.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230217035948029.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,4,4,3]
输出：true</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,2,2,null,3,null,3]
输出：false</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>DFS</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isSymmetric(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: bool
    &quot;&quot;&quot;
    if root is None:
        return True
    return self.isMirror(root.left, root.right)

def isMirror(self, node1, node2):
    if node1 is None and node2 is None:
        return True
    if node1 is None or node2 is None:
        return False
    if node1.val !&#x3D; node2.val:
        return False
    return self.isMirror(node1.left, node2.right) and self.isMirror(node1.right, node2.left)</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219184524542.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219184524542.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>BFS</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isSymmetric(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: bool
    &quot;&quot;&quot;
    queue &#x3D; [(root.left, root.right)]
    while queue:
        node1, node2 &#x3D; queue.pop()
        if not node1 and not node2:
            continue
        if not node1 or not node2 or node1.val !&#x3D; node2.val:
            return False
        queue.append((node1.left, node2.right))
        queue.append((node1.right, node2.left))
    return True</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219185856490.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219185856490.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<pre class="line-numbers language-none"><code class="language-none">  3
 &#x2F; \
9  20
  &#x2F;  \
 15   7</code></pre>

<p>返回它的最大深度 3 。</p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>DFS</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def maxDepth(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: int
    &quot;&quot;&quot;
    if root is None:
        return 0
    left &#x3D; self.maxDepth(root.left)
    right &#x3D; self.maxDepth(root.right)
    return max(left, right) + 1</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219191812189.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219191812189.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>BFS</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def maxDepth(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: int
    &quot;&quot;&quot;
    if root is None:
        return 0
    queue &#x3D; [root]
    depth &#x3D; 0
    while queue:
        depth +&#x3D; 1
        level &#x3D; len(queue)
        for i in range(level):
            node &#x3D; queue.pop(0)
            if node.left is not None:
                queue.append(node.left)
            if node.right is not None:
                queue.append(node.right)
    return depth</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219191925201.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219191925201.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>
</ul>
<p>Related Topics</p>
<p>树</p>
<p>二叉搜索树</p>
<p>数组</p>
<p>分治</p>
<p>二叉树</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def sortedArrayToBST(self, nums):
    &quot;&quot;&quot;
    :type nums: List[int]
    :rtype: TreeNode
    &quot;&quot;&quot;
    if not nums:
        return None
    mid &#x3D; len(nums) &#x2F;&#x2F; 2
    root &#x3D; TreeNode(nums[mid])
    root.left &#x3D; self.sortedArrayToBST(nums[:mid])
    root.right &#x3D; self.sortedArrayToBST(nums[mid + 1:])
    return root</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219192828844.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230219192828844.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="寻找两个正序数组中的中位数"><a href="#寻找两个正序数组中的中位数" class="headerlink" title="寻找两个正序数组中的中位数"></a>寻找两个正序数组中的中位数</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]
输出：2.00000
解释：合并数组 &#x3D; [1,2,3] ，中位数 2</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]
输出：2.50000
解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</code></pre>





<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m &lt;= 1000</code></li>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= m + n &lt;= 2000</code></li>
<li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>二分查找</p>
<p>分治</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def findMedianSortedArrays(self, nums1, nums2):
    &quot;&quot;&quot;
    :type nums1: List[int]
    :type nums2: List[int]
    :rtype: float
    &quot;&quot;&quot;
    m &#x3D; len(nums1)
    n &#x3D; len(nums2)
    res &#x3D; [0] * (m+n)
    i, j, k &#x3D; 0, 0, 0
    while i &lt; m and j &lt; n:
        if nums1[i] &lt; nums2[j]:
            res[k] &#x3D; nums1[i]
            i +&#x3D; 1
            k +&#x3D; 1
        else:
            res[k] &#x3D; nums2[j]
            j +&#x3D; 1
            k +&#x3D; 1
    while i &lt; m:
        res[k] &#x3D; nums1[i]
        k +&#x3D; 1
        i +&#x3D; 1
    while j &lt; n:
        res[k] &#x3D; nums2[j]
        k +&#x3D; 1
        j +&#x3D; 1
    if (m + n) % 2 &#x3D;&#x3D; 0:
        return (res[((m + n) &#x2F;&#x2F; 2) - 1] + res[(m + n) &#x2F;&#x2F; 2]) &#x2F; 2.0
    else:
        return res[(m + n) &#x2F;&#x2F; 2]</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230222225347902.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230222225347902.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h3><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<ul>
<li><code>&#39;.&#39;</code> 匹配任意单个字符</li>
<li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;
输出：false
解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</code></pre>

<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a*&quot;
输出：true
解释：因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;ab&quot;, p &#x3D; &quot;.*&quot;
输出：true
解释：&quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= p.length &lt;= 30</code></li>
<li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
<li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li>
</ul>
<p>Related Topics</p>
<p>递归</p>
<p>字符串</p>
<p>动态规划</p>
<p>1、动态规划</p>
<pre class="line-numbers language-none"><code class="language-none">假设字符串为 s，字符规律为 p，我们用 dp[i][j] 表示 s 的前 i 个字符是否能被 p 的前 j 个字符匹配。则有以下情况：

1. p[j] 是小写字母，即 p[j] &#x3D;&#x3D; s[i]，则 dp[i][j] &#x3D; dp[i-1][j-1]。
2. p[j] 是 &#39;.&#39;，可以匹配任意字符，即 dp[i][j] &#x3D; dp[i-1][j-1]。
3. p[j] 是 &#39;*&#39;，可以匹配零个或多个前面的元素，有两种情况：
   - 如果 p[j-1] 和 s[i] 不匹配，则 dp[i][j] &#x3D; dp[i][j-2]，表示直接忽略这个 &#39;*&#39; 和它前面的字符。
   - 如果 p[j-1] 和 s[i] 匹配，有三种情况：
     1. dp[i][j] &#x3D; dp[i-1][j]，表示忽略掉 s 的第 i 个字符；
     2. dp[i][j] &#x3D; dp[i][j-1]，表示把 &#39;*&#39; 当成单个字符，即匹配 s 的第 i 个字符；
     3. dp[i][j] &#x3D; dp[i][j-2]，表示忽略掉 &#39;*&#39; 和它前面的字符。

最终的结果为 dp[len(s)][len(p)]。</code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isMatch(self, s, p):
    &quot;&quot;&quot;
    :type s: str
    :type p: str
    :rtype: bool
    &quot;&quot;&quot;
    m, n &#x3D; len(s), len(p)
    dp &#x3D; [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] &#x3D; True

    for i in range(m + 1):
        for j in range(1, n + 1):
            if p[j - 1] &#x3D;&#x3D; &#39;*&#39;:
                dp[i][j] &#x3D; dp[i][j - 2]
                if i &gt; 0 and (s[i - 1] &#x3D;&#x3D; p[j - 2] or p[j - 2] &#x3D;&#x3D; &quot;.&quot;):
                    dp[i][j] |&#x3D; dp[i - 1][j]
            elif i &gt; 0 and (s[i - 1] &#x3D;&#x3D; p[j - 1] or p[j - 1] &#x3D;&#x3D; &#39;.&#39;):
                dp[i][j] &#x3D; dp[i - 1][j - 1]

    return dp[m][n]</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230222230424153.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230222230424153.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>2、递归</p>
<ol>
<li><p>当 <code>p</code> 为空时，判断 <code>s</code> 是否为空，如果为空则匹配成功，否则匹配失败。</p>
</li>
<li><p>当 <code>p</code> 的长度为 1 时，分两种情况，如果 <code>p</code> 为字符 <code>.</code>，则只要 <code>s</code> 不为空，就匹配成功，否则匹配失败；如果 <code>p</code> 为其他字符，那么只要 <code>s</code> 的第一个字符和 <code>p</code> 相同，就匹配成功，否则匹配失败。</p>
</li>
<li><p>当 p长度大于 1 时，分两种情况：</p>
<ol>
<li>如果 <code>p</code> 的第二个字符不是 <code>*</code>，那么只要 <code>s</code> 不为空并且 <code>s</code> 的第一个字符和 <code>p</code> 的第一个字符相同，就递归地匹配 <code>s[1:]</code> 和 <code>p[1:]</code>。</li>
<li>如果 <code>p</code> 的第二个字符是 <code>*</code>，那么有两种情况，一种是 <code>*</code> 匹配了 0 次，此时直接递归匹配 <code>s</code> 和 <code>p[2:]</code>，另一种是 <code>*</code> 匹配了 1 次或多次，此时如果 <code>s</code> 不为空并且 <code>s</code> 的第一个字符和 <code>p</code> 的第一个字符相同，就递归匹配 <code>s[1:]</code> 和 <code>p</code>。</li>
</ol>
</li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isMatch(self, s, p):
    &quot;&quot;&quot;
    :type s: str
    :type p: str
    :rtype: bool
    &quot;&quot;&quot;
    if not p:
        return not s
    match &#x3D; bool(s) and p[0] in &#123;s[0], &#39;.&#39;&#125;
    if len(p) &gt;&#x3D; 2 and p[1] &#x3D;&#x3D; &#39;*&#39;:
        return self.isMatch(s, p[2:]) or (match and self.isMatch(s[1:], p))
    else:
        return match and self.isMatch(s[1:], p[1:])</code></pre>

<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]
输出：true</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,2,2,3,3,null,null,4,4]
输出：false</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; []
输出：true</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>二叉树</p>
<p>DFS</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isBalanced(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: bool
    &quot;&quot;&quot;
    def height(root):
        if not root:
            return 0
        left_height &#x3D; height(root.left)
        right_height &#x3D; height(root.right)

        return max(left_height,right_height) + 1
    if not root:
        return True
    left_height &#x3D; height(root.left)
    right_height &#x3D; height(root.right)
    return abs(left_height - right_height) &lt;&#x3D; 1 and self.isBalanced(root.left) and self.isBalanced(root.right)</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304195909028.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304195909028.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>BFS</p>
<p>1.定义一个队列，将根节点加入队列中。 </p>
<p>2.进入循环，如果队列非空，执行以下操作： </p>
<p>1)弹出队列中的一个节点，判断该节点是否平衡。 2)如果该节点平衡，将其左右子节点加入队列。 </p>
<p>3)如果该节点不平衡，直接返回 False。 </p>
<p>3.如果队列为空，则返回 True。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isBalanced(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: bool
    &quot;&quot;&quot;

    def get_depth(node):
        if not node:
            return 0
        return max(get_depth(node.left), get_depth(node.right)) + 1

    if not root:
        return True
    queue &#x3D; [root]
    while queue:
        node &#x3D; queue.pop(0)
        left_depth &#x3D; get_depth(node.left)
        right_depth &#x3D; get_depth(node.right)

        if abs(left_depth - right_depth) &gt; 1:
            return False
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return True</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304200518933.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304200518933.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [3,9,20,null,null,15,7]
输出：2</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]
输出：5</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>DFS</p>
<p>首先判断根节点是否为空，如果是，则返回 0。如果根节点没有左右子节点，那么它的深度为 1。否则，分别求解左右子树的最小深度，并取较小值加 1，即为整棵树的最小深度。</p>
<p>需要注意的是，在递归求解左右子树的最小深度时，如果子树为空，应返回一个较大的值，以便在求最小值时不影响结果。例如，代码中使用了 <code>float(&quot;inf&quot;)</code> 表示正无穷。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def minDepth(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: int
    &quot;&quot;&quot;
    if not root:
        return 0
    if not root.left and not root.right:
        return 1

    left_depth &#x3D; float(&#39;inf&#39;) if not root.left else self.minDepth(root.left)
    right_depth &#x3D; float(&#39;inf&#39;) if not root.right else self.minDepth(root.right)

    return min(left_depth, right_depth) + 1</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304202757012.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304202757012.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>BFS</p>
<p>BFS 的基本思路是从根节点开始，一层一层地遍历，直到找到目标节点或遍历完所有节点。</p>
<p>具体实现时，可以使用队列来保存待遍历的节点。每次从队列中取出一个节点，将它的子节点加入队列中，直到找到目标节点或队列为空为止。在遍历过程中，还需要记录每个节点的深度，以便在找到目标节点时返回最小深度。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def minDepth(self, root):
    &quot;&quot;&quot;
    :type root: TreeNode
    :rtype: int
    &quot;&quot;&quot;
    if not root:
        return 0
    queue &#x3D; [(root, 1)]
    while queue:
        node, depth &#x3D; queue.pop(0)
        if not node.left and not node.right:
            return depth
        if node.left:
            queue.append((node.left, depth + 1))
        if node.right:
            queue.append((node.right, depth + 1))</code></pre>

<p><code>queue</code> 保存的是一个二元组 <code>(node, depth)</code>，表示节点和对应的深度。每次从队列头部取出一个节点，如果该节点是叶子节点，则返回其深度；否则将它的非空子节点加入队列中，并将深度加 1。如果队列为空但仍然没有找到叶子节点，则说明该树为空树，返回深度 0。</p>
<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304202515840.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304202515840.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --&gt; 2): 和为 3
(1 --&gt; 3): 和为 4
不存在 sum &#x3D; 5 的根节点到叶子节点的路径。</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [], targetSum &#x3D; 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>DFS</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def hasPathSum(self, root, targetSum):
    &quot;&quot;&quot;
    :type root: TreeNode
    :type targetSum: int
    :rtype: bool
    &quot;&quot;&quot;
    if not root:
        return False

    targetSum -&#x3D; root.val

    if not root.left and not root.right:
        return targetSum &#x3D;&#x3D; 0
    return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)</code></pre>

<p>这里使用了递归的方式实现深度优先搜索，函数参数 <code>root</code> 表示当前遍历到的节点，<code>targetSum</code> 表示目标和。如果当前节点为空，返回 <code>False</code>。否则，从目标和中减去当前节点的值，并判断当前节点是否为叶子节点。如果是叶子节点，判断目标和是否为零，如果是零，说明存在从根节点到叶子节点的路径，返回 <code>True</code>。否则返回 <code>False</code>。如果当前节点不是叶子节点，则递归遍历其左右子树，并将结果进行或运算，只要有一条路径满足条件即可。</p>
<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304204147144.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304204147144.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>BFS</p>
<p>使用 BFS 遍历二叉树。从根节点开始，对每个节点进行扩展，即将其左右子节点添加到队列中，同时更新当前路径的和。当遇到叶子节点时，检查路径和是否等于目标和，如果等于则返回 <code>true</code>，否则继续遍历下一个节点。如果队列为空仍然没有找到符合条件的路径，则返回 <code>false</code>。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def hasPathSum(self, root, targetSum):
    &quot;&quot;&quot;
    :type root: TreeNode
    :type targetSum: int
    :rtype: bool
    &quot;&quot;&quot;
    if not root:
        return False

    queue &#x3D; [(root, root.val)]

    while queue:
        node, curr_num &#x3D; queue.pop(0)
        if not node.left and not node.right:
            if curr_num &#x3D;&#x3D; targetSum:
                return True
        if node.left:
            queue.append((node.left, curr_num + node.left.val))

        if node.right:
            queue.append((node.right, curr_num + node.right.val))
    return False</code></pre>

<p>使用一个队列 <code>queue</code> 来存储当前待遍历的节点以及当前节点的路径和。我们首先将根节点和根节点的值加入队列中。然后对于每个节点，我们检查其是否为叶子节点，如果是，则检查当前路径和是否等于目标和，如果是，则返回 <code>True</code>。否则，我们将其左右子节点和路径和加入队列中，继续遍历下一个节点，直到队列为空或者找到符合条件的路径。</p>
<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304204112260.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304204112260.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" class="lazyload" data-srcset="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p><strong>示例 1:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: numRows &#x3D; 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</code></pre>

<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: numRows &#x3D; 1
输出: [[1]]</code></pre>



<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= numRows &lt;= 30</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>动态规划</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def generate(self, numRows):
    &quot;&quot;&quot;
    :type numRows: int
    :rtype: List[List[int]]
    &quot;&quot;&quot;
    if numRows &#x3D;&#x3D; 0:
        return []
    elif numRows &#x3D;&#x3D; 1:
        return [[1]]
    elif numRows &#x3D;&#x3D; 2:
        return [[1], [1, 1]]
    else:
        triangle &#x3D; [[1], [1, 1]]
        for i in range(2, numRows):
            row &#x3D; [1] * (i + 1)
            for j in range(1, i):
                row[j] &#x3D; triangle[i - 1][j - 1] + triangle[i - 1][j]
            triangle.append(row)
        return triangle</code></pre>

<p>使用了一个二维数组 <code>triangle</code> 来存储杨辉三角中的每一行。我们首先处理特殊情况：当 <code>numRows</code> 为 0 时返回空数组，当 <code>numRows</code> 为 1 时返回一个只包含一个元素 1 的数组，当 <code>numRows</code> 为 2 时返回一个包含两个元素 1 的数组。</p>
<p>对于 <code>numRows</code> 大于 2 的情况，我们使用一个循环来生成杨辉三角的每一行。在循环中，我们首先创建一个长度为 <code>i+1</code> 的数组 <code>row</code>，并将其所有元素初始化为 1。然后，我们使用另一个循环遍历 <code>row</code> 中的每一个元素，计算其对应的值，即杨辉三角中的数值，并将其赋值给 <code>row</code> 中的相应位置。最后，我们将 <code>row</code> 添加到 <code>triangle</code> 中，完成一行的生成。</p>
<p>最后，我们返回 <code>triangle</code>，即杨辉三角的所有行。</p>
<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304215151223.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304215151223.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="杨辉三角II"><a href="#杨辉三角II" class="headerlink" title="杨辉三角II"></a>杨辉三角II</h3><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" class="lazyload" data-srcset="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>
<p><strong>示例 1:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: rowIndex &#x3D; 3
输出: [1,3,3,1]</code></pre>

<p><strong>示例 2:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: rowIndex &#x3D; 0
输出: [1]</code></pre>

<p><strong>示例 3:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: rowIndex &#x3D; 1
输出: [1,1]</code></pre>



<p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt;= rowIndex &lt;= 33</code></li>
</ul>
<p><strong>进阶：</strong></p>
<p>你可以优化你的算法到 <code>*O*(*rowIndex*)</code> 空间复杂度吗？</p>
<p>Related Topics</p>
<p>数组</p>
<p>动态规划</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def getRow(self, rowIndex):
    &quot;&quot;&quot;
    :type rowIndex: int
    :rtype: List[int]
    &quot;&quot;&quot;
    row &#x3D; [1] * (rowIndex + 1)
    for i in range(1,rowIndex + 1):
        for j in range(i-1,0,-1):
            row[j] +&#x3D; row[j-1]
    return row</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304215833496.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304215833496.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>创建一个长度为 <code>rowIndex+1</code> 的数组 <code>row</code> 来保存每一行的数字。由于每行的数字只与上一行有关，我们可以使用递推公式 <code>row[j] = row[j] + row[j-1]</code> 来计算每行的数字。由于我们只需要返回第 <code>rowIndex</code> 行，因此可以在循环结束后直接返回 <code>row</code> 数组即可。</p>
<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。
     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：prices &#x3D; [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>动态规划</p>
<p>首先，定义状态 <code>dp[i]</code> 表示在第 <code>i</code> 天卖出股票所能获得的最大利润。我们需要在第 <code>0</code> 天买入，所以初始状态为 <code>dp[0] = 0</code>。</p>
<p>对于每一天 <code>i</code>，我们需要找到在前 <code>i-1</code> 天中股票价格的最小值 <code>min_price</code>。那么在第 <code>i</code> 天卖出股票所能获得的最大利润即为 <code>prices[i] - min_price</code>。如果这个利润比当前的最大利润 <code>dp[i-1]</code> 还要大，那么我们就更新 <code>dp[i]</code>。</p>
<p>最后，我们只需要遍历整个 <code>dp</code> 数组，找到最大的利润值即可。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def maxProfit(self, prices):
    &quot;&quot;&quot;
    :type prices: List[int]
    :rtype: int
    &quot;&quot;&quot;
    n &#x3D; len(prices)
    if n &lt;&#x3D; 1:
        return 0
    dp &#x3D; [0] * n
    min_price &#x3D; prices[0]
    for i in range(1, n):
        min_price &#x3D; min(min_price, prices[i - 1])
        dp[i] &#x3D; max(dp[i - 1], prices[i] - min_price)
    return dp[-1]</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304221333680.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304221333680.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h3><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> 。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入: s &#x3D; &quot;A man, a plan, a canal: Panama&quot;
输出：true
解释：&quot;amanaplanacanalpanama&quot; 是回文串。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot;race a car&quot;
输出：false
解释：&quot;raceacar&quot; 不是回文串。</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">输入：s &#x3D; &quot; &quot;
输出：true
解释：在移除非字母数字字符之后，s 是一个空字符串 &quot;&quot; 。
由于空字符串正着反着读都一样，所以是回文串。</code></pre>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2 * 105</code></li>
<li><code>s</code> 仅由可打印的 ASCII 字符组成</li>
</ul>
<p>Related Topics</p>
<p>双指针</p>
<p>字符串</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">def isPalindrome(self, s):
    &quot;&quot;&quot;
    :type s: str
    :rtype: bool
    &quot;&quot;&quot;
    s &#x3D; &#39;&#39;.join(c.lower() for c in s if c.isalnum())
    left, right &#x3D; 0, len(s) - 1
    while left &lt; right:
        if s[left] !&#x3D; s[right]:
            return False
        left +&#x3D; 1
        right -&#x3D; 1
    return True</code></pre>

<p><img src="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304223712618.png" class="lazyload" data-srcset="/post/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230304223712618.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
]]></content>
      <tags>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析的常用十大方案</title>
    <url>//post/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<h1 id="01背包问题（最优解问题）"><a href="#01背包问题（最优解问题）" class="headerlink" title="01背包问题（最优解问题）"></a>01背包问题（最优解问题）</h1><p>就是现在有一个体积为c的背包，现在要装一些东西，这些东西有体积和价值，现在要求一个最优解，<br>也就是在c之内，放最大价值的物品<br>目的是限制化重量下，求最大价值</p>
<h2 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h2><p>使用蛮力法就是，遍历每一种方案，对于每一个物品都要枚举一次看看是否放入背包，最后比较每一种方案的价值<br>（遍历每一种方案）</p>
<pre class="line-numbers language-none"><code class="language-none">def bag01_force(n,w,value,weight):
	&quot;&quot;&quot;
	蛮力法求解
	n ：物品数量
	w ：背包体积
	value ：物品价值
	weight ：物品体积
	return 能放入的物品最大价值
	&quot;&quot;&quot;

	# 返回值

​	res &#x3D; 0
​	

# 蛮力法 遍历每一种方案，n个物品，每一个物品都有两种状态，放入或者不放入背包，所以一共有

# 2**n种状态

# 1 0 1

# 2 10 01 00 11

for i in range(2**n)：

	# 方案体积

​	total_weight &#x3D; 0

	# 方案价值

​	total_value &#x3D; 0

	# 第二层循环，每一种方案下遍历每一件物品

​	for j in range(n):

		# 判断方案i是否选择了物品j，如果被选择，那么背包中体积与价值发生变化

		# i是一个整数，j是一个0到n-1的整数

		# 1&lt;&lt;j 表示1左移j位

		# 位与运算，结果如果不为0，那么表示在该位上都为1，也就是j被选择了

		if (i &amp; (1&lt;&lt;j)) !&#x3D; 0:
			total_weight +&#x3D; weight[j]
			total_value +&#x3D; value[j]
	

	# 判断，目的体积要小于背包容量

	if total_weight &lt;&#x3D; w:

		# 求最大价值

		res &#x3D; max(res,total_value)
return res</code></pre>

<p>“””<br>当i&#x3D;&#x3D;0时，代表没有选择物品</p>
<p>i&#x3D;&#x3D;1,第一种方案，j&#x3D;&#x3D;0，第一个物品 1&lt;&lt;0 &#x3D; 1 1 &amp; 1 &#x3D;1 代表在第i&#x3D;&#x3D;1种方案下，第j&#x3D;&#x3D;0（第一个物品）<br>被放进背包。<br>j &#x3D;&#x3D; 1 表示第二个物品 1 &lt;&lt; 1 &#x3D; 10 1 &amp; 10 &#x3D; 0 没有被选择<br>j &#x3D;&#x3D; 2,3,4…n-1</p>
<p>i &#x3D;&#x3D; 2 j&#x3D;&#x3D;0,1,2,,3…n-1</p>
<p>O(n) &#x3D; n * 2 **n<br>“””</p>
<h2 id="减治法"><a href="#减治法" class="headerlink" title="减治法"></a>减治法</h2><p>把一个大问题分解成几个小问题，递归求解子问题，合并子问题的解得到大问题的解（缩小问题规模）</p>
<p>第i个物品价值:value[i] 体积:weight[i],背包容量C</p>
<p>第i个物品，要么选，要么不选</p>
<p>1、前n-1个物品选择中，容量 C-weight[n] 选n</p>
<p>2、前n-1个物品选择中，容量 C 不选n</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><pre class="line-numbers language-none"><code class="language-none">def bag01(weight,value,n,c):
	# 背包容量为0或者物品数量为0,递归出口
	if c &#x3D;&#x3D; 0 or n &#x3D;&#x3D; 0
		return 0
	if weight[n-1] &gt; c:
		return bag01(weight,value,n-1,c)
		

return max(value[n-1] + bag01(weight,value,n-1,c - weight[n-1]),bag01(weight,value,n-1,c))</code></pre>

<h3 id="循环-动态规划"><a href="#循环-动态规划" class="headerlink" title="循环(动态规划)"></a>循环(动态规划)</h3><pre class="line-numbers language-none"><code class="language-none">def bag01(n,c,weight,value):
	# 保存最终结果，c+1（存储了0-c的所有结果）
	dp &#x3D; [0] * (c + 1)
	# 第一层循环，遍历物品
	for i in range(n):
		# 倒序遍历
		# 枚举第i物品，容量从c开始，枚举容量从大到小
		for j in range(c,weight[i] -1,-1):
			# 当前容量为j时，选或者不选第i个物品，取最大值，来确定这个物品是否放入背包
			# 如果加入，dp[j] &#x3D;&#x3D; dp[j - w[i]] + v[i]
			# 不加入，dp[j]
			dp[j] &#x3D; max(dp[j],dp[j-weight[i]] + value[i])
	return dp[c]</code></pre>



<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>分治法是把一个问题分解成子问题，再把子问题分解成更小的问题，直到子问题容易解决就把解合并。（分解问题）</p>
<p>n个物品，重量w1,w2,w3。。。wn。价值v1,v2…vn</p>
<p>容量为c，c-weight[i] &gt; 0</p>
<p>max(value)</p>
<p>把物品分成两组，考虑每一组是否被选择。</p>
<pre class="line-numbers language-none"><code class="language-none">#递归
def bag01(n,c,weight,value):
	# 物品数量为0或者背包容量为0
	if n&#x3D;&#x3D;0 or c &#x3D;&#x3D; 0:
		return 0
	# 物品不能放入背包
	if weight[n-1] &gt; c:
		# 不考虑当前物品
		return bag01(n-1,c,weight,value)
	else:
		# 递归解决剩下问题，（放和不放，最大值）
		return max(value[n-1] + bag01(n-1,c-weight[n-1]),bag01(n-1,c.weight,value))</code></pre>



<h3 id="迭代（循环模拟递归，需要用变量来保存中间状态）"><a href="#迭代（循环模拟递归，需要用变量来保存中间状态）" class="headerlink" title="迭代（循环模拟递归，需要用变量来保存中间状态）"></a>迭代（循环模拟递归，需要用变量来保存中间状态）</h3><pre class="line-numbers language-none"><code class="language-none">def bag01(n,c,weight,value):
	dp &#x3D; [0] * (c+1)
	for i in range(1,n+1):
		for j in range(c,weight[i-1] -1,-1):
			dp[j] &#x3D; max(dp[j],dp[j-weight[i-1]]+value[i-1])
	return dp[c]</code></pre>

<p>​	</p>
<p>分治法重点是把物品不断的切割，分别考虑每组物品是否被选择</p>
<p>减治法重点不断缩减背包容量，利用放入或者不放入物品</p>
<h2 id="变治法"><a href="#变治法" class="headerlink" title="变治法"></a>变治法</h2><p>对问题进行变形，将问题转换成简单的问题</p>
<p>例如：减小问题规模n —— n&#x2F;2</p>
<p>背包容量从小到大排序，利用分治法把大问题分解为小问题，然后减治法把子问题合并起来</p>
<pre class="line-numbers language-none"><code class="language-none">def bag01(weight,value,c,n):
	# 中间状态，f[i][j]表示前i件物品放入容量为j的背包可以获得的最大价值
	f &#x3D; [[0 for j in range(c+1)] for i in range(n+1)]
	for i in range(1,n+1):
		for j in range(1,c+1):
			# 第i个物品不能放
			if j &lt; weight[i-1]:
				# 第i个物品取第i-1个物品的状态
				f[i][j] &#x3D; f[i-1][j]
			else:
				# 取第i-1个物品的状态和第i个物品放入的状态的较大值
				f[i][j] &#x3D; max(f[i-1][j],f[i-1][j-weight[i-1]])
	return f[n][c]</code></pre>



<h2 id="时空权衡（基于计算机）"><a href="#时空权衡（基于计算机）" class="headerlink" title="时空权衡（基于计算机）"></a>时空权衡（基于计算机）</h2><p>如果想要时间效率最优，可以用动态规划，如果想要空间占用少，可以使用贪心或者滚动数组（将多余空间删去）</p>
<p>滚动数组（模2）</p>
<p>占用空间较小</p>
<pre class="line-numbers language-none"><code class="language-none">def bag01(weight,value,c,n):
	f &#x3D; [[0 for j in range(c+1)] for i in range(2)]
	for i in range(1,n+1):
		for j in range(1,c+1):
			# i物品数 j容积
			# 第i个物品不进背包的情况(% 取余)
			f[i % 2][j] &#x3D; f[(i-1) % 2][j]
			# 第i个物品不能放
			if j &gt;&#x3D; weight[i-1]:
				# 第i个物品取第i-1个物品的状态
				f[i % 2][j] &#x3D; f[（i-1） % 2][j]
			else:
				# 取第i-1个物品的状态和第i个物品放入的状态的较大值
				f[i % 2][j] &#x3D; max(f[i % 2][j],f[（i-1） % 2][j-weight[i-1]])
	return f[n][c]</code></pre>



<h2 id="动态规划（解决最优解问题的方法）"><a href="#动态规划（解决最优解问题的方法）" class="headerlink" title="动态规划（解决最优解问题的方法）"></a>动态规划（解决最优解问题的方法）</h2><p>一种求解多阶段决策问题的方法，一种面向最优化的递归计算技巧</p>
<p>用于求解分段函数的最值。它通过以一定顺序对复杂问题进行分解，以避免重复的计算。</p>
<p>并以类似递推的方式，通过对更小的子问题的解的组合得到原问题的解。</p>
<p>1、分解问题，对于分解之后的若干子问题·，定义一个状态。通过状态转移方程，将子问题的解转化成原问题的解</p>
<p>对于每一个物品i，枚举它的体积j，计算f[i][j]&#x3D;max(f[i-1][j],f[i-1][j-w[i]]+v[i])，</p>
<pre class="line-numbers language-none"><code class="language-none">def bag01(weight,value,c,n):
	# 中间状态，f[i][j]表示前i件物品放入容量为j的背包可以获得的最大价值
	f &#x3D; [[0 for j in range(c+1)] for i in range(n+1)]
	for i in range(1,n+1):
		for j in range(1,c+1):
			# 第i个物品不能放
			if j &lt; weight[i-1]:
				# 第i个物品取第i-1个物品的状态
				f[i][j] &#x3D; f[i-1][j]
			else:
				# 取第i-1个物品的状态和第i个物品放入的状态的较大值
				f[i][j] &#x3D; max(f[i-1][j],f[i-1][j-weight[i-1]])
	return f[n][c]</code></pre>



<h2 id="贪心（最优解问题）并不总能得到全局最优解"><a href="#贪心（最优解问题）并不总能得到全局最优解" class="headerlink" title="贪心（最优解问题）并不总能得到全局最优解"></a>贪心（最优解问题）并不总能得到全局最优解</h2><p>n件物品放入容量为c的背包中，（可不全部放入）使得背包中物品价值最大。</p>
<p>较好的近似解</p>
<p>问题分解，求每一个小问题的最优解。</p>
<p>1、单位重量价值最大的物品先放，直到背包无法再放。（贪心选择性质）</p>
<pre class="line-numbers language-none"><code class="language-none">def bag01(value,weight,n,c):
	# 物品的单位重量价值
	meimei &#x3D; [value[i]&#x2F;weight[i] for i in range(n)]
	# 排序（逆序，从大到小的顺序）按照价值重量比排序后的物品索引数组
	meimei &#x3D; sorted(range(n),key&#x3D;lambda i: meimei[i],reverse&#x3D;True)
	total_value &#x3D; 0
	# 是否放入背包的数组
	bag &#x3D; [0] * n
	for i in meimei:
		if weight[i] &lt;&#x3D; c:
			bag[i] &#x3D; 1
			total_value +&#x3D; value[i]
			c -&#x3D; weight[i]
		else:
			# 计算部分放入背包
			bag[i] &#x3D; c&#x2F;weight[i]
			total_value +&#x3D; value[i] * (c&#x2F;weight[i])
			break
	return total_value,bag</code></pre>



<h2 id="迭代改进（优化算法）并不总能得到全局最优解，较好的近似解"><a href="#迭代改进（优化算法）并不总能得到全局最优解，较好的近似解" class="headerlink" title="迭代改进（优化算法）并不总能得到全局最优解，较好的近似解"></a>迭代改进（优化算法）并不总能得到全局最优解，较好的近似解</h2><p>基本思想：每一次迭代中，根据当前解，确定一个方向，并且在方向上的解有所改进。</p>
<p>具体步骤：</p>
<p>1、初始化解，将解初始化为一个可行解。（全放和全不放）</p>
<p>2、迭代改进，每一次迭代中，选择一个方向，感觉该方向的优化目标，生成一个新解，并比较当前解。</p>
<p>3、判断终止条件，判断解是否满足问题要求</p>
<pre class="line-numbers language-none"><code class="language-none">def bag01(value,weight,n,c):
	# 初始化解
	select_items &#x3D; [0] * n
	total_value &#x3D; 0
	

while c &gt;0:

	# 计算性价比,并按照性价比从大到小排序

	ratios &#x3D; [(value[i] &#x2F; weight[i],i) for i in range(n)]
	ratios.sort(reverse&#x3D;True)
	

	# 尝试放入物品

	for ratio,i in ratios:
		if weight[i] &lt;&#x3D; c:
			c -&#x3D; weight[i]
			select_items[i] &#x3D; 1
			total_value +&#x3D; value[i]
	

	# 判断终止条件

	if all(select_items):
		break
return total_value,select_items</code></pre>




<h2 id="回溯与分支界限"><a href="#回溯与分支界限" class="headerlink" title="回溯与分支界限"></a>回溯与分支界限</h2><p>回溯（全局搜索）逐步构造方案来找到所有解</p>
<p>首先选择一个决策，直到找到最终的解或者无法前进，无法前进返回上一层，继续下一个决策。</p>
<p>关键：剪枝（避免重复）</p>
<p>分支界限（局部搜索找到最优解）逐步将空间缩小来找到问题的最优解。</p>
<p>根据规则生成一组候选解，对这组解评估，选出一个最优解，再根据最优解生成下一组，知道找到最终解</p>
<p>关键：剪枝（避免重复）</p>
<p>01背包中，回溯法：可以用于找到所有可能的解。分支界限：用于找到最优的解。</p>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><pre class="line-numbers language-none"><code class="language-none">def bag01(c,n,weight,value):
	def back(i,c_weight,c_value):
		&#39;&#39;&#39;
		i : 第i件物品
		c_weight：当前背包重量
		c_value：当前背包价值
		&#39;&#39;&#39;
		nonlocal max_value
		if c_weight &gt; c:
			return
		if c_value &gt; max_value:
			max_value &#x3D; c_value
		if i &#x3D;&#x3D; n:
			return
		# 不选第i件物品
		back(i+1,c_weight,c_value)
		# 选第i件物品
		back(i+1,c_weight+weight[i],c_value+value[i])
	max_value &#x3D; 0
	back(0,0,0)
	return max_value</code></pre>

<p>​	</p>
<h3 id="分支界限-对回溯算法的改进。剪枝"><a href="#分支界限-对回溯算法的改进。剪枝" class="headerlink" title="分支界限(对回溯算法的改进。剪枝)"></a>分支界限(对回溯算法的改进。剪枝)</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">def bag01(c,n,weight,value)：

	# 创建一个节点类，保存当前状态和状态的价值上界。

	class Node:
		def __init__(self,level,value,weight):

			# level表示当前节点的深度

			self.level &#x3D; level
			self.value &#x3D; value
			self.weight &#x3D; weight

		# 定义对象之间的＜比较。

		def __lt__(self,other):
			return self.value &gt; other.value

	# 创建一个优先队列，用来保存待扩展的节点，初始队列只有一个节点，表示当前状态为空

	nodes &#x3D; [Node(0,0,0)]
	max_value &#x3D; 0
	while nodes:
		node &#x3D; nodes.pop(0)

		# 代表选完了所有的节点

		if node.level &#x3D;&#x3D; n:
			if node_value &gt; max_value:
				max_value &#x3D; node_value
			continue
		

	# bound 存储计算得到的价值上界

	bound &#x3D; node_value

	# 不选第i件物品

	for j in range(node.level,n):

		# 装不下

		if node.weight + weight[j] &gt; c:

			# 取物品的部分

			bound +&#x3D; (c - node.weight) &#x2F; weight[j] * value[j]
			break
		bound +&#x3D; value[j]

	# 价值上界大于已知的最大价值

	if bound &gt; max_value:
		nodes.append(Node(node.level+1,node.value,node.weight))
	

	# 选第i件物品

	bound &#x3D; node.value + value[node.level]
	weight &#x3D; node.weight + weight[node.level]
	if weight &lt;&#x3D; c and bound &gt; max_value:
		max_value &#x3D; bound
	if bound &gt; max_value:
		nodes.append(Node(node.level+1,bound,weight))
return max_value</code></pre>

]]></content>
  </entry>
  <entry>
    <title>英语笔记</title>
    <url>//post/%E8%8B%B1%E8%AF%AD%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h2 id="虚拟语气"><a href="#虚拟语气" class="headerlink" title="虚拟语气"></a>虚拟语气</h2><p>1、—Tom is always making so many mistakes in his English exercises!  — Yeah. If he ________ more careful, he ________ fewer mistakes.</p>
<p>were,would make</p>
<p>试题分析：汤姆总是在英语联系中犯那么多错误！如果他可以更加细心一点，他就会犯更少的错误。</p>
<p>表示与现在事实相反的假设，If+主语+动词过去式（be动词用were）,主语+would&#x2F;should&#x2F;might&#x2F;could+动词原形。</p>
<p>2、If I ＿＿you . I＿＿study harder.</p>
<p>were,would</p>
<p>试题分析：如果我是你，我会更努力学习。</p>
<p>虚拟语气表示与过去事实相反。</p>
<p>3、 If I ______ you, I ______invite him to go to see a movie.</p>
<p>were,would</p>
<p>试题分析：如果我是你，我会邀请他去看电影，go to see a movie去看电影，invite sb to do 邀请某人做某事，在表达与现在事实相反的虚拟语气中，Be动词用were，主语用would。</p>
<p>4、If I  you,I  buy a bike for him.</p>
<p>were,would</p>
<p>试题分析：如果我是你，我会给他买一俩自行车，buy sth for sb给某人买某物，本句是虚拟语气，表示与现在的事实相反，在虚拟语气中不能用was。</p>
<p>5、— Come and join us, Ben!— I’m afraid I can’t. I’m too busy now. If I ________ time, I would certainly go.</p>
<p>had</p>
<p>试题分析：本、来加入我们吧！恐怕我不能，我现在太忙，如果我有时间，我一定会去的。条件状语从句中描述的与现在相反的事实，从句用一般过去时态。</p>
<h2 id="作文"><a href="#作文" class="headerlink" title="作文"></a>作文</h2><p>欢迎游客来北京旅游</p>
<p>Welcome to Beijing, the bustling capital city of China! This vibrant city offers an abundance of history, culture, and modern amenities. From visiting the iconic Forbidden City and climbing the Great Wall, to experiencing the local street food and shopping at the bustling markets, there is truly something for everyone in Beijing. Whether you are a first-time visitor or a returning traveler, we are confident that you will find this city to be a unique and fascinating destination. So come, explore and immerse yourself in the rich history and culture of Beijing. Enjoy your trip!</p>
<p>欢迎来到北京，中国繁华的首都！这座充满活力的城市提供了丰富的历史、文化和现代设施。从参观标志性的故宫和爬登长城，到体验当地的街头美食和在繁忙的市场购物，北京确实有适合每个人的地方。无论您是初次访问者还是回头客，我们相信您会发现这座城市是一个独特而有趣的目的地。所以，来吧，探索和沉浸在北京丰富的历史和文化中。祝您旅途愉快！</p>
<p>都江堰旅游</p>
<p>Welcome to Dujiangyan, a beautiful and historic city located in Sichuan province, China. This charming city is renowned for its magnificent natural scenery and rich cultural heritage, making it an ideal destination for tourists who are looking for a unique and unforgettable travel experience.</p>
<p>Dujiangyan is famous for its ancient irrigation system, which was built over 2,000 years ago and remains in use today. The system is considered one of the greatest engineering marvels of ancient China, and visitors can witness its beauty and functionality by taking a boat ride along the river. In addition to its historical significance, Dujiangyan is also surrounded by stunning natural beauty, including lush mountains, sparkling rivers, and verdant forests.</p>
<p>Whether you are interested in history, culture, or nature, Dujiangyan has something to offer for everyone. So come, explore this beautiful city and immerse yourself in its rich history and natural beauty. We guarantee that you will leave Dujiangyan with a newfound appreciation for this unique and fascinating destination. Enjoy your trip!</p>
<p>欢迎来到都江堰，一个位于中国四川省的美丽和历史悠久的城市。这个迷人的城市以其壮丽的自然风光和丰富的文化遗产而闻名，是寻求独特和难忘旅行体验的游客理想的目的地。</p>
<p>都江堰以其古老的灌溉系统而闻名，该系统建于2000多年前，至今仍在使用。该系统被认为是古代中国最伟大的工程奇迹之一，游客可以通过沿河船游见证其美丽和功能性。除了其历史意义外，都江堰周围还环绕着壮丽的自然美景，包括茂盛的山峦、闪闪发光的河流和绿油油的森林。</p>
<p>无论您对历史、文化还是自然有兴趣，都江堰都有适合每个人的内容。所以，来探索这个美丽的城市，沉浸在其丰富的历史和自然美中。我们保证您将带着对这个独特和迷人的目的地的新的钦佩离开都江堰。祝您旅途愉快！</p>
]]></content>
  </entry>
  <entry>
    <title>计算机基础</title>
    <url>//post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html</url>
    <content><![CDATA[<h1 id="计算机基础（备考版）"><a href="#计算机基础（备考版）" class="headerlink" title="计算机基础（备考版）"></a>计算机基础（备考版）</h1><h2 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h2><h3 id="1、1-ENIAC"><a href="#1、1-ENIAC" class="headerlink" title="1、1  ENIAC"></a>1、1  ENIAC</h3><p>1946年2月，世界上第一台电子数字积分计算机在美国宾夕法尼亚大学诞生，取名为ENIAC(中文名称为“埃尼阿克”)。</p>
<h3 id="1、2-冯诺依曼体系结构"><a href="#1、2-冯诺依曼体系结构" class="headerlink" title="1、2 冯诺依曼体系结构"></a>1、2 冯诺依曼体系结构</h3><p>计算机内部采用二进制数进行计算</p>
<p>计算机的指令和数据存储起来，由程序控制计算机自动执行</p>
<p>计算由五个部分组成：运算器、控制器、存储器、输入设备和输出设备</p>
<h3 id="1、3-计算机的发展"><a href="#1、3-计算机的发展" class="headerlink" title="1、3 计算机的发展"></a>1、3 计算机的发展</h3><p>根据计算机所使用的基本元件的不同，计算发展分为四代</p>
<p>第一代：电子管计算机</p>
<p>第二代：晶体管计算机</p>
<p>第三代：中、小规模集成电路</p>
<p>第四代：大、超大规模集成电路</p>
<h3 id="1、4-计算机特点"><a href="#1、4-计算机特点" class="headerlink" title="1、4 计算机特点"></a>1、4 计算机特点</h3><p>运算速度快</p>
<p>运算精度高</p>
<p>存储容量大</p>
<p>可靠性强</p>
<p>自动化程序高</p>
<p>通用性强</p>
<p>逻辑判断能力</p>
<h3 id="1、5-计算机的分类"><a href="#1、5-计算机的分类" class="headerlink" title="1、5 计算机的分类"></a>1、5 计算机的分类</h3><p>按照性能划分：巨型机、大型机、小型机、微型机、工作站等。</p>
<p>按照计算机的工作原理(处理对象)划分：数字计算机、模拟计算机、数模混合计算机。</p>
<p>按照计算机的功能用途划分：通用计算机、专用计算机。</p>
<h3 id="1、6-计算机的应用"><a href="#1、6-计算机的应用" class="headerlink" title="1、6 计算机的应用"></a>1、6 计算机的应用</h3><p>1、科学计算。例如：高能物理、工程设计、地震预测、气象预报、航天技术等。</p>
<p>2、过程检测与控制。广泛应用于机械、石油、电力等部门。</p>
<p>3、数据处理。例如：企业管理、物资管理、报表统计、账目计算、信息情报检索等。</p>
<p>4、计算机辅助系统：</p>
<p>​	计算机辅助设计 CAD、计算机辅助制造 CAM、计算机辅助教学 CAI、计算机辅助测试 CAT、计算机辅助教育 CBE、计算机管理教学 CMI、计算机集成制造系统 CIMS。</p>
<p>5、人工智能。机器人研究、智能检索等。</p>
<h3 id="1、7-计算机的发展趋势"><a href="#1、7-计算机的发展趋势" class="headerlink" title="1、7 计算机的发展趋势"></a>1、7 计算机的发展趋势</h3><p>计算机的发展表现为四种趋向：巨型化、微型化、网络化、智能化。</p>
<h3 id="1、8-二进制数的算术、逻辑运算"><a href="#1、8-二进制数的算术、逻辑运算" class="headerlink" title="1、8 二进制数的算术、逻辑运算"></a>1、8 二进制数的算术、逻辑运算</h3><p>1、算术运算</p>
<p>加法、减法（略）</p>
<p>2、逻辑运算</p>
<p>逻辑与（全1为1）、逻辑或（全0为0）、逻辑异或（同0异1）、逻辑非（1为0，0为1）。</p>
<h3 id="1、9-十进制转其他进制"><a href="#1、9-十进制转其他进制" class="headerlink" title="1、9 十进制转其他进制"></a>1、9 十进制转其他进制</h3><p>整数部分：不断除N进制取余数，余数倒排</p>
<p>小数部分：乘N取整，先整为高。</p>
<h3 id="1、10-其他进制转十进制"><a href="#1、10-其他进制转十进制" class="headerlink" title="1、10 其他进制转十进制"></a>1、10 其他进制转十进制</h3><p>按位权展开，而后求和。</p>
<h3 id="1、11-原码、反码与补码"><a href="#1、11-原码、反码与补码" class="headerlink" title="1、11 原码、反码与补码"></a>1、11 原码、反码与补码</h3><p>1、原码：即二进制码</p>
<p>2、反码：符号位不变，其余位取反</p>
<p>3、补码：反码加一</p>
<h3 id="1、12-ASCII码"><a href="#1、12-ASCII码" class="headerlink" title="1、12 ASCII码"></a>1、12 ASCII码</h3><p>1、标准采用7位二进制编码，在计算机中，用一个字节表示，最高位为0。扩展由8位二进制编码</p>
<p>2、字符码值：数字到大写字母到小写字母。大写与小写之间相差32</p>
<h3 id="1、13-汉字编码"><a href="#1、13-汉字编码" class="headerlink" title="1、13 汉字编码"></a>1、13 汉字编码</h3><p>1、输入码：音码、形码</p>
<p>2、国标码：区位码+2020H（H为16进制的标志）</p>
<p>3、机内码：国标码+8080H &#x3D; 区位码+A0A0H</p>
<p>4、字型码：点阵与矢量。n * n点阵的汉字占n * n&#x2F;8个字节</p>
<h3 id="1、14-位和字节"><a href="#1、14-位和字节" class="headerlink" title="1、14 位和字节"></a>1、14 位和字节</h3><p>1、位（bit，b）：计算机存储信息的最小单位</p>
<p>2、字节：计算机中，8个二进制位组成一个存储单元，成为字节</p>
<p>3、单位换算：1B &#x3D; 8b 1KB &#x3D; 1024B 1MB &#x3D; 1024KB………….</p>
<h3 id="1、15-计算机系统的组成"><a href="#1、15-计算机系统的组成" class="headerlink" title="1、15 计算机系统的组成"></a>1、15 计算机系统的组成</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191106207.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191106207.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220419191106207"></p>
<h3 id="1、16-计算机硬件系统的组成"><a href="#1、16-计算机硬件系统的组成" class="headerlink" title="1、16 计算机硬件系统的组成"></a>1、16 计算机硬件系统的组成</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191133911.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191133911.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220419191133911"></p>
<h3 id="1、17-计算机软件系统的分类"><a href="#1、17-计算机软件系统的分类" class="headerlink" title="1、17 计算机软件系统的分类"></a>1、17 计算机软件系统的分类</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191159519.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191159519.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220419191159519"></p>
<h3 id="1、18-程序设计语言"><a href="#1、18-程序设计语言" class="headerlink" title="1、18  程序设计语言"></a>1、18  程序设计语言</h3><p>1.低级语言：机器语言﹑汇编语言。</p>
<p>⒉高级语言：如面向过程的Fortran、 Pascal,C等,面向对象的C＋＋、Java。</p>
<p>3.编译：将高级语言所编写的源程序翻译成等价的用机器语言表示的目标程序。</p>
<p>4.解释：解释程序对原程序是一边翻译、一边执行,不产生目标程序。</p>
<h3 id="1、19-总线"><a href="#1、19-总线" class="headerlink" title="1、19 总线"></a>1、19 总线</h3><p>定义：计算机各功能部件之间传送信息的公共通信干线。</p>
<p>分类：数据总线、地址总线、控制总线。</p>
<p>总线标准：PCI、AGP、USB、PCI-Express总线。</p>
<h3 id="1、20-存储器的分类"><a href="#1、20-存储器的分类" class="headerlink" title="1、20 存储器的分类"></a>1、20 存储器的分类</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191448767.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191448767.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220419191448767"></p>
<h3 id="1、21-计算机主要性能指标"><a href="#1、21-计算机主要性能指标" class="headerlink" title="1、21 计算机主要性能指标"></a>1、21 计算机主要性能指标</h3><p>1、主频：也称为时钟频率，单位为赫兹。</p>
<p>2、字长：取决于计算机数据总线的宽度,也就是CPU一次能处理的数据的位数。</p>
<p>3、存储容量：包括内存容量和外存容量。</p>
<p>4、存取周期：存取时间越短,表示访问数据的速度越快。</p>
<p>5、内核数：指CPU内执行指令的运算器和控制器的数量。</p>
<p>6、运算速度：单位时间内执行的计算机指令数。单位有MIPS(每秒10^6条指令)和 BIPS(每秒10^8条指今)等。</p>
<h2 id="Windows-7-操作系统"><a href="#Windows-7-操作系统" class="headerlink" title="Windows 7 操作系统"></a>Windows 7 操作系统</h2><h3 id="2、1-操作系统"><a href="#2、1-操作系统" class="headerlink" title="2、1 操作系统"></a>2、1 操作系统</h3><p>1、五大管理功能：处理器管理、存储管理、设备管理、文件管理和作业管理。</p>
<p>2、分类：<br>按操作系统的功能划分：批处理操作系统、分时操作系统、实时操作系统、网络操作系统、分布式操作系统。<br>按所支持的用户数划分：单用户操作系统、多用户操作系统。<br>按是否能够运行多个任务划分：单任务操作系统、多任务操作系统。</p>
<p>3、主要特征：并发性、共享性、虚拟性、异步性。<br>4、常见操作系统：DOS磁盘操作系统、Windows 操作系统、UNIX操作系统、Linux操作系统、Mac OS。</p>
<h3 id="2、2-Windows-7操作系统的运行环境"><a href="#2、2-Windows-7操作系统的运行环境" class="headerlink" title="2、2 Windows 7操作系统的运行环境"></a>2、2 Windows 7操作系统的运行环境</h3><p>1、处理器：主频1GHz或更快的32位(X86)或64位(X64)。<br>2、内存容量：至少1GB(32位CPU)或2GB(64位CPU)的物理内存。</p>
<p>3、硬盘：16GB可用的硬盘空间(32位)或20GB可用硬盘空间(64位)。</p>
<h3 id="2、3-鼠标的基本操作"><a href="#2、3-鼠标的基本操作" class="headerlink" title="2、3 鼠标的基本操作"></a>2、3 鼠标的基本操作</h3><p>单击、双击、右击、拖动、指向</p>
<h3 id="2、4-常用键盘快捷键"><a href="#2、4-常用键盘快捷键" class="headerlink" title="2、4 常用键盘快捷键"></a>2、4 常用键盘快捷键</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191947012.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191947012.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220419191947012"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191957801.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220419191957801.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220419191957801"></p>
<h3 id="2、5-任务栏"><a href="#2、5-任务栏" class="headerlink" title="2、5 任务栏"></a>2、5 任务栏</h3><table>
<thead>
<tr>
<th>“开始”按钮</th>
<th>用于打开“开始”菜单。</th>
</tr>
</thead>
<tbody><tr>
<td>快速启动区</td>
<td>放置常用程序的快捷方式图标,通过它可以快速启动一些常用的程序。</td>
</tr>
<tr>
<td>任务按钮区</td>
<td>显示正在运行的程序或文件窗口的对应按钮。</td>
</tr>
<tr>
<td>系统通知区</td>
<td>显示时间、音量及一些告知特定程序和计算机设置状态的图标。</td>
</tr>
<tr>
<td>“显示桌面”按钮</td>
<td>用来显示桌面的按钮,也可以使用快捷键Win＋D来显示桌面。</td>
</tr>
</tbody></table>
<h3 id="2-6窗口的基本操作"><a href="#2-6窗口的基本操作" class="headerlink" title="2.6窗口的基本操作"></a>2.6窗口的基本操作</h3><p>1、最大化、最小化窗口<br>最小化按钮：在标题栏上单击“最小化”按钮，窗口会以该程序的图标形式缩小到任务栏。<br>最大化按钮：单击此按钮即可使窗口最大化。<br>还原按钮：单击此按钮即可恢复到窗口最大化前的大小。</p>
<p>2、切换窗口</p>
<p>在任务栏上单击此窗口的按钮即可切换到此窗口。</p>
<p>用Alt+Tab组合键切换窗口。<br>用Alt＋Esc组合键可切换窗口。</p>
<p>3、关闭窗口</p>
<p>直接在标题栏右侧单击“关闭”按钮。<br>按快捷键Alt十F4组合键。<br>右击任务栏上的窗口图标并在弹出式菜单中选择“关闭窗口”命令。		</p>
<h3 id="2、7-对话框"><a href="#2、7-对话框" class="headerlink" title="2、7 对话框"></a>2、7 对话框</h3><p>与窗口相比，对话框不能改变其大小，也不能缩小成任务栏图标，但<strong>可以移动</strong>。</p>
<h3 id="2、8-常见菜单命令"><a href="#2、8-常见菜单命令" class="headerlink" title="2、8 常见菜单命令"></a>2、8 常见菜单命令</h3><table>
<thead>
<tr>
<th>灰色显示的菜单命令</th>
<th>表示此命令在当前不可选用。</th>
</tr>
</thead>
<tbody><tr>
<td>命令中带有符号“√”</td>
<td>表示该命令是复选命令且被选中。</td>
</tr>
<tr>
<td>命令中带有符号“→”</td>
<td>表示当鼠标移至此命令上,会打开级联菜单。</td>
</tr>
<tr>
<td>命令中带有符号“·”</td>
<td>表示该命令是单选命令且被选中。</td>
</tr>
<tr>
<td>命令中带有符号“…”</td>
<td>表示执行命令后会打开一个对话框。</td>
</tr>
</tbody></table>
<h3 id="2、9-回收站"><a href="#2、9-回收站" class="headerlink" title="2、9 回收站"></a>2、9 回收站</h3><p>1、功能：是系统在<strong>硬盘</strong>中开辟的一块存储区域，用于存储删除的文件或文件夹。</p>
<p>2、基本操作<br>删除：在资源管理器中选定要删除的对象，单击“文件”菜单(或右击,弹出一个快捷菜单) ，选择“删除”命令，或直接按下Delete键，在对话框中单击“是”，即可删除该对象。<br>还原：打开“回收站”窗口，右击要还原的文件或文件夹，在弹出的快捷菜单中选择“还原”命令。<br>彻底删除：选定文件或文件夹，按下**Shift+Delete(Del)**组合键。</p>
<h3 id="2、10-剪贴板"><a href="#2、10-剪贴板" class="headerlink" title="2、10 剪贴板"></a>2、10 剪贴板</h3><p>1、功能：用来临时存放交换的信息，属于<strong>RAM</strong>中的一块区域。<br>2、基本操作：使用复制Ctrl+C、剪切Ctrl＋X，PrintScreen，Alt+PrintScreen 组合键将选定对象传入剪贴板。</p>
<h3 id="2、11-Windows资源管理器的启动方法"><a href="#2、11-Windows资源管理器的启动方法" class="headerlink" title="2、11 Windows资源管理器的启动方法"></a>2、11 Windows资源管理器的启动方法</h3><p>右击“开始”按钮，在弹出的快捷菜单中选择“打开 Windows资源管理器”。<br>单击“开始”按钮，在打开的“开始”菜单中选择“所有程序”“附件”“Windows资源管理器”命令。<br>按快捷键Win＋E。</p>
<h3 id="2、12-文件和文件夹管理"><a href="#2、12-文件和文件夹管理" class="headerlink" title="2、12 文件和文件夹管理"></a>2、12 文件和文件夹管理</h3><p>新建文件或文件夹<br>右击桌面或文件夹窗口工作区空白处，在弹出的快捷菜单中选择“新建”命令。</p>
<p>单击菜单栏的“文件”按钮，在弹出的下拉列表框中选择“新建”命令。</p>
<p>选择文件或文件夹</p>
<table>
<thead>
<tr>
<th>单个文件或文件夹</th>
<th>在窗口中直接单击要选定的文件或文件夹。</th>
</tr>
</thead>
<tbody><tr>
<td>连续的一组文件或文件夹</td>
<td>单击该组的第一个对象﹐按住 Shift键然后单击该组的最后一个对象。</td>
</tr>
<tr>
<td>不连续的文件或文件夹</td>
<td>在窗口选中一个对象后,按住Ctrl键然后再单击要选定的各个对象。</td>
</tr>
<tr>
<td>选取全部文件或文件夹</td>
<td>按Ctrl＋A组合键。</td>
</tr>
<tr>
<td>取消已选定的文件或文件夹</td>
<td>按住Ctrl键,再用鼠标依次单击各个需要取消的对象。</td>
</tr>
</tbody></table>
<p>复制文件或文件夹</p>
<p>利用“剪贴板”</p>
<p>选定需要复制的文件或文件夹。<br>执行“复制”命令。<br>打开目标位置，执行“粘贴”命令。</p>
<p>利用鼠标拖动</p>
<p>在不同的磁盘之间复制：直接拖动。<br>在同一磁盘的不同文件夹之间复制：按住Ctrl键的同时拖动。</p>
<p>移动文件或文件夹</p>
<p>利用“剪贴板”</p>
<p>选定需要移动的文件或文件夹。<br>执行“剪切”命令。<br>打开目标位置，执行“粘贴”命令。</p>
<p>利用鼠标拖动</p>
<p>在不同的磁盘之间移动：按住Shift键的同时拖动。<br>在同一磁盘的不同文件夹之间移动：直接拖动。</p>
<h3 id="2、13-磁盘管理"><a href="#2、13-磁盘管理" class="headerlink" title="2、13  磁盘管理"></a>2、13  磁盘管理</h3><p>1、磁盘格式化：“快速格式化”只清除磁盘中的所有数据。“完全格式化”不但清除磁盘中的所有数据，还对磁盘进行扫描检查，将发现的坏道、坏区进行标注。<br>2、磁盘清理：清除用户在使用电脑的过程中产生的一些临时文件。<br>3、磁盘碎片整理：重新排列因频繁地安装、卸载程序，或者复制、删除文件在系统中生成的磁盘碎片数据，以便磁盘和驱动器能够更有效地工作。</p>
<h3 id="2、14-文件命名规则"><a href="#2、14-文件命名规则" class="headerlink" title="2、14  文件命名规则"></a>2、14  文件命名规则</h3><p>文件名由主文件名和扩展名两部分组成,主文件名和扩展名之间用“.”作为分隔符，最多可使用255个合法的字符。文件或文件夹名中不能出现\、&#x2F;、:、* 、?、”、&lt;、&gt;、&#x2F;字符。文件名中不区分英文字母的大小写。</p>
<h3 id="2、15-通配符的使用"><a href="#2、15-通配符的使用" class="headerlink" title="2、15  通配符的使用"></a>2、15  通配符的使用</h3><p>Windows 7操作系统中规定了两个通配符，问号“?”和星号“ * ”。其中“?”代替所在位置上的任一字符。“*”代替从所在位置开始的任意一串字符。</p>
<h3 id="2、16-Windows-7任务管理器"><a href="#2、16-Windows-7任务管理器" class="headerlink" title="2、16  Windows 7任务管理器"></a>2、16  Windows 7任务管理器</h3><p>1、功能：终止未响应的应用程序、终止进程的运行。</p>
<p>2、启动方法</p>
<table>
<thead>
<tr>
<th>方法一</th>
<th>使用Ctrl+Shift＋Esc组合键打开。</th>
</tr>
</thead>
<tbody><tr>
<td>方法二</td>
<td>右击任务栏,在弹出的快捷菜单中执行“启动任务管理器”命令。</td>
</tr>
<tr>
<td>方法三</td>
<td>使用Ctrl+Alt+Delete组合键,在系统锁定界面中执行“启动任务管理器”命令。</td>
</tr>
</tbody></table>
<h3 id="2、17-Windows-7控制面板"><a href="#2、17-Windows-7控制面板" class="headerlink" title="2、17 Windows 7控制面板"></a>2、17 Windows 7控制面板</h3><p>1、功能：可以用来调整系统的环境参数及各种属性，可以更改系统的外观和功能，对计算机的软、硬件系统进行设置，还可进行用户账户管理及设备的设置和管理等操作。<br>2、按“类别”查看方式显示的常用工具</p>
<table>
<thead>
<tr>
<th>外观和个性化</th>
<th>更改主题;更改桌面背景;调整屏幕分辨率等</th>
</tr>
</thead>
<tbody><tr>
<td>网络和Internet</td>
<td>查看网络状态和任务;进行联网设置等</td>
</tr>
<tr>
<td>硬件和声音</td>
<td>查看设备和打印机;添加设备等</td>
</tr>
<tr>
<td>时钟、语言和区域</td>
<td>设置日期和时间;更改键盘或其他输入法</td>
</tr>
<tr>
<td>程序</td>
<td>卸载或更改程序等</td>
</tr>
<tr>
<td>用户账户和家庭安全</td>
<td>添加或删除用户账户等</td>
</tr>
<tr>
<td>系统和安全</td>
<td>查看计算机状态;备份计算机等</td>
</tr>
</tbody></table>
<h3 id="2、18-Windows-7的实用工具"><a href="#2、18-Windows-7的实用工具" class="headerlink" title="2、18  Windows 7的实用工具"></a>2、18  Windows 7的实用工具</h3><p>1、画图：是一个用于绘制、调色和编辑图片的程序，并可将绘制的图形存为位图文件( . bmp文件)。<br>2、记事本：是一个文本文件编辑器，可以使用它编辑简单的文档或创建Web页。“记事本”只能编辑纯文本文件。<br>3、写字板：是 Windows系统自带的，更为高级一些的文字编辑工具、具备了格式编辑和排版的功能。写字板中可以插入图片和对象，设置段落格式等。</p>
<p>4、计算器：可以进行数制转换、三角函数运算等。Windows7中的计算器有四种模式，即标准型计算器、科学型计算器、程序员模式和统计信息模式。<br>5、录音机：是 Windows 7提供给用户的一种具有语音录制功能的工具，使用它可以收录用户自己的声音，并以声音文件格式保存。默认文件类型为“. wma”。</p>
<h2 id="word-2010"><a href="#word-2010" class="headerlink" title="word 2010"></a>word 2010</h2><h3 id="3-1-Word-2o10的启动"><a href="#3-1-Word-2o10的启动" class="headerlink" title="3.1 Word 2o10的启动"></a>3.1 Word 2o10的启动</h3><p>1、从“开始”菜单启动。执行“开始”→“所有程序”&gt;Microsoft Office→Microsoft Word2010命令。<br>⒉、直接启动文档。Word 2010应用程序与. docx文档关联,双击相应的文档,即可启动Word 2010。</p>
<h3 id="3-2-Word-2010的退出"><a href="#3-2-Word-2010的退出" class="headerlink" title="3.2 Word 2010的退出"></a>3.2 Word 2010的退出</h3><p>1、单击标题栏右侧的“关闭”按钮。</p>
<p>2、单击“文件”选项卡中的“退出”命令。</p>
<p>3、双击应用程序的控制菜单图标。</p>
<p>4、按Alt＋F4组合键。</p>
<h3 id="3-3-Word-2010窗口组成"><a href="#3-3-Word-2010窗口组成" class="headerlink" title="3.3  Word 2010窗口组成"></a>3.3  Word 2010窗口组成</h3><p>l、标题栏。双击标题栏可以让 Word 2010窗口在最大化和还原状态之间切换。</p>
<p>2、快速访问工具栏。包括“保存”“撤消””恢复”等按钮，用户可以自定义。<br>3、功能区。功能区包括多个选项卡,单击不同的选项卡即可显示相应的工具集合。</p>
<p>4、文档编辑区。用于显示或编辑文档内容的工作区域。<br>5、滚动条。拖动滚动条可浏览文档的整个页面内容。<br>6、状态栏。显示当前的状态信息，如当前页数、语言、编辑状态等信息。</p>
<h3 id="3-4-Word-2010视图"><a href="#3-4-Word-2010视图" class="headerlink" title="3.4 Word 2010视图"></a>3.4 Word 2010视图</h3><p>1、页面视图。主要用于版面设计，可以显示文档的打印结果外观，是最接近打印结果的视图。</p>
<p>2、阅读版式视图。以书页的形式显示文档。<br>3、Web版式视图。可以创建Web页或文档，适用于发送电子邮件和创建网页。</p>
<p>4、大纲视图。适合编辑文档的大纲，设置和显示标题的层级结构。<br>5、草稿视图。多用于文字处理工作，是最节省计算机系统硬件资源的视图方式。</p>
<h3 id="3-5-创建新文档"><a href="#3-5-创建新文档" class="headerlink" title="3.5 创建新文档"></a>3.5 创建新文档</h3><p>1、启动Word 2010后，系统会自动创建并打开一个新的空白文档。<br>2、在 Word 2010中，单击“文件”→“新建”→“空白文档”，然后单击“创建”按钮。</p>
<p>3、在文件夹中，右击空白处，在快捷菜单中执行“新建”“Microsoft Word文档”命令。</p>
<p>4、按Ctrl十N组合键。</p>
<h3 id="3-6-保存文档"><a href="#3-6-保存文档" class="headerlink" title="3.6 保存文档"></a>3.6 保存文档</h3><p>1、单击“快速访问工具栏”中的“保存”按钮或“文件”选项卡中的“保存”命令。</p>
<p>2、按Ctrl十S组合键或Shift＋F12组合键。</p>
<h3 id="3-7-另存为"><a href="#3-7-另存为" class="headerlink" title="3.7 另存为"></a>3.7 另存为</h3><p>“另存为”命令可以将当前文档以不同的保存位置、不同的保存名称或不同的保存类型进行另存，具体操作为：在“文件”选项中单击“另存为”命令，弹出“另存为”对话框，在对话框中进行设置后，单击“保存”按钮即可。</p>
<h3 id="3-8-打开已有文档"><a href="#3-8-打开已有文档" class="headerlink" title="3.8 打开已有文档"></a>3.8 打开已有文档</h3><p>1、在文档所在的文件夹中双击文档文件图标。<br>2、单击“文件”选项卡中的“打开”命令(或直接按快捷键Ctrl+О或Ctrl十F12)，在打开的对话框中可根据需要选择打开的对象。</p>
<h3 id="3-9-关闭文档"><a href="#3-9-关闭文档" class="headerlink" title="3.9 关闭文档"></a>3.9 关闭文档</h3><p>1、单击“文件”选项卡中的“关闭”命令。</p>
<p>2、按Ctrl+W组合键。<br>注意：上述两种操作都不会关闭Word 2010程序。</p>
<h3 id="3-10-“硬回车”符和“软回车”符"><a href="#3-10-“硬回车”符和“软回车”符" class="headerlink" title="3.10 “硬回车”符和“软回车”符"></a>3.10 “硬回车”符和“软回车”符</h3><p>按Enter键，文档中会插入一个段落标记符或“硬回车”符，生成一个段落。<br>按Shift十Enter组合键，文档中会插入一个“人工分行”符或“软回车”符，可以在同一段落内换行。</p>
<h3 id="3-11-移动插入点"><a href="#3-11-移动插入点" class="headerlink" title="3.11 移动插入点"></a>3.11 移动插入点</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220420114540585.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220420114540585.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220420114540585"></p>
<h3 id="3-12-选定文本"><a href="#3-12-选定文本" class="headerlink" title="3.12 选定文本"></a>3.12 选定文本</h3><p>1、选择分散文本。先选中第一个文本区域，然后按住Ctrl键，选择其他文本区域。</p>
<p>2、选中一行。将鼠标指针指向选定栏，单击鼠标左键。<br>3、选择垂直文本。按住Alt键不放，然后按住鼠标左键拖动。<br>4、选择一个段落。双击选定栏可以选中该段落。也可以在段落内三击鼠标左键。</p>
<p>5、选择整篇文档。将鼠标指针指向选定栏，三击鼠标左键，或按Ctrl＋A组合键。</p>
<h3 id="3-13-插入和改写"><a href="#3-13-插入和改写" class="headerlink" title="3.13 插入和改写"></a>3.13 插入和改写</h3><p>文档处于“插入”状态时，插入点右边的字符和文字随新的文字的输入逐一向右移动。</p>
<p>文档处于“改写”状态时，插入点右边的字符和文字将会被新输入的文字或字符覆盖(替换)。</p>
<p>按Insert键或单击状态栏上的“插入&#x2F;改写”按钮，可以在两种状态之间进行切换。</p>
<h3 id="3-14-剪贴板"><a href="#3-14-剪贴板" class="headerlink" title="3.14 剪贴板"></a>3.14 剪贴板</h3><p>单击“开始”选项卡“剪贴板”组右下角的图标，可以打开剪贴板窗格。</p>
<p>Word 2010提供的剪贴板功能可以存储最近24次复制或剪切后的内容。</p>
<h3 id="3-15-查找和替换"><a href="#3-15-查找和替换" class="headerlink" title="3.15 查找和替换"></a>3.15 查找和替换</h3><p>1、导航窗格。单击“开始”选项卡中的“查找”按钮(或按Ctrl十F)组合键，可以打开导航窗格。<br>2、“查找和替换”对话框。单击“开始”选项卡“编辑”组→“查找”选项→“高级查找”命令，可以打开“查找和替换”对话框。在“查找”选项卡下可以查找文本；在“替换”选项卡下可以对指定内容进行替换；在“定位”选项卡下可以对文档快速定位。</p>
<h3 id="3-16-编辑字符格式"><a href="#3-16-编辑字符格式" class="headerlink" title="3.16 编辑字符格式"></a>3.16 编辑字符格式</h3><p>单击“开始”选项卡，在“字体”功能区可对选中的文本进行设置。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220420114654959.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220420114654959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220420114654959"></p>
<h3 id="3-17-段落缩进"><a href="#3-17-段落缩进" class="headerlink" title="3.17 段落缩进"></a>3.17 段落缩进</h3><p>段落的缩进方式有左缩进、右缩进、首行缩进和悬挂缩进四种。</p>
<p>1、左缩进是指整个段落左边界距离页面左侧的缩进量。<br>2、右缩进是指整个段落右边界距离页面右侧的缩进量。</p>
<p>3、首行缩进是指段落首行第1个字符的起始位置距离段落其他行左侧的缩进量。</p>
<p>4、悬挂缩进是指段落中除首行以外的其他行距离页面左侧的缩进量。</p>
<h3 id="3-18-格式刷"><a href="#3-18-格式刷" class="headerlink" title="3.18 格式刷"></a>3.18 格式刷</h3><p>格式刷可以快速复制文本或段落的格式，操作为：选定已设置格式的文本，单击“开始”选项卡中“剪贴板”组中的“格式刷”图标，然后将鼠标指针移到要复制格式的文本开始位置，选中文本，释放鼠标即可。双击“格式刷”按钮，可以多次使用格式刷。</p>
<h3 id="3-19-页面设置"><a href="#3-19-页面设置" class="headerlink" title="3.19 页面设置"></a>3.19 页面设置</h3><p>通过“页面布局”选项卡“页面设置”组中的相关命令，可以设置文字方向、页边距、纸张方向，纸张大小、分栏等，还可以插入分隔符。分隔符列表中各选项的功能如表所示。</p>
<table>
<thead>
<tr>
<th>分页符</th>
<th align="left">表示一页结束而另一页开始的格式符号,可以分为“自动分页”和“手动分页”。</th>
</tr>
</thead>
<tbody><tr>
<td>分栏符</td>
<td align="left">插人分栏符是将应用了分栏的文本与未分栏的文本分隔开。</td>
</tr>
<tr>
<td>自动换行符</td>
<td align="left">表示另起一行,与Shift＋Enter 组合键作用相同。</td>
</tr>
<tr>
<td>分节符</td>
<td align="left">下一页:光标当前位置后的全部内容移到下一页上。连续:光标当前位置以后的内容将进行新的设置安排,但其内容不转到下一页。偶数页&#x2F;奇数页;光标当前位置以后的内容将会转换到下一个偶数页&#x2F;奇数页上。</td>
</tr>
</tbody></table>
<h3 id="3-20-设置页眉页脚"><a href="#3-20-设置页眉页脚" class="headerlink" title="3.20 设置页眉页脚"></a>3.20 设置页眉页脚</h3><p>页眉是每个页面页边距的顶部区域，页脚是每个页面页边距的底部区域。通过“插入”选项卡中的“页眉”“页脚”命令，可以插入页眉页脚。页眉页脚可以设置为“首页不同”，”奇偶页不同”。</p>
<h3 id="3-21-插入图片"><a href="#3-21-插入图片" class="headerlink" title="3.21 插入图片"></a>3.21 插入图片</h3><p>通过“插入”选项卡中的“插图”命令，可以在文档中插入图片、剪贴画、图形形状、Smart-Art图形、图表和屏幕截图等。对插入的图片也可以进行编辑,如旋转、剪裁、调整大小，改变排列方式等。</p>
<h3 id="3-22-插入艺术字"><a href="#3-22-插入艺术字" class="headerlink" title="3.22 插入艺术字"></a>3.22 插入艺术字</h3><p>单击“插入”选项卡“文本”组中的“艺术字”命令，在其下拉列表中选择适合的艺术字样式，可以插入艺术字文本框，直接在文本框中输入艺术字的内容即可。</p>
<h3 id="3-23-插入表格"><a href="#3-23-插入表格" class="headerlink" title="3.23 插入表格"></a>3.23 插入表格</h3><p>单击“插入”选项卡中的“表格”命令，在弹出的下拉菜单中使用虚拟表格插人表格、也可以使用“插入表格”“绘制表格””Excel电子表格”“快速表格”等命令插入表格。</p>
<h3 id="3-24-拆分与合并单元格"><a href="#3-24-拆分与合并单元格" class="headerlink" title="3.24 拆分与合并单元格"></a>3.24 拆分与合并单元格</h3><p>1、拆分单元格：选中需要拆分的某个单元格，然后单击“拆分单元格”按钮，在弹出的“拆分</p>
<p>单元格”对话框中设置拆分的行、列数，单击“确定”按钮即可。<br>⒉、合并单元格：选中需要合并的多个单元格，然后单击“合并单元格”按钮，即可将其合并成一个单元格。</p>
<h3 id="3-25-排序"><a href="#3-25-排序" class="headerlink" title="3.25 排序"></a>3.25 排序</h3><p>将插入点置于要排序的表格中，在“布局”选项卡的“数据”工具组中单击“排序”按钮打开“排序”对话框。在对话框中设置“主要关键字””次要关键字””第三关键字””升序””降序”等。<br>在Word 2010中，表格最多可以按三个关键字进行排序。</p>
<h3 id="3-26-公式计算"><a href="#3-26-公式计算" class="headerlink" title="3.26 公式计算"></a>3.26 公式计算</h3><p>Word 2010单元格的名字由行号和列标来标识，列标在前，行号在后。列标用A、B、C、…表示；行号用1、2、3、…表示。</p>
<p>Word 2010中的表格也可以使用公式进行计算，具体操作为：将插入点定位在要插入公式的单元格中，切换到“表格工具&#x2F;布局”选项卡，然后单击“数据”组中的“公式”按钮，弹出“公式”对话框，在对话框中输入公式，完成公式的输入后单击“确定”按钮，当前单元格将显示出运算结果。<br>公式引用的数据源发生变化后，用户需要逐个更新公式。</p>
<h3 id="3-27自动更正"><a href="#3-27自动更正" class="headerlink" title="3.27自动更正"></a>3.27自动更正</h3><p>使用“自动更正”功能可以将字符、文本或图形替换成特定的字符、词组或图形,设置自动更正的步骤如下:<br>在“文件”选项卡中执行“选项”命令。<br>在打开的“Word选项”对话框中执行“校对”命令。<br>在右侧窗格中单击“自动更正选项”按钮，可以打开“自动更正”对话框,用户可以根据自己的需要设置自动更正的单词或中文词组。</p>
<h3 id="3-28-邮件合并"><a href="#3-28-邮件合并" class="headerlink" title="3.28 邮件合并"></a>3.28 邮件合并</h3><p>若要编辑处理的多份文档中主要内容都是相同的，只是具体数据有不同变化，可以使用“邮件合并”，操作步骤为:<br>创建主文档。主文档即相同部分的内容。</p>
<p>设置数据源。数据源是可变化部分。<br>插入合并域。将数据源插入到主文档中相应的位置。</p>
<p>进行邮件合并。</p>
<h3 id="3-29打印"><a href="#3-29打印" class="headerlink" title="3.29打印"></a>3.29打印</h3><p>打印前可以进行打印预览，若不满意，可返回编辑状态进行编辑。</p>
<p>打印预览状态下，不能对文档内容进行编辑。<br>打印文档时可以选择合适的打印机，自定义打印范围，设置纸张大小。</p>
<p>自定义打印范围时，若页码连续，可用“-”连接，若页码不连续，可用“,”连接。</p>
<h2 id="excel-2010"><a href="#excel-2010" class="headerlink" title="excel 2010"></a>excel 2010</h2><h3 id="4、1-工作簿、工作表和单元格"><a href="#4、1-工作簿、工作表和单元格" class="headerlink" title="4、1 工作簿、工作表和单元格"></a>4、1 工作簿、工作表和单元格</h3><p>工作簿是指在Excel中用来存储并处理数据的文件，其扩展名是.xlsx。<br>工作表是一个由行和列交叉排列的二维表格，Excel的一个工作簿默认有3个工作表，最多可以包含无数个工作表。<br>单元格的名称(也称单元格地址)是由列标(从A、B、…、Z、AA、AB、…一直到XFD)和行号(从1到1048576)来标识的，且列标在前，行号在后。</p>
<h3 id="4、2-工作表的添加、删除和重命名"><a href="#4、2-工作表的添加、删除和重命名" class="headerlink" title="4、2 工作表的添加、删除和重命名"></a>4、2 工作表的添加、删除和重命名</h3><p>工作表的添加：右击工作表标签，在弹出的菜单中选择“插入”命令，然后在弹出的对话框中选择“工作表”，单击“确定”按钮即完成添加。<br>工作表的删除：右击工作表标签，在弹出的菜单中选择“删除”命令即可完成删除。</p>
<p>工作表的重命名：选中工作表，然后双击工作表标签，然后输入新的名字即可。</p>
<h3 id="4-3-工作表的移动和复制"><a href="#4-3-工作表的移动和复制" class="headerlink" title="4.3  工作表的移动和复制"></a>4.3  工作表的移动和复制</h3><p>工作表的移动：</p>
<p>(1)选中需要移动的工作表的标签，按住鼠标左键拖动到目标位置即可。</p>
<p>(2)右击工作表标签，在弹出的菜单中选择“移动或复制”命令，在对话框中选择工作表的位置，单击“确定”按钮即可。<br>工作表的复制：</p>
<p>(1)选中工作表，按住Ctrl键的同时拖动工作表标签到目标位置即可。</p>
<p>(2)右击工作表标签，在弹出的菜单中选择“移动或复制”命令，在对话框中勾选“建立副本”复选框，选择工作表位置，单击“确定”按钮可以完成复制。</p>
<h3 id="4、4-单元格区域的选择"><a href="#4、4-单元格区域的选择" class="headerlink" title="4、4 单元格区域的选择"></a>4、4 单元格区域的选择</h3><table>
<thead>
<tr>
<th>单个单元格</th>
<th>单击相应的单元格。</th>
</tr>
</thead>
<tbody><tr>
<td>某个单元格区域</td>
<td>单击选定该区域的第一个单元格，然后拖动鼠标直至选定最后一个单元格。</td>
</tr>
<tr>
<td>工作表中的所有单元格</td>
<td>单击“全选”按钮，或按Ctrl＋A组合键。</td>
</tr>
<tr>
<td>不相邻的单元格或单元格区域</td>
<td>先选定第一个单元格或单元格区域，然后按住Ctrl键再选定其他的单元格或单元格区域。</td>
</tr>
<tr>
<td>整行</td>
<td>单击行号。</td>
</tr>
<tr>
<td>整列</td>
<td>单击列标。</td>
</tr>
<tr>
<td>连续的行或列</td>
<td>先选定第一行或第一列，然后按住Shift键再选定最后一行或最后一列。</td>
</tr>
<tr>
<td>不连续和行或列</td>
<td>先选定第一行，然后按住Ctrl键再选定其他的行或列。</td>
</tr>
</tbody></table>
<h3 id="4、5-文本型数据"><a href="#4、5-文本型数据" class="headerlink" title="4、5 文本型数据"></a>4、5 文本型数据</h3><p>数字作为文本输入时，应在数字前加一个“ ’ ”。文本型数据默认<strong>靠左对齐</strong>。</p>
<h3 id="4、6-数值型数据"><a href="#4、6-数值型数据" class="headerlink" title="4、6 数值型数据"></a>4、6 数值型数据</h3><p>输入分数时，先输入0和一个空格，再输入分数。数值型数据默认<strong>靠右对齐</strong>。</p>
<h3 id="4、7-数据有效性"><a href="#4、7-数据有效性" class="headerlink" title="4、7 数据有效性"></a>4、7 数据有效性</h3><p>设置数据有效性的操作为：选中单元格,执行“数据”→“数据工具”→“数据有效性”命令，可以在弹出的对话框中设置数据的有效性条件，设置完成后，单击“确定”按钮。设置数据有效性可以防止用户输入无效数据。</p>
<h3 id="4、8-选择性粘贴"><a href="#4、8-选择性粘贴" class="headerlink" title="4、8 选择性粘贴"></a>4、8 选择性粘贴</h3><p>选择性粘贴可以复制单元格的部分特性，具体操作为：先复制单元格或单元格区域，再选择目标区域中的第一个单元格,在“开始”选项卡的“剪贴板”组中，单击“粘贴”按钮的下拉箭头，在下拉列表中选择“选择性粘贴”命令，在对话框中选择相应选项后，单击“确定”按钮即可完成选择性粘贴。</p>
<h3 id="4、9-自动填充"><a href="#4、9-自动填充" class="headerlink" title="4、9 自动填充"></a>4、9 自动填充</h3><p>初值为纯数据：拖动填充柄进行复制填充，按住Ctrl键并拖动填充柄填充自动增1或减1的序列。</p>
<p>初值为文字＋数据：拖动填充柄填充时，文字不变，数字递增或递减；按住Ctrl键并拖动填充柄，进行的是复制填充。</p>
<h3 id="4、10-算术运算符"><a href="#4、10-算术运算符" class="headerlink" title="4、10 算术运算符"></a>4、10 算术运算符</h3><table>
<thead>
<tr>
<th>+</th>
<th>加法</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>减法</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法</td>
</tr>
<tr>
<td>%</td>
<td>百分数</td>
</tr>
<tr>
<td>^</td>
<td>乘方</td>
</tr>
</tbody></table>
<h3 id="4、11-比较运算符"><a href="#4、11-比较运算符" class="headerlink" title="4、11 比较运算符"></a>4、11 比较运算符</h3><table>
<thead>
<tr>
<th>&#x3D;</th>
<th>等于</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
</tbody></table>
<h3 id="4、12-文本连接符"><a href="#4、12-文本连接符" class="headerlink" title="4、12 文本连接符"></a>4、12 文本连接符</h3><p>文本连接符&amp;用来合并文本串。</p>
<h3 id="4、13-引用运算符"><a href="#4、13-引用运算符" class="headerlink" title="4、13 引用运算符"></a>4、13 引用运算符</h3><p>1、“:”(冒号)运算符用于定义一个连续的数据区域。<br>2、“,”(逗号)运算符用于将多个单元格或区域合并成一个引用。</p>
<p>3、“ ”(空格)运算符表示只处理区域中相互重叠的部分。</p>
<h3 id="4、14-相对引用、绝对引用和混合引用"><a href="#4、14-相对引用、绝对引用和混合引用" class="headerlink" title="4、14 相对引用、绝对引用和混合引用"></a>4、14 相对引用、绝对引用和混合引用</h3><p>1、相对引用：相对引用是指公式或函数复制或填充到其他单元格后，所引用的单元格会随着新公式所在的位置相应地发生变化。<br>2、绝对引用：行号和列标前都加“$”为绝对引用，绝对引用是指单元格中的公式复制或填充到其他单元格后，公式中引用的单元格固定不变。<br>3、混合引用：混合引用中的单元格地址中一部分是相对引用，另一部分是绝对引用。</p>
<h3 id="4、15-三维地址引用"><a href="#4、15-三维地址引用" class="headerlink" title="4、15  三维地址引用"></a>4、15  三维地址引用</h3><p>引用同一工作簿不同工作表中的单元格的格式为：工作表名!＋单元格引用。</p>
<p>引用不同工作簿中的单元格的格式为：[工作簿名]十工作表名!＋单元格引用。</p>
<h3 id="4、16-函数"><a href="#4、16-函数" class="headerlink" title="4、16 函数"></a>4、16 函数</h3><p>1、SUM函数<br>语法格式：SUM(numberl , number2 ,…)<br>功能：计算一组数值 numberl , number2,…的总和。</p>
<p>2、AVERAGE函数<br>语法格式：AVERAGE(numberl ,number2,…)</p>
<p>功能：计算. numberl , number2、…的平均值。</p>
<p>3、乘积函数PRODUCT<br>语法格式：PRODUCT(numberl,number2 ,…)</p>
<p>功能：计算一组数值number l , number2…的乘积。</p>
<p>4、COUNT函数<br>语法格式：COUNT(valuel ,value2,…)<br>功能：计算区域中数值为数字的单元格个数。</p>
<p>5、排位函数RANK<br>语法格式：RANK(number,ref,order)<br>功能：返回单元格number在一个垂直区域ref中的排名。</p>
<p>6、IF函数<br>语法格式：IF(logical_test,[value_if_true],[value_if_false])<br>功能：如果指定条件的计算结果为True，则IF函数将返回[value_if_true]；如果该条件的计算结果为False，则返回[value_if_false]。<br>7、MAX，MIN函数<br>语法格式：MAX&#x2F;MIN(numberl ,number2,…)<br>功能:：MAX，MIN分别用来求解数据集的极值(即最大值、最小值)。</p>
<p>8、ROUND函数<br>语法格式：ROUND(number,num_digits)<br>功能：ROUND函数返回按指定位数进行四舍五入的数值。</p>
<h3 id="4、17-数据清单"><a href="#4、17-数据清单" class="headerlink" title="4、17 数据清单"></a>4、17 数据清单</h3><p>在Excel 2010中，数据清单是由工作表单元格构成的矩形数据区域，包含相关数据的一系列工作表数据行，与二维数据表相似，单独一行称为一条记录，单独一列称为一个字段，列标题称为字段名。</p>
<h3 id="4、18-排序"><a href="#4、18-排序" class="headerlink" title="4、18 排序"></a>4、18 排序</h3><p>如果要对数据清单的多列进行排序，操作方法是：在需排序的数据清单中选择任一单元格，然后在“数据”选项卡中的“排序和筛选”组中选择“排序”命令，会弹出“排序”对话框。在“主要关键字”中选择字段名，“排序依据”选择“数值””单元格颜色”等排序依据，在“次序”中选择“升序”或“降序”。若想进行更加复杂的排序，可以单击“添加条件”按钮，增加“次要关键字”。Excel 2010最多可以添加64个条件。</p>
<h3 id="4、19-筛选"><a href="#4、19-筛选" class="headerlink" title="4、19 筛选"></a>4、19 筛选</h3><p>1、自动筛选<br>操作步骤为：选定数据清单中的任一单元格，执行“数据”→“排序和筛选”→“筛选”命令，数据清单中的每个字段名右侧会显示一个向下的三角箭头，单击字段名旁边的筛选器箭头，弹出下拉列表，可以按“升序”“降序”“按颜色排序”进行排序，在下拉列表中选择“数字筛选”，可以选择“等于”“不等于”“大于”“小于”“介于”等条件，还可以自动筛选前n项。</p>
<p>2、高级筛选<br>要进行高级筛选需要建立筛选条件区域，该区域用来指定筛选出的数据必须要满足的条件。筛选条件区域由两部分组成：条件的列标题和具体的筛选条件，条件区域中，若条件是“与”关系则将条件放在同一行，若是“或”关系则将条件放在不同行。</p>
<h3 id="4、20-分类汇总"><a href="#4、20-分类汇总" class="headerlink" title="4、20 分类汇总"></a>4、20 分类汇总</h3><p>分类汇总指的是对数据清单某个字段中的数据进行分类，并对各类数据进行各种统计计算，如求和、计数、求平均值和最大值等。在进行分类汇总之前，需要对分类的数据项进行排序。<br>具体操作为:</p>
<p>(1)首先对分类汇总的字段进行排序，选中需要排序的字段中的任一单元格，执行“数据”→“排序和筛选”命令，然后选择“升序”或“降序”命令。<br>⑵执行“数据”“分级显示”“分类汇总”命令，打开“分类汇总”对话框。</p>
<p>(3)在“分类字段”中选择字段名。<br>(4)在“汇总方式”中选择求和、计数、平均值、最大值等汇总方式。<br>(5)选定“选定汇总项”，单击“确定”按钮关闭对话框，即完成分类汇总。</p>
<h3 id="4、21-图表"><a href="#4、21-图表" class="headerlink" title="4、21 图表"></a>4、21 图表</h3><p>按照图表的存放位置，Excel 2010中的图表分两种，一种是嵌入式图表，它和创建图表的数据源放置在同一张工作表中，打印时同时打印；另一种是独立图表，它是一个独立的图表工作表，打印时将与数据表分开打印。<br>建立图表的操作为：将活动单元格置于创建图表的数据清单内，或选中要创建图表的单元格区域。单击“插入”选项卡中“图表”组右下角的对话框启动按钮，会弹出“插入图表”对话框，然后在对话框中选择要创建图表的类型及子类型，单击“确定”,即可创建一个图表。<br>工作表中的数据发生变化时，图表中对应项的数据系列自动变化。</p>
<h2 id="ppt-2010"><a href="#ppt-2010" class="headerlink" title="ppt 2010"></a>ppt 2010</h2><h3 id="5、1-PowerPoint-2010文件格式"><a href="#5、1-PowerPoint-2010文件格式" class="headerlink" title="5、1 PowerPoint 2010文件格式"></a>5、1 PowerPoint 2010文件格式</h3><p>PowerPoint 2010演示文稿的默认扩展名为.pptx，除此之外，还可以另存为以下格式：</p>
<p>1、PowerPoint模板文件：.potx。<br>2、PowerPoint放映文件：.ppsx。<br>3、启用宏的 PowerPoint演示文稿：.pptm。</p>
<p>4、PDF文档：.pdf。<br>5、另存为视频的演示文稿：.wmv。<br>6、另存为图片的演示文稿：.gif、.jpg、. png 等。</p>
<h3 id="5、2-PowerPoint-2010的视图方式"><a href="#5、2-PowerPoint-2010的视图方式" class="headerlink" title="5、2 PowerPoint 2010的视图方式"></a>5、2 PowerPoint 2010的视图方式</h3><p>1、普通视图：主要的编辑视图，可用于撰写或设计演示文稿。<br>2、幻灯片浏览视图：在该视图下可以同时看到演示文稿的多幅幻灯片的缩略图，可以排列、添加、复制或删除幻灯片。<br>3、备注页视图：在该视图下可以很方便地编辑备注文本内容，也可以对文本进行格式设置</p>
<p>4、阅读视图：阅读视图可以用来在幻灯片制作完成后进行简单放映浏览。按Esc键可以退出阅读视图。<br>5、幻灯片放映视图：在该视图下,用户可以看到最终文稿的演示效果，如计时、音频、动画等。</p>
<h3 id="5、3-幻灯片的基本操作"><a href="#5、3-幻灯片的基本操作" class="headerlink" title="5、3 幻灯片的基本操作"></a>5、3 幻灯片的基本操作</h3><table>
<thead>
<tr>
<th>选择</th>
<th>选择所有幻灯片：按Ctrl＋A组合键。 选择多张连续幻灯片：首先单击要选的第一张幻灯片,然后按住Shift键，再单击要选择的最后一张幻灯片。 选择多张不连续的幻灯片：按住Ctrl键,再逐个单击要选择的各个幻灯片。</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>方法一：单击“开始”选项卡→“幻灯片”组→“新建幻灯片”命令。方法二：在普通视图中选择一张幻灯片，按下Enter键，或者按下Ctrl+M组合键。方法三:选择幻灯片后右击,在快捷菜单中选择“新建幻灯片”命令。</td>
</tr>
<tr>
<td>移动</td>
<td>方法一：选择幻灯片→选择“开始”选项卡“剪切”命令→移动光标到目标位置→选择“开始”选项卡“粘贴”命令。方法二：选择幻灯片,用鼠标左键拖动幻灯片到目标位置释放鼠标。</td>
</tr>
<tr>
<td>隐藏</td>
<td>方法一:选择幻灯片,单击“幻灯片放映”选项卡“设置”组中的“隐藏幻灯片”命令。方法二:右击幻灯片的缩略图,在快捷菜单中选择“隐藏幻灯片”命令。</td>
</tr>
<tr>
<td>设置节</td>
<td>单击“开始”选项卡→“幻灯片”组→“节”按钮→“新增节”命令。</td>
</tr>
</tbody></table>
<h3 id="5、4-幻灯片内容的编辑"><a href="#5、4-幻灯片内容的编辑" class="headerlink" title="5、4 幻灯片内容的编辑"></a>5、4 幻灯片内容的编辑</h3><table>
<thead>
<tr>
<th>添加文本框</th>
<th>“插入”选项卡→“文本框”命令。</th>
</tr>
</thead>
<tbody><tr>
<td>添加图形和图像</td>
<td>“插入”选项卡→“图片””剪贴画”等命令。</td>
</tr>
<tr>
<td>添加表格和图表</td>
<td>“插入”选项卡→“表格”或“图表”命令。</td>
</tr>
<tr>
<td>添加音频</td>
<td>“插入”选项卡→“媒体”组→“音频”命令。</td>
</tr>
<tr>
<td>添加视频</td>
<td>“插入”选项卡→“媒体”组→“视频”命令。</td>
</tr>
</tbody></table>
<h3 id="5、5-母版"><a href="#5、5-母版" class="headerlink" title="5、5 母版"></a>5、5 母版</h3><p>1、幻灯片母版：用于设置幻灯片的标题、正文文字等样式,，包括字体、字号、文字颜色、阴影效果、背景、页眉页脚等内容。<br>2、讲义母版：讲义母版具有更改打印之前的页面设置，改变幻灯片方向，设置页眉、页脚、日期和页码，编辑主题和设置背景样式等功能。<br>3、备注母版：提供演讲者备注所使用的空间以及设置备注幻灯片的格式。</p>
<h3 id="5、6-幻灯片主题"><a href="#5、6-幻灯片主题" class="headerlink" title="5、6 幻灯片主题"></a>5、6 幻灯片主题</h3><p>1、定义：主题是演示文稿的颜色搭配、字体格式化以及一些特效命令的集合。<br>2、基本操作：打开需要操作的演示文稿，选择“设计”选项卡中的“主题”命令，可以设置幻灯片主题。</p>
<h3 id="5、7-幻灯片版式"><a href="#5、7-幻灯片版式" class="headerlink" title="5、7 幻灯片版式"></a>5、7 幻灯片版式</h3><p>l、定义：指幻灯片中各元素排版的方式，通过版式的设置可以对文字，图片、图表等进行更加简洁合理的布局。<br>2、基本操作：选择“开始”选项卡→“幻灯片”组→“版式”命令。</p>
<h3 id="5、8-幻灯片背景"><a href="#5、8-幻灯片背景" class="headerlink" title="5、8 幻灯片背景"></a>5、8 幻灯片背景</h3><p>基本操作：选择“设计”选项卡中的“背景样式”命令，在对话框中选择需要的背景样式。</p>
<h3 id="5、9-动画"><a href="#5、9-动画" class="headerlink" title="5、9 动画"></a>5、9 动画</h3><p>基本操作：选中要添加动画的对象，选择“动画”选项卡，在“动画”组中选择合适的动画单击即可。</p>
<p>利用“动画”选项卡的“高级动画”组中的“添加动画”按钮，可以为一个对象添加多个动画。</p>
<h3 id="5、10-超链接"><a href="#5、10-超链接" class="headerlink" title="5、10 超链接"></a>5、10 超链接</h3><p>1、定义：是指向特定位置或文件的一种链接方式。超链接只有在幻灯片放映时才有效。</p>
<p>2、基本操作：选中需要建立超链接的对象、选择“插入”选项卡中的“超链接”命令。</p>
<h3 id="5、11-动作按钮"><a href="#5、11-动作按钮" class="headerlink" title="5、11 动作按钮"></a>5、11 动作按钮</h3><p>1、定义：是PowerPoint中预先设置好的一组带有特定动作的图形按钮，可以实现在放映幻灯片时的跳转。<br>2、基本操作：选择“插入”选项卡→“链接”组→“动作”命令。</p>
<h3 id="5、12-排练计时"><a href="#5、12-排练计时" class="headerlink" title="5、12 排练计时"></a>5、12 排练计时</h3><p>1、定义：在演示文稿放映之前，演讲者可以利用PowerPoint的排练计时功能对演示文稿的放映时间进行排练，可以实现演示文稿的自动放映。<br>2、基本操作：选择“幻灯片放映”选项卡→“设置”组→“排练计时”命令。</p>
<h3 id="5、13-自定义放映"><a href="#5、13-自定义放映" class="headerlink" title="5、13 自定义放映"></a>5、13 自定义放映</h3><p>1、定义：指用户可以自定义演示文稿放映的顺序和内容，以便给特定的观众放映演示文稿中特定的部分。<br>2、基本操作：选择“幻灯片放映”选项卡→“开始放映幻灯片”组→“自定义幻灯片放映”命令。</p>
<h3 id="5、14-放映演示文稿"><a href="#5、14-放映演示文稿" class="headerlink" title="5、14 放映演示文稿"></a>5、14 放映演示文稿</h3><table>
<thead>
<tr>
<th>放映下一张</th>
<th>单击鼠标&#x2F;按下Space键&#x2F;按→键&#x2F;按 PgDn键等</th>
</tr>
</thead>
<tbody><tr>
<td>放映上一张</td>
<td>按键&#x2F;按PgUp键等。</td>
</tr>
<tr>
<td>结束放映</td>
<td>按Esc键。</td>
</tr>
</tbody></table>
<h3 id="5、15-打印演示文稿"><a href="#5、15-打印演示文稿" class="headerlink" title="5、15 打印演示文稿"></a>5、15 打印演示文稿</h3><p>基本操作：“文件”选项卡→单击“打印”命令→对打印选项进行设置。</p>
<h3 id="5、16-演示文稿打包"><a href="#5、16-演示文稿打包" class="headerlink" title="5、16 演示文稿打包"></a>5、16 演示文稿打包</h3><p>1、定义：将共同使用的单个或多个文件集成在一起，生成一种不依赖于运行环境的文件。可以实现将演示文稿转移到其他计算机上或没有安装 PowerPoint 2010应用程序的计算机上进行演示。<br>2、基本操作：选择“文件”选项卡→“保存并发送”选项→“将演示文稿打包成CD”命令。</p>
<h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><h3 id="6、1-计算机网络的组成"><a href="#6、1-计算机网络的组成" class="headerlink" title="6、1 计算机网络的组成"></a>6、1 计算机网络的组成</h3><p>1、一般由网络硬件和网络软件两部分组成。<br>2、按照计算机网络的逻辑功能可分为“资源子网”和“通信子网”两大部分。</p>
<h3 id="6、2-计算机网络的功能"><a href="#6、2-计算机网络的功能" class="headerlink" title="6、2 计算机网络的功能"></a>6、2 计算机网络的功能</h3><p>1、数据传输<br>2、资源共享<br>3、提高处理能力的可靠性和可用性</p>
<p>4、分布式处理</p>
<h3 id="6、3-计算机网络的分类"><a href="#6、3-计算机网络的分类" class="headerlink" title="6、3 计算机网络的分类"></a>6、3 计算机网络的分类</h3><p>1、按网络的覆盖范围划分：局域网(LAN)、城域网(MAN)、广域网(WAN)。</p>
<p>2、按网络的拓扑结构划分：总线型、环形、星型、树形、网状等。<br>3、按传输介质划分：有线网和无线网。</p>
<p>4、按网络的使用性质划分：公用网和专用网。</p>
<h3 id="6、4-OSI-x2F-ISO参考模型与TCP-x2F-IP参考模型"><a href="#6、4-OSI-x2F-ISO参考模型与TCP-x2F-IP参考模型" class="headerlink" title="6、4 OSI&#x2F;ISO参考模型与TCP&#x2F;IP参考模型"></a>6、4 OSI&#x2F;ISO参考模型与TCP&#x2F;IP参考模型</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220420163927810.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220420163927810.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220420163927810"></p>
<h3 id="6、5-局域网的网络硬件"><a href="#6、5-局域网的网络硬件" class="headerlink" title="6、5 局域网的网络硬件"></a>6、5 局域网的网络硬件</h3><p>1、主体设备：服务器(中心站)和客户(工作站)两类。</p>
<p>工作方式:<br>1、客户机&#x2F;服务器模式，简称C&#x2F;S模式，用户通过客户端软件可以向服务器请求提供各种服务。<br>2、浏览器&#x2F;服务器模式，简称B&#x2F;S模式，不需要安装客户端软件，只需要客户端有浏览器软件就可以完成大部分工作任务。<br>2、网络的连接设备<br>1、网卡：提供固定的网络地址。<br>2、调制解调器：是电话拨号上网的必要硬件设备。</p>
<p>3、中继器：放大电信号。<br>4、网桥：用来连接相互独立的网段从而扩大网络的最大传输距离。</p>
<p>5、集线器：主要提供信号放大和中转的功能。<br>6、路由器：为不同网络的节点之间通信选择一条最佳路径。<br>7、网关：用于连接不同结构体系的网络或进行局域网与主机之间的连接。</p>
<p>8、交换机：主要功能包括物理编址、错误校验、帧序列以及流控制等。</p>
<p>3、网络的传输介质<br>有线传输介质：双绞线、同轴电缆和光纤。<br>无线传输介质：无线电频率通信、红外通信、微波通信、卫星通信。</p>
<h3 id="6、6-局域网的网络软件"><a href="#6、6-局域网的网络软件" class="headerlink" title="6、6 局域网的网络软件"></a>6、6 局域网的网络软件</h3><p>1、网络系统软件：包括网络操作系统，网络协议软件、通信控制软件和网络管理软件等。</p>
<p>2、网络应用软件：为用户提供访问网络的手段、网络服务、资源共享和信息的传输。</p>
<h3 id="6、7-Internet的产生和发展"><a href="#6、7-Internet的产生和发展" class="headerlink" title="6、7  Internet的产生和发展"></a>6、7  Internet的产生和发展</h3><p>1、起源：Internet的前身是美国国防部高级研究计划署(ARPA)资助建成的ARPANET。</p>
<p>2、中国Internet 四大骨干网：中国公用计算机互联网(CHINANET)、中国教育与科研计算机网(CERNET)、中国国家计算机与网络设施网(NCFC，又称中国科技网(CSTNET))，中国国家经济信息通信网(CHINAGBN，又称金桥信息网)。</p>
<h3 id="6、8-IP地址"><a href="#6、8-IP地址" class="headerlink" title="6、8 IP地址"></a>6、8 IP地址</h3><p>1、结构：采用分层结构的方式，长度为4字节(32b),整个地址分为两部分，即网络号和主机号。<br>2、表示方法：采用点分十进制表示方法，即将32位的IP地址中的每8位二进制数用1个等效的十进制数表示，每段所能表示的十进制数最大范围不超过255，并在每个十进制数之间加上一个点。<br>3、分类</p>
<table>
<thead>
<tr>
<th>A类</th>
<th>0~127</th>
<th>2^24 -2</th>
<th>大规模</th>
</tr>
</thead>
<tbody><tr>
<td>B类</td>
<td>128~191</td>
<td>2^16—2</td>
<td>中等规模</td>
</tr>
<tr>
<td>C类</td>
<td>192~223</td>
<td>254</td>
<td>小型网络</td>
</tr>
</tbody></table>
<h3 id="6、9-子网掩码"><a href="#6、9-子网掩码" class="headerlink" title="6、9 子网掩码"></a>6、9 子网掩码</h3><p>1、功能：子网掩码是判断任意两台计算机的IP地址是否属于同一子网的根据。</p>
<p>将两台计算机各自的IP地址与子网掩码进行AND运算后，如果得出的结果是相同的，则说明这两台计算机是处于同一个子网的，可以进行直接通信。<br>2、表示形式：网络位全为“1”，主机位全为“O”。</p>
<p>A类  255.0.0.0<br>B类  255.255.0.0<br>C类  255.255.255,0</p>
<h3 id="6、10-IPv6"><a href="#6、10-IPv6" class="headerlink" title="6、10 IPv6"></a>6、10 IPv6</h3><p>1、定义：现有的互联网是在IPv4协议的基础上运行的，IPv6是下一版本的互联网协议。</p>
<p>2、主要优势：规模更大(IPv6的地址为128位)、速度更快、更安全可信、更及时、更方便、更可管理、更有效。</p>
<h3 id="6、11-域名系统"><a href="#6、11-域名系统" class="headerlink" title="6、11 域名系统"></a>6、11 域名系统</h3><p>1、定义：由于数字形式的IP地址不便于用户记忆和使用，Internet引入了域名系统(DNS)。运行域名服务程序的主机叫作域名服务器。<br>2、域名结构：主机名(节点名).网络名.机构名.顶级域名。<br>3、规则：域名长度不超过255个字符，由字母、数字或下划线组成,以字母开头，以字母或</p>
<p>数字结尾，域名中的英文字母不区分大小写。域名的各部分之间用“.”隔开。<br>4、组织域名</p>
<p>com 商业组织<br>net  网络服务机构<br>edu  教育机构<br>org 非营利性组织<br>gov 政府部门<br>int 国际性组织<br>mil 军事部门</p>
<p>5、常用的国家或地区域名:</p>
<p>cn 中国、ca 加拿大, au 澳大利亚、jp日本、 us美国、 uk英国等。</p>
<h3 id="6、12-Internet的接入方式"><a href="#6、12-Internet的接入方式" class="headerlink" title="6、12 Internet的接入方式"></a>6、12 Internet的接入方式</h3><p>1、PSTN(公用电话交换网)技术</p>
<p>2、ADSL(非对称数字用户环路)技术</p>
<p>3、DDN(数字数据网)技术<br>4、光纤技术<br>5、ISDN(综合业务数字网)技术6.无线技术<br>7、LAN(局域网)技术<br>8、WLAN(无线局域网)技术</p>
<h3 id="6、13-HTMl和URL"><a href="#6、13-HTMl和URL" class="headerlink" title="6、13 HTMl和URL"></a>6、13 HTMl和URL</h3><p>1、超文本标记语言(HTML)：一种专门用于 WWW超文本文件的编程语言，常用htm或html做扩展名。<br>2、统一资源定位器(URL)：格式为:≤通信协议≥:&#x2F;之主机域名或IP地址&gt;&#x2F;≤路径≥&gt;&#x2F;≤文件名&gt;</p>
<h3 id="6、14-电子邮件-E-mail"><a href="#6、14-电子邮件-E-mail" class="headerlink" title="6、14 电子邮件(E- mail)"></a>6、14 电子邮件(E- mail)</h3><p>1、地址格式：≤用户名&gt;@≤电子邮件服务器名&gt;<br>⒉、协议：电子邮件常用的协议是SMTP(简单邮件传输协议)和POP3(邮局协议)。</p>
<h2 id="计算机信息安全"><a href="#计算机信息安全" class="headerlink" title="计算机信息安全"></a>计算机信息安全</h2><h3 id="8、1-信息安全面临的威胁"><a href="#8、1-信息安全面临的威胁" class="headerlink" title="8、1 信息安全面临的威胁"></a>8、1 信息安全面临的威胁</h3><p>1、自然威胁：如自然灾害、恶劣的场地环境、电磁辐射和电磁干扰，网络设备自然老化等，具有不可抗拒性。<br>2、人为威胁：</p>
<p>(1)人为攻击<br>被动攻击：在不干扰网络信息系统正常工作的情况下，进行侦收﹑截获、窃取、破译和业务流量分析及电磁泄漏等。</p>
<p>主动攻击：以各种方式有选择地破坏信息，如修改、删除、伪造、添加、重放、乱序、冒充、制造病毒等。<br>(2)安全缺陷</p>
<p>(3)软件漏洞</p>
<p>(4)结构隐患</p>
<h3 id="8、2-信息安全的关键技术"><a href="#8、2-信息安全的关键技术" class="headerlink" title="8、2 信息安全的关键技术"></a>8、2 信息安全的关键技术</h3><p>1、数据加密技术</p>
<p>“对称式”加密法：常用的有DES、3DES、IDEA,RC2,RC4,SKIPJACK,RC5、AES等。</p>
<p>“非对称式”加密法：常用的有:RSA、ECC(移动设备用)、Diffie-Hellman、 ElGamal,DSA(数字签名用)。<br>2、数字证书技术</p>
<p>3、身份认证技术<br>4、虚拟专用网(VPN)技术</p>
<p>5、防火墙技术</p>
<h3 id="8、3-设置口令的规则"><a href="#8、3-设置口令的规则" class="headerlink" title="8、3 设置口令的规则"></a>8、3 设置口令的规则</h3><p>1、最好的口令是八位以上的英文字母和数字的组合。</p>
<p>2、用户若访问多个系统，则不要使用相同的口令。<br>3、避免使用自己不容易记的口令，以免给自己带来麻烦。</p>
<h3 id="8、4-防火墙技术"><a href="#8、4-防火墙技术" class="headerlink" title="8、4 防火墙技术"></a>8、4 防火墙技术</h3><p>1、定义：一种计算机硬件和软件的组合，它使Internet 与内部网之间建立起一个安全关卡，从而保护内部网络免受非法用户的侵入，是集身份认证、加密、数字签名和内容检查为一体的安全防范措施。<br>2、分类：包过滤防火墙(网络级防火墙)，应用代理防火墙(应用级防火墙)。</p>
<p>3、优点：</p>
<p>能强化安全策略。<br>能有效地记录Internet 上的活动。</p>
<p>限制暴露用户点。<br>是一个安全策略的检查站。<br>4、缺点：</p>
<p>不能防范恶意的知情者。</p>
<p>不能防范不通过它的连接。<br>不能防备全部的威胁。</p>
<p>不能防范病毒。</p>
<h3 id="8、5-计算机病毒的分类"><a href="#8、5-计算机病毒的分类" class="headerlink" title="8、5 计算机病毒的分类"></a>8、5 计算机病毒的分类</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220420164301924.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20220420164301924.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220420164301924"></p>
<h3 id="8、6-计算机病毒的特征"><a href="#8、6-计算机病毒的特征" class="headerlink" title="8、6 计算机病毒的特征"></a>8、6 计算机病毒的特征</h3><p>1、传染性<br>2、破坏性</p>
<p>3、寄生性</p>
<p>4、隐蔽性<br>5、潜伏性与可激活性</p>
<p>6、非授权可执行性</p>
<p>7、针对性</p>
<h3 id="8、7-几种典型计算机病毒"><a href="#8、7-几种典型计算机病毒" class="headerlink" title="8、7 几种典型计算机病毒"></a>8、7 几种典型计算机病毒</h3><p>1、CIH病毒<br>2、特洛伊木马</p>
<p>3、蠕虫病毒</p>
<p>4、宏病毒</p>
<h3 id="8、8-计算机病毒的传播途径"><a href="#8、8-计算机病毒的传播途径" class="headerlink" title="8、8 计算机病毒的传播途径"></a>8、8 计算机病毒的传播途径</h3><p>1、通过计算机网络进行传播。<br>2、通过不可移动的计算机硬件设备进行传播。<br>3、通过移动存储设备进行传播。<br>4、通过点对点通信系统和无线通道进行传播。</p>
<h3 id="8、9-病毒的预防"><a href="#8、9-病毒的预防" class="headerlink" title="8、9 病毒的预防"></a>8、9 病毒的预防</h3><p>1、谨慎地使用公用软件或硬件。<br>2、任何新使用的软件或硬件(如磁盘)必须先检查。</p>
<p>3、定期检测计算机上的磁盘和文件并及时消除病毒。</p>
<p>4、对系统中的数据和文件要定期进行备份。<br>5、对所有系统盘和文件等关键数据要进行写保护。</p>
<h3 id="8、10计算机犯罪特点"><a href="#8、10计算机犯罪特点" class="headerlink" title="8、10计算机犯罪特点"></a>8、10计算机犯罪特点</h3><p>1、智能性<br>2、隐藏性<br>3、危害性<br>4、广域性<br>5、诉讼的困难性</p>
<p>6、司法的滞后性</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>计算机算术</title>
    <url>//post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF.html</url>
    <content><![CDATA[<h1 id="计算机算术"><a href="#计算机算术" class="headerlink" title="计算机算术"></a>计算机算术</h1><h2 id="数据是什么"><a href="#数据是什么" class="headerlink" title="数据是什么"></a>数据是什么</h2><p>各种各样的信息，数字、文本、程序、音乐、符号等。信息可以是能够被计算机存储和处理的任何事物。</p>
<h3 id="位和字节"><a href="#位和字节" class="headerlink" title="位和字节"></a>位和字节</h3><p>计算机存储和处理信息的最小单位是位（bit），一个比特表示0或1。</p>
<p>数字计算机将信息以一组或一串比特成为字保存在存储器中。</p>
<p>计算机通过高低电压来存储0或1。</p>
<p>计算机对一组二进制位进行操作，8个二进制位为一个字节（byte），一些计算机制造商用术语“字”表示16位的值，长字表示32位的值，还有一些制造商用字表示32位的值，用半字表示16位的值。</p>
<h3 id="位模式"><a href="#位模式" class="headerlink" title="位模式"></a>位模式</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027123753837.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027123753837.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="位树——（计算机组成原理）"></p>
<p>每当数字增加1位，路径的总数将翻一倍。一个n位的字将得到2n条不同路径或位模式。如，一个8位的字节将得到2<sub>8</sub>&#x3D;256个可能的值。</p>
<p>为了用二进制数表示任何一个拥有最多n个值的量，应找到一个使不等式n&lt;&#x3D;2<sub>m</sub>成立的最小位数m。</p>
<h3 id="信息表示"><a href="#信息表示" class="headerlink" title="信息表示"></a>信息表示</h3><p>一个n位的二进制什么也表示不了。因为一个由二进制1和0组成的串没有任何内在含义。需要程序员赋予它何种含义。</p>
<p>一个二进制串可以表示的对象有：</p>
<p>指令</p>
<p>字长为32位或更长的计算机用一个字来表示CPU能够完成的操作（8位或16位计算机用多个字表示一条指令）。指令的二进制编码与其功能之间的关系由计算机设计者决定。如，一台计算机上表示“A加B”的二进制序列可能与另一台计算机上的完全不同。</p>
<p>数量</p>
<p>一个字或多个字都可以用来表示数量。数可以被表示为多种格式，如有符号、无符号二进制整数、二进制浮点数、整数复数等等。</p>
<p>字符</p>
<p>字符是一个叫作“字母表”的集合中元素。拉丁或罗马字母表中的字母、数字字符（A-Z，a-z，0-9）和*、-、+、？等符号都被分配了二进制值，因此可以在计算机内存储和处理。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027124028066.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027124028066.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="ASCII码表—（计算机组成原理）"></p>
<p>ASCII码表用7位表示一个字符，一共可以表示27&#x3D;128个不同的字符。其中96个字符是可打印字符。其余32个是不可打印字符，用于完成回车、退格、换行等特殊功能。</p>
<p>扩展的ASCII码表：8位的ISO 8859-1拉丁编码。将7位的ISO&#x2F;ASCII字符集扩展为8位，可以得到两个128个字符的字符集，如果字符的最高位为0,则其余7位代表128个标准ISO&#x2F;ASCII字符中的一个，如果字符最高位为1，其余7位将表示128个新字符中的任意一个。</p>
<p>图像、声音和视觉</p>
<p>数字计算机处理大量表示声音、静态图像和视频的数据。</p>
<p>组成照片的基本单位是像素，每个像素的大小可以是8位（单色）或24位（三基）。</p>
<p>视频作为一串静态图像依次传输，每秒发送60次。</p>
<p>声音通过对波形信号采样。</p>
<p>无损压缩和有损压缩。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>用来计数的数字（即1,2,3,4…）被称作自然数。我们用十进制计数，因为它有0~9共10个符号。并非所有数字都是自然数，还有负数、实数等</p>
<p>现代数字系统中，使用位置记数法表示十进制数，每个数位的值或权取决于它在数字中的位置。</p>
<p>按照位置记数法，一个n位的整数N的形式表示：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027124225524.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027124225524.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="n位整数-（位置计数法）"></p>
<p>用小数点将整数部分和小数部分分开，可以对位置记数法进行扩展，使其能表示实数。</p>
<p>一个用基数b的位置记数法表示的数的值被定义为：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027124340942.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027124340942.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="基数为b的位置计数法"></p>
<p>采用位置记数法，一个数的数值等于它各位值的总和，而每一位的值则是该位的数值乘以它在数中的位置所对应的权。</p>
<p>如：</p>
<p>十进制数1982 &#x3D; 1 x 10<sub>3</sub> + 9 x 10<sub>2</sub> + 8 x 10<sub>1</sub> + 2 x 10<sub>0</sub></p>
<p>二进制数10110.11 &#x3D; 1x2<sub>4</sub> + 0x2<sub>3</sub> + 1x2<sub>2</sub> + 1x2<sub>1</sub> + 0x2<sub>0</sub> + 1x2<sub>-1</sub> + 1x2<sub>-2</sub> </p>
<p>十进制位置记数法不能精确表示所有小数，如1&#x2F;3是0.3333333…33，二进制也是如此，如0.1<sup>10</sup> 不能被精确转换为二进制形式。</p>
<h2 id="二进制运算"><a href="#二进制运算" class="headerlink" title="二进制运算"></a>二进制运算</h2><p>二进制算术运算规则与十进制基本相同，区别是基数不同。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027135114120.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027135114120.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="二进制的四则运算规则"></p>
<p>两个位相加可能产生进位或借位，和十进制运算规则相同。</p>
<p>下面描述了011010012（乘数）与010010012（被乘数）相乘的过程，两个n位字相乘将产生一个2n位的积：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027141254062.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027141254062.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="两个二进制数相乘"></p>
<p>但是计算机并没有按照这种方式进行计算。</p>
<h3 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h3><p>负数可以用多种不同的方式表示，计算机设计者选择了3种方法：符号及值表示法、二进制补码表示法、移码表示法，每种方法都有各自的优缺点。</p>
<h4 id="符号及值表示法"><a href="#符号及值表示法" class="headerlink" title="符号及值表示法"></a>符号及值表示法</h4><p>一个n位字可以表示从0~2<sub>n-1</sub>共2<sub>n</sub>个可能的值。如，一个8位的字可以表示0,1，…，254,255。表示负数的方法是用它的最高位表示符号，通常符号位为0表示正数，符号位为1表示负数。</p>
<p>下面两个8位有符号二进制00001101和10001101的值为：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027141520250.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027141520250.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="有符号二进制数字"></p>
<p>n位有符号的表示范围为-(2<sub>n-1</sub>-1) ~ +(2<sub>n-1</sub>-1)。一个8位有符号数的表示-127（11111111）~ +127（01111111）之间的整数。</p>
<p>有人反对该系统的一个原因是它有两个值都表示0：</p>
<p>00000000 &#x3D; +0 和 10000000 &#x3D; -0</p>
<p>符号及值表示法没有被用于整数算术运算中，因为它的加、减法运行需要分别用加法器和减法器实现。符号及值表示法用于浮点算术运算中。</p>
<h4 id="二进制补码运算"><a href="#二进制补码运算" class="headerlink" title="二进制补码运算"></a>二进制补码运算</h4><p>微处理器用二进制补码系统表示有符号整数，它可以将减法运算转换为对减数的补码的加法运算。</p>
<p>一个数与它的补码之和是一个常数。如，一个一位十进制数与它的补码之和总是9。2的补码是7，因为2+7&#x3D;9。在n位二进制算术中，数P的补码为Q且P+Q&#x3D;2<sub>n</sub>。</p>
<p>在二进制算术中，求一个数的补码的方法是将其各位取反并加1。</p>
<p>如：01100101的补码为10011010+1&#x3D;10011011。</p>
<p>一个n位二进制数N的二进制补码定义为2<sub>n</sub>-N。如果N&#x3D;5&#x3D;00000101（8位二进制数），则N的补码为2<sub>8</sub>-00000101&#x3D;100000000-00000101&#x3D;11111011</p>
<p>下面说明了8位二进制数的补码运算过程，将4个数+5、-5、+7、-7转换为补码：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027143701913.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027143701913.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="补码"></p>
<p>将7与5的补码相加：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027143728851.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027143728851.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="补码相加"></p>
<p>结果为9位二进制数100000010。如果忽略最左边一位（进位位），结果为00000010<sup>2</sup>&#x3D;+2，正是希望得到的结果。</p>
<p>将-7加5：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027144848474.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027144848474.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="补码相加"></p>
<p>结果为11111110（进位位为0）。也是希望得到的结果-2，即2<sub>8</sub>-2&#x3D;100000000-00000010&#x3D;11111110</p>
<p>n位二进制算术运算Z&#x3D;X-Y，用X加上Y的补码完成运算：Y的补码为2<sub>n</sub>-Y，则Z&#x3D;X+(2<sub>n</sub>-Y)&#x3D;2<sub>n</sub>+(X-Y)。我们得到了需要的结果，X-Y，以及位于最左边的一个并不需要的进位（即2<sub>n</sub>），而这个进位被丢弃了。</p>
<p>一个数两次求补码得到该数本身。如-5&#x3D;28-00000101&#x3D;11111011。</p>
<p>即-x&#x3D;2<sub>n</sub>-x且-(-x)&#x3D;2<sub>n</sub>-(2<sub>n</sub>-x)&#x3D;x。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027145204303.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027145204303.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="加法实例"></p>
<h4 id="求补运算"><a href="#求补运算" class="headerlink" title="求补运算"></a>求补运算</h4><p>一个n位的二进制数N的补码，被定义为2<sub>n</sub>-N，则</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027194431138.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027194431138.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="补码"></p>
<p>如，8位（n&#x3D;8）时有：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027194510320.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027194510320.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="n=8时"></p>
<p>表达式11111111-N的值很容易计算，对N的第i位n<sup>i</sup>，若n<sup>i</sup>&#x3D;0，则1-0&#x3D;1，若n<sup>i</sup>&#x3D;1，则1-1&#x3D;0。显然：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027194555178.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027194555178.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>所以计算N的补码就是将N的每一位取反加1。</p>
<p>之所以使用这种求补码的方式，是因为在硬件上它十分容易实现。</p>
<h4 id="补码的特点"><a href="#补码的特点" class="headerlink" title="补码的特点"></a>补码的特点</h4><p>补码互补因为X+-X &#x3D; 0</p>
<p>补码被表示为000….000，是唯一的</p>
<p>补码的最高位为符号位，符号位为0，则该数为正，符号位为1，该数位负。</p>
<p>n位二进制位的补码表示范围为-2<sub>n</sub>-1—2<sub>n</sub>+1，对于8位，是-127-128。</p>
<p>补码的加减法使用同样的硬件完成，因为补码的减法由被减数的补码实现。</p>
<h4 id="运算溢出"><a href="#运算溢出" class="headerlink" title="运算溢出"></a>运算溢出</h4><p>溢出的问题，主要是补码表示范围的限制。如果两个数运算后结果的值不在范围内，那么就会溢出，并且如果操作数的两个符号位相同，但是结果的符号位与他们不同，同样也会发生溢出。</p>
<h3 id="乘除法"><a href="#乘除法" class="headerlink" title="乘除法"></a>乘除法</h3><p>计算机必须实现乘除法，但是相对来说，这比加减法要复杂的多。</p>
<h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p>首先是二进制的算术移位运算，进行移位运算时，一个数的所有位都会向左或者向右移动n位，有些计算机可以一次移动多个位。</p>
<p><strong>二进制补码正数左移移位等于乘2。（正数的补码原码反码一致）</strong></p>
<p>算术左移：最低位补0，最高位被复制到进位标志中，如11000101左移一位得到10001010</p>
<p>算术右移：最高位补符号位，所有位右移一位。最低位复制到进位标志中。如00100101右移一位得到00010010。11100101右移一位得到11110010。</p>
<p><strong>二进制右移一位相当于除以2。</strong></p>
<h4 id="无符号二进制乘法"><a href="#无符号二进制乘法" class="headerlink" title="无符号二进制乘法"></a>无符号二进制乘法</h4><p>计算机从乘数的最低位开始，每次检查一位，判断它是否为0，如果乘数的当前位为1则写下被乘数，若该位为0则写下n个0。接下来检查乘数的下一位，这时应从上一位数的左边一位开始写下被乘数或0。被写下的这一组数叫作部分积。得到所有的部分积后，加到一起，得到乘法结果：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027200042109.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027200042109.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="无符号二进制乘法"></p>
<p>两个二进制数相乘得到一个2n位的积。</p>
<p>但是计算机并没有实现上面的算法，这种算法要求计算机存储n个部分积，然后将它们同时相加。更好的做法是每得到一个部分积就做一次加法。</p>
<p>下面给出了一个计算两个n位无符号二进制数相乘的算法：</p>
<p>步骤a：将计数器的值置为n</p>
<p>步骤b：将2n位的部分积寄存器清零</p>
<p>步骤c：检查乘数的最右位（即最低位），将被乘数与部分积的最低位n位相加</p>
<p>步骤d：将部分积右移一位</p>
<p>步骤e：将乘数右移一位（乘数的最右位被丢弃）</p>
<p>步骤f：将计数器的值减1，重复步骤c直到n个周期后计数器的值变为0。部分积寄存器的内容就是乘积结果。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027200552235.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027200552235.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="无符号二进制乘法"></p>
<h4 id="快速乘法"><a href="#快速乘法" class="headerlink" title="快速乘法"></a>快速乘法</h4><p>通过移位和加法实现的乘法速度很慢，实际的计算机采用了多种方法加快乘法运算的速度。</p>
<p>有些程序员使用移位和加法等速度相对较快的操作避免使用乘法。</p>
<p>考虑P乘以10和P乘以9的两个例子：</p>
<p> 10P&#x3D; 2x(2x2xP+P) ，即将P左移2次，加上P，再将和左移一次</p>
<p> 9P&#x3D; 2x2x2xP + P，即将P左移3次，加上P得到结果</p>
<p>乘法运算也可以借助查找表（look-up table）实现，这种方法将两个数相乘所有可能的积都保存在一个只读存储器内。这样只需简单的用X和Y的值找到表中的对应项就可以得到X和Y的乘积。如，两个8位二进制乘法需要一个16位地址、2<sub>16</sub>项的查找表，每项记录一个16位的积。</p>
<p>缺点：太占空间了。</p>
<p>可以用一个简单方法来减少查找表的大小：假设计算两个16位数A与B的乘积，可以将16位数A拆分为两个8位数A<sup>u</sup>和A<sup>l</sup>，A<sup>u</sup>是A的高8位，A<sup>l</sup>是A的低8位。如</p>
<p>果A&#x3D;1111000010101010，则A<sup>u</sup>&#x3D;11110000，A<sup>l</sup>&#x3D;10101010。A可被表示为A<sup>u</sup> x 256+A<sup>l</sup>，B可被表示为B<sup>u</sup> x 256+B<sup>l</sup>，则</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027200737262.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027200737262.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221027200737262"></p>
<p>这样可以用8位乘法和4个加法来完成16位乘法。</p>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>除法是通过被除数不断地减去除数直到结果为0或小于除数来实现的。减去除数的次数称作商，最后一次减法的差称作余数。</p>
<p>  被除数&#x2F;除数 &#x3D; 商 + 余数&#x2F;除数</p>
<p>下面描述了575除以25的过程：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201041218.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201041218.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>将被除数的下一个数字5移到7的后面，并比较除数和75，由于75正好是25的整数倍，因此在商的下一位上写下3：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201105004.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201105004.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>因为已经处理到被除数的最后一位且75正好是测试的整数倍。除法结束，商为23，余数为0。</p>
<p>考虑用无符号二进制除法完成同样的例子： </p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201134495.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201134495.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>被除数的前5位比除数小，因此商的最高位为0并将除数与被除数的前6位比较</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201150167.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201150167.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>被除数的前6位中有一个除数，减法后得到新的部分被除数为001010（1111），将被除数的下一位移下来</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201204703.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201204703.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>新的部分被除数小于除数，因此商的下一位为0，后续除法过程如下：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201220956.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201220956.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>除法结果商为10111，余数为0。 </p>
<h4 id="恢复余数除法"><a href="#恢复余数除法" class="headerlink" title="恢复余数除法"></a>恢复余数除法</h4><p>刚刚讨论的除法方法，用计算机实现，需要修改的就是除数与部分被除数的比较方法，计算机减去并检测结果的符号位。如果减法的结果为正，则商1，如果结果为负，则商0并将部分被除数与除数相加，将其恢复为原先的值。</p>
<p>恢复余数除法算法：</p>
<p>1）将除数的最高位与被除数的最高位对齐</p>
<p>2）从部分被除数中减去除数，得到新的部分被除数</p>
<p>3）如果新的部分被除数为负数，则商0并用新的部分被除数加上除数，恢复原先的部分被除数</p>
<p>4）如果新的部分被除数为正，则商1</p>
<p>5）判断除法是否结束，如果除数的最低位与部分被除数的最低位对齐，则除法结束，最后的部分被除数就是余数。否则，执行第6步</p>
<p>6）将除数右移一位，从第2步继续执行 </p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201323182.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201323182.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201333279.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201333279.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="英文版"></p>
<h4 id="不恢复余数除法"><a href="#不恢复余数除法" class="headerlink" title="不恢复余数除法"></a>不恢复余数除法</h4><p>不恢复余数除法与恢复余数除法基本相同，唯一区别在于取消了恢复余数的操作。</p>
<p>在恢复余数除法中，在部分被除数与除数相加恢复部分被除数之后的一个周期，部分被除数将减去除数的二分之一。每个将除数右移的操作等价于将除数除以2。当前周期恢复部分被除数以及下个周期减去除数一半的操作等价于部分被除数加上除数的一半。即D – D&#x2F;2 &#x3D; +D&#x2F;2，D为除数。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201433706.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027201433706.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>部分被除数减去除数之后，将检测新的部分被除数的符号位。若为负，则商左移1位，商的最低位补0，并将部分被除数加上除数的二分之一。若为正，则商左移1位，商的最低位补1，并将部分被除数减去除数的二分之一。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数即实数，实数是所有有理数和无理数的集合。</p>
<p>之所以叫作浮点数，是因为小数点在数中的位置并不是固定的。一个浮点数值分为两部分存储 ：数值以及小数点在数值中的位置。</p>
<p>计算机中的浮点运算的计算结果一般是不确定的，一块芯片上的浮点计算结果也许与另一块芯片上的不同。</p>
<p>科学计数法：来表示很大或很小的数。</p>
<p>十进制浮点数可以被表示为：尾数x10<sub>指数</sub>，如1.2345x10<sub>20</sub></p>
<p>二进制浮点数可以被表示为：尾数x2<sub>指数</sub>，如1.0111x2<sub>5</sub></p>
<p>IEEE 754浮点数标准提供3种浮点数表示：32位单精度浮点数、64位双精度浮点数、128位四精度浮点数</p>
<p>IEEE 754浮点数的尾数总是规格化的，其范围为1.000…0x2<sub>e</sub>到1.111…1x2<sub>e</sub>，e为指数。</p>
<p>规格化浮点数的最高位总是1，规格化使尾数的所有位都是有效的，因而尾数精度最高。</p>
<p>如：</p>
<p> 0.10…x2<sub>e</sub>规格化为1.10…x2<sub>e-1</sub></p>
<p> 10.1…2<sub>e</sub>规格化为1.01…x2<sub>e+1</sub></p>
<p>尾数规格化充分利用了可用的最大精度。如，一个8位非规格化的尾数0.0000101只能有4位有效位，而规格化后的8位尾数1.0100011则有8位有效位。</p>
<p>IEEE 754浮点数的尾数被表示为符号及值的形式，即用一个符号位表示它是正数还是负数。它的指数则用偏置方式表示，即给真正的指数加上一个常数。</p>
<p>假定所用的指数为8位，偏置值为127。如果一个数的指数为0，则被保存为0 + 127&#x3D;127。如果指数为-2，则被保存为-2 + 127 &#x3D; 125。</p>
<p>实数1010.1111规格化的结果为+1.010111x2<sub>3</sub>，指数为+3，将被保存为3+127&#x3D;130，即130<sup>10</sup>用二进制表示为10000010。</p>
<p>这种用偏置表示指数的方法优点在于，最小的负指数被表示为0，如果不采用这种方法，0的浮点表示为0.0…0x2<sub>最小负指数</sub>。采用偏置指数，0就可以用尾数0和指数0表示：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027202017466.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027202017466.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>一个32位IEEE 754单精度浮点数可以被表示为下面的二进制串：</p>
<p>S EEEEEEEE 1.MMMMMMMMMMMMMMMMMMMMMMM</p>
<p>S为符号位，指明这个数是正数还是负数</p>
<p>E为8位偏置指数，指出了小数点的位置</p>
<p>M为23位尾数</p>
<p>下图描述了32位浮点数的结构：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027202054808.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027202054808.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>S位为符号位，决定了数的符号，若S&#x3D;0，则为正数，若S&#x3D;1，则为负数。</p>
<p>指数E将浮点数的尾数扩大或缩小2<sub>E</sub>倍，并且偏置值为127。</p>
<p>如浮点数+1.11001…0x2<sub>12</sub>的指数为12+127&#x3D;139<sub>10</sub>&#x3D;10001011<sub>2</sub> 。</p>
<p> IEEE浮点数的尾数总是规格化的，其值范围在1.0000..00~1.1111..11，除非这个浮点数是0，此时尾数为0.000..00。</p>
<p>由于尾数总是规格化的，且最高位总是为1，因此将尾数存入存储器时没有必要保存最高位的1。所以，一个非0的IEEE 754浮点数可被定义为：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027202333330.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221027202333330.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>S：符号位</p>
<p>E：偏置量为B的指数</p>
<p>F：尾数的小数部分（实际的尾数为1.F，有个隐含的1）</p>
<p>浮点数0被表示为S&#x3D;0，E&#x3D;0，M&#x3D;0（即浮点数0用全0表示）</p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>浮点数不能直接相加。</p>
<p>下面以一个简单的8位尾数和一个未对齐的指数为例说明浮点运算，A&#x3D;1.0101001x2<sub>4</sub>，</p>
<p>B&#x3D;1.1001100x2<sub>3</sub>。若要计算两个数的乘积，应将尾数相乘，指数相加：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221104153155711.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221104153155711.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="浮点数相乘"></p>
<p>由于浮点操作数已被表示为规格化形式，计算机在进行浮点加法时面临以下问题：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221104153842746.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221104153842746.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="浮点数相加"></p>
<p>为了对齐指数，计算机必须执行下面步骤：</p>
<p>第1步，找出指数较小的数</p>
<p>第2步，使两个数的指数相同</p>
<p>第3步，尾数相加（或相减）</p>
<p>第4步，如果有必要，将结果规格化</p>
<p>因为B的指数比A小，将B转为0.110011x2<sub>4</sub>，将A与非规格化的B相加：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221104153956601.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221104153956601.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="浮点数相加"></p>
<p>对结果规格化，得到1.00001111x2<sub>5</sub></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221105132231397.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221105132231397.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="浮点加法运算流程"></p>
<p>注意：</p>
<p>1）因为指数有时与尾数位于同一个字中，在加法过程开始之前必须将它们分离开（减压缩）</p>
<p>2）如果两个指数的差大于p+1，p为尾数的位数，较小的数由于太小而无法影响较大的数，结果实际就等于较大的数。如，1.1010x2<sub>60</sub>+1.01x2<sub>-12</sub>的结果为1.1010x2<sub>60</sub>，因为指数之差为72</p>
<p>3）结果规格化时检查指数范围，以分别检测指数下溢或上溢。指数下溢会导致结果为0，而指数上溢会造成错误。</p>
<p>舍入和截断误差</p>
<p>浮点运算可能引起尾数位数的相加，需要保持尾数位数不变的方法。最简单的技术叫作截断。</p>
<p>如，将0.1101101截断为4位尾数的结果为0.1101。截断会产生诱导误差（即误差是由施加在数上的操作计算所引起的），诱导误差是偏置的，因为截断后的数总比截断前小。</p>
<p>舍入是一种更好的减少数的位数的技术。如果丢弃的位的值大于剩余数最低位的一半，将剩余数的最低位加1。</p>
<p>考虑两个数在小数点后第4位上舍入的例子：</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221105132343588.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221105132343588.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221105132355041.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/image-20221105132355041.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="舍入机制"></p>
<p>1）最简单的舍入机制是截断或向0舍入。</p>
<p>2）“向最近的数舍入”方法会选择距离该数最近的那个浮点数作为结果。</p>
<p>3）“向正或负无穷大舍入”方法会选择正或负无穷大方向上最近的有效浮点数作为结果。</p>
<p>当要舍入的数位于两个连续浮点数的正中时，IEEE舍入机制选择最低位为0的点（即向偶数舍入）。</p>
<p>整数操作时精确、可重复的，浮点数操作是不精确的。</p>
<p>考虑表达式z &#x3D; x<sub>2</sub>-y<sub>2</sub>，x、y、z都是实数。可以将表达式视作x<sub>2</sub>-y<sub>2</sub>或(x+y)(x-y)计算，整数运算得到相同结果，但浮点数运算可能得到不同结果。</p>
<p>IEEE要求加、减、乘和除运算结果能够精确计算，并用向偶数舍入的方法将结</p>
<p>果舍入为最近的浮点数。</p>
]]></content>
  </entry>
  <entry>
    <title>计算机系统-信息的表示与处理</title>
    <url>//post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<h1 id="信息的表示与处理"><a href="#信息的表示与处理" class="headerlink" title="信息的表示与处理"></a>信息的表示与处理</h1><h2 id="信息的表示"><a href="#信息的表示" class="headerlink" title="信息的表示"></a>信息的表示</h2><p>二进制、八进制、十进制、十六进制。基数不同，只重位置，不看具体的值。</p>
<p><strong>字长</strong>（指针的大小）</p>
<p>虚拟地址以此来编码，一般的高位机向后兼容。</p>
<p>计算机与编译器都支持多种的编码</p>
<p>无符号整数与有符号整数的区别在c中，关键字unsigned注明了无符号整数。</p>
<p><strong>寻址与字节顺序</strong></p>
<p>一般的，多字节对象连续存址。</p>
<p>机器之中排列字节地址有差异，有的以最低有效字节在前面——小端法，有的以最高有效字节在前面——大端法。</p>
<p>字符串表示：一般的字符串被编码以null结尾的字符数组，每个字符使用某种编码表示，例如ASCII编码。</p>
<p><strong>布尔代数</strong> 0,1</p>
<p>布尔代数相关运算：与、或、非、异或。</p>
<p>布尔与：同位为1结果即为1，否则为0。</p>
<p>布尔或：同位有1结果即为1，否则为0。</p>
<p>布尔非：1为0，0为1。</p>
<p>布尔异或：同位为1但不同时为1为1，否则为0。</p>
<p>布尔代数—布尔环（w位向量上的与或非运算时的新形式）</p>
<p>位向量还可以用来表示掩码，i位为1时代表有效使能，为0则为无效使能。</p>
<p>C语言很号的支持按位布尔</p>
<p>位级运算实现掩码运算很好，这里的掩码表示一个位模式，表示一个字节中有效的位的集合。</p>
<p><strong>逻辑运算</strong></p>
<p>逻辑或、与、非。</p>
<p>非零的参数表示为TRUE，为0的表示为FALSE。</p>
<p>逻辑运算存在短路特性。</p>
<p><strong>移位运算</strong> 向左或向右移动位模式</p>
<p>x &lt;&lt; k 左移k位，丢弃最高的k位，在右端补齐k个0。</p>
<p>x &gt;&gt; k 右移k位，但是区分逻辑左移与算数左移的区分，对于逻辑右移，在左端补齐k个0，对于算数右移，需要补齐最高有效位，可能是1。</p>
<p>C没有规定有符号数应该使用哪一种右移，但是几乎所有的编译器都对有符号数采用算数右移，对于无符号数，右移必须是逻辑的。</p>
<p>在Java里，&gt;&gt;&gt; 表示逻辑右移，&gt;&gt;表示算数右移。</p>
<p>优先级问题，移位的运算优先级低于加减法。</p>
<p>编码整数的方式又两种，一种只能表示非负数，一种都可以表示。</p>
<p>C中有多种数据类型，都可以表示整数：</p>
<p>CHAR、SHORT、INT、LONG(UNSIGNED)</p>
<p>他们表示的字节大小各不相同，一般的取决于字长，例如在32位机中，long只占4个字节。</p>
<p>无符号编码具有重要意义，因为这是一个双射。</p>
<p>原码、反码、补码</p>
<p>最高位为符号位，0表示正数，1表示负数。</p>
<p>正数的反码是自身，负数的反码是除符号位之外，全部取反。</p>
<p>正数的补码也是自身，负数的补码是反码+1</p>
<h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>补码：反码加一”只是补码所具有的一个性质，不能被定义成补码。负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码。</p>
<p>用补码表示负数，在补码的定义之中，字的有效最高位解释为负权，因此最高位为1时，表示该数为负数。</p>
<p>对于补码而言，这也是一个双射，补码编码同样具有唯一性。</p>
<p>C语言标准之中没有要求使用补码来表示，有符号整数，但是几乎所有的机器都是使用补码的。</p>
<p>除却补码之外，原码与反码也能表示有符号整数。</p>
<p>原码、反码都以最高位为符号位，不同的是，反码符号位取非。</p>
<p>有符号数与无符号数之间转换<br>对C来说，类型的转换从不关心具体的数，对于这个问题，C是从位级角度来考虑的。</p>
<p>一般的，对于强制类型转换，位的值不发生改变，只改变位的位置。</p>
<p><strong>零扩展</strong></p>
<p>从较小的类型转换为较大类型时，在开头扩展0。</p>
<p><strong>位截断</strong></p>
<p>丢弃高位，可能会造成溢出。</p>
<p>有符号数到无符号数的隐式转换，会导致错误或者漏洞，杜绝的方式试试禁用无符号数。</p>
<p>例如：一种类型的表达式被赋值给另外一种类型的变量时，转换就是隐式的。</p>
<p>C语言中同时包含了对有符号和无符号数表达式的处理方式，当同时出现两种数时，C会隐式的强转为无符号数，例如在&lt;,&gt;运算中，结果就会很直观。</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p><strong>无符号加法</strong></p>
<p>考虑两个w位的无符号数相加，他们的和的范围应该在0到w+1位之间。</p>
<p>但是C不允许这样的扩张出现，因此必须使用过位截断，使得他们的和在0到w位之间。截断时，截断高位。</p>
<p>在C中，不会将溢出作为错误而返回信号。</p>
<p>溢出时，不难发现，结果等于两数之和与2</p>
<p>的w次方的模数。</p>
<p><strong>补码加法</strong></p>
<p>对于补码的加法，必须确定当结果太大（为正）或太小（为负）时，应该怎么做。</p>
<p>补码，最高位是符号位，表示负权。因此两个数的范围在-2<sub>w-1</sub>到2<sub>w-1</sub>之间。这意味着，要想表示两个数的和，需要w+1位。（符号位在内）</p>
<p>结果是截断到w位。</p>
<p>值得一提的是，两个数的w位补码之和和无符号数之和有完全相同的位级表示。</p>
<p><strong>无符号乘法</strong></p>
<p>对于两数乘积的取值范围，需要2w位来表示，明显的C语言不可能允许这样的大小扩张，最终结果依旧需要w位，而将无符号数截断为w位等价于计算该值取模2的w次方。</p>
<p><strong>补码乘法</strong></p>
<p>对于补码乘法，C语言的有符号乘法通过截断为w位来实现，将一个补码截断为w位，相当于先计算该值模2的w次方，再把无符号数转换为补码。</p>
<p>一般的，对于无符号和补码乘法来说，乘法运算结果的位级表示都是一样的。</p>
<p>例如：</p>
<p>（101） * （011） &#x3D; （001111） &#x3D; （111）【截断后的】</p>
<p>无符号数表示：5 * 3 &#x3D; 7</p>
<p>（101） * （011） &#x3D; （110111） &#x3D; （111）【截断后的】</p>
<p>补码表示：-1 * 3 &#x3D; -1</p>
<p>虽然完整的乘积的位级的表示可能不同，但是截断后乘积的位级表示是相同的。</p>
<p><strong>乘以常数</strong></p>
<p>因为，在大多数机器上，整数乘法指令相当的慢，需要10个或更多时钟周期，因此编译器进行了一项优化，试着用移位加加法运算的组合来代替乘以常数因子的乘法。</p>
<p>考虑乘以2的幂的情况，再推广至全体常数。</p>
<p>可以发现左移一个数值等价于执行一个与2的幂相乘的无符号乘法。固定大小的补码算数运算的位级操作与其无符号运算等价。</p>
<p>但是无论是无符号还是补码，乘以2的幂都会导致溢出，结果说明，即使溢出，通过移位得到的结果也是一样的。</p>
<p><strong>除以2的幂</strong></p>
<p>在大多数机器上，整数除法比整数乘法更慢，需要30或者更多的时钟周期。</p>
<p>除以2的幂，也可以用移位运算来实现，只不过使用的是右移，无符号数和补码分别使用逻辑移位和算术移位来达到目的。</p>
<p>整数除法总是舍入到0，它将向下舍入到一个正值，向下舍入到一个负值。</p>
<p>对于无符号运算右移很简单，一部分原因是因为无符号的右移一定是逻辑的。</p>
<p>c &gt;&gt; k产生的结果是 c &#x2F; 2的k次方。</p>
<p>对于除以2的幂的补码运算来说，情况稍微要复杂一些，因为要保证负数依然为负，移位要执行的算数移位。</p>
<p>除以2的幂的补码除法，向下舍入<br>变量x和k分别有补码值x和无符号数值k，且0≤k&lt;w，则当执行算术移位时，C表达式x&gt;&gt;k产生数值 x &#x2F;2^k。</p>
<p>对于非负数来说，最高位是0，因此算数右移k位与除以2^k是一样的。</p>
<p>作为负数，如果出现舍入的情况时，移位导致结果向下舍入，此时就需要调整策略。</p>
<p>作为一个负数，算数右移后的位向量刚好就是就w-k位表示的补码数从w-k位符号扩展到w位。通过在移位之前，偏置这个值，来修正不合适的舍入。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152105230.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152105230.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><strong>思考</strong>：</p>
<p>计算机执行的“整数”运算实际上是一种模运算形式。</p>
<p>表示数字的有限字长限制了可能的值的取值范围，结果运算可能溢出。</p>
<p>补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现，这些运算包括像加法、减法、乘法，甚至除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或者非常类似的位级行为。</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点表示对形如</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152237823.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152237823.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>的有理数进行编码。它对执行涉及非常大的数字非常接近于0的数字，以及更普遍地作为实数运算的近似值的计算，是很有用的。</p>
<p>一般的，IEEE浮点标准被几乎所有的计算机支持。</p>
<p><strong>二进制小数</strong></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152418270.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152418270.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><strong>IEEE浮点表示</strong></p>
<p>IEEE浮点标准用</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152529379.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152529379.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>的形式来表示一个数:<br>符号(sign)，s决定这数是负数(s&#x3D;1)还是正数( s&#x3D;0)，而对于数值0的符号位解释作为特殊情况处理。<br>尾数(significand)M是一个二进制小数。</p>
<p>阶码(exponent)E的作用是对浮点数加权，这个权重是2的E次幂(可能是负数)。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152628441.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113152628441.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="标准浮点格式"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113153010332.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113153010332.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><strong>规格化</strong></p>
<p>当exp的位模式不全为0，也不全为1时，都是规格化的。</p>
<p>阶码的值是E &#x3D; e - 偏置值。</p>
<p>e是无符号数，偏置值为2的k-1次方-1，对于单精度是-126到127</p>
<p>小数字段frac被描述为小数值f，f在0到1之间。尾数的定义是M &#x3D; 1+f。这种表示方法，假设没有一处，尾数在1到2之间，那么就能轻松额外获得一个精度位，既然第一位总是等于1，那么就不需要显示的表示它。</p>
<p><strong>非规格化</strong></p>
<p>当阶码全为0的时候，表示的书就是非规格化的。</p>
<p>阶码为E &#x3D; 1 - 偏置，尾数M &#x3D; f，也就是小数的值，不包含隐含的开头1。</p>
<p>非规格化数可以表示0，因为对于M来说，必须大于或等于1.因此不能表示0，事实上对于0的位模式，阶码字段与小数域全为0。</p>
<p>但是-0与+0在符号位上是有差异的，在IEEE中，在某些方面，他们被认为是不同的。</p>
<p><strong>特殊值</strong></p>
<p>当阶码全为1时，就会出现无穷的表示。</p>
<p><strong>舍入</strong></p>
<p>因为表示方法限制了浮点数的范围和精度，所有浮点运算只能近似的表示实数运算。</p>
<p>一般的，为了找到一个最接近的匹配值，可以用期望的浮点形式表示出来，这就是舍入。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113155430334.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20221113155430334.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><strong>浮点运算</strong></p>
<p>IEEE标准指定了一个简单的规则，来确定加法和乘法这样的算术运算的结果。</p>
<p><strong>C语言中的浮点数</strong></p>
<p>C语言中提供了两种不同的浮点数据类型，float和double，在支持IEEE浮点格式的机器上，这些数据类型对应单精度和双精度浮点，另外这类机器采用偶数舍入的舍入方式。</p>
<p>当在int、float和 double格式之间进行强制类型转换时，程序改变数值和位模式的原则如下(假设int是32位的)：<br>从int转换成float，数字不会溢出，但是可能被舍入。<br>从 int或float转换成double，因为double有更大的范围(也就是可表示值的范围)，也有更高的精度(也就是有效位数)，所以能够保留精确的数值。<br>从double转换成float，因为范围要小一些，所以值可能溢出成＋∞或-∞。另外，由于精确度较小，它还可能被舍入。<br>从float或者double转换成int，值将会向零舍人。例如，1.999将被转换成1,而一1.999将被转换成一1。进一步来说，值可能会溢出。</p>
<p>C语言标准没有对这种情况指定固定的结果。与Intel兼容的微处理器指定位模式<a href="%E5%AD%97%E9%95%BF%E4%B8%BAw%E6%97%B6%E7%9A%84TMin..">10…00</a>为整数不确定(integer indefinite)值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个值。因此，表达式(int)+1e10会得到-21483648，即从一个正值变成了一个负值。</p>
]]></content>
  </entry>
  <entry>
    <title>计算机系统-程序的机器级表示</title>
    <url>//post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA.html</url>
    <content><![CDATA[<h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><p>计算机执行机器代码。编译器基于编程语言、目标机器的指令集以及操作系统，生成机器代码。</p>
<p>汇编代码是机器代码的文本表示。</p>
<p>对于严谨的程序员来说，能阅读和理解汇编代码形式是一项重要的技能。</p>
<p>对于处理器的机器语言，比较常见的就是x86-64，IA32是他的32位前身。</p>
<h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><p>各类处理器中的晶体管数量与他们出现的年份呈现正比例增长的趋势，晶体管基本每26个月都会翻一番。</p>
<p>预测未来10年，芯片上的晶体管每年都会翻一番，这个预测就是摩尔定律。</p>
<h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>GCC C编译器，这是linux上的默认编译器，实际上GCC调用了一整套的程序，将源代码转化为可执行代码。</p>
<p>首先，C预处理器扩展源代码，插入所有#include命令指定的文件，并扩展所有用#include声明的宏。</p>
<p>其次，编译器会产生两个源文件的汇编代码，后缀为.s。</p>
<p>接下来，汇编器会将汇编代码转化为二进制目标代码文件，后缀为.o。（目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。）</p>
<p>最后，链接器将两个目标代码文件与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件。</p>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>计算机系统使用了不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。</p>
<p>ISA指令集体系结构或者指令集架构来定义机器级程序的格式和行为，他定义处理器状态、指令的格式，以及每条指令对状态的影响。</p>
<p>机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去一个非常大的字节数组。</p>
<p>在整个编译过程中，编译器完成大部分的工作，汇编代码非常接近于机器代码，他的主要特点是他的可读性更好。</p>
<p>x86-64的机器代码与C代码差别很大，一些通常对C程序员隐藏的处理器状态都是可见。</p>
<p>PC（计数器，在%rip来表示）给出将要执行的下一条指令在内存中的地址。</p>
<p>整数寄存器，包含16个命名的位置，分别存储64位的值，这些寄存器可以存储地址或整数数据，有些寄存器被用来记录重要的程序状态，其他的寄存器用来保存临时数据。</p>
<p>条件码寄存器，保存最近执行的算术或逻辑指令的状态信息。</p>
<p>向量寄存器，存放一个或多个整数或浮点数值。</p>
<p>程序内存包括：用来管理过程调用和返回的运行时栈，以及用户分配的内存块。</p>
<p>一条机器指令只执行一个非常基本的操作。</p>
<p>在C语言程序经过预处理与编译之后，就能得到汇编文件，代码中已经出去了所有的局部变量名或数据类型的信息。</p>
<p>但是机器执行的程序只是一个简单的字节序列，它是对一系列指令的编码，机器对产生这些指令的源代码几乎一无所知。</p>
<p>要查看机器代码的内容，反汇编器的程序就有作用，他会根据机器代码产生一种类似汇编代码的格式。并且不会去访问汇编代码或者源代码。</p>
<h3 id="关于格式的注解"><a href="#关于格式的注解" class="headerlink" title="关于格式的注解"></a>关于格式的注解</h3><pre class="line-numbers language-none"><code class="language-none">    .file  &quot;Node.c&quot;
   .text
   .globl InitList
   .def   InitList;  .scl   2; .type  32;    .endef
   .seh_proc  InitList
InitList:
   subq   $40, %rsp
   .seh_stackalloc    40
   .seh_endprologue
   movl   $16, %ecx
   call   malloc
   movq   $0, 8(%rax)
   addq   $40, %rsp
   ret
   .seh_endproc
   .section .rdata,&quot;dr&quot;</code></pre>

<p>如上是一段C语言代码经过GCC编译后的内容，它包含我们不需要关心的信息，另一方面，他不提供任何程序的描述或者他如何工作的描述。</p>
<p>所有以“.”开头的行都是知道汇编器和链接器工作的伪指令，通常可以忽略掉他们。</p>
<p>一种汇编语言程序员的代码风格是，只会给出与讨论内容相关的代码行，每一行的左边有行号提供引用，右边是注释。</p>
<p>还有网络旁注，提供一些资料，一个网络旁注者描述的是IA32的机器代码，有了x86-64的背景，学习IA32会相当简单，除此之外，它还描述了在C语言中插入汇编语言的方法。</p>
<h3 id="ATT与Intel汇编格式"><a href="#ATT与Intel汇编格式" class="headerlink" title="ATT与Intel汇编格式"></a>ATT与Intel汇编格式</h3><p>一般的表示，包括如上的表示都是AT&amp;T的，这也是很多工具的默认的编码格式，其他的一些编程工具，都是Intel的，这两种格式在许多的方面有所不同。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20221013144105321.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/image-20221013144105321.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221013144105321"></p>
<pre class="line-numbers language-none"><code class="language-none">    .file  &quot;Node.c&quot;
   .intel_syntax noprefix
   .text
   .globl InitList
   .def   InitList;  .scl   2; .type  32;    .endef
   .seh_proc  InitList
InitList:
   sub    rsp, 40
   .seh_stackalloc    40
   .seh_endprologue
   mov    ecx, 16
   call   malloc
   mov    QWORD PTR 8[rax], 0
   add    rsp, 40
   ret
   .seh_endproc
   .section .rdata,&quot;dr&quot;</code></pre>

<p>使用如上的命令行，GCC可以产生Intel格式的代码。</p>
<p>Intel代码省略了指示大小的后缀。</p>
<p>Intel代码省略了寄存器名字前面的“%”符号。</p>
<p>Intel代码用不同的方式来描述在内存中的位置。</p>
<p>在带有多个操作数的指令情况下，列出操作数的顺序相反。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>32位的体系结构是由16位扩展而来的，在Intel中用术语“字（word）”来表述16位数据类型，因此，32位数据类型成为双字，64位数称为四字。</p>
<p>C语言数据类型在x86-64中的大小。</p>
<table>
<thead>
<tr>
<th>C声明</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody></table>
<p>住：指针在64位的系统中，长8个字节。</p>
<p>大多数GCC产生的汇编代码指令中都有一个字符的后缀，表明操作数的大小，例如数据传送指令的变种：movb（字节）、movw（字）、movl（双字）、movq（四字）。</p>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针，他们都以%r开头，最初的8086中有8个16位的寄存器，扩展到IA32时，这些寄存器也扩展为32位寄存器，标号从%eax到%ebp。</p>
<table>
<thead>
<tr>
<th>64位</th>
<th>32位</th>
<th>16位</th>
<th>8位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%rax</td>
<td>%eax</td>
<td>%ax</td>
<td>%al</td>
<td>返回值</td>
</tr>
<tr>
<td>%rbx</td>
<td>%ebx</td>
<td>%bx</td>
<td>%bl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td>%ecx</td>
<td>%cx</td>
<td>%cl</td>
<td>第4个参数</td>
</tr>
<tr>
<td>%rdx</td>
<td>%edx</td>
<td>%dx</td>
<td>%dl</td>
<td>第3个参数</td>
</tr>
<tr>
<td>%rsi</td>
<td>%esi</td>
<td>%si</td>
<td>%sil</td>
<td>第2个参数</td>
</tr>
<tr>
<td>%rdi</td>
<td>%edi</td>
<td>%di</td>
<td>%dil</td>
<td>第1个参数</td>
</tr>
<tr>
<td>%rbp</td>
<td>%ebp</td>
<td>%bp</td>
<td>%bpl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td>%esp</td>
<td>%sp</td>
<td>%spl</td>
<td>栈指针</td>
</tr>
<tr>
<td>%r8</td>
<td>%r8d</td>
<td>%r8w</td>
<td>%r8b</td>
<td>第5个参数</td>
</tr>
<tr>
<td>%r9</td>
<td>%r9d</td>
<td>%r9w</td>
<td>%r9b</td>
<td>第6个参数</td>
</tr>
<tr>
<td>%r10</td>
<td>%r10d</td>
<td>%r10w</td>
<td>%r10b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>%r11d</td>
<td>%r11w</td>
<td>%r11b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>%r12d</td>
<td>%r12w</td>
<td>%r12b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>%r13d</td>
<td>%r13w</td>
<td>%r13b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>%r14d</td>
<td>%r14w</td>
<td>%r14b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>%r15d</td>
<td>%r15w</td>
<td>%r15b</td>
<td>被调用者保存</td>
</tr>
</tbody></table>
<p>整数寄存器，所有16个寄存器的低位部分都可以作为字节、字、双字和四字来访问。</p>
<p>在如上的寄存器中，esp与ebp较为特殊，前者是栈指针，后者为帧指针。其余的都可以通用。</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令都有一个或多个操作数，指示出一个操作中要使用的源数据值，以及放置结果的目的位置。</p>
<p>操作数被分为三种类型：</p>
<p>​	立即数：表示常数值，在AT&amp;T中，立即数的书写方式是“$”后面跟一个标准C表示法表示的整数。</p>
<p>​	寄存器：表示某个寄存器内的内容。</p>
<p>​	内存引用：根据计算出来的地址访问某个的内存位置。</p>
<p>有多种不同的寻址方式，其中比例变址寻址比较常见，Imm（rb，ri，s），Imm表示立即数偏移，rb表示基址寄存器，ri表示变址寄存器和一个比例因子s。</p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>最频繁的指令是将数据从一个位置让复制到另一个位置的指令。</p>
<p>最简单形式的数据传送指令是——MOV类，这些指令把数据从源位置复制到目的位置，不做任何变化。</p>
<p>movb、movw、movl、movq组成了MOV类，这些指令都执行相同的操作，区别在于他们操作的数据大小不同，分别为1 2 4 8字节。</p>
<p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中，目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址，传送指令的两个操作数不能都指向内存地址。</p>
<p>这些指令的寄存器数可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符指定的大小相匹配，MOV指令只会更新目的操作数指令的那些寄存器字节或内存位置，唯一的例外是movl指令以寄存器作为目的时，他会把该寄存器的高位4字节设置为0。</p>
<p>在做数据传送时，常常会遇到将较小的源传送到较大的目的，对此MOV有两类数据移动指令。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MOVZ S R</td>
<td>R 零扩展S</td>
<td>以零扩展进行传送</td>
</tr>
<tr>
<td>movzbw</td>
<td></td>
<td>将做了零扩展的字节传送到字</td>
</tr>
<tr>
<td>movzbl</td>
<td></td>
<td>字节传送到双字</td>
</tr>
<tr>
<td>movzwl</td>
<td></td>
<td>字传送到双字</td>
</tr>
<tr>
<td>movzbq</td>
<td></td>
<td>字节传送到四字</td>
</tr>
<tr>
<td>movzwq</td>
<td></td>
<td>字传送到四字</td>
</tr>
<tr>
<td>MOVS S R</td>
<td>R 符号扩展S</td>
<td>传送符号扩展的字节</td>
</tr>
<tr>
<td>movsbw</td>
<td></td>
<td>字节传送到字</td>
</tr>
<tr>
<td>movsbl</td>
<td></td>
<td>字节传送到双字</td>
</tr>
<tr>
<td>cltp</td>
<td>%rax——（符号扩展）%eax</td>
<td>把%eax符号扩展到%rax</td>
</tr>
</tbody></table>
<p>如上的表省略了部分。</p>
<h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><p>两个数据传送操作可以将数据先压入栈中，再从栈中弹出。</p>
<p>pushq 压栈</p>
<p>popq 弹栈</p>
<p>将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。</p>
<p>​                                       </p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络笔记</title>
    <url>//post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p><strong>说明</strong></p>
<p>教材是谢希仁的计算机网络第八版，但是在写笔记阶段已经学完了以及一些其他的原因，所以笔者想用自上而下的方式。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221003152310810.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221003152310810.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20221003152310810"></p>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p><strong>互联网</strong></p>
<p>局域网和广域网连在一起就是互联网，也就是说互联网不是单个网络，而是多个网络的组合。</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h3><p>一组具有通信能力的设备连接在一起就是网络，他们可以是两台主机（host），也可以是一台主机和一台打印机，甚至是平常距离日常很遥远的路由器，交换机，调制解调器。</p>
<p>路由器，连接网络和网络。</p>
<p>交换机，用来连接设备。</p>
<p> 调制解调器，用来交换数据形式。</p>
<p>当一台路由器（即插即用）连接两台电脑时，这时候一个局域网就组建成功了。</p>
<p><strong>局域网</strong></p>
<p>在局域网中，每一台主机都有一个标识符（地址），用来在这个局域网中定义这台主机。这台主机向另一台主机发送的数据包里就包含了源和目的主机的地址。</p>
<p>在过去的一段时间，一个网络中的所有主机都用一条电缆连接，一台主机发送的数据其他的主机都可以接受到，这时候由这些主机选择接收还是丢弃这些数据包，目标主机就选择保存这个数据包。现在多数的局域网采用交换机，他可以识别数据包的目的地址并引导数据包达到他的目的地而不必发送到其他的主机。</p>
<p>交换机减轻了局域网中的流量，如果不是共同的源主机和目的主机，那么交换机允许同一时刻多对主机之间同时互相通信。</p>
<p><strong>广域网</strong></p>
<p>同样是由具有通信能力的设备相互连接而成的，但是不同的是，广域网的地理覆盖范围很广，通常的局域网值覆盖一个大楼或者是一个校园，但是广域网则十分的大，可能是一个城市，一个省，一个国家等。</p>
<p>局域网互联主机，但广域网互联交换机、路由器、调制解调器等连接设备。</p>
<p><strong>点到点广域网</strong></p>
<p>这种广域网通过传输介质来连接两个通信设备。</p>
<p><strong>交换式广域网</strong></p>
<p>交换式广域网具有多个端点，可以说交换式广域网是交换机连接几个点到点的广域网而形成的。</p>
<p><strong>互联网络</strong></p>
<p>现在很少有单独的局域网或者广域网，他们都互相连接在一起的，当两个或多个网络连接在一起时，它们就形成了一个互联网络，或者互联网。 </p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a><strong>交换</strong></h3><p>互联网是由链路和交换机组成的，实际上互联网是一个交换式的网络，其中一台交换机至少将两条链路连接的一起，在需要的时候，交换机需要将数据从一条链路转发到另一条链路，交换式网络最常见的类型为电路交换网络和分组交换网络。</p>
<p><strong>电路交换网络</strong></p>
<p>在电路交换网络中，两个网络之间总是存在一条专用的连接（电路），交换机只能让他变成活跃或者非活跃状态。</p>
<p>这样的模式存在一个弊端：电路容量必须足够的大，以便于在两个网络所有主机通信时，不至于通信失败，但是这样的情况并不是每时每刻都在发生的，在一般的场景下，工作时，可能只有部分的容量被占用，因此这种模式的效率是低下的。</p>
<p>此处的效率低下指的是，高容量的电路使用率不足，并非通信效率不佳。</p>
<p><strong>分组交换网络</strong></p>
<p>在一个计算机网络中，两个端点之间使用被称为分组（packet）的数据块进行通信，也就是说，两个计算机交换的是独立的数据分组，由于分组能够被存储和发送时是一个独立的实体，因此这种机制允许我们实施存储转发的交换功能。</p>
<p>分组交换网络中的路由器具有能够存储和转发分组的队列，如果现在需要发送的分组大于了线路的容量，那么此时的分组会在路由器存储并且进行排队的状态，他的效率看上去比电路要高了，但是分组可能也会在大规模使用时遇到延迟。</p>
<h3 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a><strong>因特网</strong></h3><p>这是最著名的互联网了，它是由成千上万个相互连接的网络组成。</p>
<p>概念上的因特网由一系列主干、提供者网络和客户网络组成，主干是最高层次，是一些通信公司拥有的大型网络，主干网络通过对等点的复杂交换系统进行连接，一些小的提供者网络处于第二个层次，这些网络通过付费使用主干网络服务，提供这网络连接主干网络，有时提供网络之间也相互连接，客户网络是因特网边缘的网络，他们使用因特网提供的服务，为了接收服务，客户网络需要像提供者网络付费。</p>
<p>主干和提供者网络其实都是服务提供商，主干常常称为国际ISP，提供者网络常常被称为国家或地区ISP。</p>
<h3 id="访问因特网"><a href="#访问因特网" class="headerlink" title="访问因特网"></a><strong>访问因特网</strong></h3><p>因特网允许任何用户成为他的一部分，但是还需要用户在物理上连接到一个ISP。物理连接通常利用一条点到点的广域网实现。</p>
<p><strong>电话网络</strong></p>
<p>具有电话服务的客户，大多数电话网络自身就已经连接到因特网，因此这些客户可以选择把他们和电话中心的语音线路转换成点到点的广域网。</p>
<p>实现方式有两种：</p>
<p>拨号服务，在电话线路中增加将数据转换成语音的调制解调器，安装在计算机中的软件拨打ISP的号码，形成一条电话连接。但是拨号服务很慢，同时线路用于因特网连接的时候，线路无法进行电话连接，因此这种方式只对偶尔访问因特网的客户有效。</p>
<p>DSL，将电话线路升级，可以同时使用语音服务。</p>
<p>除此之外还可以通过：有线电视网络、无线网络、直连Internet（将自身变成一个ISP）</p>
<h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a><strong>协议分层</strong></h3><p>协议定义了发送者、接受者和所有中间设备为了高效通信需要遵循的规则。通信复杂时，我们需要把任务划分到不同层，不同层需要不同的协议。</p>
<p><strong>协议分层原则</strong></p>
<p>1、双方双向通信，每一层都能执行两个相反的任务，每个方向上一个</p>
<p>2、两端中，每一层的两个对象都应该相同。</p>
<p><strong>逻辑连接</strong></p>
<p>每层之间拥有逻辑上的连接，这意味着我们可以拥有层与层之间的通信，这是为了方便理解。</p>
<h3 id="TCP-IP协议簇"><a href="#TCP-IP协议簇" class="headerlink" title="TCP|IP协议簇"></a>TCP|IP<strong>协议簇</strong></h3><p>不同层次组织的协议集——协议簇。</p>
<p>这是一个相互交互的模块组成的一个层次结构协议，层次意味着上层的协议需要得到一个或者多个较下层的协议提供的服务支持。</p>
<p>初始的TCP|IP提供了四个层次，但通常的它应当是一个五层模型。</p>
<p>层次：应用层、传输层、网络层、数据链路层、物理层</p>
<p>对等体：消息、段或用户数据报、数据报、帧、bit位</p>
<p>采用逻辑连接使得每一层的任务变得简单，其中应用层、传输层和网络层的任务都是从端到端的，但是数据链路层和物理层的任务是从点到点的。换句话说，高层次的任务范围是互联网，而低层次也就是下两层的任务范围是链路。</p>
<p>还可以从每一层的数据单元出发，上三层的分组（packet）不应该被任何路由器或者链路层的交换机改变，在下两层，主机创建的分组仅仅被路由器不改变，链路层交换机不改变任何东西。</p>
<p><strong>各层描述</strong></p>
<p><strong>应用层</strong></p>
<p>逻辑连接是端到端的，两个应用层之间好像有一架桥梁负责交换消息，但实际上通信要经历所有的层次才能完成。</p>
<p>应用层的通信处于两个进程之间，一个进程发送请求，接受另一个进程的响应，进程到进程的通信就是应用层的任务，在因特网上，应用层包含了许多的协议（HTTP、WWW、FTP、SSH与TELNET、DNS）</p>
<p><strong>传输层</strong></p>
<p>端到端，源主机的传输层从应用层得到消息，封装为传输层的分组（段或数据报，不同协议叫法不同。）然后进行发送，通过逻辑连接，到达目的主机的传输层。</p>
<p>传输层向应用层提供服务，，从运行于应用层的程序得到消息，并将它投递到目的主机相应的应用程序。（主要原因是为了分割任务和责任），传输层也有很多协议，每一个都是为了一些特定的任务设计的。（TCP、UDP）</p>
<p><strong>网络层</strong></p>
<p>主机到主机，源主机到目的主机之间可能存在多个路由器，因此路径上的路由器负责为每一个分组选择最好的路径（IP）</p>
<p><strong>数据链路层</strong></p>
<p>互联网是由多个链路通过路由连接而成的，当主机传输数据报到目的地可能存在多个交叠的链路集，路由器负责挑选最好的链路进行传输，当路由器决定好了链路之后，数据链路层开始接管这个数据报并且让他穿过这条链路，这条链路可以是无线网、有线网，对于不同的链路类型存在不同的协议，无论什么情况，链路层都要负责通过链路传输分组。</p>
<p>TCP&#x2F;IP没有为了数据链路层定义任何协议，因此它支持所有所有私有和标准的协议能接管数据报并且携带它穿过链路的任意协议都能满足网络层的要求，链路层接管数据报并且封装在一个称为帧的分组中。</p>
<p><strong>物理层</strong></p>
<p>物理层负责携带一个帧中单独的比特穿过链路，尽管物理层已经位于协议簇的最底层，但是在物理层之下还存在一个隐藏的传输介质层，因此物理层之间的还是逻辑通信，两个设备通过可以携带电信号或者光信号的介质到达目的地。将一个bit转换为电信号或者光信号存在多个协议。</p>
<p><strong>封装和解封装</strong></p>
<p>在Internet协议分层中，一个重要的概念是封装和解封装。</p>
<p>在链路层交换机中没有封装和解封装发生。</p>
<p>应用层，交换的数据称为消息，消息一般的不包含头部和尾部，即使包含了这些，我们也称其为消息，消息会被传递到传输层。</p>
<p>传输层，把这个消息称为有效载荷，该载荷是传输应该关注的负载，传输层增加了传输层头部，其中包含了希望进行通信的源和目的程序的标识符和一些投递消息的更多信息，例如：流量控制、差错控制和拥塞控制需要的信息，结果为一个传输层分组。在TCP中称为段、在UDP中成为用户数据报，然后传输到网络层</p>
<p>网络层，把传输层分组作为数据或者有效载荷，并且加上自己的头部，包含源和目的主机的地址，以及用于差错检查、分片的信息和一些其他的信息，结果为一个称为数据报的网络层分组，然后网络层投递到数据链路层。</p>
<p>数据链路层，把网络层分组作为数据或者有效载荷并且添加上自己的头部，包含主机或者下一跳步（路由器）的链路层地址，结果为一个称为帧的链路层分组，投递到物理层进行传输。</p>
<p><strong>路由器的解封装与封装</strong></p>
<p>路由器连接多个链路，因此路由器也存在解封装与封装的问题。</p>
<p>在比特集被投递到数据链路层之后，这一层从帧中解封装出数据报并把它投递到网络层。</p>
<p>在网络层只检查数据报头部的源地址和目的地址，查阅它的转发表以寻找数据报将要被投递的下一跳步。除非数据报太大需要分片，数据报的内容不应该被网络层改变。</p>
<p>下一链路的链路层将数据报封装为一个帧，将其放到物理层进行传输。</p>
<p><strong>目的主机的解封装</strong></p>
<p>目的主机端，每一层都只解封装接收到的分组，移出有效载荷，并将有效的载荷移至上一层，直到消息到达应用层，目的主机中的解封装包含差错检查。、</p>
<p><strong>地址</strong></p>
<p>看起来，似乎这个模型的每一层都需要逻辑通信，那么每一层之间就都需要一对地址，但是因为物理层不需要地址（介质连接），因此只需要四对地址。</p>
<p>在应用层，一般的是域名定义提供服务的站点，或者是电子邮件地址，在传输层，地址是端口号，端口号指的是源和目的地的进程，端口号是本地地址，用于区分同一时间运行的几个程序，网络层地址是全局的，涵盖了整个Internet，链路层地址有时叫做MAC地址，是本地定义的地址，每个链路层地址在网络中定义一个特定的主机或路由器。</p>
<p><strong>多路复用与多路分解</strong></p>
<p>协议簇在一些层次使用多个协议，因此我们在源进行多路复用（一个协议能封装多个来自上层协议的分组，一次一个），在目的端进行多路分解（一个协议可以解封装并且将分组投递到上层协议，一次一个）。</p>
<h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a><strong>OSI</strong></h3><p>应用层</p>
<p>表示层</p>
<p>会话层</p>
<p>传输层</p>
<p>网络层</p>
<p>数据链路层</p>
<p>物理层</p>
<p>看起来似乎比TCP&#x2F;IP更加好一些，但实际上，表示层和会话层没有定义协议，并且模型完成较晚，并且在实际的应用上，并没有想象中的高效。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>整个Internet、硬件和软件的设计和开发都是为了为应用层提供服务。</p>
<p>因特网提供服务的本质以及两个应用类型：传统客户—服务器模式，以及新类型对等模式</p>
<h3 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a><strong>提供服务</strong></h3><p>应用层是唯一向因特网用户提供服务的层次，因此它十分的灵活，新的协议可以随时加入Internet。</p>
<p>标准和非标准协议</p>
<p>描述的都是具体的程序，前者是被管理机构标准化和归档化的内容，后者是自己定义的内容，例如在自己写的程序。</p>
<h3 id="应用层模式"><a href="#应用层模式" class="headerlink" title="应用层模式"></a><strong>应用层模式</strong></h3><p>传统：客户—服务器</p>
<p>这种模式对服务器负担较大，要求服务器一直保持开启阶段，为了让客户机随时都可以访问他，并且当许多客户一起访问服务器，对服务器的考验十分巨大。</p>
<p>通信负荷集中在服务器上，WWW、HTTP、FTP、SSH以及电子邮件还是这样的模式。</p>
<p>新模式：对等模式</p>
<p>P2P，不存在客户和服务器，两者是对等结点，最经典的是网络电话，没有一方需要等待另一方呼叫，还有计算机的文件共享。</p>
<p>对等模式不用一直维护服务器，容易扩展并且经济划算，但是依旧存在问题，安全性部署困难，适用性不高（并不是所有应用都可以应用对等模式。）</p>
<p>混合模式</p>
<p>结合了两种模式优点来吧这二者混合起来，比如轻量级的客户和服务器可以用来寻找对等结点的地址，当实际服务时，是从对等结点中获得。</p>
<h3 id="API应用程序接口"><a href="#API应用程序接口" class="headerlink" title="API应用程序接口"></a>API<strong>应用程序接口</strong></h3><p>一个计算机程序通常是由预定义了指令集的计算机语言编写的，这个指令集告诉计算机要做什么，如果我们需要使得进程之间通信，那么就需要一个新的指令集，这就是API。</p>
<p>此时API连接了两个实体，OS与程序，其中OS封装了TCP&#x2F;IP协议簇的前四层。</p>
<p>通信API：套接字、传输层接口TLI、STREAM。</p>
<h3 id="WWW与HTTP"><a href="#WWW与HTTP" class="headerlink" title="WWW与HTTP"></a>WWW与HTTP</h3><p>万维网（WWW）又叫WEB，今天它是信息宝库，其中网页文档在全世界发布，分布式允许web无限增长，链接使得网页之间出现引用。（超文本）</p>
<p>WWW是一个分布式客户—服务器模式，使用浏览器的用户可以访问一个正在服务器上运行的服务，服务分布在不同的site上。</p>
<p>浏览器通常包含三个部分：控制程序、客户协议和解释程序。</p>
<p><strong>网络服务器</strong></p>
<p>URL，统一资源定位符，（协议+主机+端口+路径）来定位文档。</p>
<p>网上文档：静态文档（用户只能得到副本的文档，html等）、动态文档（返回的响应文档）、活动文档（在客户站点运行的脚本或程序，js等）</p>
<p>HTTP，超文本传输协议，用来定义客户服务器程序如何编写和如何获取网页的协议，一个用户发送请求，服务器返回响应，服务器使用80端口，客户使用临时端口，HTTP使用TCP服务。</p>
<p><strong>非持续与持续连接</strong></p>
<p>获取一个对象就创建一个连接的模式就是非持续的，创建一个连接获取所有对象就是持续的。其中这些对象应该位于同一台服务器。</p>
<p><strong>报文格式</strong></p>
<p>HTTP定义了请求报文和响应报文的格式，每一种报文由四个部分组成。</p>
<p><strong>请求报文</strong></p>
<p>第一行：请求行</p>
<p>由方法、URL和版本构成。</p>
<p>方法定义了请求类型（GET、POST、PUT等），URL定义了相关网页的地址和名称，版本给出了协议的版本（常用1.1）</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221004215743478.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221004215743478.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="请求方法"></p>
<p>请求行之后有一个或者多个请求头部，从客户端向服务端发送额外的信息。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221004215844724.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221004215844724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="请求头部名称"></p>
<p><strong>响应报文</strong></p>
<p>包含状态行、头部行有时候包含主体。</p>
<p>状态行：http协议的版本、状态码</p>
<p>状态码：100范围内只代表一个报告，200范围内表示这是一个成功的请求，300内表示把客户端重定向到另一个URL，400范围内表示客户端发生错误，500范围内表示错误发生在服务端。</p>
<p>响应头部行，发送额外信息。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221004220200461.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221004220200461.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="响应头部名称"></p>
<p>主体包含了服务器发送给客户的文档，除非响应是一个错误报文，否则主体是存在的。</p>
<p>条件请求:客户在请求中加入条件</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>WWW起初被设计为无状态实体，客户发送请求，服务器响应，二者关系结束。</p>
<p>Cookie的创建和存储与实现有关，然而它的原理是相同的。<br>1．当服务器从客户端接收到请求后，它将客户端的信息存储在文件或字符串中。这些信息可能包含客户端的域名、cookie内容（服务器收集到的关于客户端的信息，如主机名、注册号等)、时间戳,以及与实现有关的其他信息。<br>2．服务器在响应中包含了它发送给客户端的cookie。<br>3．当客户端接收到响应后，浏览在cookie目录中查询是否有从那个服务器使用Cookie，当客户向服务器发送请求时，浏览器在cookie目录中查询是否有从那个服务器发送过来的cookie。如果有，则在请求中包含这个cookie。当服务器接收到这个请求后，它就知道了这是一个老客户，而不是新的。注意，cookie的内容从来不让浏览器读取或者透露给用户，只由服务器创建并回收cookie。</p>
<h3 id="WWW高速缓存、代理服务器"><a href="#WWW高速缓存、代理服务器" class="headerlink" title="WWW高速缓存、代理服务器"></a>WWW高速缓存、代理服务器</h3><p>代理服务器是一台计算机，可以保存最近请求的响应的副本，客户端向代理服务器发请求，代理服务器检查本地高速缓存，如果高速缓存中不存在响应正文，那么代理服务器就向相应的服务器发送请求，返回的响应会发送到代理服务器中，并且进行存储，以用于其他客户端将来的请求。</p>
<p>代理服务器可以降低负载，减少通信量，并且降低延迟，但是，为了使用代理，必须配置客户端。</p>
<p>代理服务器既是服务又是客户，通常位于客户节点。</p>
<p>缓存更新，一个响应应该在被改变前，在代理服务器保留多长时间，第一个策略是保存站点列表，保存一段时间，另一个建议是加入头部信息显示最近修改时间，代理服务器可以从时间猜测他们在多长时间内是有效的。</p>
<h3 id="HTTP安全"><a href="#HTTP安全" class="headerlink" title="HTTP安全"></a>HTTP安全</h3><p>其实，http不提供安全，但是http可以在安全套接层（STL）上运行，此时HTTP称为HTTPS，它提供保密性、客户和服务器鉴别，以及数据完整性。</p>
<h3 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP 文件传输协议"></a>FTP 文件传输协议</h3><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层提供了包括分组、路由以及转发的服务，网络层中的内容主要包括分组交换、网络层性能、网络层拥塞以及路由器结构。</p>
<h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>这是网络层的首要责任，packet。在源端将负载封装进网络层packet中并在目的端解封装。</p>
<p>源从上层协议接受分组，加入一个头部，头部包含源和目的地址以及其他网络层协议所需要的信息。</p>
<p>并且将其传送到数据链路层，源端不改变负载的内容，除非负载过大不能传递才需要分段处理。</p>
<p>目的主机从数据链路层接受网络层分组、解封分组并且将负载传递到相对应的上层协议。如果分组在源或者在沿途被分段，那么网络层负责等待，直到所有的分组都到达，他同时负责重组分组并且将它们传递到上层协议。路径上的路由器不可以解封它们接受到的分组，除非它们接受到的分组需要被分段，也不允许路由器改变地址，无论是源或者是目的。路由器能做的仅仅是检查和、转发，当然如果需要分段的情况，路由器会复制头部并且做出一些改变。</p>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>网络层的另一个责任就是路径选择，这就是路由。网络层寻找最佳的路由，但是如何定义最佳，网络层需要一些特定的策略。</p>
<p>在现在，有一些专业的路由协议可以帮助路由器很快的实现这一点。</p>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>路由应用一些策略并运行某些路由协议来为每个路由创建决策表，那么转发可以定义为当packet到达路由器的一个端口时，路由器所采取的决策表有时也被叫做转发表。路由器根据它来实施行为，当接受到一个packet时，他需要将分组转发到另一个或多个所连接的网络上。一个与多个的区别就区分了单播和多播路由。为了做出这样的决策，路由器使用packet头部的一个信息片段来找到转发表中相应的输出接口号。</p>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>尽管差错控制可以在网络层中实现，但是网络层的设计者似乎忽略了携带数据中的差错问题，因为数据有可能会被分段，因此差错控制的效率会变得非常低。但是网络层的设计者将校验的字段加入到了头部中，用来校验头部的好坏，这个校验和可能防止两跳之间以端与端之间的数据报头部的改变或损坏。</p>
<p>但是如果数据报被丢弃或者在头部中含有未知信息，ICMP这样的辅助协议来提供某种差错控制。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>源端可以发送但不会淹没接收方的数据量，如果源端计算机上层产生数据的速度比目的端极端及上层消耗数据的速度快，那么接收方会被数据所淹没，为了控制数据流量，接收方需要发送一些反馈给发送方，从而通知后者接收方被数据淹没了。</p>
<p>但是网络层中没有提供任何的流量控制，当准备好时，数据报被发送方发送，而不考虑接收方是否准备好了。</p>
<p>网络层设计中缺乏流量控制的原因有这么一些：这一层没有差错控制，接受端网络层的工作是很简单的，以致于它很少被淹没。当准备好时，利用网络层服务的上层可以实现缓冲区，用它来从网络层接受数据，而无需一接受数据的速度消耗数据。流量控制被提供给绝大多数使用网络层服务的上层协议，因此另一级流量控制使得网络层更复杂且整个系统低效。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>网络层的另外一个事件是拥塞控制，网络层的拥塞控制是某一个区域出现过多的数据报的情况，如果源计算机发送的数据报数量超过了网络或者路由器的容量，那么就可能发生拥塞，在这种情况下一些路由器可能丢弃一些数据报，然后随着更多的数据报被丢弃，这种情况会变得更加槽糕，由于上层的差错控制，发送方可能发送丢失分组的副本，如果拥塞继续，那么有时可能导致系统崩溃。</p>
<h4 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h4><p>Qos（通信服务质量）变得十分重要，为了保证网络层不变，一般的这些服务通常在上层实现。</p>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>这是绕不开的事件，在最开始设计的时候，并没有考虑安全，网络层的设计本身就是不安全的，为了给无连接的网络层提供安全，我们需要另一个虚拟层将无连接服务变成面向连接服务，这个虚拟层成为IPSec。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>交换发生在网络层，事实上，路由器是一个创建了输入端口和输出端口连接的交换机，就像将输入连接连接到输出让电流流动的开关。</p>
<p>数据通信技术分为两部分，电路交换与分组交换，但是在网络层只使用分组交换，因为这一层数据单位是分组。</p>
<p>分组交换网络的连接装置仍然决定如何将分组路由到最终的目的端，如今分组交换网络使用两种不同的方法，数据报方法和虚电路方法。</p>
<h4 id="数据报方法"><a href="#数据报方法" class="headerlink" title="数据报方法"></a>数据报方法</h4><p>无连接服务，转发分组基于分组的目的地址。每个分组都是独立的实体。</p>
<h4 id="虚电路方法"><a href="#虚电路方法" class="headerlink" title="虚电路方法"></a>虚电路方法</h4><p>面向连接服务，同一报文的分组存在着连接，分组包含流标号，定义了分组应该经过的路径。转发决策基于标签的值或者虚电路标识符。</p>
<p>创建面向连接服务：建立、数据交换和拆除。</p>
<h3 id="网络层性能"><a href="#网络层性能" class="headerlink" title="网络层性能"></a>网络层性能</h3><p>延迟、吞吐量、分组丢失来度量网络层性能。</p>
<p>延迟：发送延迟、传播延迟、处理延迟以及排队延迟</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134555368.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134555368.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="发送延迟"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134613117.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134613117.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="传播延迟"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134621560.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134621560.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="处理延迟"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134631761.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134631761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="排队延迟"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134643722.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134643722.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="总延迟"></p>
<p>吞吐量：一秒内通过这个点的位的数量，由最小的路径以及平均路径来决定。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134755259.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134755259.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="吞吐量"></p>
<p>分组丢失：缓冲区满造成丢失。</p>
<h3 id="网络层拥塞"><a href="#网络层拥塞" class="headerlink" title="网络层拥塞"></a>网络层拥塞</h3><p>网络层的拥塞和两个问题有关，吞吐量和延迟。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134954440.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016134954440.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="分组延迟和吞吐量的负载函数"></p>
<p>当负载远远小于网络容量时，延迟是最小的，这一部分延迟只有处理延迟和传播延迟，某种程度上说，这可以忽略。让负载容量增长，此时就需要排队延迟。</p>
<p>吞吐量会随着负载的大小而增加，但是路由器丢弃分组，当负载超过网络容量时，队列变满路由器必须丢弃一些分组，这不会减少分组数量，因为当分组没有到达目的端，源端使用超时机制重发分组。</p>
<h4 id="拥塞控制机制"><a href="#拥塞控制机制" class="headerlink" title="拥塞控制机制"></a>拥塞控制机制</h4><p>开环拥塞控制（预防）</p>
<p>预防策略，源端和目的端都可以处理拥塞控制。</p>
<p>重传策略</p>
<p>发送方认为一个分组损坏或者是丢失，分组就需要重发，重传会增加拥塞。但是好的重传可以预防拥塞。优化设计重传策略和重传定时器，使之具有高效率。</p>
<p>窗口策略</p>
<p>发送方窗口的类型会影响拥塞。</p>
<p>确认策略</p>
<p>丢弃策略</p>
<p>许可策略</p>
<p>闭环拥塞控制（消除）</p>
<p>背压、抑制分组、隐含信令、显式信令</p>
<h3 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h3><p>元件：输入端口、输出端口、路由器处理器以及交换结构。</p>
<p>交换结构：纵横制交换机、榕树交换机、Batcher榕树交换机。</p>
<h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><p>第四版网络层主要为一个主要协议和三个辅助协议。</p>
<p>主要协议为：ipv4负责网络层的分组、转发以及传递。控制报文协议ICMP帮助IPv4处理一些网络层传递中可能发生的错误。组管理协议IGMP用于帮助IPV4多播。在网络层地址映射到链路层地址当中，地址解析协议ARP用来将网络和链路层联合起来。</p>
<p>Ipv4 不可靠且无连接的数据报协议，一个尽力而为的传递服务。</p>
<p>分组可以被破坏、丢弃、失序、延迟，也可能造成拥塞，因此Ipv4必须和TCP搭配。</p>
<p>数据报独立处理，意味着数据报也可能被破坏等，因此Ipv4依赖高层协议处理这些问题。</p>
<h3 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h3><p>IP使用的分组叫做数据报，数据报长度可变，由头部和数据组成，头部由20-60个字节组成，包含路由选择和传输相关的重要信息，习惯上以4个字节表示头部。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016145747587.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221016145747587.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="IP数据报"></p>
<p>版本号：4位版本号定义IPv4的版本。</p>
<p>头部长度：HLEN字段以4字节定义数据报头部的总长度，IP数据报有变长头部。</p>
<p>服务类型：他定义了数据报如何被处理，这个字段也被定义为差分服务。</p>
<p>总长：定义了一个以字节计算的IP数据报总长度。</p>
<p>标识、标记以及分段偏移（字节为单位）：数据报大于底层网络可以携带的大小时，这三个字段和IP数据报的分段有关。</p>
<p>生存时间：存储一个数字，大约是任意量主机之间路由数量最大值的两倍，每个处理数据报的路由器把这个值减1，如果数值为0，路由器就丢弃它。</p>
<p>协议：TCP|IP中，分组的数据段称为负载。一个数据报可以携带任意属于传输层协议的分组。</p>
<p>头部校验和：IP是不可靠的，头部校验和来检查头部，但是不检查负载，校验需要在每一个路由器重新计算，因为从一个路由器到另一个路由器头部的某些字段（TTL）会发生改变。</p>
<p>源和目的地址：这个段的值在整个过程中应当表示不变，并且在链路上的路由也应该知道这个值。</p>
<p>选项：这个选项多达40个字节，用来进行网络的测试和调试，他不是必需部分，因此头部只需要20字节，但是选项是ip软件必需的，选项给数据报处理增加了一些负担。</p>
<p>负载：负载就是数据，来自使用IP服务的其他协议的分组，如同邮件一样，数据报中负载就是内容，头部就是包裹。</p>
<p>分段</p>
<p>IP根据链路所使用的协议将数据报封装成帧，这其中就包括了负载的最大长度。也就是最大传输单元MTU（MTV）。IP数据报的总长度必须小于这个长度，这是计算机网络中的硬件和软件决定的。</p>
<p>为了让IP独立出来，设计者决定把IP数据报的最大长度定义为65535个字节。但是对于其他物理链路来说，我们必须分割数据报，这个分割的过程就是分段。</p>
<p>当数据报被分段，每个段都需要自己的头部，虽然头部中有些字段是重复的，但是有一些会被改变 ，如果一个数据报出现再次分段的情况，这时候这些看似重复的头部就能发挥作用了。</p>
<p>虽然是在路由器上，但是重组必须是在目的主机上，因为分段的独立性，无法控制数据报的每一个分段都到达，更强的一个目的是，在传输期间重组会带来效率的降低。</p>
<p>标识：16位，发送数据报时，使用一个计数器来保证唯一性，并且这个值被复制到标识字段内，标识号在分段时会被复制到所有的分段之中，这使得所有分段和原始数据段有相同的标识号。方便目的端重组。</p>
<p>标记：3位，他定义了3个标识，最左侧是保留位不使用，第二位是不分段位，如果为1，那么机器不能对他进行分段，如果数据报不分段无法传输，那么就丢弃这个报文，第三位是多分段位。为0表示他是最后或者唯一的分段。</p>
<p>段偏移：13位，表示这个分段在数据报中的相对位置，他是原始数据报中的数据偏移量，因此要注意分段之后的头部对他的影响，以8字节为单位。（13位较短）</p>
<p>因此，分段后的第一个字节标号能被8整除就很关键。</p>
<p>因此，即使是分段失序，最终目的主机也可以重组（没有丢失）原始数据报。</p>
<p>第一个分段偏移量为0，将第一个分段长度除8，结果就是第二个分段的偏移值，将第一个和第二个分段总长度除8，就是第三分段的偏移值，继续过程，最后一个分组的M位的值为0。</p>
<h3 id="IPV4数据报安全"><a href="#IPV4数据报安全" class="headerlink" title="IPV4数据报安全"></a>IPV4数据报安全</h3><p> 安全问题：分组嗅探，分组修改，IP欺骗。</p>
<p>前两者都是劫持分组，前者拷贝一个分组，这很难被发现，目前的解决措施是分组加密，是的被劫持也无法解密其中内容。分组修改是修改分组内容，一般的利用数据完整性机制来发现这类型攻击。在打开并使用报文的内容之前，接收方可以在发送阶段使用这个机制来确定分组没有被改变。</p>
<p>IP欺骗，是攻击者可以伪装成其他人并创建一个IP分组，他携带另一个电脑的源地址。这类型的攻击可以使用源鉴别机制来预防。</p>
<p>IPSec（IP安全）的协议以免遭到之前提到的攻击。这个协议与IP协议一起使用，在两个实体之间创建一个面向连接服务。IPSec提供四种服务：定义算法和秘钥，分组加密，数据完整性，源鉴别。</p>
<h3 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a>IPV4地址</h3><p>IP是连接的地址，不是主机或路由器的地址。IPv4地址是唯一的，这表示每一个地址定位了一个且唯一一个连接到因特网上的设备。</p>
<p>地址空间</p>
<p>地址空间是系统能使用的地址个数，IPV4是用32位地址。这意味着有2的32次方个设备可以连接到因特网上。</p>
<p>IPV4地址表示方法，二进制、点份十进制、十六进制。一般的点份十进制更易阅读。</p>
<p>一个32位的IPv4地址是有层次结果的，第一部分是前缀，他定义了网络，第二部分是后缀，他定义了代码。</p>
<p>前缀可以是固定长度也可以是变长的，起初是定长的，但是现在被废弃了。</p>
<h3 id="分类寻址"><a href="#分类寻址" class="headerlink" title="分类寻址"></a>分类寻址</h3><p>前缀定长的情况，三种长度的前缀（8,16,24）。整个地址空间分为五类，ABCDE，这个方案称为分类寻址。</p>
<p>前三类符合三种长度，D类不分前缀和后缀，他是多播地址，E类地址是保留地址，不分前缀和后缀。</p>
<p>地址耗尽，这是分类寻址被废弃的原因，地址没有被合适的分配，A类地址的结点太多，C类地址过小，E类几乎不使用。</p>
<p>为了减轻这种情况，提出了子网化和超网化，子网化特就是将某类网络划分为子网，每个子网有一个10的前缀。超网化可以将几个小类地址组合成一个较大的块，但是这让分组路由更困难。</p>
<p>虽然他有很多问题，但是他有一个优势，给定一个地址，我们可以轻易的找到这个地址的类。</p>
<p>无类寻址，长期的解决方案是IPV6，但是短期的解决方案是为了补偿地址被耗尽，类特权被从分配中消除。还是为了ISP，扩大个人与中小型组织的市场。</p>
<p>在无类寻址中，前缀是变长块，地址的前缀定义了块。</p>
<p>前缀长度：斜杠标记法。无类域间路由或CIDR策略。</p>
<p>对于一个网络，下面三条信息至关重要，地址数量，首尾地址。</p>
<p>斜杠后的n，可以得出这些。</p>
<p>数量：2的32-n次方、首地址，左n位不变，右侧32-n位变成0,，尾地址，左n位不变，右侧32-n位全变1。</p>
<p>另外一种方式是地址掩码，他也是32位数字，最左边n位是1，右边32-n位是0。计算机可以很容易的找到地址掩码，因为他是2的32-n次方-1的补码。</p>
<p>计算机程序可以使用非、与、或简单的得到上述三条信息。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025183923197.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025183923197.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="使用子网掩码"></p>
<p>块分配</p>
<p>请求地址数量必须是2的整数次幂，请求块被分配时，地址空间要有连续的可用地址，首地址必须可以被块中地址数量整除。</p>
<p>在划分子网时，也是如上的逻辑。</p>
<p>地址聚合</p>
<p>基于更大的前缀就可以完成这一点。</p>
<p>特殊地址：本地主机地址，0.0.0.0&#x2F;32，有限广播地址：255.255.255.255&#x2F;32，回送地址：127.0.0.0&#x2F;8，私有地址：10.0.0.0&#x2F;8,172.16.0.0&#x2F;16,192.168.0.0&#x2F;16,192.254.0.0&#x2F;16，多播地址：224.0.0.0&#x2F;4.</p>
<h3 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h3><p>将一个块的地址自动分配给设备，DHCP是应用层程序，使用客户—服务端来帮助网络层上的TCP-IP。</p>
<p>他经常被称为即插即用协议。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025184804277.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025184804277.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="DHCP报文格式"></p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h2 id="思科模拟器"><a href="#思科模拟器" class="headerlink" title="思科模拟器"></a>思科模拟器</h2><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022222228563.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022222228563.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="主界面" style="zoom:50%;">

<p>这是思科模拟器的逻辑空间，还可以切换到物理空间，此处不讨论。</p>
<p>在右下角选择添加的设备，按住CTRL键并且鼠标左键选中点击，就可以连续添加，添加完成之后，esc键退出模式。</p>
<img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022222418571.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022222418571.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="集线器连接的四台主机" style="zoom:50%;">

<p>此处，使用通用集线器连接了四台主机，在线缆的选择中，一般的选择自动类型会容易的多。</p>
<h3 id="配置主机IP"><a href="#配置主机IP" class="headerlink" title="配置主机IP"></a>配置主机IP</h3><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022222625806.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022222625806.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="主机界面" style="zoom:50%;">

<img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022222637730.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022222637730.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="IP配置" style="zoom:50%;">

<p>设置好ip之后，很简单的就可以实现几台主机之间的互联，通过ping ip地址的方式。当然这是因为集线器把他们连接到一起的原因。</p>
<h3 id="使用数据包来观察"><a href="#使用数据包来观察" class="headerlink" title="使用数据包来观察"></a>使用数据包来观察</h3><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223314480.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223314480.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="新建一般的分组" style="zoom:50%;">

<p>创建一个数据报，例如从PC7发送到PC9。选择左下角，将事件改为模拟或仿真。观察数据包行为。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223441518.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223441518.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="正在发送数据包"></p>
<p>此处，在发送的时候，无法直接发送，因为源端没有目的端的MAC与IP之间的映射关系，于是需要发送ARP广播请求。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223511271.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223511271.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="发送到集线器"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223544198.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223544198.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="集线器转发到其他主机，其他主机判断会否需要"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223617629.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223617629.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="接受主机响应集线器"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223638528.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223638528.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="集线器转发响应"></p>
<p>数据包信息</p>
<img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223852706.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223852706.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="过程描述" style="zoom:50%;">

<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223955313.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022223955313.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="分组封装"></p>
<h3 id="访问web服务器"><a href="#访问web服务器" class="headerlink" title="访问web服务器"></a>访问web服务器</h3><p>选择一台主机和服务器，简单的使用交叉线连起来，建一个数据报，观察。</p>
<img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225219060.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225219060.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="创建分组" style="zoom:50%;">

<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225444106.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225444106.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="发送到服务器"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225505540.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225505540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="服务器返回响应"></p>
<img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225648185.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225648185.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="web浏览器请求服务器" style="zoom:50%;">

<img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225905053.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225905053.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="最终返回的响应报文内容" style="zoom:50%;">

<img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225944309.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221022225944309.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="最终到达主机的数据报响应信息" style="zoom:50%;">

<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>利用交换机，搭建一个简单的局域网，并且使用DHCP动态分配ip地址。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025120450496.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025120450496.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="DHCP动态分配ip"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025120535597.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025120535597.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="服务器配置"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025120619513.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025120619513.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="DHCP配置，注意保存"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025120804174.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221025120804174.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="DHCP自动分配"></p>
<h3 id="静态路由实现网络互通"><a href="#静态路由实现网络互通" class="headerlink" title="静态路由实现网络互通"></a>静态路由实现网络互通</h3><p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194556839.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194556839.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="网络拓扑"></p>
<p> 在拓扑结构之中，路由器的接口可以简单的看做是一台设备，路由器的作用是连接网络，做的是网络与网络之间的连接。</p>
<p>上述的拓扑图中，三台路由器组成的环路，此时三台主机是无法彼此通信的。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026193448137.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026193448137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="路由器1的路由表"></p>
<p>如图路由表中只有pc0网络的信息。</p>
<p>此时，在拓扑图中，设备之间端口正常开启，但是PC之间还是无法通信，因为默认的，路由只知道和自己直接连接的设备信息，如同PC0想要连接PC1，但是发送的报文到达路由器1之后，路由器1无法解析出PC1所在的网段在哪里，因此返回发送失败。</p>
<p>对此，我们可以手动的配置静态路由来更新路由表来解决。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194022409.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194022409.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="添加静态路由"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194042809.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194042809.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="命令行形式"></p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194102186.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194102186.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="此时路由器1的路由表"></p>
<p>但仅仅配置了路由器1，只能保证数据报文到达PC1，但是PC1需要返回一个响应，因此还需要配置路由器0。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194237303.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194237303.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="路由器0添加静态路由"></p>
<p>发送ICMP数据报或者ping对方主机，发现网络互通。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194815825.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026194815825.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="连接成功"></p>
<h3 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h3><p>这是一个基于RIP路由向量选择的协议，总的来说，他需要和路由器直连的网络，然后自行发送请求，获得与路由器相关联的网络信息，保存在路由表之中。类似于路由器自己寻找网段，自动更新路由表。配置较为简单。</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026195021581.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026195021581.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="配置Rip"></p>
<h3 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h3><p>这也是一类路由选择协议，和RIP不同，这是基于链路的协议，重点在于以邻居链表为前提生成最短路径树更新路由表。</p>
<p>配置稍复杂</p>
<p><img src="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026195314412.png" class="lazyload" data-srcset="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/image-20221026195314412.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="ospf的配置"></p>
<p>如图，OSPF是一个进程，因此需要进程号，而后，分为主干与枝干，分区域添加网络，注意的是，此时的子网掩码需要取反。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学</title>
    <url>//post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6.html</url>
    <content><![CDATA[<h1 id="高等数学学习笔记"><a href="#高等数学学习笔记" class="headerlink" title="高等数学学习笔记"></a>高等数学学习笔记</h1><p>数学公式显示错误时，可刷新界面。</p>
<p><button onclick="location.reload();">点击刷新</button></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在高等数学里，微积分无疑是极为重要的，但是如果没有函数去研究微积分，这其实很没有意义，在微积分的世界里，函数在参与排行榜绝对排行第一。</p>
<h3 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h3><p>函数是什么？在很多教材或者课外读本上都有规范或者是特殊的定义，我更加喜欢普林斯顿微积分的描述，<strong>函数是将一个对象转化为另一个对象的规则。</strong></p>
<p>这听起来似乎和工厂、程序之类的概念类似，而且一点也不数学。</p>
<p>首先要说的是，函数是一个变换规则，例如f（x），说 “f (x) 是 一个函数”其实是不正确的, 应该说 “f 是一个函数“。</p>
<p>其次，每一个函数都有输入与输出，对于输入而言，应当是有效的，如同f（x） &#x3D; x-2这样函数表达式，如果我们输入一个“人”，这显然没有任何意义。</p>
<p>然后，对于函数而言，如果只有输入而没有输出就会显得毫无意义，因此，<strong>一个函数必须给每一个有效的输入指定唯一的输出。</strong></p>
<h3 id="区间表示"><a href="#区间表示" class="headerlink" title="区间表示"></a>区间表示</h3><p>我们在说明输入的有效与输出的范围时，会使用定义域与值域，但实际上，在普林斯顿里，还有上域与下域的说法。在描述这样的范围时，区间的表示会让我们做的更好。</p>
<p>我们约定 [a, b] 是指从 a 到 b 端点间的所有实数, 包括 a 和 b。类似这样的称作闭区间。 如果你不想包括端点, 把方括号变为圆括号就行了，这样的成为开区间，当然如果你想包含一边又不要一边的端点，你就可以一边方括号一边圆括号，这样的就是半开区间。</p>
<h3 id="求定义域"><a href="#求定义域" class="headerlink" title="求定义域"></a>求定义域</h3><p>很多时候，函数的定义会包括定义域，但是有些时候，函数的定义域没有给出，通常，定义域包含实数集R以及尽可能多的部分。</p>
<p>但是在某些时候，例如负数的平方根，这就会出现问题，它的定义域一定是非负数。</p>
<p>还有一些常见的情况：</p>
<p>分数的分母不能为0。（tan 90不成立）</p>
<p>不能取一个负数的偶次方根。</p>
<p>不能取到一个负数或者是0的对数。</p>
<h3 id="求值域"><a href="#求值域" class="headerlink" title="求值域"></a>求值域</h3><p>如果可以，我们将一个函数画出图像后，我们会发现，无论是定义域还是值域似乎都变得容易起来，我们甚至还可以从图像上观察出最值，变化趋势等等很多的内容。</p>
<p>函数的值域，在我们画出图像后，我们不妨假设此此刻有左右的光束射入光束，而后在y轴上留上影子，这个影子的并集就是值域。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802150538282.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802150538282.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="普林斯顿微积分图1-1" style="zoom:33%;">

<p>感谢普林斯顿，在看到这一幅图的时候，想必你对某些教材上关于函数与映射的描述也能清晰几分。</p>
<p>检验函数成立</p>
<p>上面的例子里，我们用横线来模拟光照得到了值域，如果我们使用竖线呐？</p>
<p>这很帮助我们确定函数是否成立。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802150809227.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802150809227.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220802150809227" style="zoom:33%;">

<p>如图的画，我们发现对于某些竖线，圆与它有超过一个以上的交点，这就违反了函数中，一个输入得到唯一输出的原则。</p>
<h3 id="反函数"><a href="#反函数" class="headerlink" title="反函数"></a>反函数</h3><p>对于函数而言，你给一个输入就可以得到一个输出，前提是在定义域与值域之内。如果我们把过程倒过来，你选一个输出，那么说明样的输入能得到这个输出呐？</p>
<p>这其实就是一个逆转变换的过程，从输出出发，发现一个新的函数，这个函数就是原函数的反函数。f<sub>-1</sub>这就是他的写法。</p>
<p>对于这样的情形有一些总结：</p>
<p>反函数的定义域和原函数的值域相同.</p>
<p>原函数的定义域和反函数的值域相同。</p>
<p>反函数更加像是原函数的撤销按钮，从x出发你可以得到y，从y出发，你可以逆转这个过程，重新得到x。</p>
<p>但是并不是所有的原函数都可以得到反函数的。</p>
<p>我们知道函数成立的基本条件就是，一个输入得到一个唯一确定的输出。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802151604787.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802151604787.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220802151604787" style="zoom:50%;">

<p>如上的函数，我们通过他的图像不难发现，一个输出对应了两个输入。</p>
<p>如果对于他的定义域不加以限制，那么反函数就会出现一个输入对应两个输出的情况。</p>
<p>对于什么样的函数能得到反函数，可以使用水平线的方式检验。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802151750935.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802151750935.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220802151750935" style="zoom:33%;">

<p>如上，每一条水平线与函数至多只有一个交点，那么这样的函数就可以得到反函数。</p>
<h3 id="求反函数"><a href="#求反函数" class="headerlink" title="求反函数"></a>求反函数</h3><p>这看起来似乎很困难，但其实只要得到表达式，我们根据表达式，直接解出x就好了。</p>
<p>在图像上，反函数其实类似于镜面反射，在坐标轴中，这个镜面指的就是y&#x3D;x这一第一、第三象限的分界线。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802152103114.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802152103114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220802152103114" style="zoom:33%;">

<p>限制定义域</p>
<p>这是为了没有通过水平线检验的函数准备的，通过限制定义域的方式，相当于擦去了一部分图像，来得到反函数。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802152244347.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220802152244347.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220802152244347" style="zoom:33%;">

<p>但是要注意原函数限制了定义域，那么反函数的值域也就得到了限制。</p>
<p>反函数的反函数</p>
<p>既然反函数是对原函数的撤销，那么反函数的反函数其实就是原函数，但是要注意定义域。</p>
<h3 id="复合函数"><a href="#复合函数" class="headerlink" title="复合函数"></a>复合函数</h3><p>有一个表达式为 g(x) &#x3D; x<sub>2 </sub>的函数g。 你可以将 x 替换成任何使函数有意义的对象，这样的复合函数可能包含两个或者更多的基本函数。</p>
<p>复合函数有一个很简单也很重要的例子，将函数f(x)&#x3D;x<sub>2</sub>和函数g(x)&#x3D;x-a(a是常数)进行复合。这时得到的函数在形状上看起来与函数f是一样的，只不过是原函数图像向右平移了a个单位。（假设，向左平移3个单位与向右平移-3个单位是一样的。）</p>
<h3 id="奇函数和偶函数"><a href="#奇函数和偶函数" class="headerlink" title="奇函数和偶函数"></a>奇函数和偶函数</h3><p>有的函数在图像上具有对称的特性，这很方便对他们进行讨论。</p>
<p>偶函数的图像关于y轴对称，而奇函数关于原点有180<sub>o</sub>对称</p>
<p>研究函数<br>$$<br>y &#x3D; x^n<br>$$<br>，我们发现当n为奇数时，函数图像虽然各不相同，但是总是关于原点对称，n为偶数时，函数图像总是关于y轴对称。</p>
<h3 id="线性函数"><a href="#线性函数" class="headerlink" title="线性函数"></a>线性函数</h3><p>形如，mx+b的函数就是线性函数，这个名字的来源就是他们的图像是直线，直线的斜率是m，b是y轴的截距。</p>
<h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><h4 id="1、多项式（二次函数）"><a href="#1、多项式（二次函数）" class="headerlink" title="1、多项式（二次函数）"></a>1、多项式（二次函数）</h4><p>$$<br>f(x) &#x3D; a_nx^n + a_{n-1}x^{n-1} + \cdots + a_1x + a_0<br>$$</p>
<h4 id="2、有理函数"><a href="#2、有理函数" class="headerlink" title="2、有理函数"></a>2、有理函数</h4><p>有理函数是指一个多项式除以另一个多项式的形式。<br>$$<br>f(x) &#x3D; \frac{p(x)}{q(x)}<br>$$<br>有理函数的定义域由分母确定，即在分母等于 0 的点处有定义域限制。</p>
<p>有理函数的图像可能包含垂直渐近线和水平渐近线，因为在某些点上有理函数可能无限接近于某个数值或无限增长。</p>
<h4 id="指数和对数函数"><a href="#指数和对数函数" class="headerlink" title="指数和对数函数"></a>指数和对数函数</h4><p>$$<br>f(x) &#x3D; a^x<br>$$</p>
<p>数函数的图像通常是一个增长或衰减非常快的曲线。当 a&gt;1 时，函数增长得非常快；当 0&lt;a&lt;1 时，函数衰减得非常快。</p>
<p>对数函数是指数函数的反函数。<br>$$<br>f(x) &#x3D; \log_a x<br>$$<br>对数函数的定义域是<br>$$<br>(0, \infty)<br>$$<br>，值域是<br>$$<br>(-\infty, \infty)<br>$$<br>。对数函数的图像通常是一个缓慢增长或下降的曲线，且它与指数函数的图像在 y&#x3D;x 的直线上对称。</p>
<p>需要注意的是，当底数 a 等于自然常数<br>$$<br>e \approx 2.71828<br>$$<br> 时，指数函数<br>$$<br>e^x<br>$$<br> 称为自然指数函数，对数函数<br>$$<br>\ln x<br>$$<br> 称为自然对数函数。</p>
<h4 id="带有绝对值的函数"><a href="#带有绝对值的函数" class="headerlink" title="带有绝对值的函数"></a>带有绝对值的函数</h4><p>$$<br>f(x) &#x3D; |x|<br>$$</p>
<p>它表示的是 x 的绝对值，即无论 x 是正数还是负数，它的函数值总是非负数。对于正数 x，|x| &#x3D; x，对于负数 x，|x| &#x3D; -x。</p>
<p>有一个看待绝对值函数的方法是，他表示数轴上0和x之间的距离。</p>
<p>绝对值函数的图像是一条 V 形的曲线，过原点，并且它在 x 轴左侧和右侧的斜率分别为 -1 和 1。</p>
<p>需要注意的是，绝对值函数并不是光滑函数，即它在 x&#x3D;0 处不可导。</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p> 弧度是一个角度的度量单位，它是一种用弧长来度量角度大小的方式。</p>
<p>在一个圆的周长上选取一个弧段，如果这个弧段长度等于该圆半径的长度，那么这个弧段所对的圆心角就称为一个弧度。通常用符号<br>$$<br>\theta<br>$$<br> 来表示一个角度的弧度值。</p>
<p>由于圆的周长是<br>$$<br>2\pi r<br>$$<br>，所以圆心角度数为<br>$$<br>360^\circ<br>$$<br> 的弧长为 $2\pi r$，所以一个圆心角度数为<br>$$<br>360^\circ<br>$$<br> 的角对应的弧度值为<br>$$<br>2\pi<br>$$<br>。因此，我们可以用以下公式将角度转换为弧度：<br>$$<br>\theta &#x3D; \frac{\pi}{180} \times \text{度数}<br>$$<br>类似地，我们也可以用以下公式将弧度转换为角度：<br>$$<br>\text{度数} &#x3D; \frac{180}{\pi} \times \theta<br>$$</p>
<h2 id="微积分概念"><a href="#微积分概念" class="headerlink" title="微积分概念"></a>微积分概念</h2><p>微积分到底是什么？</p>
<p>微分与积分的关系是什么？</p>
<p>回想高数的学习历程，最后发现好像对于微积分来说，除了课本上习题册上的题目，其他的我就完全不知道了，甚至于再过些时间，这些题目我也做不了了。</p>
<p>我的看法是，当我们学习或者是掌握了一门学科或者是一门技术之后，我们应当对它有提纲挈领的认知。</p>
<p><strong>微积分关心的是瞬时的情况。</strong></p>
<p>首先，让我们来看一个实际例子，我们用最常见的时间、速度、路程函数。</p>
<p>假设，一辆汽车，当然也可以是一个人或者你想要假设的任何东西，现在它以20km每小时的速度向前行驶，三个小时过后。让我们看看时间与速度、时间与路程的关系。</p>
<p>时间与速度：</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624144454251.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624144454251.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="时间与速度" style="zoom:33%;">

<p>时间与路程：</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624144804969.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624144804969.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="时间与路程" style="zoom:33%;">

<p>如上，我们得到了时间与速度的关系，时间与路程的关系。</p>
<p>如果我们再试着想象一下，速度如果不是匀速？</p>
<p>时间与速度：</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624145428032.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624145428032.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="时间与速度" style="zoom:33%;">

<p>时间与路程：</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624150325333.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624150325333.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220624150325333" style="zoom:33%;">

<p>虽然在图像上，好像两个路程函数看起来差不多，但是从y轴，也就是distance的值上，我们明显的感觉到，因为速度的变化，路程函数发生了变化。</p>
<p>同样的，如何我们改变路程函数，那么速度函数也会发生改变。</p>
<p>而微积分研究的本质上就是两个函数的关系。</p>
<p>其中从速度到路程，是积分的过程，而从路程到速度，是微分的过程。</p>
<p>或者说，我们再举一个例子。</p>
<p>当你出生的时候，你的年龄为0岁，这时候你大概有10公斤，当然我也不知道，瞎编了一个数字。而后当你10岁的时候，你已经37公斤了，当你18岁的时候，你已经49公斤了，而后等你30岁的时候，你已经59公斤了，此时你来到你人生体重最高点，再往后，50岁的时候，你就只有58公斤了，一直到62岁，你就只有52公斤了。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624151515813.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624151515813.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220624151515813" style="zoom:33%;">

<p>如图，简单的把以上提到的点描成这样的图。</p>
<p>那么？新的问题来了，能否根据它得出体重的增长率呐？</p>
<h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>关于导数，首先应该区分开一个概念。</p>
<p>那就是可导与可微，前者表示的是变化率的极限，而后者表示的是局部线性化。</p>
<p>导数和微分是紧密相关的概念，但并不是完全一样的概念。导数是函数在某一点处的变化率，也就是函数值的增量与自变量值的增量之比，它表示的是函数在某一点处的瞬时变化率。而微分则是对函数进行局部线性近似的一种方法，它用切线来近似曲线，从而得到函数在某一点处的变化情况。</p>
<p>可以说，导数是微分的结果，也就是函数在某一点处的局部线性近似斜率。微分的本质是用线性函数逼近非线性函数，即把非线性函数局部线性化，这样就可以利用线性函数的性质来分析非线性函数的性质。</p>
<p>斜率，如果你还记得他，那么再好不过。</p>
<p>在生活中，我们用斜率来表示倾斜角度，回到函数图像上，其实他也同样如此。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624155740453.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624155740453.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220624155740453" style="zoom:33%;">

<p>如图，这是函数x<sub>2</sub>的函数图像。</p>
<p>这样的曲线，我们是如何求斜率的呐？</p>
<p>如果这不是曲线，而是直线，例如y &#x3D; 2x呢。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624155958257.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624155958257.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220624155958257" style="zoom:33%;">

<p>我们直接利用垂直距离差比上水平距离差，就可以解出斜率。</p>
 <img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624192633829.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624192633829.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220624192633829" style="zoom:33%;">

<p>这时候，∆y与∆x的比值，也就是θ角的正切就是斜率。</p>
<p>再次回到曲线的问题，只看x轴右半轴，假设这是一个表示路程的函数，那么在这里我们就可以得到任意的时间段内，这个车或者是其他的什么东西在这个时间段内的平均速度，这很简单，还未涉及微积分。<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624195456195.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624195456195.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220624195456195" style="zoom:33%;"></p>
<p>那么这段时间的速度，我们就应该用路程差比时间差，反应在图像中，就是垂直距离差比水平距离差。</p>
<p>微积分只关心瞬时情况，不如我就从x &#x3D; 0这一点开始，当x&#x3D;0的时候，这一点的斜率是怎么样的？</p>
<p>x &#x3D; 0，y &#x3D; 0.这是原点，可以发现此时虽然曲线依然在上升，但是有点像是刚刚起步，此时速度为0，因此这一点斜率为0，曲线水平。</p>
<p>实际上，求最低点也是微积分的主要应用之一，通过求斜率为0，可以求出最低点，这一点不上升也不下降，斜率为0。</p>
<p>这时，我们可以选一个离原点距离极小的点，标记为∆x，这个∆单纯的就是为了表示“小”的意思，他代表一个极小极小的变化。那么这时候从原点到∆x这一小段的平均速度是多少？平均斜率？</p>
<p>水平距离是∆x，曲线是简单的x<sub>2</sub>,垂直距离很明显。</p>
<p>平均斜率还是垂直比水平。即∆y &#x2F; ∆x</p>
<p>虽然∆x已经非常非常小了，但是这里他依旧是平均值，我想让他减少到0，取极限，让这一段不断的减小，从而无限接近某个瞬间的情况，这样就能得到斜率，这样就能得到0点处的斜率。</p>
<p>这里的情形很简单，可以看到∆x<sub>2</sub> &#x2F; ∆x的比值∆x会非常的小。因此平均斜率非常之小，沿着这种逐渐变小的思路，我将得到x &#x3D; 0处的瞬时斜率。</p>
<p>让∆x逐渐减小，最后到0。</p>
<p>相当于行驶从静止开始，然后慢慢加速，这时候斜率很明显就不是0了。</p>
<p>来看一下任意点的斜率。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624193632932.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220624193632932.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:33%;">

<p>微积分的要义，取一小段距离∆x,移动到x+∆x处，这样的y就会移动到曲线上另外一点，这一点的值为y + ∆y或者是（x+∆x）<sub>2</sub>,因为此时的曲线还是y &#x3D; x<sub>2</sub></p>
<p>此时的水平距离与垂直距离各自是∆x与∆y。</p>
<p>此时的∆y 比 ∆x应当为 (（x+∆x）<sub>2</sub> - x<sub>2</sub>)  &#x2F;  ∆x</p>
<p>继续进行代数运算，我们得到了2x+∆x的结果，也就是说，此时的∆y比∆x的结果为2x + ∆x。</p>
<p>当然，到目前为止，这依然是小范围的平均值，还不是瞬时的情形。</p>
<p>当微积分开始介入，dy &#x2F; dx。</p>
<p>如果说前面是小 &#x2F; 小，那么这就是极小 &#x2F; 极小。</p>
<p>这里的d，小的可以说已经无法分辨，小的已经无法把dy或者dx作为分开距离来考虑。</p>
<p>要注意，这里其实不是真正的除法了，因为在除法中，是不允许0 &#x2F; 0的。而此处的0 &#x2F; 0其实就是上面这种情况（∆y &#x2F; ∆x）的极限。</p>
<p>这就是从代数走进微积分最关键的一步，这就得到了某一点上的瞬时情形。</p>
<p>再看上面的结论，取∆x趋近于0，那么结果就是2x。</p>
<p>因此最终的结论是，导数为2x。</p>
<p>因此这就是我们所说的函数二，也就是斜率函数，或者说是速度函数。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625174451687.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625174451687.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220625174451687" style="zoom:33%;">

<p>再来看，此时如果我们取（1,1）与（2,4）这两个点来讨论斜率。</p>
<p>那么自然而然的就会得到，斜率为3.</p>
<p>但实际上，这只是一条弦，这里跳了一大步。</p>
<p>我们在讨论∆x时，只是前进了一小步，更别说趋近于0时的dx了，这就成了无限小的一步。</p>
<p>因此实际的斜率，可以认为是过某一点的切线。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625175138540.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625175138540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220625175138540" style="zoom:33%;">

<p>那么这一点的斜率，实际上就是把x &#x3D;1 代入到我们的斜率函数也就是2x里。</p>
<p>因为我们可以通过斜率判断函数图像的走向，当斜率为负时，函数呈现下降趋势，当斜率很大的时候，函数图像往往更加陡峭，反之，当斜率为正时，函数图像成上升趋势，斜率很小的时候，函数图像更加平滑。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625204426879.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625204426879.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220625204426879" style="zoom:33%;">

<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625204433564.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625204433564.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220625204433564" style="zoom:33%;">

<p>这是sinx与cosx的函数图像，当然可能坐标轴有些陌生。</p>
<p>sinx的导数是cosx，那么比较这两个图像，增长，下降，快，慢，极大值，极小值。这些都体现了导数的重要性和实用性。</p>
<h2 id="二阶导数与极值"><a href="#二阶导数与极值" class="headerlink" title="二阶导数与极值"></a>二阶导数与极值</h2><p>二阶导数：也就是导数的导数。</p>
<p>在实际中，很少提到导数的导数，或者说更加高阶的导数，但是二阶导数对于处理极大、极小值时作用很大。</p>
<p>我们经常需要定位极值点，并且判断是极大值还是极小值。</p>
<p>定位极值点是一阶导数的职责，一阶导数为0的点就是极值点，如果函数存在极大值或者是极小值，要找到这个极值点的位置，就可以通过导数&#x3D;0来寻找，此时函数图像趋于水平，根据它向下还是向上弯曲，得到极大值或者是极小值。</p>
<p>而判断极值点是极大值还是极小值就是二阶导数的职责了。</p>
<p>二阶导数表明，函数朝上还是朝下弯曲。</p>
<p>原函数，导函数，二阶导函数，现在的函数组就扩充为三个。</p>
<p>回到实际问题，依旧是路程，时间，速度的关系，二阶导函数其实表示的就是加速度。</p>
<p>我们知道路程求速度，只需要求导数就可以了，现在我们要求速度的导数，也就是二阶导数，加速度，也就是速度的变化率，加速或者减速的率。</p>
<p>先来看看x<sub>2</sub>的原函数，导函数与二阶导函数。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625210639471.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625210639471.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220625210639471" style="zoom:33%;">

<p>依旧是x<sub>2</sub>，表示函数高度，2x表示斜率，而2表示二阶导数，表示弯曲性，这表明斜率正在逐渐增加，函数图像向上弯曲。</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625211737687.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220625211737687.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220625211737687" style="zoom:33%;">

<p>在看看sinx的原函数、导函数与二阶导函数的图像。</p>
<p>事实上，图像上包含的信息可比说的信息多的多了，在0-π&#x2F;2区间内，我们发现，sinx的二阶导数小于0的，也就是说此时的原函数向下弯曲，导函数应当呈现下降趋势。</p>
<p>引入“凹凸”的概念，事实上，我个人觉得，向上弯曲与向下弯曲的描述比凹凸更好。</p>
<p>sinx就是一个很经典的例子，在图像中，我们发现0-π&#x2F;2区间内，即使图像向下弯曲，但是同样呈现在不断增长。</p>
<p>原函数 导函数 二阶导函数的关系也明了了。</p>
<p>二阶导函数大于零，表示导函数上升，毕竟对于导函数来说，二阶导数就是它的导数，原函数向上弯曲，反之。</p>
<p>x &#x3D; π时，二阶导数变号了，而此时原函数开始向上弯曲。这个点就是拐点，二阶导数为0的点。</p>
<p>拐点意味着，二阶导数穿过0，即原函数的图像弯曲性发生改变。这一点在图像里很重要，当然没有极大值和极小值那么显眼。</p>
<p>y &#x3D; x<sub>3</sub> - x<sub>2</sub> </p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220705145615431.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220705145615431.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220705145615431" style="zoom:33%;">

<p>首先求导：3x<sub>2</sub>-2x ,二阶导数：6x -2</p>
<p>极值点：令一阶导数为0，将所有的极值点一网打尽，之后通过二阶导数判断极大值与极小值。</p>
<p>那些点上，函数停止住了，既不上升，也不下降</p>
<p>在图像上，很容易找到，代数也很容易求出，一元二次方程的两个解。</p>
<p>不同的是，看图像很容易得到极大值与极小值，之所以不是最值，是因为图像明显的，会在x趋近于正无穷时，趋近于正无穷，因为该点只在其附近（领域内）是最大值，因此称作极大值或者局部最大值。极大值处会有什么性质？</p>
<img src="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220705150148722.png" class="lazyload" data-srcset="/post/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/image-20220705150148722.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220705150148722" style="zoom:33%;">

<p>x &#x3D; 0处，此时明显的，斜率应该为0，二阶导数为-2，此时二阶导数表示，图像向下弯曲，即凸。因此，此处是极大值而不是极小值。</p>
<p>另一个极值点，x &#x3D; 2&#x2F;3处，斜率为0，二阶导数为2，此时二阶导数表示图像向上弯曲，即凹，因此此处是极小值点。当然它也不是最小值，导数只能解释点周围很小很小范围内（领域内）的情况，这一点的导数无法连接，函数左会无限下降，函数右会无限上升。</p>
<p>知道函数后就能求出极大值点和极小值点，但最好还能找到拐点（弯曲方向变化的分界点）。</p>
<p>令二阶导数为0，或者通过图像，得出当x &#x3D; 1&#x2F;3的时候，这是一个拐点。</p>
<p>现在，就基本上找齐了函数上的所有特殊点，这些点其实都是有实际意义的。</p>
<p>假设你是一个经济学家，你正在分析某个地区的经济统计数据，你发现曲线的斜率一直为负，即经济一直在不断的下降，但是突然你发现近两年有经济复苏的现象，因为此时的图像向上弯曲，即二阶导数为正，数据虽然继续下降，但是速度开始变慢，在某一点上，到达最低点，触底反弹，一定是拐点后某一点。</p>
<p>极值点，可以说是导数最重要的应用之一，设导数为0，找到极大值和极小值点，微积分里大多数应用问题都要令导数等于0。</p>
<h2 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h2><p>y &#x3D; e<sub>x</sub></p>
<p>这种函数用代数的方法无法建立，只有用微积分才能得到，因为要得到e<sub>x</sub>，要用到一些极限的步骤， 有些量趋于0，有些量趋于无穷。虽然有各种方法来得到e的x次方，但这些方法都会涉及极限的过程。</p>
<p>而对于极限</p>
<p>指数函数最重要的性质就是，指数函数的导数等于函数本身的常数倍，这就是指数函数与众不同的地方。<br>$$<br>\frac{d}{dx}a^x &#x3D; a^x\ln a<br>$$<br>对于指数函数，y &#x3D; dy &#x2F; dx</p>
<p>这其实就是一个简单的微分方程，同时包含函数和函数导数。</p>
<p>首先，任何数的0次方都等于1，因此指数函数从1开始。</p>
<p>y(x) &#x3D; 1</p>
<p>此时 dy &#x2F;dx &#x3D; 1</p>
<p>反推，y(x) &#x3D; 1 +x时，导数为1。</p>
<p>为了确保微分方程相等，dy &#x2F; dx &#x3D; 1+x</p>
<p>此时，y（x）&#x3D; 1 + x + x<sub>2</sub>&#x2F;2</p>
<p>以此类推，好像让微分方程成立，即两者相等是不可能的，除非两个方程无限，这里也确实无限。</p>
<p>直接写出n次之后的结果</p>
<p>y(x) &#x3D; 1+x+x<sub>2</sub>&#x2F;2 + x<sub>3</sub> &#x2F; 3 * 2 + …. + x<sub>n</sub>&#x2F;n(n-1)(n-2)…(1)+…</p>
<p>dy &#x2F;dx &#x3D; 1+x+x<sub>2</sub>&#x2F;2 + x<sub>3</sub> &#x2F; 3 * 2 + …. + x<sub>n-1</sub>&#x2F;(n-1)！+x<sub>n</sub> &#x2F; n!+ …</p>
<p>简单的说，n！的增长速度太快了，远远超过了x<sub>n</sub>，因此实际上，在末尾的项，这些量会变得极其的小。这个级数会趋于一个极限，不会因为加了很多项而无限变大。</p>
<h2 id="积分总览"><a href="#积分总览" class="headerlink" title="积分总览"></a>积分总览</h2><p>一般地，我们说积分是与求导相逆的运算，也就是说这两个概念是相对的。</p>
<p>导数是函数变化率的一种度量，表示函数在某一点处的瞬时变化率；积分则是导数的逆运算，是在一段区间内的函数面积或曲线长度的计算，可以看作是对函数的累积求和。</p>
<p>其中关于面积的计算</p>
<p>对于一个函数 f(x)，在区间 [a, b] 上的面积可以近似地用若干个矩形的面积之和来计算。</p>
<p>如果将区间 [a, b] 分成 n 个小区间，每个小区间的长度为<br>$$<br>\Delta x &#x3D; \frac{b - a}{n}<br>$$<br>，则第 i 个小区间的左端点为<br>$$<br>x_i &#x3D; a + i \Delta x<br>$$<br>，右端点为<br>$$<br>x_{i+1} &#x3D; a + (i+1)\Delta x<br>$$<br>。在区间<br>$$<br>[x_i, x_{i+1}]<br>$$<br>上，可以用<br>$$<br>f(x_i)<br>$$<br> 或者<br>$$<br>f(x_{i+1})<br>$$<br> 来代表 f(x) 的值。因此，区间<br>$$<br>[x_i, x_{i+1}]<br>$$<br>上的矩形面积为<br>$$<br>f(x_i) \Delta x<br>$$<br> 或者<br>$$<br>f(x_{i+1}) \Delta x<br>$$<br>。将所有小矩形的面积相加即可得到函数在区间 [a, b] 上的近似面积 ：<br>$$<br>S \approx \sum_{i&#x3D;0}^{n-1} f(x_i) \Delta x<br>$$<br>当 n 趋近于无穷大时，小矩形的宽度趋近于无穷小，可以得到函数在区间 [a, b] 上的确切面积 A：<br>$$<br>A &#x3D; \lim_{n \to \infty} \sum_{i&#x3D;0}^{n-1} f(x_i) \Delta x &#x3D; \int_a^b f(x) dx<br>$$<br>其中，<br>$$<br>\int<br>$$<br> 表示积分符号，dx表示对 x进行积分。</p>
<p>曲线长度的计算</p>
<p>曲线长度指的是一个平面曲线的长度，也被称为弧长。在微积分中，曲线长度的计算可以使用积分来实现。假设我们有一个函数<br>$$<br>y &#x3D; f(x)<br>$$<br>，其定义域为区间 [a, b]。如果我们想要计算从 a到 b 的曲线长度，我们可以将曲线划分为许多小线段，每个小线段的长度可以用勾股定理求得。我们可以将每个小线段的长度相加，得到曲线的近似长度。为了得到更准确的结果，我们需要使用更小的线段来逼近曲线。将线段长度无限小的极限值称为弧长，可以用以下公式计算：<br>$$<br>L &#x3D; \int_a^b \sqrt{1 + \left(\frac{dy}{dx}\right)^2} dx<br>$$<br>其中<br>$$<br>dy&#x2F;dx<br>$$<br> 表示函数在每个点处的导数。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
</search>
