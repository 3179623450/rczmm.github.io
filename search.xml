<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>String类</title>
    <url>/2021/07/27/String%E7%B1%BB/</url>
    <content><![CDATA[<p>String 类</p>
<p>string在实际开发中，几乎是一个必须使用的程序类，也可以说是项目的核心组件类。</p>
<p>string用“”双引号定义，可以用+实现字符串连接。</p>
<p>1、string类对象实例化</p>
<p>java中基本数据类型不包含string，但是考虑到程序开发的实际需要，就设计了string类，并且这个类的对象可以直接赋值进行实例化。</p>
<p>java程序中使用双引号定义的内容，都是字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class String</span><br><span class="line"></span><br><span class="line">private final byte[] value</span><br></pre></td></tr></table></figure>

<p>jdk8 保存的是字符数组，jdk9之后字符串源代码实现就是字节数组。</p>
<p>我们可以得出一个结论，string就是对数组的特殊包装应用，而对数组而言最大的问题是长度的固定。</p>
<p>string本身是一个系统类，除了可以赋值进行对象实例化之外，还可以使用相关的构造方法来进行对象实例化。</p>
<p>string类构造方法(之一)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String(String original) &#123;</span><br><span class="line">    this.value = original.value;</span><br><span class="line">    this.coder = original.coder;</span><br><span class="line">    this.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    String str02 = new String(&quot;2222&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，两种定义方式，看起来效果几乎完全一样，但实际上两者是有本质差别的。</p>
<p>字符串比较</p>
<p>如果是基本数据类型，在java中，可以使用==比较运算符直接进行比较。</p>
<p>但是string属于引用数据类型，他的对象名中保存的是堆内存地址，string对象使用==比较的就不再是内容，而是堆内存地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    String str03 = &quot;1111&quot;;</span><br><span class="line">    String str02 = new String(&quot;1111&quot;);</span><br><span class="line">    System.out.println(str02==str01);</span><br><span class="line">    System.out.println(str03==str01);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于自定义类的比较，和字符串一样，都是比较的堆内存地址。</p>
<p>在string类里，提供了equals（）方法来比较字符串内容（区分大小写）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object anObject)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    String str03 = &quot;1111&quot;;</span><br><span class="line">    String str02 = new String(&quot;1111&quot;);</span><br><span class="line">    System.out.println(str01.equals(str02));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure>



<p>字符串常量</p>
<p>常量就是不会修改的内容。</p>
<p>字符串常量，严格意义上说是string类的匿名对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    System.out.println(&quot;1111&quot;.equals(str01));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中的普通方法只有对象能调用，所以我们说字符串常量是string类的匿名对象。</p>
<p>所谓的直接赋值的操作，实际上就是给匿名对象一个名字而已。</p>
<p>区别：string类的匿名对象是系统自动生成的，不再由用户自己创建。</p>
<p>实际问题——字符串比较：</p>
<p>如果我们要获取用户输入，然后进行字符串比较，但是用户没有输入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String input = null;</span><br><span class="line">    if (input.equals(&quot;baidu&quot;))&#123;</span><br><span class="line">        System.out.println(&quot;www。baidu.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></pre></td></tr></table></figure>

<p>解决途径：（回避）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String input = null;</span><br><span class="line">    if (&quot;baidu&quot;.equals(input))&#123;</span><br><span class="line">        System.out.println(&quot;www。baidu.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中直接调用了字符串常量“baidu”来执行。equals方法，因为字符串<strong>常量</strong>是string对象，所以永远不可能是null，而equals方法的参数又是object，因此这就避免了空指针异常。</p>
<p>两种实例化方式的比较：</p>
<p>1、直接赋值：</p>
<p>在堆内存中开辟一块地址，保存字符串常量，并且栈内存直接引用这一部分的堆内存。</p>
<p>而且，对同一字符串的多次直接赋值还可以实现对堆内存的重复利用。也就是说采用直接赋值的方式进行string对象实例化，在内容相同（字符串常量一致）的情况下，不会开辟新的堆内存空间，而会直接指向已有的堆内存。</p>
<p>字符串对象池</p>
<p><strong>jvm的底层的存在一个对象池</strong>（string只是对象池中的一种类型），当我们使用直接赋值的方式定义了一个string对象之后，字符串所使用的匿名对象入池保存，如果后面我们还有string对象直接赋值定义，并且采用了同一块字符串常量，也就是内容相同，那么就不会开辟新的堆内存空间，而是使用已经有的对象进行引用的分配。</p>
<p>共享设计模式的应用：（如果有一天，你需要一把剪刀，你出去买了一把，用完之后不可以丢掉，放在家里，等下一次用的时候再继续使用，剪刀放在工具箱里，同样工具箱的东西都可以下一次继续使用）</p>
<p>构造方法实例化：</p>
<p>如果要明确的调用string类的构造方法进行实例化string对象，那么一定要使用new关键字，而每当使用new关键字时，就会开辟新的堆内存空间。而这块堆内存的内容就是构造方法传入的字符串常量。</p>
<p>构造方法定义时：传入的字符串常量会创建一个匿名对象，然后new关键字会开辟一块堆内存空间，也会传入一个字符串常量。那么就相当于一共创建了两块堆内存空间，并且字符串常量也就是匿名对象创建的堆内存只负责实例化string对象，不与构造方法实例化出的string对象有关联。真正使用的堆内存是new开辟的堆内存，而之前定义字符串常量开辟的堆内存空间不会被任何栈内存引用（指向），成为垃圾空间，等待gc回收。</p>
<p>因此，构造方法创建string对象，会开辟两份空间，并且一块空间成为垃圾。</p>
<p>除此之外。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = new String(&quot;mm&quot;);</span><br><span class="line">    String str02 = &quot;mm&quot;;</span><br><span class="line">    System.out.println(str01 == str02);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>使用构造方法定义的string对象不会自动入池保存。</p>
<p>string对象手动入池：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = new String(&quot;mm&quot;).intern();</span><br><span class="line">    String str02 = &quot;mm&quot;;</span><br><span class="line">    System.out.println(str01 == str02);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>所以，实际开发时，尽量的直接赋值定义字符串。</p>
<p>字符串常量池</p>
<p>为了防止字符串过多，jdk进行了结构上的优化。（本质是一个动态对象数组），所有直接赋值的字符串对象都可以自动保存在常量池中，方便下次使用。</p>
<p>静态常量池：</p>
<p>程序（class）在加载（不是运行）时会把字符串、常量、类、方法全部进行分配</p>
<p>运行时常量池：</p>
<p>加载之后，有一些字符串内容是通过拼接的，由于string对象内容可以改变，所以叫做运行时常量池。</p>
<p>字符串修改：</p>
<p>常量的内容一旦被定义就无法修改，但是字符串比较特殊，重新实例化来实现修改字符串内容。</p>
<p>string类关于数据的存储是通过数组，数组本身又是定长的数据类型。实际上就代表了string对象一旦被实例化，内容就无法改变，那么字符串对象内容实际上就是通过改变引用的方式来实现的。</p>
<p>要注意：这样会产生许多的垃圾空间。</p>
<p>主方法组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String [] args) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>public: 一种访问权限、主方法是一切程序的入口，有且只能有一个，一定是公共的。</p>
<p>static：程序的执行是通过类，所以这个方法由类直接调用。</p>
<p>void：主方法是一切程序的起点，程序一旦开始，不需要返回结果。</p>
<p>main：系统定义好的方法名称，当java执行时，自动寻找。</p>
<p>String [] args：字符串的数组，可以实现启动参数的接受。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if (args.length == 0)&#123;</span><br><span class="line">            System.out.println(&quot;please input your argments:&quot;);</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for (String temp:args) &#123;</span><br><span class="line">                System.out.println(temp+&quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java demo04 one 2 3 4 5</span><br></pre></td></tr></table></figure>



<p>string类常用方法：</p>
<p>1、字符数组转字符串（字节等同理）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char [] char01 =new char[]&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;&#125;;</span><br><span class="line">String str01 = new String(char01);</span><br><span class="line">System.out.println(str01);</span><br></pre></td></tr></table></figure>

<p>2、指定范围转换（第二个参数是步长）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char [] char01 =new char[]&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;&#125;;</span><br><span class="line">String str01 = new String(char01,0,3);</span><br><span class="line">System.out.println(str01);</span><br></pre></td></tr></table></figure>

<p>3、获取指定索引的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.charAt(0));</span><br></pre></td></tr></table></figure>

<p>4、大小写转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.toLowerCase());</span><br><span class="line">System.out.println(str01.toUpperCase());</span><br></pre></td></tr></table></figure>

<p>5、截取字符串（开始索引到结束索引）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.substring(0,10));</span><br><span class="line">System.out.println(str01.substring(0));</span><br></pre></td></tr></table></figure>

<p>6、判断是否以指定字符串开头、结尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.startsWith(&quot;12&quot;));</span><br><span class="line">System.out.println(str01.startsWith(&quot;12&quot;,3));</span><br><span class="line">System.out.println(str01.endsWith(&quot;rf&quot;));</span><br></pre></td></tr></table></figure>

<p>7、字符串替换（全部替换，替换第一个）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.replaceAll(&quot;1&quot;,&quot;mm&quot;));</span><br><span class="line">System.out.println(str01.replaceFirst(&quot;3&quot;,&quot;mm&quot;));</span><br></pre></td></tr></table></figure>

<p>………..</p>
<p>java doc文档</p>
<p>这是java官方提供的关于jdk相关api的文档，文档中详细描述了每一个模块中不同的包里不同的类的相关定义和相关说明信息，以及成员属性介绍，包括构造方法普通方法以及其他的说明摘要。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，朋友</title>
    <url>/2021/07/18/hello-world/</url>
    <content><![CDATA[<p>欢迎来到“小小世界”，博主是一名编程爱好者，在这里你将会看到博主总结的宝贵经验、看到博主狼狈的踩坑，如果你是初学者，那么恭喜你，你能得到很良好的体验。</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>io编程</title>
    <url>/2021/08/12/io%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="io编程"><a href="#io编程" class="headerlink" title="io编程"></a>io编程</h1><p>io（input|output，输入|输出）可以实现数据的读取和写入的操作。Java针对io提供了一给工具包。</p>
<h2 id="file文件操作"><a href="#file文件操作" class="headerlink" title="file文件操作"></a>file文件操作</h2><p>file类是一个与文件本身操作有关的类，创建、删除、重命名、取得文件大小、修改日期等常见的系统文件操作。</p>
<h3 id="file类的基本使用"><a href="#file类的基本使用" class="headerlink" title="file类的基本使用"></a>file类的基本使用</h3><p>如果要使用file类则必须提供完整的文件操作路径，对于文件路径的设置可以通过file类的构造方法来完成。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public File(String pathname)</td>
<td>构造</td>
<td>给定一个操作文件的完整路径</td>
</tr>
<tr>
<td>public File(String parent, String child)</td>
<td>构造</td>
<td>规定操作文件的完整路径和子文件名称</td>
</tr>
<tr>
<td>public boolean createNewFile() throws IOException</td>
<td>普通</td>
<td>创建文件</td>
</tr>
<tr>
<td>public boolean delete()</td>
<td>普通</td>
<td>删除文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>普通</td>
<td>判断文件路径是否存在</td>
</tr>
</tbody></table>
<h3 id="file类操作深入"><a href="#file类操作深入" class="headerlink" title="file类操作深入"></a>file类操作深入</h3><p>路径分割符：public static final String separator</p>
<p>文件路径定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;E:&quot;+File.separator+&quot;demo.txt&quot;</span><br></pre></td></tr></table></figure>

<p>file父路径操作方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public File getParentFile()</td>
<td>普通</td>
<td>获取父路径</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>普通</td>
<td>创建指定目录</td>
</tr>
</tbody></table>
<h3 id="获取文件元信息"><a href="#获取文件元信息" class="headerlink" title="获取文件元信息"></a>获取文件元信息</h3><p><img src="/2021/08/12/io%E7%BC%96%E7%A8%8B/image-20210812171347514.png" alt="image-20210812171347514"></p>
<h2 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h2><p><img src="/2021/08/12/io%E7%BC%96%E7%A8%8B/image-20210812171601095.png" alt="image-20210812171601095"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java发展历史</title>
    <url>/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<p>java发展历史</p>
<p><img src="/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/u=593216026,135847718&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>java语言诞生于20世纪90年代，经过长期的发展，已经成为最流行的编程语言之一，java不但广泛应用在服务端编程上，而且各个移动设备也大量使用java平台。</p>
<p>java是sun公司开发出来的一套编程语言，来源于一个green的嵌入式程序项目，目的是为了电子消费产品开发一个分布式代码系统，这样子就可以通过网络对家用电器进行控制。</p>
<p>在green项目最开始，工程师本来是打算c++进行开发，但是考虑到c++语言开发的复杂性，于是就基于c++设计了自己的一套的独立平台oak，这个就被称为是java的前身，是一种用于网络的安全语言，刚好碰到了当时的一个mosaic和netscape项目，这两个项目启发了oak的工程师，于是他们设计了一个hotjava浏览器，触发了java进军互联网，但是由于后来互联网低潮，sun公司被oracle收购。</p>
<p>java是一门综合性的编程语言，从最初设计的时候就考虑了嵌入式系统开发以及企业平台的支持。</p>
<p><img src="/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/u=2578611845,4184638346&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>实际java开发过程之中，主要有三种方向。</p>
<p>java se （java标准开发，包含的主要是语言核心类，（jdbc、接口定义、输入输出、网络io）当用户安装jdk之后，就自动支持java se开发）</p>
<p>java ee（包含了java se部分的类，用于是电子产品的软件开发，但是此类开发已经几乎被安卓替代）</p>
<p>java me（包含se所有类，并且还包含了开发企业级的应用类。（xml、事务控制、jsp、servlet）、也是目前大型系统和互联网项目开发的主要平台）</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java语言特点</title>
    <url>/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[<p>java语言特点</p>
<p>java之所以能广泛的活跃在互联网和电子设备上，主要是因为其开发语言简洁并且有完善的生态系统，是一门优秀编程语言。</p>
<p><img src="/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/u=656404101,826481724&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>java不仅拥有完善的编程体系，同时也收到众多软件厂商的追捧——围绕其开发出来了大量的第三方应用，使得java的技术得以迅速的发展壮大，并且被广泛的应用，在长期的技术发展中，java语言的特性也在不断的提升。</p>
<p>1、简洁有效</p>
<p>克服了c++中所有的难以理解和容易混淆的特点，比如：头文件、指针、结构、单元、运算符重载和虚拟基础类，java更加的严谨、简洁、因此也足够简单。</p>
<p>2、可移植性</p>
<p>一次编写、处处运行。因为java的执行是基于jvm，在源代码编译后形成字节码文件，在不同的os上只需要植入与系统匹配的jvm就可以直接利用jvm的指令集解释程序运行，降低了开发难度，提高了开发效率。</p>
<p>3、面向对象</p>
<p>java是面向对象的语言，并且有着良好的程序结构定义，</p>
<p>4、垃圾回收</p>
<p><img src="/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/u=3964968350,1272502470&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>gc，无用的内存回收，java提供了垃圾回收机制。</p>
<p>5、引用传递</p>
<p>指针的代替品，更加简单。（指针虽然高效，但是需要较强的逻辑分析能力）</p>
<p>6、分布式</p>
<p>java适合网络编程，适合分布式程序开发，socket（套接字），还包括公共网关接口，cgi等，还有包括nio、aio等。</p>
<p>7、健壮性</p>
<p>编译时，有语法检查，异常可以避免错误产生时程序中断运行。</p>
<p>8、多线程</p>
<p>线程是轻量级的进程、juc多线程开发框架。</p>
<p>9、安全性</p>
<p>jvm安全，jdk更新，jvm也能更新。</p>
<p>10、函数式编程</p>
<p>lambda表达式编程</p>
<p>11、模块化支持</p>
<p>拉锯（代码名字）、jdk9之后的功能。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy</title>
    <url>/2021/09/09/numpy/</url>
    <content><![CDATA[<h1 id="numpy（基础篇）"><a href="#numpy（基础篇）" class="headerlink" title="numpy（基础篇）"></a>numpy（基础篇）</h1><p>numpy是一个python的扩展程序库，支持大量的维度数组和矩阵运算，除此之外还为数组计算提供了大量的科学库，运行速度很快，包含了一个强大的多维数组对象ndarray，广播功能函数，整合了c与c++语言的工具，还有线性代数、随机数生成等功能。</p>
<h2 id="numpy是什么？"><a href="#numpy是什么？" class="headerlink" title="numpy是什么？"></a>numpy是什么？</h2><p>NumPy是使用Python进行科学计算的基础软件包。除其他外，它包括：</p>
<ul>
<li>功能强大的N维数组对象。</li>
<li>精密广播功能函数。</li>
<li>集成 C/C+和Fortran 代码的工具。</li>
<li>强大的线性代数、傅立叶变换和随机数功能。</li>
</ul>
<h2 id="numpy两大利器"><a href="#numpy两大利器" class="headerlink" title="numpy两大利器"></a>numpy两大利器</h2><h3 id="利器之一：Ndarray"><a href="#利器之一：Ndarray" class="headerlink" title="利器之一：Ndarray"></a>利器之一：Ndarray</h3><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。ndarray 对象是用于存放同类型元素的多维数组。ndarray 中的每个元素在内存中都有相同存储大小的区域。</p>
<h3 id="利器之二：切片和索引"><a href="#利器之二：切片和索引" class="headerlink" title="利器之二：切片和索引"></a>利器之二：切片和索引</h3><p>ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。</p>
<span id="more"></span>

<h2 id="numpy的主要应用"><a href="#numpy的主要应用" class="headerlink" title="numpy的主要应用"></a>numpy的主要应用</h2><p>NumPy是一个功能强大的Python库，主要用于对多维数组执行计算。NumPy这个词来源于两个单词– <code>Numerical</code>和<code>Python</code>。NumPy提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算。这类数值计算广泛用于以下任务：</p>
<ul>
<li><strong>机器学习模型</strong>：在编写机器学习算法时，需要对矩阵进行各种数值计算。例如矩阵乘法、换位、加法等。NumPy提供了一个非常好的库，用于简单(在编写代码方面)和快速(在速度方面)计算。NumPy数组用于存储训练数据和机器学习模型的参数。</li>
<li><strong>图像处理和计算机图形学</strong>：计算机中的图像表示为多维数字数组。NumPy成为同样情况下最自然的选择。实际上，NumPy提供了一些优秀的库函数来快速处理图像。例如，镜像图像、按特定角度旋转图像等。</li>
<li><strong>数学任务</strong>：NumPy对于执行各种数学任务非常有用，如数值积分、微分、内插、外推等。因此，当涉及到数学任务时，它形成了一种基于Python的MATLAB的快速替代。</li>
</ul>
<h2 id="numpy安装"><a href="#numpy安装" class="headerlink" title="numpy安装"></a>numpy安装</h2><p>值得一提的是，python官网提供的发行版并没有包含numpy库，我们需要单独的下载，其中最简单的就是通过pip安装，安装成功后，可以使用numpy中生成对角矩阵的eye方法来检测是否安装成功。</p>
<p>在你的计算机上安装NumPy的最快也是最简单的方法是在shell上使用以下命令：<code>pip install numpy</code>。</p>
<p>这将在你的计算机上安装最新/最稳定的NumPy版本。通过PIP安装是安装任何Python软件包的最简单方法。</p>
<h2 id="NumPy-Ndarray-对象"><a href="#NumPy-Ndarray-对象" class="headerlink" title="NumPy Ndarray 对象"></a>NumPy Ndarray 对象</h2><p>NumPy提供的最重要的数据结构是一个称为NumPy数组(Ndarray)的强大对象。NumPy数组是通常的Python数组的扩展。NumPy数组配备了大量的函数和运算符，可以帮助我们快速编写上面讨论过的各种类型计算的高性能代码。</p>
<p>这是numpy中一个重要的特性，他是同一类数据类型的集合，以0为下标开始索引。</p>
<p>这是一个存放同类对象的多维数组，其中每个元素都有相同的区域储存，ndarray内部由一个指向数据的指针，数据类型，一个描述数组形状的数组，一个跨度元组组成。</p>
<p><img src="/2021/09/09/numpy/image-20210909093335315.png" alt="mdarray对象内部结构">值得一提的是，跨度可以是负数，这样数组在内存之中就会产生向前移动的效果。</p>
<p>创建这个对象只需要调用array函数。            </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th>object</th>
<th>数组或者嵌套的数列（也是对象中的基本元素）</th>
</tr>
</thead>
<tbody><tr>
<td>dtype</td>
<td>数组中元素的数据类型</td>
</tr>
<tr>
<td>copy</td>
<td>数组中元素是否可复制</td>
</tr>
<tr>
<td>order</td>
<td>数组中元素的样式，C为行方向，F为列方向，A为任意方向（默认）</td>
</tr>
<tr>
<td>subok</td>
<td>返回一个与基本类型一样的数组</td>
</tr>
<tr>
<td>ndmin</td>
<td>指定生成数组的最小维度</td>
</tr>
</tbody></table>
<p>让我们看看如何快速定义一维NumPy数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">my_array = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) </span><br><span class="line"><span class="built_in">print</span>(my_array)</span><br></pre></td></tr></table></figure>

<p>在上面的简单示例中，我们首先使用import numpy作为np导入NumPy库。然后，我们创建了一个包含5个整数的简单NumPy数组，然后我们将其打印出来。继续在自己的机器上试一试。在看 “NumPy安装” 部分下面的步骤的时候，请确保已在计算机中安装了NumPy.</p>
<p>现在让我们看看我们可以用这个特定的NumPy数组能做些什么。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> my_array.shape</span><br></pre></td></tr></table></figure>

<p>它会打印我们创建的数组的形状：<code>(5, )</code>。意思就是 my_array 是一个包含5个元素的数组。</p>
<p>我们也可以打印各个元素。就像普通的Python数组一样，NumPy数组的起始索引编号为0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> my_array[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> my_array[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>上述命令将分别在终端上打印1和2。我们还可以修改NumPy数组的元素。例如，假设我们编写以下2个命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_array[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> my_array</span><br></pre></td></tr></table></figure>

<p>我们将在屏幕上看到：<code>[-1,2,3,4,5]</code>。</p>
<p>现在假设，我们要创建一个长度为5的NumPy数组，但所有元素都为0，我们可以这样做吗？是的。NumPy提供了一种简单的方法来做同样的事情。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_new_array = np.zeros((<span class="number">5</span>)) </span><br><span class="line"><span class="built_in">print</span> my_new_array</span><br></pre></td></tr></table></figure>

<p>我们将看到输出了 <code>[0., 0., 0., 0., 0.]</code>。与 <code>np.zeros</code> 类似，我们也有 <code>np.ones</code>。  如果我们想创建一个随机值数组怎么办？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_random_array = np.random.random((<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span> my_random_array</span><br></pre></td></tr></table></figure>

<p>我们得到的输出看起来像 [0.22051844 0.35278286 0.11342404 0.79671772 0.62263151] 这样的数据。你获得的输出可能会有所不同，因为我们使用的是随机函数，它为每个元素分配0到1之间的随机值。</p>
<p>现在让我们看看如何使用NumPy创建二维数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_2d_array = np.zeros((<span class="number">2</span>, <span class="number">3</span>)) <span class="built_in">print</span> my_2d_array</span><br></pre></td></tr></table></figure>

<p>这将在屏幕上打印以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[0. 0. 0.]</span><br><span class="line"></span><br><span class="line">[0. 0. 0.]]</span><br></pre></td></tr></table></figure>

<p>猜猜以下代码的输出结果如何：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_2d_array_new = np.ones((<span class="number">2</span>, <span class="number">4</span>)) <span class="built_in">print</span> my_2d_array_new</span><br></pre></td></tr></table></figure>

<p>这里是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1. 1. 1. 1.]</span><br><span class="line"></span><br><span class="line">[1. 1. 1. 1.]]</span><br></pre></td></tr></table></figure>

<p>基本上，当你使用函数<code>np.zeros()</code>或<code>np.ones()</code>时，你可以指定讨论数组大小的元组。在上面的两个例子中，我们使用以下元组，(2, 3) 和(2, 4) 分别表示2行，3列和4列。像上面那样的多维数组可以用 <code>my_array[i][j]</code> 符号来索引，其中i表示行号，j表示列号。i和j都从0开始。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_array = np.array([[<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span> my_array[<span class="number">0</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>上面的代码片段的输出是5，因为它是索引0行和索引1列中的元素。</p>
<p>你还可以按如下方式打印my_array的形状：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> my_array.shape</span><br></pre></td></tr></table></figure>

<p>输出为(2, 2)，表示数组中有2行2列。</p>
<p>NumPy提供了一种提取多维数组的行/列的强大方法。例如，考虑我们上面定义的<code>my_array</code>的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">4</span> <span class="number">5</span>] [<span class="number">6</span> <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p>假设，我们想从中提取第二列（索引1）的所有元素。在这里，我们肉眼可以看出，第二列由两个元素组成：<code>5</code> 和 <code>1</code>。为此，我们可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_array_column_2 = my_array[:, <span class="number">1</span>] </span><br><span class="line"><span class="built_in">print</span> my_array_column_2</span><br></pre></td></tr></table></figure>

<p>注意，我们使用了冒号(<code>:</code>)而不是行号，而对于列号，我们使用了值<code>1</code>，最终输出是：<code>[5, 1]</code>。</p>
<p>我们可以类似地从多维NumPy数组中提取一行。现在，让我们看看NumPy在多个数组上执行计算时提供的强大功能。</p>
<h2 id="NumPy中的数组操作"><a href="#NumPy中的数组操作" class="headerlink" title="NumPy中的数组操作"></a>NumPy中的数组操作</h2><p>使用NumPy，你可以轻松地在数组上执行数学运算。例如，你可以添加NumPy数组，你可以减去它们，你可以将它们相乘，甚至可以将它们分开。 以下是一些例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]) </span><br><span class="line">b = np.array([[<span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>]]) </span><br><span class="line"><span class="built_in">sum</span> = a + b </span><br><span class="line">difference = a - b </span><br><span class="line">product = a * b </span><br><span class="line">quotient = a / b </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Sum = \n&quot;</span>, <span class="built_in">sum</span> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Difference = \n&quot;</span>, difference </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Product = \n&quot;</span>, product </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Quotient = \n&quot;</span>, quotient </span><br><span class="line"></span><br><span class="line"><span class="comment"># The output will be as follows: </span></span><br><span class="line"></span><br><span class="line">Sum = [[ <span class="number">6.</span> <span class="number">8.</span>] [<span class="number">10.</span> <span class="number">12.</span>]]</span><br><span class="line">Difference = [[-<span class="number">4.</span> -<span class="number">4.</span>] [-<span class="number">4.</span> -<span class="number">4.</span>]]</span><br><span class="line">Product = [[ <span class="number">5.</span> <span class="number">12.</span>] [<span class="number">21.</span> <span class="number">32.</span>]]</span><br><span class="line">Quotient = [[<span class="number">0.2</span> <span class="number">0.33333333</span>] [<span class="number">0.42857143</span> <span class="number">0.5</span> ]]</span><br></pre></td></tr></table></figure>

<p>如你所见，乘法运算符执行逐元素乘法而不是矩阵乘法。 要执行矩阵乘法，你可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix_product = a.dot(b) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Matrix Product = &quot;</span>, matrix_product</span><br></pre></td></tr></table></figure>

<p>输出将是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[19. 22.]</span><br><span class="line"></span><br><span class="line">[43. 50.]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架初步解析</title>
    <url>/2021/07/21/scrapy%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>scrapy框架是一个常用的爬虫框架，其中内嵌了许多的内容，使得爬取网页的过程不再像原生那样复杂。</p>
<p>Scrapy的架构</p>
<p><img src="/2021/07/21/scrapy%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5%E8%A7%A3%E6%9E%90/clip_image001.png" alt="架构图"></p>
<p>引擎：负责控制数据流在所有组件流动，并在相应动作是触发事件。可以理解为爬虫的大脑</p>
<p>调度器：从引擎接受请求（requests）并将它们加入爬虫队列，可以理解把等待爬取的网页排队的功能</p>
<p>下载器：负责获取页面并提供给引擎，相当于之前学的“获取网页”数据</p>
<p>爬虫器：负责解析网页（response），提取数据，或额外跟进一些url，相当于之前的解析网页的功能。</p>
<p>管道：负责处理被爬虫提取的数据（items），例如保存下来，相当于之前的“储存数据”功能</p>
<p>下载器中间件：引擎的下载器中间的一个部分，处理下载器传递给引擎的数据（response），一般不做处理</p>
<p>爬虫器中间件：引擎和爬虫器中间的一部分，处理爬虫器的输入（response）和输出（items，requests）</p>
<p>作为一个框架，上面列出来的各种组件还是很复杂的，一不小心就处于一个懵逼的状态了。</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>对应爬虫三大流程</th>
<th>Scrapy项目是否需要修改</th>
</tr>
</thead>
<tbody><tr>
<td>引擎</td>
<td></td>
<td>无需修改</td>
</tr>
<tr>
<td>调度器</td>
<td></td>
<td>无需修改</td>
</tr>
<tr>
<td>下载器</td>
<td>获取网页（requests库）</td>
<td>无需修改</td>
</tr>
<tr>
<td>爬虫器</td>
<td>解析网页（beautifulsoup库）</td>
<td>需要</td>
</tr>
<tr>
<td>管道</td>
<td>储存数据</td>
<td>需要</td>
</tr>
<tr>
<td>下载器中间件</td>
<td>获取网页（个性化部分）</td>
<td>一般不用</td>
</tr>
<tr>
<td>爬虫器中间件</td>
<td>解析网页（个性化部分）</td>
<td>一般不用</td>
</tr>
</tbody></table>
<p>可以看出来，使用scrapy框架之后，我们要写的内容就变得少了很多，一般来说，只需要负责好爬虫器和管道就可以了。</p>
<p>?</p>
<p>到底数据是怎么在scrapy中流动的呐？</p>
<p>（1）   引擎：向爬虫器发送第一个要抓取的url</p>
<p>（2）   爬虫器：提供www…….给引擎</p>
<p>（3）   引擎：接收到网址，交给调度器排序入队</p>
<p>（4）   调度器：将它处理成请求（requests）给引擎</p>
<p>（5）   引擎：接收到request，并通过下载器中间件给下载器下载</p>
<p>（6）   下载器：根据request下载页面，返回回应（response）给引擎</p>
<p>（7）   引擎：接收到response，并通过爬虫器中间件给爬虫器处理</p>
<p>（8）   爬虫器：处理response，提取内容，返回item给引擎，如果有跟进的request也会提交给引擎</p>
<p>（9）   引擎：接收到item，交给管道，新的request交给调度器</p>
<p>（10） 管道：储存数据</p>
<p>从这里就可以很明显的看出来scrapy框架的优缺点。</p>
<p>写爬虫的人，就像古代练剑一样，从开始用的木剑，到绝世好剑，最后到一草一木，爬虫也是这样，从最开始的不用框架，到使用框架，最后再到不用框架。</p>
<p>最开始使用request和bs4的时候很方便，但是接触了scrapy之后，你就会发现，原来真正的只需要几行代码就可以实现一个爬虫，这时候你会觉得scrapy很好用，但是随着需求越来越奇怪，也就是说你需要特地的去定制化一些功能的时候，scrapy作为一种条条框框的框架已经是不能满足这些需求了，所以还是会回到原始的request和bs4上。</p>
<p>Scrapy的优势就是并发性比较强，在做大批量的数据爬虫的时候简单易用，此外，做一些长期的爬虫项目维护管理也比较容易。</p>
<p>相比之下，不使用框架的话，爬虫的定制化就比较高，身经百战的高手总是可以杀人无形之中，爬虫之中最关键的就是反爬虫，scrapy毕竟作为一个框架，写的太死了，固然他也有中间件可以用来使用，但是比起不用框架的各种扩展功能，scrapy功能还是不够强大。</p>
<p>scrapy的安装</p>
<p>在Windows下的scrapy安装非常简单，只需要pip install scrapy就可以。但是一般来说都不会这么简单。</p>
<p>Scrapy框架是一个Python爬虫的框架没错，但是他确是要基于Twisted的，所以我们可以直接选择先安装Twisted组件，再安装Scrapy框架程序可以成功安装。</p>
<p>组件下载完成后文件名为“Twisted-20.3.0-cp38-cp38-win_amd64.whl”。我们打开cmd命令，在dos窗口中直接输入“pip install D:\软件安装包\Twisted-20.3.0-cp38-cp38-win_amd64.whl”其中“D:\软件安装包\Twisted-20.3.0-cp38-cp38-win_amd64.whl”为Twisted安装文件在电脑上的存放路径</p>
<p>使用pip安装Scrapy框架程序。</p>
<p>在cmd命令的DOS窗口中输入“pip install scrapy”进行安装。</p>
<p>制作爬虫</p>
<p>制作Scrapy爬虫大致需要4步：<br> 新建项目（scrapy startproject xxx）:新建一个新的爬虫项目。<br> 明确目标（编写items.py）:明确你想要抓取的目标。<br> 制作爬虫（spiders/xxspider.py）:制作爬虫开始爬取网页。<br> 存储内容（pipelines.py）:设计管道存储爬取内容</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>入门部分</title>
    <url>/2021/07/20/%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="计算机基础知识（电子计算机）"><a href="#计算机基础知识（电子计算机）" class="headerlink" title="计算机基础知识（电子计算机）"></a>计算机基础知识（电子计算机）</h2><h3 id="1、计算机是什么？"><a href="#1、计算机是什么？" class="headerlink" title="1、计算机是什么？"></a>1、计算机是什么？</h3><p>计算机就是一个用来计算的机器</p>
<p>目前来讲，计算机智能根据人类的指令来完成各种操作，人让他干嘛他就得干嘛</p>
<p>所以说，我们现在学习计算机，就是学习如何的去控制计算机</p>
<h3 id="2、计算机的组成"><a href="#2、计算机的组成" class="headerlink" title="2、计算机的组成"></a>2、计算机的组成</h3><p>硬件</p>
<p>键盘、鼠标、显示器、cpu（中央处理器）、主板（连接）、内存（运行内存、内存条）、硬盘（机械、固态…）…</p>
<p>看得见、摸得着的东西</p>
<p>软件</p>
<p><strong>系统</strong>软件（操作系统）</p>
<p>Windows、linux、macos</p>
<p>应用软件</p>
<p>办公软件（office、wps、xmind）、游戏、浏览器、聊天工具….</p>
<p>看得见、但是摸不着，软件起到的作用是负责控制计算机的硬件。</p>
<h3 id="3、计算机的使用方式"><a href="#3、计算机的使用方式" class="headerlink" title="3、计算机的使用方式"></a>3、计算机的使用方式</h3><p>必须要通过软件来完成对计算机的各种操作</p>
<p>但是、注意一点</p>
<p>一个软件并不是说，你下载了这个软件，你就可以使用它的全部功能。</p>
<p>用户需要的功能：接口（interface（接口） 交互界面）来操作计算机。</p>
<p>接口这个概念， c# java 这些编程语言当中，大多数是以一种方法集的形式，本质上说他是个类</p>
<p>web开发，写网站。写接口（例子：修改我的密码（第一个接口）、我想充值（也是一个接口）、注册（也是一个接口））</p>
<p>用户界面：文本交互界面（TUI） 和图形化交互界面（GUI）</p>
<p>TUI（Windows）</p>
<p>命令行（cmd，dos命令窗口、命令提示符、cmd窗口、shell、终端、terminal）</p>
<p>shell编程（命令行输入指令去操作系统）</p>
<p>终端</p>
<p>terminal 控制台</p>
<p>文本交互界面，指令去操作计算机</p>
<p>任何一个计算机操作系统都拥有命令行</p>
<h3 id="windows-命令行"><a href="#windows-命令行" class="headerlink" title="windows 命令行"></a>windows 命令行</h3><p>进入方式：1、底部搜索框 2、win键加r键，运行窗口，输入cmd</p>
<p>结构：</p>
<p>-版本以及版权的声明（一般没有什么用处）</p>
<p>Microsoft Windows [版本 10.0.18363.1316]<br>(c) 2019 Microsoft Corporation。保留所有权利。</p>
<p>-命令提示符</p>
<p>C:\Users***  **&gt;**（命令提示符、在&gt;后面可以直接输入指令）</p>
<p>C：</p>
<p>​    -当前所在的磁盘的根目录</p>
<p>​    -可以通过x：来切换盘符（x是表示你的盘符）</p>
<p>\Users***</p>
<p>​    -所在磁盘的路径、当前所在的文件夹</p>
<p>​    -cd切换目录</p>
<p>常见的dos命令</p>
<p>dir（查看当前路径下的所有文件包括文件夹）</p>
<p>cd（切换到指定的目录）. ..（正则表达式）</p>
<p>.表示的当前的目录</p>
<p>..表示的是上一级目录</p>
<p>md 创建一个目录</p>
<p>rd 删除一个目录</p>
<p>del 删除文件</p>
<p>cls 清屏</p>
<p>小技巧：</p>
<p>方向键上下键：会出现命令的历史记录</p>
<p>tab键：自动补全命令</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>path（路径）</p>
<p>Windows，path或许没有，可以手动添加</p>
<p>path不区分大小写pAth</p>
<p>修改完环境变量，必须重启命令行窗口</p>
<p>多个路径必须用;（英文的分号）隔开</p>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>十进制（满十进一）</p>
<p>0、1、2、3、4、5、6、7、8、9</p>
<p>千位、百位、个位</p>
<p>10^3  10^2    10^1</p>
<p>二进制（计算机底层使用的进制、满二进一）</p>
<p>01、001、01101</p>
<p>0000011010100   1      0        1</p>
<p>​                            2^2      2^1    2^0</p>
<p>计算机底层储存方式，二进制方式，内存中的每一个小格子，我们称之为一个bit（位）</p>
<p>一位（1 bit（其实就是一个1或者0））</p>
<p>bit是计算机中最小的单位</p>
<p>byte（字节）才是我们最小的可操作的单位</p>
<p>1 byte=8 bit</p>
<p>1024 byte =1 kb</p>
<p>……</p>
<p>八进制（一般不用）</p>
<p>十六进制</p>
<p>（不是给计算机底部用的，而是给我们（用户、开发者）看的）</p>
<p>一般来讲，查看二进制数据的时候，都不会用二进制来显示，而是用提供十六进制</p>
<h3 id="文本文件和字符集"><a href="#文本文件和字符集" class="headerlink" title="文本文件和字符集"></a>文本文件和字符集</h3><p>文本分成两种：纯文本（只能保存单一的文本内容、（字体、颜色、图片….）这些都不能保存） 富文本（可以保存文本之外的内容）</p>
<p>但是，在开发的时候，使用的全都是纯文本</p>
<p>纯文本在计算机底层转换成二进制保存</p>
<p>将字符转换二进制的过程、编码</p>
<p>二进制码转换成字符的过程、解码</p>
<p>编码与解码、所采用的规则，叫做字符集</p>
<p>常见：</p>
<p>ascll 美国人</p>
<p>iso 欧洲</p>
<p>ltain（mysql默认的编码方式）只认英文</p>
<p>gbk gb2312 中国</p>
<p>unicode 编码（万国码）utf-8 、utf-16、utf-32</p>
<h2 id="python入门"><a href="#python入门" class="headerlink" title="python入门"></a>python入门</h2><h3 id="python是什么？"><a href="#python是什么？" class="headerlink" title="python是什么？"></a>python是什么？</h3><p>计算机语言</p>
<p>机器语言(全是二进制，执行效率高、编写太麻烦)</p>
<p>符号语言（汇编语言）</p>
<p>（符号来代替二进制）</p>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>基本跟英语语法很相似，并且和硬件的关系没有那么紧密了，而且学习起来更容易。</p>
<p>c c++ c# java JavaScript（node.js）（本质上写服务器的时候还是用的服务器加客户端的结构，而且一般不用js写服务器，用js写中间件，因为他的并发处理）、python….</p>
<p>高级语言又分类：编译型语言（在代码执行前，转化为二进制（机器码），然后交给计算机执行）</p>
<p>源码——编译——机器码</p>
<p>c语言</p>
<p>执行速度很快，跨平台性很差</p>
<p>解释型语言（不对代码进行编译，而是一边执行一边编译）</p>
<p>源码–解释器–解释运行</p>
<p>执行速度会比较慢，但是跨平台性会非常好</p>
<p>js java python</p>
<p>python 使用广泛、可读性强、比较简洁，用更少的代码去完成自己的想法，不管是大程序还是小程序，都让结构变得清晰明了。</p>
<h3 id="python的用途"><a href="#python的用途" class="headerlink" title="python的用途"></a>python的用途</h3><p>web（facebook、豆瓣）</p>
<p>爬虫</p>
<p>科学计算</p>
<p>大数据（数据清洗）</p>
<p>云计算</p>
<p>人工智能</p>
<p>游戏</p>
<p>…</p>
<h3 id="python开发环境的搭建"><a href="#python开发环境的搭建" class="headerlink" title="python开发环境的搭建"></a>python开发环境的搭建</h3><p>python是有解释器的</p>
<p>cpython（官方）</p>
<p>用c语言（c语言直接作用在内存上）编写的python解释器</p>
<p>大型游戏（全部都是由c或者c#编写的，为什么？因为c能够直接作用在内存上）</p>
<p>pypy</p>
<p>用python语言编写的Python解释器</p>
<p>ironpython</p>
<p>.net编写</p>
<p>jpython</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>信息就是位加上下文</title>
    <url>/2021/08/16/%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机系统是由硬件和系统软件组成的，他们共同的来运行应用程序。</p>
<p>我们通过一个简单的c程序输出hello程序的生命周期来开始分析：从它被程序员创建开始，到在系统上运行，输出简单的信息，然后终止。</p>
<h1 id="信息就是位加上下文"><a href="#信息就是位加上下文" class="headerlink" title="信息就是位加上下文"></a>信息就是位加上下文</h1>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>基于vm的完全分布式hadoop3-2集群搭建</title>
    <url>/2021/07/20/%E5%9F%BA%E4%BA%8Evm%E7%9A%84%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8Fhadoop3-2%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>文章最终效果为，三台虚拟机三个namenode节点，依赖zkfc处理活跃问题，两个rm节点，同样依赖zkfc处理活跃问题。3之后的hadoop。hdfs的http端口改为了9870，也可以自行修改，yarn不变，依旧是8088。</p>
<h2 id="1、部署环境"><a href="#1、部署环境" class="headerlink" title="1、部署环境"></a>1、部署环境</h2><p>Windows 10 家庭中文版（家庭版不存在问题）</p>
<p>vmware 16.0 （百度到处都有激活码，可尝试下面的激活码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZF3R0-FHED2-M80TY-8QYGC-NPKYF</span><br><span class="line">YF390-0HF8P-M81RQ-2DXQE-M2UT6</span><br><span class="line">ZF71R-DMX85-08DQY-8YMNC-PPHV8</span><br></pre></td></tr></table></figure>

<p>centos 7.4  64位（linux系统，附带官网链接）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://isoredirect.centos.org/centos/7/isos/x86_64/</span><br></pre></td></tr></table></figure>

<p>jdk 1.8 （稳定版本，hadoop神器版本）</p>
<p>hadoop 3.2.1</p>
<p>zookeeper 3.6.2（版本不限）</p>
<h2 id="2、准备工作"><a href="#2、准备工作" class="headerlink" title="2、准备工作"></a>2、准备工作</h2><p>1、完成ssh免密配置的三台虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三台虚拟机生成秘钥</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">三节点拷贝到同一节点</span><br><span class="line">ssh-copy-id node1 </span><br><span class="line">将此节点上的秘钥通过scp发送到其他节点，此处可通过编写sh脚本，简化。</span><br></pre></td></tr></table></figure>

<p>2、三台安装jdk并且配置其环境变量</p>
<p>3、三台虚拟机成功安装并且部署好zookeeper集群</p>
<h2 id="3、配置文件"><a href="#3、配置文件" class="headerlink" title="3、配置文件"></a>3、配置文件</h2><p>1、/etc/profile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar</span><br><span class="line"></span><br><span class="line">export ZOOKEEPER_HOME=/export/server/zookeeper</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$ZOOKEEPER_HOME/bin</span><br><span class="line"></span><br><span class="line">export HADOOP_HOME=/export/server/hadoop</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure>

<p>2、core-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;hdfs://my01&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;/export/server/hadoop/tmp&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;io.file.buffer.size&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;131072&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">          &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">          &lt;value&gt;node1:2181,node2:2181,node3:2181&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>3、hdfs-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.nameservices&lt;/name&gt;                                      </span><br><span class="line"> &lt;value&gt;my01&lt;/value&gt;                               </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.replication&lt;/name&gt;                  </span><br><span class="line"> &lt;value&gt;3&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                                                 </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.namenodes.my01&lt;/name&gt;             </span><br><span class="line"> &lt;value&gt;nn1,nn2,nn3&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.rpc-address.my01.nn1&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node1:9820&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.rpc-address.my01.nn2&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node2:9820&lt;/value&gt;                                 </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.rpc-address.my01.nn3&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node3:9820&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                                              </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.http-address.my01.nn1&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node1:9870&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.http-address.my01.nn2&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node2:9870&lt;/value&gt;                               </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.http-address.my01.nn3&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;node3:9870&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                          </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;true&lt;/value&gt;                                 </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;                                   </span><br><span class="line"> &lt;value&gt;qjournal://node1:8485;node2:8485;node3:8485/my01&lt;/value&gt;               </span><br><span class="line">&lt;/property&gt;                               </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;                                      </span><br><span class="line"> &lt;value&gt;/export/data/hadoop/journaldata&lt;/value&gt;                               </span><br><span class="line">&lt;/property&gt;     </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.client.failover.proxy.provider.my01&lt;/name&gt;                         &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;                                  </span><br><span class="line">&lt;/property&gt;                    </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;                   </span><br><span class="line"> &lt;value&gt;sshfence</span><br><span class="line"> shell(/bin/true)&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;                             </span><br><span class="line"> &lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;                                        </span><br><span class="line">&lt;/property&gt;                      </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.fencing.ssh.connect-timeout&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;30000&lt;/value&gt;                   </span><br><span class="line">&lt;/property&gt;                                        </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.namenode.handler.count&lt;/name&gt;                                       </span><br><span class="line"> &lt;value&gt;100&lt;/value&gt;                           </span><br><span class="line">&lt;/property&gt;                    </span><br><span class="line">&lt;property&gt;                                        </span><br><span class="line"> &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;                               </span><br><span class="line"> &lt;value&gt;true&lt;/value&gt;                          </span><br><span class="line">&lt;/property&gt;   </span><br><span class="line">&lt;property&gt; </span><br><span class="line">       &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; </span><br><span class="line">       &lt;value&gt;file:///export/data/hadoop/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt; </span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; </span><br><span class="line">        &lt;value&gt;file:///export/data/hadoop/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;ture&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>4、mapred-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">&lt;name&gt;mapreduce.framework.name&lt;/name&gt;                                    </span><br><span class="line">&lt;value&gt;yarn&lt;/value&gt;            </span><br><span class="line">&lt;/property&gt; </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">    &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;                               </span><br><span class="line">    &lt;value&gt;                                    </span><br><span class="line">        /export/server/hadoop/etc/hadoop,                                    </span><br><span class="line">        /export/server/hadoop/share/hadoop/common/*,                           </span><br><span class="line">        /export/server/hadoop/share/hadoop/common/lib/*,                       </span><br><span class="line">        /export/server/hadoop/share/hadoop/hdfs/*,</span><br><span class="line">        /export/server/hadoop/share/hadoop/hdfs/lib/*,                         </span><br><span class="line">        /export/server/hadoop/share/hadoop/mapreduce/*,                       </span><br><span class="line">        /export/server/hadoop/share/hadoop/mapreduce/lib/*,</span><br><span class="line">        /export/server/hadoop/share/hadoop/yarn/*,</span><br><span class="line">        /export/server/hadoop/share/hadoop/yarn/lib/*                         </span><br><span class="line">    &lt;/value&gt;                                    </span><br><span class="line">  &lt;/property&gt;    </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">  &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;HADOOP_MAPRED_HOME=/export/server/hadoop&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.map.env&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;HADOOP_MAPRED_HOME=/export/server/hadoop&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;mapreduce.reduce.env&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;HADOOP_MAPRED_HOME=/export/server/hadoop&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>5、yarn-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- Site specific YARN configuration properties --&gt;                           </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;                      </span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.automatic-failover.enabled&lt;/name&gt;       </span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                                                   </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;            </span><br><span class="line">        &lt;value&gt;yarn-rm-cluster&lt;/value&gt;                  </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;        </span><br><span class="line">        &lt;value&gt;rm1,rm2&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;                           </span><br><span class="line">        &lt;value&gt;node1&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;                         </span><br><span class="line">        &lt;value&gt;node2&lt;/value&gt;                                    </span><br><span class="line">&lt;/property&gt;                                    </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.recovery.enabled&lt;/name&gt;                     </span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;                      </span><br><span class="line">&lt;/property&gt;   </span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.ha.id&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;rm1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;      </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;                           </span><br><span class="line">        &lt;value&gt;node1:2181,node2:2181,node3:2181&lt;/value&gt;                       </span><br><span class="line">&lt;/property&gt;                                                         </span><br><span class="line">&lt;property&gt;                                    </span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;                            </span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;                       </span><br><span class="line">&lt;/property&gt;       </span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.store.class&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address.rm1&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;node1:8088&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;   </span><br><span class="line">        &lt;property&gt;                                    </span><br><span class="line">    &lt;name&gt;yarn.application.classpath&lt;/name&gt;                                   </span><br><span class="line">    &lt;value&gt;                                    </span><br><span class="line">/export/server/hadoop/etc/hadoop:/export/server/hadoop//share/hadoop/common/lib/*:/export/server/hadoop//share/hadoop/co  mmon/*:/export/server/hadoop//share/hadoop/hdfs:/export/server/hadoop//share/hadoop/hdfs/lib/*:/export/server/hadoop//sh  are/hadoop/hdfs/*:/export/server/hadoop//share/hadoop/mapreduce/lib/*:/export/server/hadoop//share/hadoop/mapreduce/*:/e  xport/server/hadoop//share/hadoop/yarn:/export/server/hadoop//share/hadoop/yarn/lib/*:/export/server/hadoop//share/hadoop/yarn/*                             </span><br><span class="line">    &lt;/value&gt;                                    </span><br><span class="line">  &lt;/property&gt;    </span><br><span class="line"> &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt;</span><br><span class="line">&lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">         &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.scheduler.address.rm2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;node2&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address.rm2&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;node2&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>6、yarn-env.sh  hadoop-env.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line">export HADOOP_HOME=/export/server/hadoop/</span><br></pre></td></tr></table></figure>

<p>7、start-dfs.sh  stop-dfs.sh  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HDFS_DATANODE_USER=root</span><br><span class="line">HDFS_DATANODE_SECURE_USER=hdfs </span><br><span class="line">HDFS_NAMENODE_USER=root </span><br><span class="line">HDFS_SECONDARYNAMENODE_USER=root</span><br><span class="line">HDFS_JOURNALNODE_USER=root</span><br><span class="line">HDFS_ZKFC_USER=root</span><br></pre></td></tr></table></figure>

<p>8、start-yarn.sh  stop-yarn.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YARN_RESOURCEMANAGER_USER=root</span><br><span class="line">HADOOP_SECURE_DN_USER=yarn</span><br><span class="line">YARN_NODEMANAGER_USER=root</span><br></pre></td></tr></table></figure>

<p>9、启动顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zkServer.sh start</span><br><span class="line">hadoop-daemon.sh start journalnode</span><br><span class="line">hdfs namenode -format / /namenode 格式化</span><br><span class="line">hdfs zkfc -formatZK //格式化高可用</span><br><span class="line">hdfs namenode //启动namenode</span><br><span class="line">hdfs namenode -bootstrapStandby</span><br><span class="line">hadoop-daemon.sh stop namenode</span><br><span class="line">hadoop-daemon.sh stop journalnode</span><br><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>

<h2 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h2><p>1、启动顺序一定不要乱</p>
<p>2、格式化出错就排错</p>
<p>3、配置文件写完之后，先开启zk集群，先status查看集群状态，确认无误之后再进行初始化操作</p>
<p>4、zk集群状态，开启后等待半分钟左右再去查看</p>
<p>5、如何验证集群搭好了，jps查看节点无误，向集群上传文件无误，启动wordcount实例无误。</p>
<p>6、启动顺序，先开启zk，一键启动start-all.sh或者分别启动yarn和hdfs都可以。不需要再次格式化了。</p>
<p>7、防火墙关闭</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>安装和几个概念</title>
    <url>/2021/07/20/%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>python的安装</p>
<p><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></p>
<p>python   2和3两个版本，这两个版本是并行，而且差距还有点大</p>
<p>idle python自带的一个开发工具（tab 自动补全）</p>
<p>交互界面去完成一些简单的测试</p>
<p>一般将python代码保存到一个py文件里，然后通过python指令来执行文件中的代码。</p>
<p> 几个概念</p>
<p>1、表达式</p>
<p>表达式就是类似于数学公式的东西</p>
<p>表达式一般仅仅用来计算，不会对程序有什么实质性影响，如果说你在交互模式直接输入表达式，那么解释器会自动的表达式的值输出。</p>
<p>2、语句</p>
<p>语句，一般需要他完成某种功能</p>
<p>print 打印一些信息</p>
<p>input  获取信息</p>
<p>a=1  为变量赋值</p>
<p>……</p>
<p>语句的执行一般来说都会对程序造成一定的影响</p>
<p>在交互模式中不一定会输出语句的结果</p>
<p>3、程序</p>
<p>程序是由一条一条的语句和一条条的表达式构成的</p>
<p>4、函数</p>
<p>函数也是一种语句，来完成特定的功能</p>
<p>函数：xx（）</p>
<p>函数的分类：</p>
<p>​    内置函数：</p>
<p>​        由解释器提供的函数：print（）</p>
<p>​    自定义函数：</p>
<p>​        由开发者自己创建的函数</p>
<p>函数有两个要素：参数（），括号中的内容就是参数</p>
<p>​        函数可以没有参数，也可以有很多个参数，多个参数用，隔开</p>
<p>​    返回值</p>
<p>​        返回值就是函数的返回结果，不是所有的函数都有返回值</p>
<span id="more"></span>

<p>5、字面量和变量</p>
<p>​    字面量就是一个一个的值，一个一个看得到的值，</p>
<p>​    1,2,3，asa，“dsd”</p>
<p>​    就是它表面上的值，在程序·中可以直接使用字面量</p>
<p>​    变量 变量可以用来保存字面量，而且保存的字面量是不一定的。</p>
<p>​    x=qwq</p>
<p>​    变量本身是没有任何意思的，他的意思根据字面量来表达</p>
<p>6、数据类型</p>
<p>​    数据类型就是变量的值的类型，也就是说可以为变量赋那些值，还可以说，变量可以等于那些东西</p>
<p>​    数值（整型（整数）、浮点型（浮点数）、布尔（就是是或者否，true or false 1或者0）、字符串、空值）</p>
<p>7、对象</p>
<p>python是一门面向对象的语言</p>
<p>一切都是对象（一切都是函数）</p>
<p>程序运行当中，所有的数据都要储存到内存当中然后运行，对象实际上就是一个在内存中用来存储数据的一块区域，他就是一个容器，用来存储数据。</p>
<p>对象的结构</p>
<p>id（标识）</p>
<p>用来确定对象的唯一性</p>
<p>id是由解析器生成的，cpython中，id就是对象的内存地址。</p>
<p>id（）函数可以查看id</p>
<p>对象一旦创建。他的id永远不能改变。</p>
<p>type（类型）</p>
<p>int float bool str</p>
<p>类型决定了对象的功能</p>
<p>type（）函数可以查看对象类型</p>
<p>python是一门强类型的语言，java也是，但是js，JavaScript他不是，对象一旦创建就是更改类型</p>
<p>value（值）</p>
<p>值就是对象里存储的数据</p>
<p>对于值有些对象是可以改变的</p>
<p>对象又分为两个大类，一个是可变的，一个是不可变的。</p>
<p>8、变量和对象</p>
<p>对象其实没有存储到变量中，在Python中，变量更加像是给对象取了一个名字（别名）</p>
<p>变量中存储的不是对象的值，而是对象的id（内存地址）</p>
<p>使用变量，实际上就是通过id来查找对象</p>
<p>变量中保存的对象，只有在再一次赋值的时候才会改变</p>
<p>变量与变量是独立的，修改一个变量不会影响到下一个变量</p>
<p>9、类型转换</p>
<p>一个类型的对象转换为其他对象（不是改变对象本身，而是根据对象的值来创建一个新对象）</p>
<p>10、运算符</p>
<p><strong>+</strong>  <strong>-</strong> ***** <strong>/</strong> </p>
<p>算术运算符 </p>
<p>= 赋值运算符</p>
<p>== &lt;= &gt;= ! 比较运算符（关系运算符）</p>
<p>条件运算符（三元运算符）</p>
<p>逻辑运算符 and or</p>
<p>11、基本语法</p>
<p>1、python严格区分大小写</p>
<p>2、每一行就是一条语句</p>
<p>3、一行语句不要过长</p>
<p>4、一条语句可以多行写，后面\（转义字符）结尾</p>
<p>5、严格缩进（在python里不要随便写缩进）</p>
<p>6、#这是单行注释，严格养成写注释的习惯，而且一般来说，#后面加一个空格</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>序列</title>
    <url>/2021/07/20/%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>序列</p>
<p>1、列表 list</p>
<p>​    1、列表是python中的一个对象</p>
<p>​    2、之前所说的对象，他只能单一的保存数据</p>
<p>​    3、列表可以保存很多个<strong>有序</strong>的数据</p>
<p>​    4、列表是用来存储对象的对象</p>
<p>​    5、列表的使用（本身、里面数据）</p>
<p>2、序列</p>
<p>​    1、序列是python中最基本的数据结构</p>
<p>​    2、数据结构是计算机中数据储存的方式</p>
<p>​    3、序列用于保存一组有序的数据，所有数据在序列当中是唯一的。（索引）</p>
<p>​    4、序列中的数据会按照添加的顺序来分配索引（从0开始）</p>
<p>​    5、序列的分类：</p>
<p>​            可变序列：list</p>
<p>​            不可变序列：str、tuple</p>
<p>3、字典 dict</p>
<p>​    1、字典又叫映射（mapping）</p>
<p>​    2、列表存的性能很好，查的性能很差。</p>
<p>​    3、字典查的性能很好，在字典中，每一个元素都有一个唯一的名字，通过这个名字可以很快的找到指定的元素</p>
<p>​    4、字典有可以被称为键值对，唯一的名字，键，那个值叫做值</p>
<p>4、集合 set</p>
<pre><code> 1、集合和列表很像
</code></pre>
<p>​     2、集合只能存不可变的对象</p>
<p>​     3、集合中的对象是无序的</p>
<p>​     4、集合中不能出现重复的元素</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>异常-1</title>
    <url>/2021/08/05/%E5%BC%82%E5%B8%B8-1/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在程序中，编译和运行是两个不同的阶段。编译主要针对的是语法检测，运行时有可能出现各种的错误导致程序中断，这些错误统一的被称为异常。</p>
<h2 id="1、认识异常"><a href="#1、认识异常" class="headerlink" title="1、认识异常"></a>1、认识异常</h2><p>异常是在程序执行时，由于程序处理逻辑的错误导致程序中断的一种指令流（机器执行指令序列 数据流）</p>
<p>当异常产生时，程序会在异常产生的地方被中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(10 / 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">	at demo08.day5.demo01.main(demo01.java:5)</span><br></pre></td></tr></table></figure>

<p>程序中产生了数学异常，由于程序没有对异常做任何的处理，所以默认的进行了异常信息的打印，同时会终止异常之后的代码，</p>
<p>为了让程序出现异常后还可以正常执行，必须引入异常处理语句来完善代码编写。</p>
<h2 id="2、异常处理"><a href="#2、异常处理" class="headerlink" title="2、异常处理"></a>2、异常处理</h2><p>try catch finally三个核心关键字用来针对异常的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(10 / 0);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;这是:&quot;+e+&quot;  异常！&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;程序执行完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>异常的格式组合：</p>
<p>其实，catch和finally都是可选的，就是在这三个关键字的组成上，try是必不可少的，其次的catch和finally都是可以任何搭配的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(10 / 0);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;app&quot;+ &quot;ing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取完整异常信息，所有的异常类都提供了printStackTrace方法，这个方法可以输出异常信息，明确的告诉我们那一行代码出现了异常。</p>
<blockquote>
<p>提问：finally的作用是不是较小</p>
<p>我们发现，异常处理之后的语句无论是否出现异常都可以正常运行，那么finally是不是有些冗余？</p>
<p>答：两者执行机制不一样</p>
<p>上述程序只是执行了一个简单的数学计算异常，并不能正常处理其他异常，而对于不能正常处理的代码，程序依然会中断执行，中断之后，后面的代码不会执行，但是finally依然会执行。在开发中finally一般用来资源释放。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;please input number:&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            int x = Integer.parseInt(input.next());</span><br><span class="line">            System.out.println(10 / x);</span><br><span class="line">        &#125;catch (ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;ing&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;app&quot;+ &quot;ing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、处理多个异常："><a href="#3、处理多个异常：" class="headerlink" title="3、处理多个异常："></a>3、处理多个异常：</h2><p>使用多个catch语句进行异常处理</p>
<h2 id="4、异常处理流程："><a href="#4、异常处理流程：" class="headerlink" title="4、异常处理流程："></a>4、异常处理流程：</h2><p>面向对象的核心设计思想就是统一标准。</p>
<p>前面提问：每次处理异常的时候都要去考虑所有的异常，那么直接使用判断不是更好嘛？</p>
<img src="/2021/08/05/%E5%BC%82%E5%B8%B8-1/image-20210805160039738.png" alt="异常处理流程" style="zoom:200%;">

<p>核心：在于异常类的实例化对象类型。</p>
<hr>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">	|-java.lang.Exception</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如上，所有异常类的最高继承类是throwable。这个类下面有两个子类，其中一个是error，jvm错误。还有一个就是exception。</p>
<p>按照对象的引用原则，可以自动向上转型，按照这样的逻辑，所有的异常都可以用exception来处理。</p>
<blockquote>
<p>问题：为什么不用throwable？</p>
<p>答：表示的范围大，用户处理error错误</p>
<p>问题：异常一起处理好还是分开处理好？</p>
<p>答：根据实际要求</p>
</blockquote>
<p><strong>注意：处理多个异常时，范围小的要放在范围大的之前。</strong></p>
<h2 id="5、throws关键字"><a href="#5、throws关键字" class="headerlink" title="5、throws关键字"></a>5、throws关键字</h2><p>方法是类的主要操作形式。</p>
<p>在程序执行中，更多的考虑到的是方法的调用，为了方便调用时异常的处理，往往会在方法声明时对可能出现的异常进行标记。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            div(12,12);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int div(int x,int y) throws Exception&#123;</span><br><span class="line">        return x / y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：以上的计算没有错误，为什么还是强制异常处理？</p>
<p>答：设计方法的需要</p>
</blockquote>
<p>主方法也是方法，如果主方法进行了throws异常抛出，那么在主方法里不用强制性地进行异常处理。异常交给了jvm默认处理，程序中断执行，并且打印异常信息。</p>
<p>注意：主方法就是程序的起点，因此所有的异常都应该在主方法里处理完成，而不应该选择向上抛出。</p>
<h2 id="6、throw关键字"><a href="#6、throw关键字" class="headerlink" title="6、throw关键字"></a>6、throw关键字</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           throw new Exception(&quot;跑着玩玩&quot;);</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，所有异常类的实例化对象都会自动生成并且自动抛出，但是为了方便用户，提供了手动抛出的异常。</p>
<blockquote>
<p>问题：两个关键字的区别，throws与throw</p>
<p>答：前者是在方法定义使用的，表示将方法中可能产生的异常明确的告诉调用者，由调用进行处理。后者是在代码块使用，手动进行异常对象抛出。</p>
</blockquote>
<h2 id="7、自定义异常类"><a href="#7、自定义异常类" class="headerlink" title="7、自定义异常类"></a>7、自定义异常类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DemoException extends Exception&#123;</span><br><span class="line">    public DemoException(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void eat (int num) throws DemoException&#123;</span><br><span class="line">        if (num &gt;999)&#123;</span><br><span class="line">            throw new DemoException(&quot;吃撑了！&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;不怕胖，一直吃！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">          DemoException.eat(6708);</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、assert关键字"><a href="#8、assert关键字" class="headerlink" title="8、assert关键字"></a>8、assert关键字</h2><p>断言：程序执行到一定阶段时，其结果一定是预期的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo02 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        int x = 10;</span><br><span class="line">        assert x == 100 : &quot;x no 100&quot;;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java默认不开启断言的，如果想要启动断言，需要加入（“-ea”）选项。</p>
<blockquote>
<p>java -ea demo08.day5.demo02<br>Exception in thread “main” java.lang.AssertionError: x no 100<br> at demo08.day5.demo02.main(demo02.java:6)</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2021/07/20/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>异常</p>
<p>程序在运行当中，不可避免的会产生一些错误。</p>
<p>​    使用了没有赋值的变量，使用了不存在的索引、使用了过深的递归、传入了无效的参数…</p>
<p>一旦出现异常，程序会立即停止。</p>
<p>处理异常</p>
<p>python是希望在出现异常的时候，程序不停，可以编写代码来对异常进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">	代码块（可能出现异常的语句）</span><br><span class="line">except 异常类型 as 异常名（可以自定义）:</span><br><span class="line">	代码块（程序出错了的处理方式）</span><br><span class="line">else:</span><br><span class="line">	代码块（没出错要执行的语句）</span><br><span class="line">finally:</span><br><span class="line">	代码块（一定会执行，无论是否出错的语句）</span><br></pre></td></tr></table></figure>

<p>try语句是必须的，else则不是，except和finally至少要有一股</p>
<p>raise语句 抛出异常</p>
<p>常见的异常对象</p>
<p>nameerror（你的变量名称为找到，函数名称，类名称。变量没有定义）</p>
<p>recursionerror（超过最大递归深度）</p>
<p>syntaxerror 语法错误</p>
<p>timeoueerror 超时</p>
<p>typeerror 类型错误（print（1+“sasda”））</p>
<p>valueerror   int（”12.2月”）</p>
<p>keyerror </p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（1）</title>
    <url>/2021/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>编程就是在跟数据打交道，计算机程序总是在接受数据、操作数据或者返回数据。</strong></p>
<p>数据：其实就是指很多的信息（数字、字符串）</p>
<p>无论多复杂的数据结构，我们都可以拆成最简单的数字和字符串来看。</p>
<p>数据结构则是数据的组织形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=&quot;hello&quot;</span><br><span class="line">b=&quot;liupeng&quot;</span><br><span class="line">print(a+b)</span><br></pre></td></tr></table></figure>

<p>这个程序就把两条数据连成了一句话，如果要描述该程序中的数据结构。</p>
<p>（这个有两个独立的变量，分别引用了两个独立的字符串）</p>
<p>数据结构：不只是用来组织数据，他影响了代码的运行速度。</p>
<p>数据结构和算法不同，对程序的影响也不同。</p>
<p><strong>时间复杂度、空间复杂度。</strong></p>
<p>时间复杂度</p>
<p>list（列表）python []</p>
<p>[1,2,3,4,5,6]</p>
<p>python中的列表</p>
<p>索引：标识数据的位置的，从0开始计算。</p>
<p>数据结构：一般数据结构有4种操作（用法）</p>
<p>1、读取：查看数据结构中某一个位置的数据</p>
<p>2、查找：从数据结构中找出某一个数据的所在</p>
<p>3、插入：给数据结构增加一个数据值</p>
<p>4、删除：从数据结构中移走一个数据值</p>
<p>操作的速度：在程序中，操作的速度不是按照时间来计算的，而是按照<strong>步数</strong>来计算。</p>
<p>因为，影响程序运行的一个很关键的因素是硬件。受硬件而影响的计时方法，非常不可靠。</p>
<p>步数</p>
<p>a操作需要5步，b操作需要500步。</p>
<p>步数作为衡量程序快慢的标准（时间复杂度、速度、效率、性能、步数）</p>
<p>1、读取：查看列表中某一个索引所指的数据</p>
<p>一步，计算机本身就有跳到任何一个索引位置的能力</p>
<p>list=[]</p>
<p><strong>所以，列表的读取是一种十分高效的操作，无论他有多长，一步就可以完成操作</strong></p>
<p>2、查找：检查它是否包含某个值</p>
<p>如果包含，需要给出索引</p>
<p>（计算机没有眼睛，他只能一步一步走）</p>
<p>这种逐一去检查的做法，就叫做<strong>线性查找</strong></p>
<p>我们需要多少步？</p>
<p>最多6步（长度只有索引5的列表）</p>
<p>以此类推，一个长度为n的列表，线性查找的步数最多就是n（自然数）</p>
<p>3、插入</p>
<p>从列表里插入一个新元素，取决于插入的位置。</p>
<p>末尾插入：一步</p>
<p>开头插入：一步是真正的插入，六步是在移动数据。</p>
<p>类推，一个n长度的列表，最坏的情况，插入需要n+1步，n次移动，一次插入（开头插入）</p>
<p>4、删除：</p>
<p>末尾删除：一步</p>
<p>开头删除：一步删除，5步时移动元素</p>
<p>类推·，一个长度n的列表，删除，最坏情况，n步（n-1（移动元素）+1（删除元素））</p>
<p><strong>集合：set （不允许元素重复）</strong></p>
<p>比如说，我们现在需要一个电话本来存储一万个电话，我们需要选择一个数据结构（一个电话不应该出现两次）</p>
<p>1、读取：一步</p>
<p>2、查找：n步</p>
<p>3、插入：</p>
<p>末尾插入：（需要先确定插入的值在不在集合中间）检查元素6步，插入一步</p>
<p>类推，n长度的集合，末尾插入，n+1（n步检查元素，1步用来插入元素）</p>
<p>开头插入，n步（检查元素），1步（插入），n步（移动元素）</p>
<p>那么，最坏的情况 ，插入需要2n+1步</p>
<p><strong>数据结构的的性能（理解），关键在于步数。</strong></p>
<p>算法，不高级。</p>
<p>某种操作的过程。</p>
<p>读取、查找、插入、删除</p>
<p>有序列表</p>
<p>二分查找（5，线性：5步。二分需要：2步）</p>
<p>python</p>
<p><strong>1、将序列分解为单独的变量，序列（数据结构）</strong></p>
<p>问题：我们有一个包含n个元素的元组或者序列，现在想把它分解成n个单独的变量</p>
<p>解决方案：任何的序列都可以通过一个简单的赋值操作来分解为单独的变量，唯一的要求是变量的总数和结构要与序列一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tuple=(1,2,3)</span><br><span class="line">x,y,z=tuple</span><br><span class="line">print(x,y,z)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tuple=(1,2,3,4)</span><br><span class="line">x,y,z=tuple</span><br><span class="line">print(x,y,z)</span><br></pre></td></tr></table></figure>

<p>ValueError: too many values to unpack (expected 3)</p>
<p>元素的数量不匹配，就会得到错误提示。</p>
<p>讨论：上面是元组。来看一下其他的序列（可以迭代的对象），比如：字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str=&quot;hello&quot;</span><br><span class="line">_,a,_ ,_  ,_   =str</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p><strong>2、从任意长度的可迭代对象中分解元素</strong></p>
<p>问题：需要从某个可迭代对象（字符串、列表、集合、字典）分解出n个元素，但是这个可迭代对象的长度可能超过了n，这就会出现分解的值过多的情况。</p>
<p>解决方案：python中的*表达式可以解决这个问题。</p>
<p>比如：我开了一门课，并且决定在期末成绩中去掉一个最高分，去掉一个最低分，接下来求平均数。</p>
<p>*，用在两个字面量或者变量中间，乘号</p>
<p>单一的* ，*是用来接受多个参数，并且放到一个元组里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def demo(*p):</span><br><span class="line">    print(p)</span><br><span class="line">demo(1,2)</span><br></pre></td></tr></table></figure>

<p>函数在调用多个参数的时候，在可迭代对象作为实参，并在前面加*</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def d(a,b,c):</span><br><span class="line">    print(a,b,c)</span><br><span class="line"></span><br><span class="line">a=[1,2,3]</span><br><span class="line">b=[1,2,3]</span><br><span class="line">c=[1,2,3]</span><br><span class="line"></span><br><span class="line">d(*a)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=(&quot;liupeng&quot;,&quot;liupeng@qq.com&quot;,&quot;110&quot;,&quot;119&quot;)</span><br><span class="line">name,email,*phone = list</span><br><span class="line">print(phone)</span><br><span class="line">print(name)</span><br><span class="line">print(email)</span><br></pre></td></tr></table></figure>

<p>不管需要分解出多少个电话号码（甚至说没有电话号码），变量phone都一直是一个列表，而这时毫无意义的，如此一来，任何使用了变量phone的代码（万一这些代码默认phone是一个字符串，那么如果出错了，这些代码就不负责任。）</p>
<p>由*修饰的变量也可以位于列表最开始，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=(&quot;liupeng&quot;,&quot;liuxiaopen&quot;,&quot;liupeng@qq.com&quot;)</span><br><span class="line">*name,email=list</span><br><span class="line">print(name)</span><br><span class="line">print(email)</span><br></pre></td></tr></table></figure>

<p>讨论：分解未知或者任意长度的可迭代对象，这种扩展式的操作可谓是是量身定做的工作，通常，这类可迭代对象中会有一些已知的组件或者模式，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line=&quot;E:\qq\3179623450\FileRecv\MobileFile&quot;</span><br><span class="line"></span><br><span class="line">panfu,*dir=line.split(&quot;:&quot;)</span><br><span class="line">print(panfu)</span><br><span class="line">print(dir)</span><br></pre></td></tr></table></figure>

<p>用这种*式的语法所支持的分解操作非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=[&#x27;acme&#x27;,50,39,343,54,232,(12,3,54,2021)]</span><br><span class="line">name,*_,(*_,year)=list</span><br><span class="line">print(name)</span><br><span class="line">print(year)</span><br></pre></td></tr></table></figure>

<p>这个就是说，有时候想分解出某些值然后丢弃他们，在分解的时候，不能只是一个单独的*，可以使用激光常用的来表示要丢掉的变量名。</p>
<p>递归不是python的强项。</p>
<p>递归深度过深（1000），RecursionError: maximum recursion depth exceeded</p>
<p>电脑不同，栈空间或许不同</p>
<p>python为什么对递归有限制，是为了害怕内存溢出。递归有限制，效率低，而且有大量重复计算，时间复杂度搞。默认最大深度1000。</p>
<p><strong>3、保存最后n个元素</strong></p>
<p>问题：我们希望在迭代或者是其他的形式的处理过程中对最后迹象记录做一个有限的历史记录。</p>
<p>解决方案：from collections import deque</p>
<p>讨论：编写搜索某项记录的代码时，通常会用到含有id的生成器。</p>
<p>deque（maxlen=n）创建一个固定长度的队列，当有新纪录加入而队列满了的时候回自动转移那一条最老的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections import deque  # 内部库,内库</span><br><span class="line">q=deque(maxlen=3)</span><br><span class="line">q.append(1)</span><br><span class="line">q.append(2)</span><br><span class="line">q.append(3)</span><br><span class="line">print(q)</span><br><span class="line">q.append(4)</span><br><span class="line">print(q)</span><br></pre></td></tr></table></figure>

<p>尽管在列表中可以使用append与del手动完成这些操作，但是我们使用队列这种解决方法会优雅并且运行速度会快得多。</p>
<p>更普遍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q=deque()</span><br><span class="line">q.append(1)</span><br><span class="line">q.append(2)</span><br><span class="line">q.append(3)</span><br><span class="line">q.append(4)</span><br><span class="line">print(q)</span><br><span class="line">q.appendleft(5)</span><br><span class="line">print(q)</span><br><span class="line">print(q.pop())</span><br></pre></td></tr></table></figure>

<p>从队列两端添加或者弹出元素的步数，1步。O(1)</p>
<p>列表从开始插入或者删除元素，n步，O（n）</p>
<p><strong>4、找到最大或者最小的n个元素</strong></p>
<p>问题：我们想在某个集合中找出最大或者最小的n个元素</p>
<p>解决方案：heapq模块（内库）中有两个函数，nlargest（）和nsmallest（）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line">nums=[1,3,5,65,-1,453,121,-65]</span><br><span class="line">print(heapq.nlargest(2,nums))</span><br><span class="line">print(heapq.nsmallest(2,nums))</span><br></pre></td></tr></table></figure>

<p>这正是我们需要的，这两个函数都可以接受一个参数key，从而允许他们工作在更加复杂的数据结构之下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line">list=[</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng&#x27;,&quot;age&quot;:18,&#x27;class&#x27;:12&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng1&#x27;,&quot;age&quot;:23,&#x27;class&#x27;:45&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng2&#x27;,&quot;age&quot;:43,&#x27;class&#x27;:2&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng3&#x27;,&quot;age&quot;:21,&#x27;class&#x27;:22&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng4&#x27;,&quot;age&quot;:54,&#x27;class&#x27;:62&#125;,</span><br><span class="line">    &#123;&#x27;name&#x27;:&#x27;liupeng5&#x27;,&quot;age&quot;:23,&#x27;class&#x27;:212&#125;</span><br><span class="line">]</span><br><span class="line">forclass=heapq.nsmallest(3,list,key=lambda s :s[&quot;class&quot;])</span><br><span class="line">minage=heapq.nlargest(3,list,key=lambda s:s[&quot;age&quot;])</span><br><span class="line">print(forclass)</span><br><span class="line">print(minage)</span><br></pre></td></tr></table></figure>

<p>讨论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line">nums=[1,2,3,54,12,546,-324,-54,67512,45,34321,54534,34,53453,465,4645]</span><br><span class="line">heap=list(nums)</span><br><span class="line">heapq.heapify(heap)</span><br><span class="line">print(heapq.heappop(heap))</span><br><span class="line">print(heapq.heappop(heap))</span><br></pre></td></tr></table></figure>

<p>heapify这个方法，排序，从小到大。</p>
<p>那么heap[0]总是最小的那个元素，此外接下来的元素就可以通过headpop方法轻松找到，这个方法将第一个元素（最小的）弹出，然后用第二个元素代替第一个元素。</p>
<p>当所要找的元素相对较小是，nlargest（）和nsmallest（）这个最适合，如果只是想找最大和最小（n=1），min（）和max（）这两个函数更加方便和快捷。如果说n和序列本身的大小差不多。通常先对序列排序，然后做切片。（堆数据结构）</p>
<p><strong>5、实现优先级队列</strong></p>
<p>问题：我们要一个队列，能使用给定的优先级对元素排序，每次pop，都会返回优先级高的元素。</p>
<p>解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import heapq</span><br><span class="line"></span><br><span class="line">class Queue:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._queue=[]</span><br><span class="line">        self._index=0</span><br><span class="line">    def push(self,item,p):</span><br><span class="line">        heapq.heappush(self._queue,(p,self._index,item))</span><br><span class="line">        self._index+=1</span><br><span class="line">    def pop(self):</span><br><span class="line">        return heapq.heappop(self._queue)[-1]</span><br><span class="line"></span><br><span class="line">class Item:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#x27;Item(&#123;!r&#125;)&#x27;.format(self.name)</span><br><span class="line"></span><br><span class="line">q=Queue()</span><br><span class="line">q.push(Item(&#x27;liupeng&#x27;),1)</span><br><span class="line">q.push(Item(&#x27;liupeng1&#x27;),5)</span><br><span class="line">q.push(Item(&#x27;liupeng2&#x27;),3)</span><br><span class="line">q.push(Item(&#x27;liupeng3&#x27;),8)</span><br><span class="line">q.push(Item(&#x27;liupeng4&#x27;),12)</span><br><span class="line">q.push(Item(&#x27;liupeng5&#x27;),45)</span><br><span class="line">print(q.pop())</span><br><span class="line">print(q.pop())</span><br><span class="line">print(q.pop())</span><br></pre></td></tr></table></figure>

<p><strong>6、在字典中将键映射到多个值上</strong></p>
<p>问题：我们想要一个能将键映射到多个值的字典，一键多值</p>
<p>解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=&#123;</span><br><span class="line">    &quot;a&quot;:[1,2,3],</span><br><span class="line">    &quot;b&quot;:(1,6)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line"># a=defaultdict(list)</span><br><span class="line"># a[&quot;a&quot;].append(1)</span><br><span class="line"># a[&quot;a&quot;].append(2)</span><br><span class="line"># a[&quot;a&quot;].append(3)</span><br><span class="line"># q=&#123;&#125;</span><br><span class="line"># q.setdefault(&#x27;a&#x27;,[]).append(1)</span><br><span class="line"></span><br><span class="line">d=&#123;&#125;</span><br><span class="line">for key,value in pairs:</span><br><span class="line">    if key not in d:</span><br><span class="line">        d[key]=[]</span><br><span class="line">    d[key].append(value)</span><br><span class="line"></span><br><span class="line">w=defaultdict(list)</span><br><span class="line">for jey,value in pairs1:</span><br><span class="line">    d[key].append(value)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构算法</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建java开发环境</title>
    <url>/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Java语言执行需要经过编译器编译，而后才可以在jvm上解释字节码程序，这些操作都需要jdk的支持才可以正常完成。</p>
<p>jdk java开发工具包，java专属的开发工具，也是最底层的技术支持。</p>
<p>开发者可以直接通过oracle官网（<a href="https://www.oracle.com/cn/java/">Java 软件 | Oracle 中国</a>）获取jdk工具。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224057138.png" alt="image-20210723224057138"></p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224120031.png" alt="image-20210723224120031"></p>
<p>进入java se的下载页面时会展示我们下载的jdk类型。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224213603.png" alt="image-20210723224213603"></p>
<p>同时，除了jdk，也提供了jre的下载。</p>
<p>jre java运行时环境，jdk自带。（分两类，一个是server 一个是client），jre本身不支持开发。</p>
<p>注意选择自己适合的系统版本。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224534162.png" alt="image-20210723224534162"></p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224859826.png" alt="image-20210723224859826"></p>
<p>x86 32位，x64 64位。注意根据自己的电脑系统合理选择。</p>
<p>jdk的安装与配置</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225353570.png" alt="image-20210723225353570"></p>
<p>打开我们下载的一个Windows的程序安装包，双击运行即可安装，并出现以上的界面。点击下一步。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225450635.png" alt="image-20210723225450635"></p>
<p>选择安装目录，不要带有中文的目录。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225543007.png" alt="image-20210723225543007"></p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225554851.png" alt="image-20210723225554851"></p>
<p>显示成功安装。</p>
<p>打开目录</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225655107.png" alt="image-20210723225655107"></p>
<p>打开bin目录。</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225716346.png" alt="image-20210723225716346"></p>
<p>在这个目录里，有两个核心的命令，java.exe and javac.exe</p>
<p>这两个命令本身不属于Windows本身，如果要在命令行（cmd）里直接使用，那么就必须在Windows系统中进行可执行程序的路径配置，也就是环境变量。</p>
<p>计算机——属性——高级系统设置</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225913817.png" alt="image-20210723225913817"></p>
<p>高级——环境变量——系统变量——path</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225943116.png" alt="image-20210723225943116"></p>
<p>添加jdk下bin的目录</p>
<p>E:\Program Files\java-13\bin</p>
<p>打开cmd窗口。</p>
<p>输入 java -version</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723230140245.png" alt="image-20210723230140245"></p>
<p>出现以上内容，表示安装成功。</p>
<p>Windows命令行</p>
<p>可以直接在搜索cmd，dos，命令提示符等，</p>
<p>也可以win +R 打开运行</p>
<p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723230310972.png" alt="image-20210723230310972"></p>
<p>搜索cmd。</p>
<p>如果配置了环境变量，必须重新启动命令行才能加载到最新的环境变量配置。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/07/26/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>数组</p>
<p>数组是程序设计语言里面一门很重要的数据结构，java里，数组是引用数据类型，就必然牵扯到栈内存的开辟和引用传递。</p>
<p>数组是一门非常基础的线性存储结构，可以实现一组变量的有效关联。</p>
<p>数组是一些相关变量的集合。如果我现在要定义100个整形变量，</p>
<p>int i1，i2，i3…i100.</p>
<p>以上的定义方式可以满足需求，但是每一个变量之间不存在逻辑控制关系，每一个变量完全独立，就会出现不方便管理变量的情况。</p>
<p>数组：</p>
<p>声明与开辟：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int listDemo01 [] = new int[10];</span><br><span class="line">int [] listDemo02 = new int[10];</span><br><span class="line">数据类型 [] 数组名称 = new 数据类型[长度]</span><br></pre></td></tr></table></figure>

<p>声明：</p>
<p>数据类型 [] 数组名称 = null；</p>
<p>开辟：</p>
<p>数据名称 = new 数据类型 [长度]；</p>
<p>当数组开辟空间之后，就可以通过访问下标，索引的方式去实现查询，修改，删除。所有数组的索引都是从0开始的。如果访问的索引超过了数组下标的长度，那就会抛出异常，（数据越界）</p>
<p>以上的都是动态初始化的内容，只给了数组长度，如果如上声明，则每一个元素的数据类型都是int，且根据默认值，是0。</p>
<p>数组是一种顺序结构，长度是固定的，输出的时候采用循环。（for循环）</p>
<p>java为了方便获取数组长度，提供了此listDemo01.length属性。</p>
<p>数组的核心：声明并且分配内存空间，而后根据索引进行访问。</p>
<p>数组和对象：差别就在于堆内存中，对象保存的是属性，数组保存的是信息。</p>
<p>静态初始化（在开辟内存空间的时候，就给出数组中元素的值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int data [] =null;</span><br><span class="line">data = new int[] &#123;1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure>

<p>数组最大的方便就是在于可以使用线性结构来存储相同数据类型的变量，但是另一个角度来看，最大的缺陷也正是如此，保存个数固定，因此在实际中，我们会采用类集框架（java提供的数据结构实现）来实现动态数组的操作。但是这并不意味着，我们不会使用数组。</p>
<p>数组引用传递分析：</p>
<p>数组属于引用数据类型，在使用是需要new关键字开辟堆内存空间，一个堆内存可以被多个栈内存指向。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int data[] = new int[]&#123;10, 20, 30&#125;;</span><br><span class="line">int temp[] = data;</span><br><span class="line">temp[0] = 99;</span><br><span class="line">for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">    System.out.print(data[i]+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">99	20	30	</span><br></pre></td></tr></table></figure>



<p>要注意对数组来说，如果只是声明，没有开辟空间，是无法根据下标访问的，否则会报空指针异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int temp[] = null;</span><br><span class="line">temp[0] = 99;</span><br><span class="line">System.out.println(temp[0]);</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></pre></td></tr></table></figure>

<p>foreach输出</p>
<p>数组的输出除了索引和循环之外，还提供了foreach结构。</p>
<p>数组，定长。</p>
<p>foreach（加强的for循环）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int data[] = new int[]&#123;10, 20, 30&#125;;</span><br><span class="line"></span><br><span class="line">for (int temp : data) &#123;</span><br><span class="line">    System.out.println(temp+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：没有foreach关键字。</p>
<p>利用foreach输出，可以避免数组越界异常。</p>
<p>二维数组：</p>
<p>两个数组的嵌套。</p>
<p>之前的数组，一维数组，实际上是一种线性结构。（相当于只描述了一行的内容）</p>
<p>现在我们要描述多行多列的内容，那就需要用到二维数组。（多维数组）</p>
<p>动态初始化、静态初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int data [][] = new int [8][8];</span><br><span class="line">int data1 [][] = new int [][] &#123;&#123;1,1,1&#125;,&#123;2,2,2&#125;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int data1 [][] = new int [][] &#123;&#123;1,1,1&#125;,&#123;2,2,2&#125;,&#123;1,2,4,5,6,7&#125;&#125;;</span><br><span class="line">for (int x =0 ;x&lt;data1.length;x++)&#123;</span><br><span class="line">    for (int y=0;y&lt;data1[x].length;y++)&#123;</span><br><span class="line">        System.out.print(data1[x][y]+&quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外层循环控制行，内存循环控制列。</p>
<p>foreach循环输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int temp[] : data) &#123;</span><br><span class="line">    for (int num: temp) &#123;</span><br><span class="line">        System.out.print(num + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>数组与方法：</p>
<p>在数组进行引用传递，最为常见的就是利用方法进行引用数据的处理或者返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int data[][] = new int[][]&#123;&#123;1, 1, 1&#125;, &#123;2, 2, 2&#125;, &#123;1, 2, 4, 5, 6, 7&#125;&#125;;</span><br><span class="line">    printArray(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void printArray(int data[][])&#123;</span><br><span class="line">    for (int temp[] : data) &#123;</span><br><span class="line">        for (int num: temp) &#123;</span><br><span class="line">            System.out.print(num + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void changeArray(int data[][])&#123;</span><br><span class="line">    for (int temp[] : data) &#123;</span><br><span class="line">        for (int num: temp) &#123;</span><br><span class="line">            num *= 2;</span><br><span class="line">            System.out.print(num+&quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int data[] = new int[]&#123;1, 3, 4, 5, 6, 78, 23, 54, 65, 76, 432, 32, 54&#125;;</span><br><span class="line">    Arrays.sort(data);</span><br><span class="line"></span><br><span class="line">    for (int temp : data) &#123;</span><br><span class="line">        System.out.print(temp + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组转置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int data[] = new int[]&#123;1, 3, 4, 5, 6, 78, 23, 54, 65, 76, 432, 32, 54&#125;;</span><br><span class="line">    Arrays.sort(data);</span><br><span class="line"></span><br><span class="line">    int center = data.length / 2; //确定交换次数</span><br><span class="line">    int head = 0;</span><br><span class="line">    int tail = data.length - 1;</span><br><span class="line">    for (int x = 0; x &lt; center; x++) &#123;</span><br><span class="line">        int temp = data[head];</span><br><span class="line">        data[head] = data[tail];</span><br><span class="line">        data[tail] = temp;</span><br><span class="line">        head++;</span><br><span class="line">        tail--;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int temp : data) &#123;</span><br><span class="line">        System.out.print(temp + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组复制：</p>
<p>是把源数组部分内容复制到另一个数组，但是数组长度不变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int data[] = new int[]&#123;1, 3, 4, 5, 6, 78, 23, 54, 65, 76, 432, 32, 54&#125;;</span><br><span class="line">int data1[] = new int[]&#123;1, 3, 4, 5, 6&#125;;</span><br><span class="line"></span><br><span class="line">System.arraycopy(data,4,data1,1,3);</span><br></pre></td></tr></table></figure>

<p>（源数组名称、源数组开始点、目标数组名、目标数组开始点、长度）</p>
<p>方法可变参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int sum(int... data) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int temp:data) &#123;</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(sum(data));</span><br><span class="line">System.out.println(sum(1,23,45,65,7543,9));</span><br></pre></td></tr></table></figure>

<p>为了方便我们灵活的定义方法，避免参数限制，就给出了方便可变参数。</p>
<p>（参数类型…变量）</p>
<p>混合参数定义时（既有普通参数，也有可变的参数）</p>
<p>可变参数一定要写在最后、并且一个方法只能有一个可变参数</p>
<p>对象数组</p>
<p>数组内不止可以存放基本数据类型，还可以存放引用数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person0 &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person0(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return &quot;name:&quot; + this.name + &quot;\tage:&quot; + this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person0 p1[] = new Person0[3];</span><br><span class="line">        p1[0] = new Person0(&quot;mm&quot;, 7);</span><br><span class="line">        p1[1] = new Person0(&quot;mm01&quot;, 4);</span><br><span class="line">        p1[2] = new Person0(&quot;mm01&quot;, 8);</span><br><span class="line">        for (Person0 temp : p1) &#123;</span><br><span class="line">            System.out.println(temp.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>引用传递应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line">    private Person1 person;</span><br><span class="line"></span><br><span class="line">    public Car(String name, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person1 getPerson() &#123;</span><br><span class="line">        return this.person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPerson(Person1 person) &#123;</span><br><span class="line">        this.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tprice:&quot;+this.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person1&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Car car;</span><br><span class="line"></span><br><span class="line">    public Person1(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Car getCar() &#123;</span><br><span class="line">        return this.car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCar(Car car) &#123;</span><br><span class="line">        this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tage:&quot;+this.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person1 p1 = new Person1(&quot;mm&quot;,7);</span><br><span class="line">        Car c1 = new Car(&quot;mm01&quot;,1223132.32);</span><br><span class="line">        p1.setCar(c1);</span><br><span class="line">        c1.setPerson(p1);</span><br><span class="line">        System.out.println(p1.getCar().getInfo());</span><br><span class="line">        System.out.println(c1.getPerson().getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意87、88.代码链。</p>
<p>自身类结构关联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line">    private Person1 person;</span><br><span class="line"></span><br><span class="line">    public Car(String name, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person1 getPerson() &#123;</span><br><span class="line">        return this.person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPerson(Person1 person) &#123;</span><br><span class="line">        this.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tprice:&quot;+this.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person1&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person1[] getChild() &#123;</span><br><span class="line">        return this.child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setChild(Person1[] child) &#123;</span><br><span class="line">        this.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Car car;</span><br><span class="line">    private Person1 child[];</span><br><span class="line"></span><br><span class="line">    public Person1(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Car getCar() &#123;</span><br><span class="line">        return this.car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCar(Car car) &#123;</span><br><span class="line">        this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tage:&quot;+this.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person1 p1 = new Person1(&quot;mm&quot;,7);</span><br><span class="line">        Person1 child1 = new Person1(&quot;mm01&quot;,7);</span><br><span class="line">        Person1 child2 = new Person1(&quot;mm02&quot;,7);</span><br><span class="line">        child1.setCar(new Car(&quot;法拉克&quot;,121321321.2221));</span><br><span class="line">        child2.setCar(new Car(&quot;卡车拉货&quot;,12132.3231));</span><br><span class="line">        p1.setChild(new Person1[]&#123;child1,child2&#125;);</span><br><span class="line">        Car c1 = new Car(&quot;bbb&quot;,12121.32);</span><br><span class="line">        p1.setCar(c1);</span><br><span class="line">        c1.setPerson(p1);</span><br><span class="line"></span><br><span class="line">        for (int x=0;x&lt;p1.getChild().length;x++)&#123;</span><br><span class="line">            System.out.println(p1.getChild()[x].getInfo());</span><br><span class="line">            System.out.println(p1.getChild()[x].getCar().getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合成设计模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Pc &#123;   //父结构</span><br><span class="line">    private 显示器 对象数组[];  //一台计算机可以连接多个小显示器</span><br><span class="line">    private 主机 对象; //一台计算机只能有一个主机</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 显示器 &#123;  //独立类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 主机 &#123;   //子结构</span><br><span class="line">    private 主板 对象; //一块主板</span><br><span class="line">    private 鼠标 对象1; //一个鼠标</span><br><span class="line">    private 键盘 对象2; //一块键盘</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 主板 &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 鼠标 &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 键盘 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过不同的类实现子结构，然后在父结构中整合。（如上，就是典型的面向对象思想）</p>
<p>引用数据类型不仅仅是内存的操作形式，更多的是抽象和关联的设计思想</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>方法</title>
    <url>/2021/07/25/%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>方法（method，有时候也被叫做函数），指的是一段可以被重复调用的代码块，利用方法可以实现程序的拆分</p>
<p>public static void main(String [] args){}</p>
<p>公共的 静态的 返回值类型 方法名（参数）{</p>
<p>方法体</p>
<p>return【返回值】</p>
<p>}</p>
<p>定义一个无参数，且无返回值的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void method1()&#123;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">method1();</span><br></pre></td></tr></table></figure>

<p>return结束方法调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(10);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void method1(int num)&#123;</span><br><span class="line">    if (num &lt;= 10)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法重载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(10);</span><br><span class="line">    method1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void method1(int num)&#123;</span><br><span class="line">    if (num &lt;= 10)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void method1()&#123;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：方法名相同，但是参数不同（个数、类型）、返回值类型不同。</p>
<p>（为了统一标准，一般来说都用同一种返回值类型，当然也可以不用）</p>
<p>方法递归调用</p>
<p>一种特殊的方法嵌套形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(100);</span><br><span class="line">    System.out.println(method1(100));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int method1(int num)&#123;</span><br><span class="line">    if (num==1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num + method1(num-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求阶乘和。（由于计算结果过大，所以使用了double类型）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(100);</span><br><span class="line">    System.out.println(method1(100));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static double method1(int num)&#123;</span><br><span class="line">    if (num==1)&#123;</span><br><span class="line">        return method2(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return method2(num) + method1(num-1);</span><br><span class="line">&#125;</span><br><span class="line">public static double method2(int num)&#123;</span><br><span class="line">    if (num==1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num * method2(num-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2021/08/03/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>泛型</p>
<p>泛型其实不是java最开始的概念，他起源于jdk5之后，是一个新加入的特性。</p>
<p>泛型的出现是为了解决对象强制转型之后可能出现的安全隐患问题。</p>
<p>我们知道，为了方便参数的统一，我们会使用object类，利用此类对象可以接受所有类型的数据，包括基本数据类型和引用数据类型，但是由于其描述的数据类型过大，所以在实现中就会出现传入数据类型错误，从而引发异常classcastexception异常。</p>
<p>例如：</p>
<p>现在要设计一个描述坐标的类，point（包括x与y坐标轴信息），对于坐标点，允许保留整形、浮点与字符串三类数据。</p>
<p>于是在设计point的时候，就需要考虑到x和y的具体类型，这个类型要求就可以保存以上三种类型的数据，于是最明显的就是利用object进行定义，这是因为存在以下的转换关系：</p>
<p>整形：基本数据类型—包装为integer对象—自动向上转型为object</p>
<p>浮点：基本数据类型——包装为double对象—自动向上转型为object</p>
<p>字符串：string类对象——自动向上转型为object</p>
<p>定义point坐标类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    private Object x;</span><br><span class="line">    private Object y;</span><br><span class="line"></span><br><span class="line">    public Object getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(Object x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(Object y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为采用了object作为存储类型，这样就可以接受任意的数据类型，于是此时可能出现两种情况：</p>
<p>1、使用者按照同意的数据类型设计坐标内容，并且利用向下转型获取原始坐标数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point p1 = new Point();</span><br><span class="line">        p1.setX(10);</span><br><span class="line">        p1.setY(20);</span><br><span class="line"></span><br><span class="line">        int x = (Integer) p1.getX();</span><br><span class="line">        int y = (Integer) p1.getY();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;x:&quot;+x+&quot;y:&quot;+y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用基本数据类型自动装箱为包装类对象的特点向point类对象传入了x与y两个坐标信息，并且在获取坐标原始数据时，也依据设置的数据类型进行强制性的向下转型，所以可以得到正确的执行结果。</p>
<p>2、使用者没有按照统一的数据类型设置坐标内容，读取数据时使用了错误的类型进行强制转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point p2 = new Point();</span><br><span class="line">p2.setX(100);</span><br><span class="line">p2.setY(&quot;北纬20度&quot;);</span><br><span class="line"></span><br><span class="line">int x1 = (Integer) p2.getX();</span><br><span class="line">int y1 = (Integer) p2.getY();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;x:&quot; + x + &quot;y:&quot; + y);</span><br></pre></td></tr></table></figure>

<p>值得一提的是，程序完全符合语法规范，不会在编译的时候告诉开发者，而是会在执行过程中才会出现安全隐患，而造成此问题的核心就是object类型能够接收的类型过大。</p>
<p>泛型：可以在编译时检测出程序的安全隐患，使得程序更加的健壮。</p>
<p>如果想要解决项目中可能出现的classcastexception安全隐患，最核心的方案就是避免强制性的向下转型，所以泛型的核心思想就是，类中的属性或方法的参数与返回值的类型采用动态标记，在对象实例化的时候动态配置要使用的数据类型。</p>
<blockquote>
<p><strong>泛型在类上标记出以后，需要通过实例化对象进行类型的设置，而所设置的类型只能够是引用数据类型，如果要设置基本数据类型，则必须采用包装类的形式，这就是为什么jdk5之后才引入包装类对象的自动装箱和自动拆箱机制的原因。</strong></p>
</blockquote>
<p>在类上使用泛型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Point&lt;T&gt; &#123;</span><br><span class="line">    private T x;</span><br><span class="line">    private T y;</span><br><span class="line"></span><br><span class="line">    public T getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(T x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(T y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point&lt;Integer&gt; p1 = new Point&lt;Integer&gt;();</span><br><span class="line">        p1.setX(100);</span><br><span class="line">        p1.setY(20);</span><br><span class="line"></span><br><span class="line">        int x = p1.getX();</span><br><span class="line">        int y = p1.getY();</span><br><span class="line">        System.out.println(&quot;x:&quot;+x+&quot;y:&quot;+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本程序中实例化point类对象所采用的的泛型设置为了integer，这样一类当前point类对象的x，y的属性类型就是integer，对应的方法参数和返回值也都是integer，这样不仅可以在编译的时候明确知道数据类型的错误，也避免了对象向下转型操作。</p>
<blockquote>
<p>7之后的jdk版本再定义泛型的时候简化了，在实例化对象时的泛型类型就通过声明时的泛型类型来定义了，但是依旧建议使用完整语法。</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point&lt;Integer&gt; p1 = new Point&lt;&gt;();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>为了照顾到最初的开发者，允许开发者在实例化对象时不设置泛型类型，这样在程序的编译时就会出现相应的警告信息，同时为了保证程序不出错，未设置的泛型类型将使用object作为默认类型。</p>
<p>泛型虽然保证了代码的正确性。但是对于引用传递会带来参数统一问题。</p>
<p>利用泛型类在实例化对象时进行的动态类型匹配，虽然可以有效地解决对象向下转型的安全隐患，但是在程序中实例化泛型类对象时，不同的泛型类型对象之间彼此是无法进行引用传递的。</p>
<p>所以在进行泛型类型的引用对象时，为了可以适应所有本类的实例化对象，则可以在接收时使用“？”作为泛型通配符来使用，利用？表示的泛型类型只允许从对象中获取数据，而不允许修改数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Point&lt;T&gt; &#123;</span><br><span class="line">    private T x;</span><br><span class="line">    private T y;</span><br><span class="line"></span><br><span class="line">    public T getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(T x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(T y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point&lt;Integer&gt; p1 = new Point&lt;Integer&gt;();</span><br><span class="line">        p1.setY(100);</span><br><span class="line">        fun(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fun (Point &lt;?&gt; temp)&#123;</span><br><span class="line">        System.out.println(temp.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不设置泛型类型或者设置泛型类型为object可否解决以上问题？</p>
<p>1、public static void fun(point <object> temp){}</object></p>
<p>2、public static void fun(point temp){}</p>
<p>泛型需要考虑到操作类型统一性</p>
<p>首先搞清楚一个核心问题，object可以接收一切的数据类型，但是在泛型概念里，point<string>与point<integer>这是两个不同的类型的对象。</integer></string></p>
<p>如果采取类型1的引用，表示fun方法只接收point<object>类型的引用</object></p>
<p>如果采取类型2的引用，实际上可以解决当前问题（不同泛型类型的对象传递），但是也会带来新的问题，允许随意修改数据</p>
<p><strong>观察不设置泛型类型的方法参数定义：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Point&lt;T&gt; &#123;</span><br><span class="line">    private T x;</span><br><span class="line">    private T y;</span><br><span class="line"></span><br><span class="line">    public T getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(T x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(T y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point&lt;Integer&gt; p1 = new Point&lt;Integer&gt;();</span><br><span class="line">        p1.setY(100);</span><br><span class="line">        fun(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fun (Point temp)&#123;</span><br><span class="line">        temp.setY(199);</span><br><span class="line">        System.out.println(temp.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完程序可以发现，虽然不设置泛型类型可以实现对所有泛型类型的接收，但是无法对修改做出控制，然而使用了通配符？只允许获取，不允许修改。</p>
</blockquote>
<p>通配符？除了可以匹配任意的泛型类型之外，还可以通过泛型上限和下限的配置实现更加严格的类型定义。</p>
<p>类和方法：设置泛型的上限，（？ extends 类）只能够使用当前类或者其子类设置泛型</p>
<p>方法：设置泛型的下限，（？ super 类）只能设置指定的类或者父类。</p>
<p>设置泛型上限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class  demo22_1 &lt;T extends Number&gt;&#123;</span><br><span class="line">    private T content;</span><br><span class="line"></span><br><span class="line">    public T getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(T content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo22 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo22_1&lt;Integer&gt; d1 = new demo22_1&lt;Integer&gt;();</span><br><span class="line">        d1.setContent(199);</span><br><span class="line">        fun(d1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fun(demo22_1&lt;? extends Number&gt; temp)&#123;</span><br><span class="line">        System.out.println(temp.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置泛型的下限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class demo23_1&lt;T&gt;&#123;</span><br><span class="line">    private T content;</span><br><span class="line"></span><br><span class="line">    public T getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(T content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo23_1&lt;String&gt; d1 = new demo23_1&lt;&gt;();</span><br><span class="line">        d1.setContent(&quot;i always love mm&quot;);</span><br><span class="line">        fun(d1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void fun(demo23_1&lt;? super String&gt; temp)&#123;</span><br><span class="line">        System.out.println(temp.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>泛型接口</p>
<p>泛型可以定义在任意程序的结构体中</p>
<p>泛型也可以定义在接口上，这样的接口叫做泛型接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface demo24_1&lt;T&gt;&#123;</span><br><span class="line">    String echo(T t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于此时的泛型接口来说，子类定义时就有两种方式，在子类中继续声明泛型和子类中为父类设置泛型类型。</p>
<p>1、在子类中继续声明泛型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface demo24_1&lt;T&gt;&#123;</span><br><span class="line">    String echo(T t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class demo24_2&lt;S&gt; implements demo24_1&lt;S&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String echo(S t1) &#123;</span><br><span class="line">        return &quot;echo:&quot;+t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo24_1&lt;String&gt; d1= new demo24_2&lt;String&gt;();</span><br><span class="line">        System.out.println(d1.echo(&quot;i always like mm&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义子类声明了一个泛型标记S，并且实例化子类对象的时候，设置的泛型类型会传递到泛型接口中去。</p>
<p>2、在子类中为父类设置泛型;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface demo24_1&lt;T&gt;&#123;</span><br><span class="line">    String echo(T t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class demo24_2 implements demo24_1&lt;String&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String echo(String t1) &#123;</span><br><span class="line">        return &quot;echo:&quot;+t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo24_1&lt;String&gt; d1= new demo24_2();</span><br><span class="line">        System.out.println(d1.echo(&quot;i always like mm&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类时，没有定义泛型标记，而是为父接口设置了泛型类型为string，所以说在覆写echo方法的时候，参数类型就是string。</p>
<p>泛型方法：对于泛型，除了可以定义在类上之外，也可以在方法上进行定义，而在方法上直接定义的泛型不一定要在类中定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demo25 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer num [] = fun(1,2,3,4,5,6,7,8,9);</span><br><span class="line">        for (int temp: num) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T[] fun(T... args)&#123;</span><br><span class="line">        return args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，这是在一个没有泛型声明的类中定义了泛型方法，所以在fun方法声明处就必须单独定义泛型标记，此时的泛型类型由传入的参数来决定。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制语句</title>
    <url>/2021/07/20/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="流程控制语句（练习）"><a href="#流程控制语句（练习）" class="headerlink" title="流程控制语句（练习）"></a>流程控制语句（练习）</h2><h2 id="1、获取用户输入，判断奇数还是偶数"><a href="#1、获取用户输入，判断奇数还是偶数" class="headerlink" title="1、获取用户输入，判断奇数还是偶数"></a>1、获取用户输入，判断奇数还是偶数</h2><p>​    input函数的返回值默认是字符串类型，而字符串类型是无法直接用整形的运算符的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num=int（input(&quot;请输入一个任意的整数：&quot;)）</span><br><span class="line">if num%2==0:</span><br><span class="line">    print(&quot;偶数！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;奇数&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="2、检查一个年份是否是闰年"><a href="#2、检查一个年份是否是闰年" class="headerlink" title="2、检查一个年份是否是闰年"></a>2、检查一个年份是否是闰年</h2><p>​    闰年：年份可以被4整除并且不能被100整除，或者可以被400整除，这个年份刚好就是闰年</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">year=int(input(&quot;请输入一个任意的年份：&quot;))</span><br><span class="line">if year %4==0 and year % 100==0 or year % 400 ==0:</span><br><span class="line">    print(year,&quot;是闰年&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(year,&quot;不是闰年！&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="3、我有一条狗，他叫大鹏，他今年五岁了，他相当于人类多大年龄？"><a href="#3、我有一条狗，他叫大鹏，他今年五岁了，他相当于人类多大年龄？" class="headerlink" title="3、我有一条狗，他叫大鹏，他今年五岁了，他相当于人类多大年龄？"></a>3、我有一条狗，他叫大鹏，他今年五岁了，他相当于人类多大年龄？</h2><p>​    狗的年纪：狗的前两年的每一年相当于人类的10.5岁，然后每一年增加四岁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dog_age=float(input(&quot;请输入狗的年龄：&quot;))</span><br><span class="line">like_person_age=0</span><br><span class="line">if dog_age&gt;0:</span><br><span class="line">    if dog_age&lt;=2:</span><br><span class="line">        like_person_age=dog_age*10.5</span><br><span class="line">    else:</span><br><span class="line">        like_person_age=2*10.5</span><br><span class="line">        like_person_age+=(dog_age-2)*4</span><br><span class="line">    print(dog_age,&quot;岁的狗，相当于人类年龄的&quot;,like_person_age,&#x27;岁&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;请输入一个合法的年龄！&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="4、小鹏的期末成绩"><a href="#4、小鹏的期末成绩" class="headerlink" title="4、小鹏的期末成绩"></a>4、小鹏的期末成绩</h2><p>​    当成绩为100的时候，奖励一台手机</p>
<p>​    当成绩为80到99的时候，奖励一台ps4</p>
<p>​    当成绩为60到79的时候，奖励他一本参考书</p>
<p>​    其他，奖励他一个大嘴巴子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">score=int(input(&quot;请输入小鹏的成绩：&quot;))</span><br><span class="line"># 来一条华丽的分割线</span><br><span class="line">print(&quot;==&quot;*40)</span><br><span class="line"># 检查用户的输入</span><br><span class="line">if 0 &lt;= score &lt;= 100:</span><br><span class="line">    # 判断奖励</span><br><span class="line">    if score == 100:</span><br><span class="line">        print(&quot;奖励一台手机&quot;)</span><br><span class="line">    elif score &gt;= 80:</span><br><span class="line">        print(&quot;ps4，拿去玩吧！&quot;)</span><br><span class="line">    elif score &gt;= 60:</span><br><span class="line">        print(&quot;参考书！拿去！&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;大嘴巴子！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;你的输入内容不合法！&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="5、高富帅问题，小鹏要结婚了，要娶一个女孩子，但是女方家里有条件"><a href="#5、高富帅问题，小鹏要结婚了，要娶一个女孩子，但是女方家里有条件" class="headerlink" title="5、高富帅问题，小鹏要结婚了，要娶一个女孩子，但是女方家里有条件"></a>5、高富帅问题，小鹏要结婚了，要娶一个女孩子，但是女方家里有条件</h2><p>​    高：180dm以上，富：1000块以上，帅：颜值分250以上</p>
<p>​    如果三个条件都满足，“一定能娶到老婆”</p>
<p>​    如果三个条件有一个满足，“有可能娶到老婆”</p>
<p>​    如果三个条件都不满足，“一定娶不到”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">height=int(input(&quot;请输入你的身高！&quot;))</span><br><span class="line">money=int(input(&quot;请输入你的余额！&quot;))</span><br><span class="line">face=int(input(&quot;你觉得你这张脸能打多少分！&quot;))</span><br><span class="line">if height &gt;180 and money &gt;1000 and fcae &gt; 250:</span><br><span class="line">    print(&quot;一定能娶到老婆&quot;)</span><br><span class="line">elif height &gt;180 or money &gt;1000 or face &gt; 250:</span><br><span class="line">    print(&quot;有可能娶到老婆&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;不嫁给你！&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="6、大鹏大战白骨精"><a href="#6、大鹏大战白骨精" class="headerlink" title="6、大鹏大战白骨精"></a>6、大鹏大战白骨精</h2><p>​    首先，你可以有两个身份，大鹏和白骨精</p>
<p>​    其次，你有生命值和攻击力，生命值归0，那一方输了，另一方胜利。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示欢迎信息</span><br><span class="line"></span><br><span class="line">print(&quot;+&quot;*40)</span><br><span class="line">print(&quot;欢迎来到大鹏大战白骨精&quot;)</span><br><span class="line">print(&quot;+&quot;*40)</span><br><span class="line"></span><br><span class="line"># 身份选择</span><br><span class="line"></span><br><span class="line">print(&quot;请选择你的身份！&quot;)</span><br><span class="line">print(&quot;\t 1.大鹏&quot;)</span><br><span class="line">print(&quot;\t 2.白骨精&quot;)</span><br><span class="line">player_choose=input(&quot;请选择[1|2]&quot;)</span><br><span class="line"></span><br><span class="line"># 华丽的分割线</span><br><span class="line"></span><br><span class="line">print(&quot;+&quot;*40)</span><br><span class="line"></span><br><span class="line"># 提示信息</span><br><span class="line"></span><br><span class="line">if player_choose==&quot;1&quot;:</span><br><span class="line">    print(&quot;你已经选择了1，你将会用大鹏的身份来进行游戏！&quot;)</span><br><span class="line">elif player_choose==&quot;2&quot;:</span><br><span class="line">    print(&quot;你居然选了白骨精！你还是会用大鹏的身份进行游戏！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;你的输入有问题！系统将自动分配身份！你将成为不要脸的大鹏！&quot;)</span><br><span class="line"></span><br><span class="line"># 进行游戏</span><br><span class="line"></span><br><span class="line">player_life=100</span><br><span class="line">player_attack=1000</span><br><span class="line"></span><br><span class="line">boss_life=10000</span><br><span class="line">boss_attack=10</span><br><span class="line"></span><br><span class="line"># 华丽的分割线</span><br><span class="line"></span><br><span class="line">print(&quot;+&quot;*40)</span><br><span class="line">print(f&#x27;大鹏，你的生命值是&#123;player_life&#125;,你的攻击力是&#123;player_attack&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(&quot;请选择你要做的操作！&quot;)</span><br><span class="line">    print(&#x27;\t 1.练级&#x27;)</span><br><span class="line">    print(&#x27;\t 2.打boss&#x27;)</span><br><span class="line">    print(&#x27;\t 3.逃跑&#x27;)</span><br><span class="line">    game_choose=input(&quot;请选择要做的操作！&quot;)</span><br><span class="line">   if game_choose==&#x27;1&#x27;:</span><br><span class="line">    player_life+=1</span><br><span class="line">    player_attack+=1</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(f&quot;恭喜你升级了，你现在的生命值是&#123;player_life&#125;,你的攻击力是&#123;player_attack&#125;&quot;)</span><br><span class="line"></span><br><span class="line">elif game_choose==&#x27;2&#x27;:</span><br><span class="line">    boss_life-=player_attack</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(&#x27;大鹏偷袭了白骨精！不讲武德！&#x27;)</span><br><span class="line">    if boss_life &lt;=0:</span><br><span class="line">        print(f&#x27;白骨精受到了&#123;player_attack&#125;点伤害，重伤不治，最终还是死了，大鹏获得了胜利！&#x27;)</span><br><span class="line">        break</span><br><span class="line">    </span><br><span class="line">    player_life-=boss_attack</span><br><span class="line">    print(&#x27;白骨精攻击了大鹏，大快人心！&#x27;)</span><br><span class="line">    if player_life &lt;=0:</span><br><span class="line">        print(f&#x27;大鹏受到了&#123;boss_attack&#125;点伤害，重伤不治，最后死了！game over!&#x27;)</span><br><span class="line">        break</span><br><span class="line">elif game_choose==&#x27;3&#x27;:</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(&#x27;大鹏扭头就跑！，撒腿就跑！game over!&#x27;)</span><br><span class="line">    break</span><br><span class="line">else:</span><br><span class="line">    print(&quot;+&quot;*40)</span><br><span class="line">    print(&quot;你的输入有问题&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="7、求1000以内的所有的质数"><a href="#7、求1000以内的所有的质数" class="headerlink" title="7、求1000以内的所有的质数"></a>7、求1000以内的所有的质数</h2><p>（质数就是除了1和他本身，不能被其他数整除的数，除数，被除数）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个循环，求1-1000以内的质数</span><br><span class="line">i=2</span><br><span class="line">while i&lt;=1000:</span><br><span class="line">    # 创建一个变量，储存一下i的状态</span><br><span class="line">    flag=True</span><br><span class="line">    # 判断i是否为质数</span><br><span class="line">    j=2</span><br><span class="line">    while j &lt; i:</span><br><span class="line">        if i % j == 0:</span><br><span class="line">            flag=False</span><br><span class="line">        j += 1</span><br><span class="line">    if flag:</span><br><span class="line">        print(i)</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure>

<h2 id="8、求1000以内的水仙花数"><a href="#8、求1000以内的水仙花数" class="headerlink" title="8、求1000以内的水仙花数"></a>8、求1000以内的水仙花数</h2><p>水仙花数：是一个n位数（n&gt;=3），他的每一个位上的数字的n次幂之和等于它本身<br>$$<br>153=1<strong>3+5</strong>3+3**3<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 求1000以内的水仙花数</span><br><span class="line">i = 100</span><br><span class="line">while i &lt; 1000 :</span><br><span class="line">    # 假设 i的百位数是a，十位数是b，个位数是c</span><br><span class="line">    a = i // 100</span><br><span class="line">    # b = i // 10 % 10</span><br><span class="line">    b = ( i- a * 100 ) // 10</span><br><span class="line">    c = i % 10</span><br><span class="line">    if a ** 3 + b ** 3 + c ** 3 == i:</span><br><span class="line">        print(i)</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure>

<h2 id="9、打印99乘法表"><a href="#9、打印99乘法表" class="headerlink" title="9、打印99乘法表"></a>9、打印99乘法表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个循环，来控制高度</span><br><span class="line">i = 0</span><br><span class="line">while i &lt; 9:</span><br><span class="line">    i += 1</span><br><span class="line">    # 创建一个循环，来控制宽度</span><br><span class="line">    j = 0</span><br><span class="line">    while j &lt; i:</span><br><span class="line">        j += 1</span><br><span class="line">        print(f&quot;&#123;j&#125;*&#123;i&#125;=&#123;i*j&#125; &quot;,end=&quot;&quot;)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>真正的看python（1）</title>
    <url>/2021/07/20/%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%9C%8Bpython%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="真正的看python（1）"><a href="#真正的看python（1）" class="headerlink" title="真正的看python（1）"></a>真正的看python（1）</h1><h2 id="1、python是一门解释性语言嘛？"><a href="#1、python是一门解释性语言嘛？" class="headerlink" title="1、python是一门解释性语言嘛？"></a>1、python是一门解释性语言嘛？</h2><p>是但不完全是，python其实是一门基于虚拟机的语言，首先他有三门主要的解释器，他利用这个解释器，来解释并且执行自己定义的语法来生成代码执行。解释性语言并不需要编译。</p>
<p>再说的清楚一点、计算机并不能直接理解我们的语言，他只能理解机器语言，也就是0和1，因此，我们需要进行翻译。</p>
<p>而翻译，有两种，一种就是解释、一种就是编译。</p>
<p>编译型语言、在我们的程序执行之前，会通过编译器编译为机器语言</p>
<p>，那么在运行的时候，就不需要翻译，直接执行就可以了，最典型的例子就是c。</p>
<p>解释型语言、没有提前编译的过程，在程序运行的时候，通过解释器对程序逐行做出解释，然后执行。</p>
<p>可以发现，从效率上来说，势必的，编译型语言的效率绝对是要比解释型语言要强的，但是现在的热门语言其实已经脱离了单纯的编译和解释的差别。</p>
<p>例如，java，java先通过编译器编译成字节码文件，然后运行时通过解释器解释成机器文件，可以说java是先编译再解释的语言。</p>
<p>python，其实和java一样，都是基于虚拟机的，同样也是先编译再解释的语言。</p>
<p>py文件，pyc文件，pycodeobject文件。</p>
<p>py文件不用说，就是我们写的，pyc我们也能在硬盘上看到。</p>
<p>pycodeobject其实是python编译器真正编译成的结果，只不过当程序运行时，这个文件被保存在内存中，运行完了后，解释器会把这个文件写到pyc文件中，当程序第二次运行时，首先会寻找pyc文件，然后对py和pyc的时间戳判断，是否修改过，没有的话，就直接载入pyc。</p>
<p>那么就很清晰了，pyc其实就是pyo的持久化存储方式。</p>
<h2 id="2、python的面向对象"><a href="#2、python的面向对象" class="headerlink" title="2、python的面向对象"></a>2、python的面向对象</h2><p>首先，要明白，面向对象是一种编程方式、基于的是类和对象的使用。</p>
<p>类是一个模板，封装了多个函数和变量。对象就是根据模板创建的实例。</p>
<p>面向对象有三大特性，封装、继承、多态。</p>
<p>来看看类。</p>
<span id="more"></span>

<p>类有成员，即字段、方法和属性。</p>
<p>java中static修饰了静态的变量和方法。而静态变量被储存在方法区里，实际上，static修饰的变量已经成为了类的成员。（没学过java的可以略过这一段）</p>
<p>在python里，字段分为两种类型，一种是在函数外定义的普通字段，这一类字段，只需要声明变量名和初始值就可以，同时这一类的字段属于类的成员，在实例化为对象的时候，是保存在内存中的、访问也是类型变量名的形式去访问，而另外一种，则是写在init初始化函数的变量，这一类的我们称之为静态字段，静态字段不同的是，这是保存在对象中的内容。</p>
<p>简明一点来说，普通字段定义在函数体外，同时属于对象。静态字段定义在init初始化函数体内，属于类。</p>
<p>那么在访问方式上的差别也就比较明显了，普通字段是通过对象访问的，静态字段则是由类去访问的。</p>
<p>再推导开去，静态字段在类中，那么在内存中，只保存一份，但是普通字段属于对象，那么就意味着每初始化一次对象、就会保存一份普通字段。</p>
<p>那么回到场景之中，如果说每个对象都有相同的字段时，那么就可以静态字段了。</p>
<p>方法，不存在属于类或者对象的差异，因为无论是类方法还是静态方法还是普通的方法，这三种方法在内存中都归属于类，区别仅仅是调用方式的差异罢了。</p>
<p>普通方法：由对象来调用，至少要有一个self参数，执行普通方法时，自动将调用方法的对象赋值个self。</p>
<p>类方法：由类来调用，至少一个cls参数，执行类方法是，自动将调用该方法的类赋值给cls。</p>
<p>静态方法：由类来调用，没有默认的参数</p>
<p>其实对于方法而言，都属于类，在内存当中只保存一份，只是在调用的时候，调用者不同，那么自动传入的参数也不同罢了。</p>
<p>属性，属性其实严格意义上说是一种特殊的普通方法。</p>
<p>定义时，使用装饰器定义，只有一个self参数，调用的时候，不用括号。</p>
<p>属性存在的意义是，访问属性时可以制造出和访问字段完全相同的假象，它由方法变种而来，如果没有属性，那么方法可以完全代替他。</p>
<p>那么属性的功能其实就很清楚了，内部进行一系列的逻辑计算，最红返回一个计算结果。</p>
<p>python的类是分为经典类和新式类的，其中新式类的属性比经典类的属性要丰富一些（两者的区别，就是是否继承了object，继承了就是新式类）</p>
<p>经典类中，具有一种装饰器。</p>
<p>新式类中，具有三种装饰器定义属性。</p>
<p>经典类中的属性只有一种访问方式，其对应被 <code>@property</code> 修饰的方法</p>
<p>新式类中的属性有三种访问方式，并分别对应了三个被<code>@property</code>、<code>@方法名.setter</code>、<code>@方法名.deleter</code>修饰的方法</p>
<p>由于新式类中具有三种访问方式，我们可以根据他们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p>
<p>静态字段方式，创建值为property对象的静态字段</p>
<p>当使用静态字段的方式创建属性时，经典类和新式类无区别</p>
<p>property的构造方法中有个四个参数</p>
<ul>
<li>第一个参数是方法名，调用 <code>对象.属性</code> 时自动触发执行方法</li>
<li>第二个参数是方法名，调用 <code>对象.属性 ＝ XXX</code> 时自动触发执行方法</li>
<li>第三个参数是方法名，调用 <code>del 对象.属性</code> 时自动触发执行方法</li>
<li>第四个参数是字符串，调用 <code>对象.属性.__doc__</code> ，此参数是该属性的描述信息</li>
</ul>
<p>由于静态字段方式创建属性具有三种访问方式，我们可以根据他们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p>
<p>所以，定义属性共有两种方式，分别是【装饰器】和【静态字段】，而【装饰器】方式针对经典类和新式类又有所不同。</p>
<p><strong>类成员的修饰符</strong></p>
<p>类的所有成员在上一步骤中已经做了详细的介绍，对于每一个类的成员而言都有两种形式：</p>
<ul>
<li>公有成员，在任何地方都能访问</li>
<li>私有成员，只有在类的内部才能方法</li>
</ul>
<p><strong>私有成员和公有成员的定义不同：</strong>私有成员命名时，前两个字符是下划线。（特殊成员除外，例如：<strong>init</strong>、<strong>call</strong>、<strong>dict</strong>等）</p>
<p><strong>私有成员和公有成员的访问限制不同：</strong></p>
<p><strong>静态字段</strong></p>
<ul>
<li>公有静态字段：类可以访问；类内部可以访问；派生类中可以访问</li>
<li>私有静态字段：仅类内部可以访问</li>
</ul>
<p><strong>普通字段</strong></p>
<ul>
<li>公有普通字段：对象可以访问；类内部可以访问；派生类中可以访问</li>
<li>私有普通字段：仅类内部可以访问；</li>
</ul>
<p>ps：如果想要强制访问私有字段，可以通过 【对象._类名__私有字段明 】访问（如：obj._C__foo），不建议强制访问私有成员。</p>
<p>方法、属性的访问于上述方式相似，即：私有成员只能在类内部使用</p>
<p><em>ps：非要访问私有属性的话，可以通过</em> <em><code>对象._类__属性名</code></em></p>
<p><strong>类的特殊成员</strong></p>
<p>上文介绍了Python的类成员以及成员修饰符，从而了解到类中有字段、方法和属性三大类成员，并且成员名前如果有两个下划线，则表示该成员是私有成员，私有成员只能由类内部调用。无论人或事物往往都有不按套路出牌的情况，Python的类成员也是如此，存在着一些具有特殊含义的成员，详情如下：</p>
<p><strong>1.</strong> <strong>doc</strong></p>
<p>表示类的描述信息</p>
<p><strong>2.</strong> <strong>module</strong> <strong>和</strong> <strong>class</strong></p>
<ul>
<li><strong>module</strong> 表示当前操作的对象在那个模块</li>
<li><strong>class</strong> 表示当前操作的对象的类是什么</li>
</ul>
<p><strong>3.</strong> <strong>init</strong></p>
<p>构造方法，通过类创建对象时，自动触发执行。</p>
<p><strong>4.</strong> <strong>del</strong></p>
<p>析构方法，当对象在内存中被释放时，自动触发执行。</p>
<p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p>
<p><strong>5.</strong> <strong>call</strong></p>
<p>对象后面加括号，触发执行。</p>
<p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p>
<p><strong>6.</strong> <strong>dict</strong></p>
<p>类或对象中的所有成员</p>
<p>上文中我们知道：类的普通字段属于对象；类中的静态字段和方法等属于类.</p>
<p><strong>7.</strong> <strong>str</strong></p>
<p>如果一个类中定义了<strong>str</strong>方法，那么在打印 对象 时，默认输出该方法的返回值。</p>
<p><strong>8、getitem、setitem、delitem</strong></p>
<p>用于索引操作，如字典。以上分别表示获取、设置、删除数据</p>
<p><strong>9、getslice、setslice、delslice</strong></p>
<p>该三个方法用于分片操作</p>
<p><strong>10.</strong> <strong>iter</strong></p>
<p>用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了 <strong>iter</strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>程序基础概念</title>
    <url>/2021/07/24/%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>程序都有其各自的代码结构，所以对于代码的命名就需要通过标识符来完成，但是一个完整的程序的核心意义在于数据的处理、那么掌握数据类型的定义以及运算就是最重要的基础知识。</p>
<p>1、注释</p>
<p>在程序中，基本组成都是代码，所以考虑到程序可维护性的特点，在编写代码的时候在每段代码上增加若干说明文字，即注释。注释本身不需要被编译器编译。</p>
<p>java里一共分为3种形式的注释</p>
<p>单行注释</p>
<p>多行注释</p>
<p>文档注释</p>
<p>2、标识符与关键字</p>
<p>程序本质是一个逻辑结果的综合体，在java里有很多不同的结构。</p>
<p>例如：类、方法、变量结构。</p>
<p>对于这些不同的结构一定要有不同的说明，这些说明就被称为标识符，所以在进行标识的时候一定要采取有意义的名称。</p>
<p>java中定义标识符的原则，字母、数字、下划线、$美元符号，不能用数字开头、不能使用保留的关键字。</p>
<p>1、尽量的不要用数字</p>
<p>2、命名尽量有意义，不要使用类似x y之类的简单标识符。</p>
<p>3、标识符区分大小写</p>
<p>4、$ 美元符号有特殊含义（内部类）</p>
<p>数据类型</p>
<p>程序严格来讲都是一个数据处理游戏，所有数据的保存就必须有严格的限制，具体就体现在数据类型的划分上。也就是不同的数据类型的保存不同的的数据内容。</p>
<p>java数据类型基本可以分为基本数据类型、引用数据类型</p>
<p>基本数据类型：byte、short、int、long、float、double、char、boolean</p>
<p>引用数据类型在操作的时候必须进行内存的开辟。基本数据类型不牵扯内存分配的问题。</p>
<p>考虑到语言的严谨性，java需要对每一个变量进行数据类型的定义，这样才方便开辟内存空间，同时在进行变量定义的时候可以通过赋值表达式对变量设置初始化内容。</p>
<p>整型</p>
<p>byte、short、int、long</p>
<p>默认的数据类型是int。（整型常量）</p>
<p>数据类型转换</p>
<p>自动转换：范围小——范围大</p>
<p>强制转换：大——小（数据溢出）</p>
<p>浮点型 小数 double</p>
<p>char</p>
<p>16进制的unicode</p>
<p>布尔型</p>
<p>一种逻辑结果，true和false</p>
<p>string</p>
<p>string是java提供一个系统类，这个类比较特殊，不是基本数据类型，但是可以像基本数据类型一样直接定义并且使用。</p>
<p>转义字符：\ \ \t \n &#39; &quot;</p>
<p>运算符</p>
<p>&amp;&amp;      ||</p>
<p>短路与 短路或</p>
<p>（逻辑运算符）</p>
<p>boolean || boolean （短路原则）（有假则假）</p>
<p>&amp;   | （位运算符）</p>
<p>逻辑与 逻辑或 （按位与、按位或）</p>
<p>逻辑是从左到右全部判断、短路得到结果就停止。</p>
<p>3 5</p>
<p>0011 </p>
<p>0101</p>
<p>3 | 5  0111 7</p>
<p>3 &amp; 5 0001 1</p>
<p>负数的补码</p>
<p>&lt;&lt; &gt;&gt; 按位左移 按位右移</p>
<p>19 </p>
<p>二进制：原码：0001 0011</p>
<p>20</p>
<p>010100</p>
<p>按位与 都是1，就是1. </p>
<p>按位或 有一个1，就是1</p>
<p>异或 相同就是0，不同就是1</p>
<p>取反</p>
<p>-20</p>
<p>二进制原码：1001 0100</p>
<p>反码：1110 1011 + 1 = 补码</p>
<p>补码：1110 1100（将原码求反码，每一位不包含符号位第一位，加一）</p>
<p>按位取反：0001 0011（正数）</p>
<p>19</p>
<p>正数的补码、反码、原码都是一样的。</p>
<p>20</p>
<p>原码：0001 0100</p>
<p>按位取反：1110 1011</p>
<p>取反码：1001 0100</p>
<p>取补码：1001 0101</p>
<p>-21</p>
<p>取反</p>
<p>1、求补码</p>
<p>2、按位取反</p>
<p>3、求补码(最终结果)</p>
<p>按位左移、按位右移。(负数补1，正数补0)</p>
<p>20 &lt;&lt; 2</p>
<p>0000 0000 0001 0100</p>
<p>0000 0000 0101 0000</p>
<p>80</p>
<p>20 &gt;&gt; 2</p>
<p>0000 0000 0001 0100</p>
<p>0000 0000 0000 0101</p>
<p>5</p>
<p>无符号右移（全部补0）</p>
<p>20 &gt;&gt;&gt; 2</p>
<p>~13</p>
<p>原码、补码：0000 1101</p>
<p>按位取反：1111 0010</p>
<p>取反码：1000 1101</p>
<p>取补码：1000 1110</p>
<p>-14</p>
<p>~-27</p>
<p>原码：1001 1011</p>
<p>反码：1110 0100</p>
<p>补码：1110 0101</p>
<p>按位取反：0001 1010（正数）</p>
<p>26</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>程序逻辑控制</title>
    <url>/2021/07/24/%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>程序是一场数据的计算游戏，想要让这些数据处理更加具有逻辑性，那么就需要利用分支结构与循环结构来实现控制。</p>
<p>程序逻辑</p>
<p>java中的程序结构有三种：顺序结构、分支（选择）结构、循环结构。</p>
<p>这三种结构的共同点是，他们都只拥有一个入口，也只有一个出口。单一的入口和出口可以让程序更加的易读，好维护，可以减少调试的时间。</p>
<p>顺序结构</p>
<p>程序自上而下<strong>逐行</strong>执行，一条语句执行完之后继续执行下一条语句，一直到程序的末尾。</p>
<p>这是程序设计中最常的使用到的结构，在程序的世界扮演了举足轻重的角色，因为大部分的程序基本上都是按照这种由上而下的流程来设计的。</p>
<p>分支结构</p>
<p>选择结构是根据判断条件的成立与否再决定要执行哪些语句的一种结构。</p>
<p>这种结构可以依据判断条件的结构来决定要执行的语句，当判断条件的值为真的时候，则执行语句，为假的时候，则执行另外的语句。</p>
<p>循环结构</p>
<p>根据判断条件的成立与否，决定程序段落的执行次数</p>
<p>分支结构</p>
<p>根据布尔表达式的判断结果来决定是否执行某段代码</p>
<p>java里的分支结构有两种，if分支结构和switch开关结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;else if (true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;else if(true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;else &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch开关结构。</p>
<p>switch是一种开关语句，它主要根据内容来进行判断。注意一点，switch只能判断int、枚举、string、char类型的数据。不能使用布尔表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Demolist &#123;</span><br><span class="line">//定义一个枚举类型</span><br><span class="line">    a, b, RED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">    Demolist demolist = Demolist.RED;</span><br><span class="line"></span><br><span class="line">    switch (10 | &#x27;a&#x27; | &quot;i miss mm&quot; | demolist) &#123;</span><br><span class="line">        case 1: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 2: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case RED: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if可以判断布尔表达式、switch只能判断内容。</p>
<p>switch语句默认的会从第一个满足的case语句开始执行全部的语句代码，直到全部执行完或者遇到了break语句。</p>
<p>循环结构</p>
<p>while</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">    </span><br><span class="line">&#125;while (true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while需要先判断条件再执行，do先执行再判断</p>
<p>避免死循环。（循环条件一直满足）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">int sum = 0;</span><br><span class="line">while (num &lt;= 100) &#123;</span><br><span class="line">    sum += num;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result:&quot; + sum);</span><br></pre></td></tr></table></figure>

<p>for</p>
<p>while是根据判断条件的结果来实现是否执行，for，在明确知道循环次数的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">for (int num = 1; num &lt;= 100; num++) &#123;</span><br><span class="line">    sum += num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result:&quot; + sum);</span><br></pre></td></tr></table></figure>

<p>for（循环初始化条件 ; 循环判断 ; 循环变更）{</p>
<p>}</p>
<p>循环初始化条件：只执行一次</p>
<p>循环判断：循环前后各执行一次</p>
<p>循环变更：循环内语句执行完执行一次</p>
<p>尽量不要这么去写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line"></span><br><span class="line">int sum = 0;</span><br><span class="line">for (;num &lt;= 100;) &#123;</span><br><span class="line">    sum += num;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result:&quot; + sum);</span><br></pre></td></tr></table></figure>

<p>while：不确定循环次数的情况下、确定循环结束条件的时候用。</p>
<p>for：确定循环次数。</p>
<p>循环控制语句</p>
<p>continue</p>
<p>break</p>
<p>循环结构内，只要条件满足，就会一直执行。</p>
<p>这程序内，提供了两个停止的控制语句，一个continue（退出本次循环），一个break（退出整个循环）。</p>
<p>循环嵌套</p>
<p>循环结构可以在内部嵌入若干个循环结构。这样可以实现更加复杂的循环。（注意，时间复杂度）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int x = 1; x &lt;= 9; x++) &#123;</span><br><span class="line">    for (int y = 1; y &lt;= x; y++) &#123;</span><br><span class="line">        System.out.print(y + &quot;*&quot; + x + &quot;=&quot; + (x * y) + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> int line =10;</span><br><span class="line">        for (int x =0;x&lt;line;x++)&#123;</span><br><span class="line">            for(int y =0;y&lt;line-x;y++)&#123;</span><br><span class="line">//                输出空格</span><br><span class="line">                System.out.print(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int y =0;y&lt;x;y++)&#123;</span><br><span class="line">                System.out.print(&quot;* &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>笔趣阁爬虫—scrapy小实例</title>
    <url>/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="笔趣阁爬虫—scrapy小实例"><a href="#笔趣阁爬虫—scrapy小实例" class="headerlink" title="笔趣阁爬虫—scrapy小实例"></a>笔趣阁爬虫—scrapy小实例</h1><h2 id="项目环境："><a href="#项目环境：" class="headerlink" title="项目环境："></a>项目环境：</h2><h3 id="基础环境："><a href="#基础环境：" class="headerlink" title="基础环境："></a>基础环境：</h3><p>Windows10主机</p>
<p>Python 3.9（版本不一，可能写法不同）</p>
<p>Pycharm 2021.1.3</p>
<h3 id="外部库："><a href="#外部库：" class="headerlink" title="外部库："></a>外部库：</h3><p>scrapy（注意scrapy基于c语言的异步组件twisted，自行下载）</p>
<p>Pymysql，连接数据库。</p>
<h2 id="下载与安装（略）、"><a href="#下载与安装（略）、" class="headerlink" title="下载与安装（略）、"></a>下载与安装（略）、</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>与传统意义的爬虫一样，scrapy也是通过对目标url发起请求来获取响应信息，而后解析这些信息，来得到我们想要的数据，</p>
<p>但是与传统爬虫不一样的，scrapy使用了c语言编写的异步组件来实现异步请求，从而大大的提高了爬虫的效率，众所周知，python是没有真正的多线程的，因此纯python开发的爬虫在scrapy面前不堪一击。</p>
<p>异步往往意味着一些不好的事情发生，例如爬取小说网站中最为关注的顺序问题。</p>
<p>​    同时，scrapy作为一个框架，我们不需要编写全部的代码，同时我们也不能那么去做，就如同一个工厂，我们只需要在里面添加内容就可以了。</p>
<p>新笔趣阁，这是我们要爬取的目标网站，</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image002.png" alt="img"></p>
<p>与传统小说网站一样，我们需要首先对主页中的全部小说页面发起请求，之后在拿到每一本小说对应的url。</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image003.png" alt="img"></p>
<p>在拿到这样的数据之后，我们继续对这个url进行请求。</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image005.png" alt="img"></p>
<p>发起请求，网站给我们返回了一个章节列表，同样我们需要解析出url地址并且逐个访问。</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image007.png" alt="img"></p>
<p>来到正文页面解析，这里就是我们想要的数据了。</p>
<h2 id="编写items，确定字段"><a href="#编写items，确定字段" class="headerlink" title="编写items，确定字段"></a>编写items，确定字段</h2><p>这是scrapy中的关键文件之一，首先你要确定自己想要获取的信息，在本例中，设置了三个变量，在分别对应，小说名，章节名以及章节内容。</p>
<p>当然你也可以选择扩充，不过在这里要提醒你的是，无论我们如何去写，最终的结果都是，数以百万甚至更多的url摆在哪里，我们需要对每个url发送一次请求，要想保证效率，又想要数据的准确性，说实话，items里的数据，全部在最底层的网页中比较好。</p>
<p>观察如上的网页，我们确定好三个字段。</p>
<p>Items文件内容如下：</p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image009.png" alt="img"></p>
<h2 id="Setting文件，设置编码以及是否遵循robot协议"><a href="#Setting文件，设置编码以及是否遵循robot协议" class="headerlink" title="Setting文件，设置编码以及是否遵循robot协议"></a>Setting文件，设置编码以及是否遵循robot协议</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image011.png" alt="img"></p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image013.png" alt="img"></p>
<h2 id="编写管道文件，连接数据库"><a href="#编写管道文件，连接数据库" class="headerlink" title="编写管道文件，连接数据库"></a>编写管道文件，连接数据库</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image015.png" alt="img"></p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image017.png" alt="img"></p>
<p>值得一提的是，在管道文件中，写入了异常处理语句，以及插入数据的时候添加的双引号，具体是针对于，某些章节特殊符号的出现，出现写入异常，从而终止了爬虫，添加双引号是为了贴合mysql的规范，避免1064错误。</p>
<h2 id="真正的爬虫，demo"><a href="#真正的爬虫，demo" class="headerlink" title="真正的爬虫，demo"></a>真正的爬虫，demo</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image019.png" alt="img"></p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image021.png" alt="img"></p>
<p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image023.png" alt="img"></p>
<p>这是真正的爬虫主体，我们需要先设置域名，然后确定第一个url，值得一提，我使用了yield这个生成器来逐个发起请求，但是这并不意味着一定的一致性，因为twisted的关系，同样可能会出现数据不一致的情况，所以尽量保证所有数据在最底层的url里。通过逐步解析url，最终得到数据，提交给管道储存。</p>
<h2 id="Start，编写启动脚本"><a href="#Start，编写启动脚本" class="headerlink" title="Start，编写启动脚本"></a>Start，编写启动脚本</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image024.png" alt="img"></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="item的数据只有最后一条"><a href="#item的数据只有最后一条" class="headerlink" title="item的数据只有最后一条"></a>item的数据只有最后一条</h3><p>出现这种情况一般存在是在需要进行遍历的时候，将item对象放在了for循环的外面，解决方法：直接放进去就可以了。</p>
<h3 id="item字段传递后混乱、错误"><a href="#item字段传递后混乱、错误" class="headerlink" title="item字段传递后混乱、错误"></a>item字段传递后混乱、错误</h3><p>有时候遇到这种情况，item传递几次之后，发现不同页面的数据被混乱的组合在了一起，这种情况一般出在item的传递过程中，解决方式可以像我那样，将所有要存放的数据全部放在最后一层里，但是这并不友好，因此，建议是使用深拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">def parse_base(self,response):</span><br><span class="line"></span><br><span class="line">  base_url = &#x27;https://www.base_url.com&#x27;</span><br><span class="line"></span><br><span class="line">  for result in result_list:</span><br><span class="line"></span><br><span class="line">​    item = ExampleItem()</span><br><span class="line"></span><br><span class="line">​    item[&#x27;name&#x27;] = result.css(&#x27;div a::text&#x27;).extract_first()</span><br><span class="line"></span><br><span class="line">​    item[&#x27;age&#x27;] = result.css(&#x27;div #id&#x27;).extract_first()</span><br><span class="line"></span><br><span class="line">​    yield scrapy.Request(url=base_url,meta=copy.deepcopy(&#123;&#x27;item&#x27;:item&#125;),callback=self.parse_detail) # 使用深拷贝将item存在meta中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">def parse_detail(self,response):</span><br><span class="line"></span><br><span class="line">  item = response.meta[&#x27;item&#x27;] # 取出之前传递的item</span><br><span class="line"></span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  do some thing</span><br><span class="line"></span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  yield item</span><br></pre></td></tr></table></figure>



<h3 id="对一个页面要进行多种的解析"><a href="#对一个页面要进行多种的解析" class="headerlink" title="对一个页面要进行多种的解析"></a>对一个页面要进行多种的解析</h3><p>出现这种情况的原因是，scrapy默认的对同一个url，相同的body以及相同的请求视为一个请求，但是如果我们想要对同一页面有不同的请求时，就会发现默认情况下只能得到第一个parse的结果。解决方式：设置参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def start_requests(self):</span><br><span class="line"></span><br><span class="line">  base_url = &#x27;https://www.base_url.com&#x27;</span><br><span class="line"></span><br><span class="line">  yield scrapy.Request(url=base_url,dont_filter=&#x27;True&#x27;,callback=self.parse_one)</span><br><span class="line"></span><br><span class="line">  yield scrapy.Request(url=base_url,dont_filter=&#x27;True&#x27;,callback=self.parse_two)</span><br></pre></td></tr></table></figure>



<h3 id="Xpath中contains的使用"><a href="#Xpath中contains的使用" class="headerlink" title="Xpath中contains的使用"></a>Xpath中contains的使用</h3><p>这种情况出现在标签没有特定属性值但是文本中又包含了特定的汉字的时候，当然也可以包含特定的属性值来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def parse(self,response):</span><br><span class="line"></span><br><span class="line">  item = BookItem()</span><br><span class="line"></span><br><span class="line">  item[&#x27;author&#x27;] = response.xpath(&#x27;//span[contains(.//text(),&quot;作者：&quot;)]//text()&#x27;).split(&#x27;作者：&#x27;)[-1] # 先用contains限定好特定的span标签，然后取出文本字符串并进行字符串切片得到需要的信息。下同</span><br><span class="line"></span><br><span class="line">  item[&#x27;book_name&#x27;] = response.xpath(&#x27;//span[contains(.//text(),&quot;书名：&quot;)]//text()&#x27;).split(&#x27;书名：&#x27;)[-1]</span><br><span class="line"></span><br><span class="line">  yield item</span><br><span class="line"></span><br><span class="line">### 提取不在</span><br></pre></td></tr></table></figure>

<h3 id="标签的文本内容"><a href="#标签的文本内容" class="headerlink" title="标签的文本内容"></a>标签的文本内容</h3><p>这种情况也会出现，加入文本在两个标签中间，但是不属于任何一个，此时可以用xpath或者正则来解决这个问题。</p>
<h3 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h3><p>当页面数据需要登陆进行抓取时，就需要模拟登陆了。常见的方式有：使用登陆后的cookie来抓取数据；发送表单数据进行登陆；使用自动化测试工具登陆，比如selenium配合chrome、firefox等，不过听说selenium不再更新，也可以使用chrome的无头模式。鉴于自动化测试的抓取效率比较低，而且我确实很久没使用过这个了。本次只讨论使用cookie和发送表单两种方式来模拟登陆。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/2021/07/25/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-1/</url>
    <content><![CDATA[<p>类与对象</p>
<p>面向对象，java一大特点之一。</p>
<p>面向对象三大特性：封装、继承、多态。</p>
<p>类：成员属性和成员方法组成的，成员属性实际上就是一个变量，方法就是操作上的行为。</p>
<p>定义类，要根据程序语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    </span><br><span class="line">    public void tell()&#123;</span><br><span class="line">        System.out.println(name+&quot;\t&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点注意，没有static。</p>
<p>调用形式不同，主类中（public修饰的类）由主方法（main）直接调用的方法必须加static。但是现在tell方法是由对象调用的。</p>
<p>一个类定义完成之后。并不能直接使用，因为类描述的只是一个广泛的概念，具体的操作要通过对象来执行，类属于引用数据类型。</p>
<p>对象的定义格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person p1 = new Person();</span><br></pre></td></tr></table></figure>

<p>类名 对象名 = new 类名（）;</p>
<p>java里引用数据类型是需要进行内存分配，所以在定义的时候必须用new关键字来分配相对应的内存空间，这个过程也被叫实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(p1.name);</span><br><span class="line">System.out.println(p1.age);</span><br><span class="line">p1.tell();</span><br></pre></td></tr></table></figure>

<p>对象内存分析</p>
<p>引用数据类型必须用new开辟内存，才可以储存成员属性，在引用数据类型操作中最重要的内存有两块。</p>
<p>heap（堆）：对象的具体信息（成员属性），new开辟的也正是堆内存</p>
<p>stack（栈）：保存的是堆内存的地址，也就是通过地址找到堆，而后找到对象内容，简单理解就是栈里保存了对象名称。</p>
<p>方法信息</p>
<p>类中成员属性是对象私有的，但是方法是对象共有的，方法的信息会保存在全局方法区（公共内存）</p>
<p>对象引用传递分析</p>
<p>引用传递是java的核心概念。引用数据类型的核心就是在于堆内存和栈内存的分配与指向处理，同一块堆内存可以指向不同的栈内存。（一个人可以有很有名字）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">p1.name=&quot;mm&quot;;</span><br><span class="line">p1.age=8;</span><br><span class="line">p1.tell();</span><br><span class="line">Person p2=p1;</span><br><span class="line">p2.age=9;</span><br><span class="line">p1.tell();</span><br></pre></td></tr></table></figure>

<p>引用传递（将p1对象的内存堆地址赋值给p2）这就相当于两个不同的栈内存指向了同一块堆内存。</p>
<p>引用传递与垃圾产生分析</p>
<p>内存管理，java——gc机制。</p>
<p>一块栈只允许一个堆内存地址信息。（如果需要改变，那就存在一个丢弃原有的引用实体，更换新的引用实体的问题。）</p>
<p>丢弃原始引用实体的时候（产生垃圾）</p>
<p>所有的垃圾都将等待gc不定期回收释放。</p>
<p>开发的时候尽量避免垃圾产生。</p>
<p>成员属性封装</p>
<p>封装性、本质上就是让内部结构对外不可见。</p>
<p>如果没有封装，类中的所有成员属性可以直接通过实例化对象在类外部直接调用，但是这样的调用是很不安全的，这时最稳妥的就是使用private关键字对成员属性进行封装处理。</p>
<p>当使用了private之后，是不允许外部对象直接访问成员属性的。</p>
<p>此时，访问成员属性，需要用到getter（），setter（）方法。</p>
<p>实际上，不仅针对成员属性封装，还有方法、内部类封装，这里只说一点点。</p>
<p>setter和getter的目的，是为了设置和取得属性内容，有时候或许不会用到其中某一个，但是作为一种标准，我们必须全部提供。</p>
<p>还可以在setter里添加限制条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if (age &gt;= 0 &amp;&amp; age &lt;= 300) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;this age is error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tell() &#123;</span><br><span class="line">        System.out.println(name + &quot;\t&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法与匿名对象</p>
<p>构造方法是实例化的时候一种重要的结构，一种特殊的方法。在new这个类的时候，默认调用构造方法，功能：主要是为了完成成员属性的初始化操作。</p>
<p>构造方法名和类名一样，构造方法没有返回值<strong>类型</strong>。</p>
<p>其实，对象实例化一定要求有构造方法的，java提供了一个默认的构造方法。（这个方法没有参数、没有返回值，如果我们定义了，那就不会生成。）一个类中至少存在一个构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的构造方法。</p>
<p>构造方法虽然特殊，但还是方法，就存在重载。不过构造方法重载的时候只需要考虑参数的类型个数就可以了。</p>
<p>对象实例化的时候，new关键字主要是进行开辟堆内存，对象名称是为了对堆内存的引用，这样一是为了防止堆内存变成垃圾空间。</p>
<p>有了构造方法之后，在堆内存开辟的同时就可以对对象进行实例化处理，也就是即使没有栈内存指向，也就是没有对象名称，但是对象至少可以使用一次，对于这种没有指向的对象就叫做匿名对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demo01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Person(&quot;mm&quot;,7).tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String tempname,int tempage)&#123;</span><br><span class="line">        name = tempname;</span><br><span class="line">        age = tempage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if (age &gt;= 0 &amp;&amp; age &lt;= 300) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;this age is error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tell() &#123;</span><br><span class="line">        System.out.println(name + &quot;\t&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程序，因为没有栈内存的指向，所以这个对象在使用了一次之后将成为垃圾空间。</p>
<p>匿名对象相当于一个一次性饭盒，使用一次就被定义为垃圾空间，等待gc回收，普通对象存在一个引用关系，所以就可以反复操作。</p>
<p>this关键字</p>
<p>this描述的是本类结构调用的关键字，java里this可以描述3种结构</p>
<p>1、类的属性</p>
<p>2、类的方法</p>
<p>3、当前对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    char sex;</span><br><span class="line"></span><br><span class="line">    public Person(String name,int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if (age &gt;= 0 &amp;&amp; age &lt;= 300) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;this age is error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tell() &#123;</span><br><span class="line">        System.out.println(this.name + &quot;\t&quot; + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明确的标注了本类属性。</p>
<p>在日后，为了避免不必要的bug，只要是调用成员属性时，最好加this。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Person(String name,int age)&#123;</span><br><span class="line">    this.setName(name);</span><br><span class="line">    setAge(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对于是否使用this没有明确要求，但是从标准出发，采用this.方法名（）</p>
<p>但一个程序出现多个构造方法时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Person(String name,int age)&#123;\</span><br><span class="line">    this();</span><br><span class="line">    this.setName(name);</span><br><span class="line">    setAge(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Person()&#123;</span><br><span class="line">    System.out.println(&quot;this is a person&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，要注意，这里为了避免出现死循环（递归调用），要注意留一个出口。</p>
<p>this当前对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Person p1 = new Person();</span><br><span class="line">    p1.tell();</span><br><span class="line">    Person p2 = new Person();</span><br><span class="line">    p2.tell();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void tell() &#123;</span><br><span class="line">        System.out.println(this.name + &quot;\t&quot; + this.age);</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里实例化了两个person对象，分别调用了tell方法，通过执行结果得出，this会随着对象不同而表现出不同的实例。</p>
<p>this.属性，严格意义上来说，这一操作执行的是当前对象的属性。</p>
<p>static关键字</p>
<p>属性、方法、代码块</p>
<p>类的成员，属性和方法，静态的和非静态的。</p>
<p>对象不同，各自的属性内容也不同。</p>
<p>静态的含义：类中的某个属性变成公共的。（所有对象都可以去使用），则在声明前加上static关键字。</p>
<p>static关键字声明后，this调用不了。</p>
<p>static属性属于类，而不属于对象。</p>
<p>所以在调用的时候，直接用类名访问。</p>
<p>static属性存在（全局数据区）</p>
<p>static方法</p>
<p>static定义方法时，通过类名来调用。（方法体不能含有当前对象的属性或方法也就是this调用的属性或者方法。）</p>
<p>static代码块</p>
<p>主类</p>
<p>优于主方法执行</p>
<p>非主类</p>
<p>优于构造代码块执行</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/2021/07/20/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>函数</p>
<p>python是一门面向对象的语言，万物皆是对象（一切其实皆函数（不准确，不正确））</p>
<p>函数也是一种对象（内存中专门用来储存数据的一块区域）</p>
<p>函数可以保存一些可执行的代码，并且，在需要的时候，这一部分代码可以重复的使用。</p>
<p>创建函数：</p>
<p>def 函数名（形参1，形参2…..）：</p>
<p>​    代码块</p>
<p>函数名的命名规范，（不能占用保留字符，可以包含字母、数字、下划线，但是不能用数字开头）</p>
<p>函数中保存的代码不会立即执行，而是要调用才会执行（注意函数的参数）</p>
<p>调用函数</p>
<p>函数名（参数）</p>
<p>函数可以没有参数，也可以有多个参数，调用时必须要符合定义的规范</p>
<p>参数</p>
<p>形参（就相当于在函数内部声明了一个变量），多个形参用逗号隔开</p>
<p>实参（实际参数）调用函数的时候，传递进来的参数，实参会赋值给形参</p>
<p>有几个形参就要几个实参</p>
<p>函数式的编程</p>
<p>在python中，函数式一等对象</p>
<p>一等对象，如下特点</p>
<p>1、对象是在运行时创建的</p>
<p>2、能赋值给变量或者作为数据结构中的元素</p>
<p>3、能作为参数转递</p>
<p>4、能作为返回值返回</p>
<p>高阶函数</p>
<p>第一、接受一个或者多个函数作为参数</p>
<p>第二、将函数作为返回值返回</p>
<p>第三、装饰器</p>
<p>类与对象</p>
<p>面向对象</p>
<p>所谓的面向对象、简单来说就是所有操作都可以通过对象来实现</p>
<p>面向过程、将程序拆解成一个个的步骤</p>
<p>大鹏上学记</p>
<p>​    1、妈妈起床</p>
<p>​    2、妈妈上厕所</p>
<p>​    3、妈妈洗漱</p>
<p>​    4、妈妈做早饭</p>
<p>​    5、妈妈叫大鹏</p>
<p>​    6、大鹏上厕所</p>
<p>​    7、大鹏洗漱</p>
<p>​    8、大鹏吃早饭</p>
<p>​    9、背上书包</p>
<p>​    10、上学校‘</p>
<p>编程思想（面向过程）：将一个功能拆分成许多的小步骤</p>
<p>只适用于一个功能，如果要实现另外一个功能，即使两个功能相差很小，但是依旧要重新写代码</p>
<p>复用性比较低，难于维护</p>
<p>面向对象：关注的不是过程，关注的是对象</p>
<p>大鹏上学记</p>
<p>​    1、大鹏妈妈叫大鹏上学</p>
<p>编程思想（面向对象），将所有的功能保存到一个对象里</p>
<p>比如，妈妈的功能保存到妈妈对象里，大鹏的功能保存到大鹏的对象里，要使用这个功能，直接来找对象。</p>
<p>（要值得一提的是，作为一个功能来讲，（中小功能），面向过程写起来比较酣畅淋漓，同时比较快）</p>
<p>简单归纳一下，面向对象的思想：1、找对象、2、搞对象（设计对象，做对象）、调用对象</p>
<p>类（class）</p>
<p>类和对象是什么关系</p>
<p>类就是对象的图纸！</p>
<p>对象是类的实例</p>
<p>类也是一个对象（一个用来创建对象的对象）</p>
<p>类：</p>
<p>生活中所有的事物都可以抽象出来</p>
<p>1、数据（属性） 变量</p>
<p>2、行为（方法） 函数</p>
<p>所有的这个类的实例都可以对象.属性来访问这个变量，对象.方法（）都可以来调用这个方法</p>
<p>定义一个类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 类名（）:</span><br><span class="line">	公共的一些属性</span><br><span class="line">	a=1</span><br><span class="line">	b=2</span><br><span class="line">	</span><br><span class="line">	对象的初始化方法</span><br><span class="line">	def __init__(self,...):</span><br><span class="line">		...</span><br><span class="line">	其他的方法</span><br><span class="line">	def method():</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<p>p1=类名（）（创建了一个对象，根据类名的那个类）然后，初始化方法就会自动调用，其他方法需要手动调用。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>类结构扩展</title>
    <url>/2021/08/03/%E7%B1%BB%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>类结构扩展</p>
<p>面向对象中核心组成是类与接口，在项目中会利用包进行一组相关类的管理，这样适用于程序代码的更新。也符合了我们面向对象封装性的概念。</p>
<p>包</p>
<p>可以把一个大型项目中的类分别独立出来，并且分别存在文件里，再把这些文件放到一起编译运行。这样的程序更加方便维护，避免代码开发中因为命名所造成的代码冲突。</p>
<p>包的定义</p>
<p>包的主要目的是把不同功能的文件进行分割，所谓的包就是文件夹，在java里可以用package定义包，此语句编写在源代码首行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">public class hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本程序把hello类放到一个自定义包中，这样一来在程序编译后就必须将class文件保存在指定的目录中，但是手动的建立程序包目录比较麻烦，最好的就是进行打包编译处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -d(表示生成目录) .(表示当前目录下生成程序文件) hello,java</span><br></pre></td></tr></table></figure>



<p>项目中必须提供包：在实际开发中，所有的程序类都必须放在一个包里，并且往往会设计一个总包名称和子包名称，所有字母必须小写。</p>
<p>包的导入：<br>利用的包的定义可以将不同功能的程序类保存在不同的包中以实现不同的需要，但是不同的包中的类也可能存在这相互调用的关系，这个时候就需要使用import导入语句来导入被调用的其他包中的程序类。</p>
<blockquote>
<p>注意：类定义的时候必须要使用public class</p>
<p>如果一个包中的类想被其他包中的类使用，那么这个类一定要定位为public class，而不能用class来声明，因为class声明的类只能在同一个包中使用。</p>
<p>注意：public class与class</p>
<p>public class：文件名与类名保持一致，在一个java文件中只能存在public class，同时一个类要想被外部包访问，就必须定义为public class</p>
<p>class：文件名可以与类名不一致，一个java文件可以存在多个class，并且编译时会形成多个class文件，使用class定义的类只能在本包中被使用。</p>
</blockquote>
<p>编译顺序：</p>
<p>问题：现在import导入了一个类，问是那个类先被编译。<br>答：先编译导入的类，然后再编译主类。</p>
<p>可以使用java自动编译。</p>
<p>在开发中如果所有程序代码按照顺序编译，就很可怕，为了解决这个问题，java中可以用*.java的匹配模式进行编译</p>
<p>还可以import 包名.*来导入所有的类。</p>
<p>静态导入</p>
<p>static</p>
<p>当一个类中所有的方法都是静态方法的时候，就可以进行静态导入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import static 包名.类名</span><br></pre></td></tr></table></figure>

<p>优点：不同类的静态方法就感觉是在主类中定义一样，不需要类名称就可以调用。</p>
<p>jar文件</p>
<p>为了整体管理，对程序进行打包，java提供了文件jar。</p>
<p>jar（java archive 归档文件）是java提供的一种压缩格式，即将class文件压缩为jar给用户，这样方便程序的维护。</p>
<p>使用jar：（先编译，再打包）</p>
<p>jar–help</p>
<p>jar -c 创建一个新的文件</p>
<p>jar -v 生成标准的压缩信息</p>
<p>jar -f 由用户自己指定jar的文件名称</p>
<p>系统常用包：</p>
<p>9之后的版本：实际上提供的是一个jar文件。</p>
<p>访问控制权限：</p>
<p>面向对象：封装。（对类结构的保护）</p>
<p>java实现封装就是通过访问控制权限。</p>
<table>
<thead>
<tr>
<th>范围</th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody><tr>
<td>同一个包的同一个类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一个包不同类</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>不同包的子类</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>不同包的非子类</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<p>初学者原则：属性private，方法public。</p>
<p>构造方法私有化</p>
<p>new实例化对象，在设计中，可以让构造方法私有来控制控制实例化对象。</p>
<p>单例设计模式：</p>
<p>整个系统只允许一个类提供实例化对象为，为了实现这个要求，就可以用private封装构造方法，这样子这个类就无法在外部利用new实例化对象。</p>
<p>饿汉单例设计模式：（定义成员属性时，进行对象实例化）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">class Food&#123;</span><br><span class="line">    private static final Food INFO = new Food();</span><br><span class="line"></span><br><span class="line">    private Food() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Food getInfo()&#123;</span><br><span class="line">        return INFO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Food f1 = null;</span><br><span class="line">        f1 = Food.getInfo();</span><br><span class="line">        f1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉单例设计模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private static Person info;</span><br><span class="line"></span><br><span class="line">    private Person() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Person getInfo()&#123;</span><br><span class="line">        if (info == null)&#123;</span><br><span class="line">            info = new Person();</span><br><span class="line">        &#125;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class demo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p1 = null;</span><br><span class="line">        p1 = Person.getInfo();</span><br><span class="line">        p1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义成员属性的时候没有实例化，而是第一次调用方法时实例化了，这样节约程序启动资源。</p>
<p>多例设计模式：</p>
<p>多例设计模式会定义出多个对象，例如性别类，就应该定义男和女两个对象。类似这样的类不应该由用户无限制的创造实例化对象，所以只使用有限的几个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">class Sex&#123;</span><br><span class="line">    private static final Sex MAN = new Sex(&quot;man&quot;);</span><br><span class="line">    private static final Sex WOMAN = new Sex(&quot;woman&quot;);</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    private Sex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sex getInstance(String sex)&#123;</span><br><span class="line">        switch (sex)&#123;</span><br><span class="line">            case &quot;man&quot;:</span><br><span class="line">                return MAN;</span><br><span class="line">            case &quot;woman&quot;:</span><br><span class="line">                return WOMAN;</span><br><span class="line">            case &quot;男&quot;:</span><br><span class="line">                return MAN;</span><br><span class="line">            case &quot;女&quot;:</span><br><span class="line">                return WOMAN;</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Sex s1 = Sex.getInstance(&quot;男&quot;);</span><br><span class="line">        s1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>枚举（一个有名字的集合）</p>
<p>enum，利用此关键字可以实现枚举的定义。利用枚举可以简化多例设计模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">enum Color &#123;</span><br><span class="line">    RED, GREEN, WHITE, BLACK, YELLOW, BLUE, GRAY,PURPLE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Color c: Color.values()) &#123;</span><br><span class="line">            System.out.print(c+&quot;、&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch操作类型：int、char、string、枚举</p>
<p>enum类</p>
<p>枚举不是一种新类型，它只是提供了一种方便的结构，实际上都是继承了一个父类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;</span><br><span class="line">        implements Comparable&lt;E&gt;, Serializable &#123;</span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final String name();</span><br><span class="line">public final int ordinal();</span><br><span class="line">protected Enum(String name, int ordinal)</span><br></pre></td></tr></table></figure>

<p>1、获取对象名</p>
<p>2、获取对象序号</p>
<p>3、传入名字和序号</p>
<p>定义枚举结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">enum Color &#123;</span><br><span class="line">    RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;);</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    private Color(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print(Color color)&#123;</span><br><span class="line">        System.out.println(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Color c: Color.values()) &#123;</span><br><span class="line">            System.out.print(c.ordinal()+c.name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举对象必须写在首行。</p>
<p>枚举应用案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum Sex1&#123;</span><br><span class="line">    MAN(&quot;男&quot;),WOMAN(&quot;女&quot;);</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    private Sex1(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return this.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person1&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Sex1 sex;</span><br><span class="line"></span><br><span class="line">    public Person1(String name, int age, Sex1 sex) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return this.name+this.age+this.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(new Person1(&quot;mm&quot;,7,Sex1.WOMAN));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>进程基础概念</title>
    <url>/2021/09/01/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>一般地，现代程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和io设备。处理器看上去就像在不间断的一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象就是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的的概念之一。</p>
<p>进程是操作系统对一个正在运行的程序的一种抽象，在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而<strong>并发运行</strong>，则是说一个进程的指令和另外一个进程的指令其实是交错着在执行的。</p>
<p>在大多数系统中，需要运行的进程数是可以多于可以运行他们的cpu个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序，这是通过处理器在进程之间切换来实现的，操作系统实现这种交错执行的机制成为<strong>上下文切换</strong>。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息，这种状态，也就是上下文，包括许多信息，比如pc（寄存器，处理器核心（大小为一个字的储存设备））和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单核处理器都只能执行一个进程的代码，当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。</p>
<p>一个进程到另一个进程的转换是由操作系统内核负责管理的，内核不是一个独立的进程，他是操作系统用来管理全部进程所用的代码和数据结构的集合。他是操作系统代码常驻主存的部分，当app需要操作系统的某些操作时，例如最简单的读写文件，内核就会执行一条特殊的系统调用指令，将控制权传递给内核，然后内核执行被请求的操作并返回app。</p>
<p>现在进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作，以后会揭示这项工作的基本原理，以及app是如何创建和控制他们的进程的。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器、生成器与装饰器</title>
    <url>/2021/07/21/%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p>迭代器、生成器与装饰器</p>
<p>迭代器</p>
<p>迭代几乎是python最强的功能之一，是访问集合元素的一种方式</p>
<p>for i in rang(1,101)</p>
<p>迭代器是一个可以记住遍历的位置的<strong>对象</strong></p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完，结束</p>
<p>迭代器<strong>只能前进，不能后退</strong>。</p>
<p>迭代器基本方法：iter（）和next（）</p>
<p>迭代器用在哪儿？（字符串、列表、元组等对象都可以创建迭代器）（序列）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=[1,2,3,4,5]</span><br><span class="line">it=iter(list)</span><br></pre></td></tr></table></figure>

<p>for语句遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=[1,2,3,4,5]</span><br><span class="line">it =iter(list)</span><br><span class="line">for i in it:</span><br><span class="line">	print(i,end=&#x27; &#x27;)</span><br></pre></td></tr></table></figure>

<p>next()函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">list=[1,2,3,4,5]</span><br><span class="line">it =iter(list)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">	try:</span><br><span class="line">		print(next(it))</span><br><span class="line">	except StopIteration:</span><br><span class="line">		sys.exit()</span><br></pre></td></tr></table></figure>

<p>创建一个迭代器</p>
<p>类有一个构造函数，python中，他会在对象初始化的时候执行</p>
<p>迭代器类里，iter()方法返回一个特殊的迭代器对象，这个迭代器对象实现了next（）并且通过StopIteration</p>
<p>异常的标识来判断迭代是否完成</p>
<p>next（）方法返回下一个迭代器的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        self.a=1</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        x = self.a</span><br><span class="line">        self.a+=1</span><br><span class="line">        return x</span><br><span class="line">myclass=MyNumbers()</span><br><span class="line">myiter=iter(myclass)</span><br><span class="line"></span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>

<p>以上的代码把一个类当做了迭代器，我们不难发现，需要至少实现两个方法，iter和next。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        self.a=1</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.a &lt;= 3:</span><br><span class="line">            x = self.a</span><br><span class="line">            self.a+=1</span><br><span class="line">            return x</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration</span><br><span class="line">myclass=MyNumbers()</span><br><span class="line">myiter=iter(myclass)</span><br><span class="line"></span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>

<p>以上代码，使用了stopiteration异常来限制了循环的次数（迭代的次数）</p>
<p>所有的技术都要根据使用场景来。</p>
<span id="more"></span>

<p>生成器</p>
<p>python中，使用了yield的函数被成为生成器</p>
<p>跟普通函数不同，生成器是一个返回迭代器的函数，只能用于迭代操作，简单理解，生成器就是一个迭代器</p>
<p>在调用生成器，运行的过程中，遇到yield函数会暂停并且保存当前所有的运行信息，返回yield的值</p>
<p>在下一次执行next方法时继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象</p>
<p>yield来实现斐波那契数列(从第三项开始，每一项等于前面两项之和的数列)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def fibonaqi(n):# 生成器函数</span><br><span class="line">    a,b,counter=0,1,0</span><br><span class="line">    while True:</span><br><span class="line">        if (counter &gt; n):</span><br><span class="line">            return</span><br><span class="line">        yield a</span><br><span class="line">        a,b=b,a+b</span><br><span class="line">        counter+=1</span><br><span class="line">f=fibonaqi(10) # f是一个迭代器，由生成器返回生成</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print(next(f),end=&#x27; &#x27;)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<p>装饰器</p>
<p>装饰器之前，先来理解一个概念（闭包）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a():</span><br><span class="line">    s=&#x27;i am liupeng!&#x27;</span><br><span class="line"></span><br><span class="line">    # p是一个嵌套函数</span><br><span class="line">    def p():</span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line">    return p</span><br><span class="line"># 把a函数赋值给变量myclass的时候，这个就获得了一个闭包</span><br><span class="line"># s是一个局部变量，在a函数结束之后就不会存在了。</span><br><span class="line"># 但是现在我们使用了一个嵌套函数，把这个局部变量封闭在了嵌套函数中</span><br><span class="line"># 这样子就形成了一个闭包</span><br><span class="line">myclass=a()</span><br><span class="line">myclass()</span><br><span class="line"># 闭包其实就是一个引用了自有变量的函数</span><br><span class="line"># 函数保存了执行的上下文，可以脱离原本的作用域而存在。</span><br></pre></td></tr></table></figure>

<p>装饰器是python一个重要部分，他是一个函数（修改其他函数功能的函数）有助于让代码更短</p>
<p>父类与子类。</p>
<p>一切皆可对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a(name=&#x27;liupeng&#x27;):</span><br><span class="line">    return &quot;hello  &quot; + name</span><br><span class="line"># print(a())</span><br><span class="line">b=a</span><br><span class="line"># 为什么我不用小括号呐？因为我并不是在调用函数，而是把这个函数放在变量里面</span><br><span class="line"># print(b())</span><br><span class="line">del a</span><br><span class="line"># print(a())</span><br><span class="line">print(b())</span><br></pre></td></tr></table></figure>

<p>函数的嵌套</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a(name=&#x27;liupeng&#x27;):</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">    def b():</span><br><span class="line">        return &#x27;2&#x27;</span><br><span class="line">    def c():</span><br><span class="line">        return &quot;3&quot;</span><br><span class="line"></span><br><span class="line">    print(b())</span><br><span class="line">    print(c())</span><br><span class="line">    print(&quot;4&quot;)</span><br><span class="line"></span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<p>函数中返回函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a(name=&#x27;liupeng&#x27;):</span><br><span class="line">    def b():</span><br><span class="line">        return 1</span><br><span class="line">    def c():</span><br><span class="line">        return 2</span><br><span class="line">    if True:</span><br><span class="line">        return b</span><br><span class="line">    else:</span><br><span class="line">        return c</span><br><span class="line">x=a()</span><br><span class="line">print(x)</span><br><span class="line">print(x())</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># x=a() a函数会被执行，而由于判断条件时true，那么b会被返回，如果是flase，那么c会被返回</span><br><span class="line"># 我们还可以打印出a（）（）</span><br></pre></td></tr></table></figure>

<p>把函数作为参数传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a():</span><br><span class="line">	return 1</span><br><span class="line">def b(func):</span><br><span class="line">	print(2)</span><br><span class="line">	print(func())</span><br><span class="line">b(a)</span><br></pre></td></tr></table></figure>

<p>装饰器（最简单的装饰器）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a(a_func):</span><br><span class="line">    def b():</span><br><span class="line">        print(1)</span><br><span class="line"></span><br><span class="line">        a_func()  # c（）</span><br><span class="line"></span><br><span class="line">        print(2)</span><br><span class="line">    return b</span><br><span class="line">def c():</span><br><span class="line">    print(3)</span><br><span class="line"># c()</span><br><span class="line">c=a(c)</span><br><span class="line">c()</span><br></pre></td></tr></table></figure>

<p>装饰器：封装一个函数，并且用不同的方式去修改它的行为，@是一个简短的方式来生成一个被装饰的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@a</span><br><span class="line">def c():</span><br><span class="line">	print(3)</span><br><span class="line">c()</span><br><span class="line">c=a(c)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line">def a_name(f):</span><br><span class="line">    @wraps(f)</span><br><span class="line">    def b(*args,**kwargs):</span><br><span class="line">        if not can_run:</span><br><span class="line">            return &quot;函数不会运行&quot;</span><br><span class="line">        return f(*args,**kwargs)</span><br><span class="line">    return b</span><br><span class="line"></span><br><span class="line">@a_name</span><br><span class="line">def func():</span><br><span class="line">    return &quot;函数正在运行&quot;</span><br><span class="line"></span><br><span class="line"># can_run=True</span><br><span class="line"># print(func())</span><br><span class="line"></span><br><span class="line">can_run=False</span><br><span class="line">print(func())</span><br></pre></td></tr></table></figure>

<p>以上就是装饰器的一个简单的应用场景，@wraps 接受一个函数进行装饰，并且加入了函数的一些功能，函数名称、参数列表、注释文档等等，这可以让我们在装饰器里访问装饰之前的函数的属性</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2021/08/05/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>常见的嵌套结构，利用这样的结构使得内部类和外部类并存，并且可以方便的进行私有操作的访问，内部类又进一步扩展到了匿名内部类。</p>
<h2 id="1、内部类基本概念："><a href="#1、内部类基本概念：" class="headerlink" title="1、内部类基本概念："></a>1、内部类基本概念：</h2><p>程序开发为了更加准确的描述结构体的作用，提供各种的嵌套结构，类也是一种程序结构，它也是支持嵌套的。</p>
<p>内部类（普通类、抽象类、接口的统称）指的是一种嵌套的关系，也就是在一个类结构中除了属性和方法还定义了一个类结构，这样可以让程序更加灵活。</p>
<blockquote>
<p>定义内部类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">class Outer&#123;</span><br><span class="line">    private String info = &quot;i love mm&quot;;</span><br><span class="line">    public void fun()&#123;</span><br><span class="line">        Inner i1 = new Inner();</span><br><span class="line">        i1.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Inner&#123;</span><br><span class="line">        public void print()&#123;</span><br><span class="line">            System.out.println(Outer.this.info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer o1 = new Outer();</span><br><span class="line">        o1.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心结构就是在外部类的方法里实例化了内部类对象，并且调用了内部类的方法，并且利用内部类的方法输出了外部类的私有属性。</p>
<blockquote>
<p>提问：内部类的结构差嘛？（从类的结构看，成员属性和方法，此时如果在一个类中定义许多的内部类，这样就会使得代码结构非常混乱，为什么要这么定义？）</p>
<p>答：内部类方便访问私有属性</p>
<p>实质上内部类在整体结构上破坏了良好的程序结构，但是最大的有点就是方便的访问外部类中的私有属性。</p>
<p>为了证明这一点，我们将上述的代码拆开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">class Outer1 &#123;</span><br><span class="line">    private String info = &quot;i love mm&quot;;</span><br><span class="line"></span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void fun() &#123;</span><br><span class="line">        Inner1 i1 = new Inner1(this);</span><br><span class="line">        i1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Inner1 &#123;</span><br><span class="line">    private Outer1 out;</span><br><span class="line"></span><br><span class="line">    public Inner1(Outer1 out) &#123;</span><br><span class="line">        this.out = out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(this.out.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer1 o1 = new Outer1();</span><br><span class="line">        o1.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意：之所以出现内部类，更多的时候是希望某一个类只为了单独的一个类服务</p>
<h2 id="2、内部类相关说明："><a href="#2、内部类相关说明：" class="headerlink" title="2、内部类相关说明："></a>2、内部类相关说明：</h2><p>内部类除了可以被定义的外部类操作之外，本身也可以被外部类明确实例化调用。</p>
<p>在内部类结构中，不仅是内部类可以方便的访问外部类的成员，外部类也同样可以方便的访问内部类的私有成员，内部类本身是一个独立的结构，这样在进行普通成员访问是，为了明确的标记出属性是外部类提供的，可以采用“外部类.this.属性”的方式进行标注。</p>
<blockquote>
<p>外部类访问内部类私有成员</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class f&#123;</span><br><span class="line">    private String info = &quot;i love mm&quot;;</span><br><span class="line">    public void fun()&#123;</span><br><span class="line">        s s1= new s();</span><br><span class="line">        s1.print();</span><br><span class="line">        System.out.println(s1.info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class s &#123;</span><br><span class="line">        private String info = &quot;i always love mm&quot;;</span><br><span class="line">        public void print()&#123;</span><br><span class="line">            System.out.println(f.this.info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        f f1 = new f();</span><br><span class="line">        f1.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意：内部类虽然被外部类包裹，但是本身也属于一个完整类，所以可以直接进行实例化对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类.内部类 内部类对象 = new 外部类().new 内部类();</span><br></pre></td></tr></table></figure>

<p>要求先获取相应的外部类对象，再利用外部类对象对内部类进行实例化。</p>
<blockquote>
<p>提示：关于内部类的字节码文件名称</p>
<p>当内部类源码进行编译时，我们会发现有一个外部类$内部类的class文件，这个标识符来程序中会转化成.，因此内部类的全程就是外部类.内部类，由于内部类和外部类可以进行私有属性的访问，这样就必须保证在实例化内部类对象之前必须实例化外部类对象。</p>
</blockquote>
<blockquote>
<p>内部类私有化：</p>
<p>出现一个内部类不希望被其他类所使用，那么也可以使用private关键字将这个内部类定义为私有的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class d &#123;</span><br><span class="line">    private String info = &quot;mm&quot;;</span><br><span class="line">    private class x&#123;</span><br><span class="line">        public void fun()&#123;</span><br><span class="line">            System.out.println(d.this.info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由于内部类用了private在定义，表示内部类只允许被外部类使用。</p>
<p>值得一提：private，protected这两个关键字定义类时只出现内部类。</p>
<blockquote>
<p>定义内部接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface I&#123;</span><br><span class="line">    public void send(m m1);</span><br><span class="line">    interface m&#123;</span><br><span class="line">        public String getinfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Is1 implements I&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void send(m m1) &#123;</span><br><span class="line">        System.out.println(m1.getinfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class mm1 implements m&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getinfo()&#123;</span><br><span class="line">            return &quot;mm&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo07 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        I i1 = new Is1();</span><br><span class="line">        i1.send(((Is1) i1).new mm1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类的形式定义了内部接口，并且分别的为外部接口和内部接口实现了子类，由于是内部接口，因此在定义子类的时候也要用内部类的形式</p>
</blockquote>
<blockquote>
<p>在接口中定义内部抽象类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface fatherinterface &#123;</span><br><span class="line">    public void send();</span><br><span class="line"></span><br><span class="line">    abstract class AbstractSon &#123;</span><br><span class="line">        public abstract String getinfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father implements fatherinterface &#123;</span><br><span class="line">    class Son extends AbstractSon &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getinfo() &#123;</span><br><span class="line">            return &quot;mm&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void send() &#123;</span><br><span class="line">        AbstractSon s1 = new Son();</span><br><span class="line">        System.out.println(s1.getinfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        fatherinterface f1 = new Father();</span><br><span class="line">        f1.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部接口中定义了内部抽象类，在定义外部接口的外部类的send方法时，利用内部抽象类的子类为父类对象实例化。</p>
</blockquote>
<blockquote>
<p>接口子类定义为自身内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface Father1&#123;</span><br><span class="line">    public void print();</span><br><span class="line">    class Son1 implements Father1&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(&quot;mm&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Father1 getinfo()&#123;</span><br><span class="line">        return new Son1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Father1 f1 = Father1.getinfo();</span><br><span class="line">        f1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>定义接口的时候直接在内部定义了子类，同时为了方便获取接口实例，就定义了一个静态方法，这样用户就可以在不关心子类的前提下，使用子类对象</p>
<h2 id="3、static定义内部类："><a href="#3、static定义内部类：" class="headerlink" title="3、static定义内部类："></a>3、static定义内部类：</h2><p>static定义的结构可以不用受类的制约，内部类也可以使用static定义类结构体。此时的内部类就不再受外部类对象的影响了，此时的内部类等同于一个外部类。内部类的名称是：外部类.内部类，使用static定义的内部类只能调用外部类中static定义的结构，并且在实例化的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类.内部类 内部类对象 = new 外部类.内部类();</span><br></pre></td></tr></table></figure>

<p>如果接口中使用static定义“外部接口”，那么我们就需要在外部使用外部类分别实现外部接口。</p>
<h2 id="4、方法中定义内部类："><a href="#4、方法中定义内部类：" class="headerlink" title="4、方法中定义内部类："></a>4、方法中定义内部类：</h2><p>内部类的嵌套除了写在类中，也可以在代码块中完成，就典型的就是方法。</p>
<p>在方法中定义内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">class father&#123;</span><br><span class="line">    private String info = &quot;mm&quot;;</span><br><span class="line">    public void fun()&#123;</span><br><span class="line">        class son&#123;</span><br><span class="line">            public void print()&#123;</span><br><span class="line">                System.out.println(father.this.info);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new son().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new father().fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、匿名内部类："><a href="#5、匿名内部类：" class="headerlink" title="5、匿名内部类："></a>5、匿名内部类：</h2><p>继承开发需要子类，但是子类过多有可能产生很多额外代码。</p>
<p>在一个接口或者抽象类定义完成之后，在使用之前都需要专门定义子类，随后利用向上转型使用接口和抽象类，很多时候子类只使用一次，为了它单独创建一个类文件有些浪费，此时就可以使用匿名内部类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IMessage&#123;</span><br><span class="line">    public void send(String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IMessage mag = new IMessage() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void send(String str) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        mag.send(&quot;mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优势在于：减少类的定义次数。</p>
<p>结合static：</p>
<p>在接口中利用匿名内部类实现接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface Message&#123;</span><br><span class="line">    public void send(String str);</span><br><span class="line">    public static Message getInstance()&#123;</span><br><span class="line">        return new Message() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void send(String str) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo12 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Message.getInstance().send(&quot;mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、lambda表达式："><a href="#6、lambda表达式：" class="headerlink" title="6、lambda表达式："></a>6、lambda表达式：</h2><p>函数式编程：更加简洁</p>
<p>lambda表达式（jdk1.8之后）：指的是应用在含有一个抽象方法的接口的环境下的定义形式，用于解决匿名内部类的定义复杂问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface Messsage1&#123;</span><br><span class="line">    public void send(String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo13 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Messsage1 msg = (str) -&gt; &#123;</span><br><span class="line">          System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        msg.send(&quot;mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用lambda表达式定义了接口的实现类。可以发现lambda表达式进一步简化了匿名内部类的定义结构。</p>
<p>lambda表达式应用在有抽象方法的接口上，而且只能有一个抽象方法。</p>
<p>此时可以使用@FunctionalInterface注解来标注出使用lambda表达式的接口，这样表示这个是函数式接口，里面只允许定义一个抽象方法。</p>
<h2 id="7、方法引用："><a href="#7、方法引用：" class="headerlink" title="7、方法引用："></a>7、方法引用：</h2><p>引用是java的灵魂，早期的时候，受到c++的影响，只有对象引用，后来加强了引用的概念，提供了方法的引用。</p>
<p>java中对象引用实现了不同的对象名操作一块堆内存。jdk8开始，方法也支持引用操作，这就相当于为方法定义了别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Func&lt;P,R&gt;&#123;</span><br><span class="line">    public R change(P p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo14 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Func&lt;Integer,String&gt; fun = String::valueOf;</span><br><span class="line">        String str = fun.change(100);</span><br><span class="line">        System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了函数式接口，利用方法引用的概念引用了string的valueof方法，并且利用这个方法将int转化字符串。</p>
<p>引用普通方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface func1&lt;T&gt;&#123;</span><br><span class="line">    public T upeer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1&lt;String&gt; f1 = &quot;www.baidu.mm&quot;::toUpperCase;</span><br><span class="line">System.out.println(f1.upeer());</span><br></pre></td></tr></table></figure>

<p>类：：方法，引用的一定是类中的静态方法，这种形式也可以引用普通方法</p>
<p>引用构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;  age:&quot;+this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface funcA&lt;R&gt;&#123;</span><br><span class="line">    public R create(String s, int a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface funcB&lt;E&gt;&#123;</span><br><span class="line">    public E create(String a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        funcA f1 = Person::new;</span><br><span class="line">        System.out.println(f1.create(&quot;mm&quot;,20));</span><br><span class="line"></span><br><span class="line">        funcB f2 = Person::new;</span><br><span class="line">        System.out.println(f2.create(&quot;love&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、内建函数式接口"><a href="#8、内建函数式接口" class="headerlink" title="8、内建函数式接口;"></a>8、内建函数式接口;</h2><p>1、功能性函数式接口：（有参数，有返回值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line">	public R apply&lt;T t&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Function&lt;String, Boolean&gt; fun = &quot;www.google&quot;::startsWith;</span><br><span class="line">        System.out.println(fun.apply(&quot;www&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、消费型函数式接口：（只有参数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line">	    void accept(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Consumer&lt;String&gt; con = System.out::println;</span><br><span class="line">        con.accept(&quot;aaaaaa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、供给型函数式接口：（有返回值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Supplier&lt;String&gt; sup = &quot;www.baidu.com&quot;::toUpperCase;</span><br><span class="line">        System.out.println(sup.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、断言型函数式接口：（主要是进行判断，接受参数，返回boolean）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Predicate&lt;String&gt; p1 = &quot;mm1&quot;::equals;</span><br><span class="line">        System.out.println(p1.test(&quot;mm&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、链表："><a href="#9、链表：" class="headerlink" title="9、链表："></a>9、链表：</h2><p>解决数组的问题，（固定长度）。</p>
<p>链表本身比较复杂，包含的内容，只介绍单向链表。</p>
<p>链表（动态数组）：本质是利用对象引用的逻辑来实现存储逻辑，一个链表是由若干个节点组成的，每一个节点依赖于上一个节点的引用来形成一个链。</p>
<p><img src="/2021/08/05/%E5%86%85%E9%83%A8%E7%B1%BB/image-20210805231331987.png" alt="image-20210805231331987"></p>
<p>设计的时候，为了避免安全隐患，用泛型定义，这样子为了保证链表中的数据类型统一。</p>
<p>直接使用node类存放多个数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import com.sun.tools.javac.Main;</span><br><span class="line"></span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">class Node&lt;T&gt; &#123;</span><br><span class="line">    private T data;</span><br><span class="line">    private Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node&lt;T&gt; getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Node&lt;T&gt; next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo17 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node&lt;String&gt; n1 = new Node&lt;&gt;(&quot;mm&quot;);</span><br><span class="line">        Node&lt;String&gt; n2 = new Node&lt;&gt;(&quot;mm1&quot;);</span><br><span class="line">        Node&lt;String&gt; n3 = new Node&lt;&gt;(&quot;mm2&quot;);</span><br><span class="line">        Node&lt;String&gt; n4 = new Node&lt;&gt;(&quot;mm3&quot;);</span><br><span class="line">        n1.setNext(n2);</span><br><span class="line">        n2.setNext(n3);</span><br><span class="line">        n3.setNext(n4);</span><br><span class="line">        printNode(n1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printNode(Node&lt;?&gt; node) &#123;</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            System.out.print(node.getData() + &quot;、&quot;);</span><br><span class="line">            printNode(node.getNext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个链表的模型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface ILink&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Link01&lt;T&gt; implements ILink&lt;T&gt;&#123;</span><br><span class="line">    private class Node&lt;T&gt;&#123;</span><br><span class="line">        private T data;</span><br><span class="line">        private Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        public Node(T data) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    以下的link类定义的结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、花店的例子："><a href="#10、花店的例子：" class="headerlink" title="10、花店的例子："></a>10、花店的例子：</h2><p>分析：要求许多种花上线，花店针对上线、下线、查询的信息依据接口实现，保存数据使用链表。</p>
<p><img src="/2021/08/05/%E5%86%85%E9%83%A8%E7%B1%BB/image-20210805233421891.png" alt="image-20210805233421891"></p>
<p>1、创建花的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">public interface IFlower &#123;</span><br><span class="line">    public String getName();</span><br><span class="line">    public String getColor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、花和花的接口有关，但是和具体的花无关，因此创建花类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class Flower &#123;</span><br><span class="line">    private LinkedList&lt;IFlower&gt; allFlower = new LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public void add(IFlower flower)&#123;</span><br><span class="line">        this.allFlower.add(flower);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void delete(IFlower flower)&#123;</span><br><span class="line">        this.allFlower.remove(flower);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedList&lt;IFlower&gt; search(String keyword)&#123;</span><br><span class="line">        LinkedList&lt;IFlower&gt; searchResult = new LinkedList&lt;&gt;();</span><br><span class="line">        Object result[] = this.allFlower.toArray();</span><br><span class="line">        if (result != null)&#123;</span><br><span class="line">            for (Object obj:result) &#123;</span><br><span class="line">                IFlower flower = (IFlower) obj;</span><br><span class="line">                if(flower.getName().contains(keyword) || flower.getColor().contains(keyword))&#123;</span><br><span class="line">                    searchResult.add(flower);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return searchResult;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、根据花接口，定义具体的花，值得注意的是，为了保证链表中的方法可以正常使用，需要覆写equals方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">class Lavender implements IFlower&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Lavender(String name, String color) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getColor() &#123;</span><br><span class="line">        return this.color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj)&#123;</span><br><span class="line">        if (obj == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (!(obj instanceof Lavender))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (this == obj)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Lavender lavender = (Lavender) obj;</span><br><span class="line">        return this.name.equals(lavender.name) &amp;&amp; this.color.equals(lavender.color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;  color:&quot;+this.color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">class Lily implements IFlower&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Lily(String name, String color) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getColor() &#123;</span><br><span class="line">        return this.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj)&#123;</span><br><span class="line">        if (obj == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(obj instanceof Lily))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this == obj)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Lily lily = (Lily) obj;</span><br><span class="line">        return this.name.equals(lily.name) &amp;&amp; this.color.equals(lily.color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;  color:&quot;+this.color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、主类测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">public class FlowerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FlowerShop shop = new FlowerShop();</span><br><span class="line">        shop.add(new Lily(&quot;白百合&quot;,&quot;白色&quot;));</span><br><span class="line">        shop.add(new Lily(&quot;粉百合&quot;,&quot;粉色&quot;));</span><br><span class="line">        shop.add(new Lily(&quot;黄百合&quot;,&quot;黄色&quot;));</span><br><span class="line">        shop.add(new Lily(&quot;黑百合&quot;,&quot;紫褐色&quot;));</span><br><span class="line">        shop.add(new Lavender(&quot;紫色薰衣草&quot;,&quot;紫色&quot;));</span><br><span class="line">        shop.add(new Lavender(&quot;蓝色薰衣草&quot;,&quot;蓝色&quot;));</span><br><span class="line">        shop.add(new Lavender(&quot;白色薰衣草&quot;,&quot;白色&quot;));</span><br><span class="line">        shop.delete(new Lily(&quot;白百合&quot;,&quot;白色&quot;));</span><br><span class="line">        Object result[] = shop.search(&quot;白&quot;).toArray();</span><br><span class="line">        for (Object obj: result) &#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程</title>
    <url>/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>多线程编程是java最重要的特性之一，利用多线程可以提升单位时间内的程序处理性能，也是高并发的主要设计形式。</p>
<h2 id="1、进程和线程"><a href="#1、进程和线程" class="headerlink" title="1、进程和线程"></a>1、进程和线程</h2><p>计算机系统不断的升级，每一次升级都是在提升硬件处理性能。</p>
<p>进程是程序的动态执行过程，包括代码加载、执行到执行完毕的一个完整过程，这个过程也是进程本身产生、发展到消亡的过程。多进程系统可以同时运行多个进程（程序），由于cpu分时机制，每一个进程都可以循环得到自己的cpu时间片(运行时间段)，由于cpu执行速度很快，看起来就像是同时运行一样。</p>
<p>（进程在os中是调度切换执行的、每一个进程都有一个cpu时间片，在cpu时间片上运行完毕后切换到下一个进程）。</p>
<p>Windows属于多进程的处理操作，但是这个时候依然只有一组资源，所以说在同一个时间段会有多个程序共同执行，而同一个时间点上只能有一个进程执行。</p>
<p>多进程可以提高硬件资源的利用率，但是进程的启动与销毁依然需要大量的系统性能，导致程序执行下降，进一步提升并发操作的处理能力，在进程的基础上又提供了多线程，线程依附于指定的进程，并且可以快速启动和并发执行。</p>
<h2 id="java多线程实现"><a href="#java多线程实现" class="headerlink" title="java多线程实现"></a>java多线程实现</h2><p>依靠一个线程的主体类，主体类定义的时候有一些特殊的要求，继承thread类，实现runnable或者callable接口来完成定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day6;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    public MyThread(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int x = 1 ; x&lt;10;x++)&#123;</span><br><span class="line">            System.out.println(this.title+&quot;|&quot;+x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyThread(&quot;线程A&quot;).start();</span><br><span class="line">        new MyThread(&quot;线程B&quot;).start();</span><br><span class="line">        new MyThread(&quot;线程C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义了一个线程类，同时覆写了thread里的run方法，这个方法里实现了输出，多线程的执行方法都是fun中定义，但是多线程启动的时候不能直接调用run方法，由于多线程需要并发执行，因此需要调用操作系统的资源调度才可以，在java中就必须调用start方法，调用start方法时会间接的调用run方法。</p>
<p>结果分析：多个线程之间是彼此交替运行。</p>
<p>runnable和callable的区别：</p>
<p>前者比较早，后者比较晚。</p>
<p>runnable只提供了一个run方法，并且没有返回值的</p>
<p>callable提供有call方法，并且可以有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day9;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line">    public MyThread(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int x = 1; x &lt; 10; x++) &#123;</span><br><span class="line">            System.out.println(this.title + &quot;:   &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(new MyThread(&quot;aaa&quot;));</span><br><span class="line">        Thread t2 = new Thread(new MyThread(&quot;bbb&quot;));</span><br><span class="line">        Thread t3 = new Thread(new MyThread(&quot;ccc&quot;));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runnable线程实现类结构</p>
<p><img src="/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20210809211257691.png" alt="image-20210809211257691"></p>
<p>并发资源访问（卖票程序）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day9;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int ticket = 50;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int x = 0; x &lt; 100; x++) &#123;</span><br><span class="line">            if (this.ticket &gt; 0)&#123;</span><br><span class="line">                System.out.println(&quot;卖票，ticket  &quot;+this.ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread m1 = new MyThread();</span><br><span class="line">        new Thread(m1).start();</span><br><span class="line">        new Thread(m1).start();</span><br><span class="line">        new Thread(m1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CALLABLE实现多线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day9;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">class mythread11 implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        for (int x = 0;x&lt;10;x++)&#123;</span><br><span class="line">            System.out.println(&quot;程序执行：  &quot;+x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;www.baidu,com&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo02 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new mythread11());</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot; &quot;+task.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>多线程运行状态</p>
<p>要想实现多线程，必须在主线程中创建新的线程对象。</p>
<p>任意线程一般来说都有五种基本状态：创建、就绪、运行、阻塞、终止。</p>
<p><img src="/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20210809214300501.png" alt="image-20210809214300501"></p>
<blockquote>
<p>基本转换状态</p>
</blockquote>
<p>多线程常用操作方法：</p>
<p>1、线程的取名</p>
<p>线程本身属于不可见的运行状态，每次操作时间是无法预料的，所以如果要想在程序中操作线程，唯一的依靠就是线程名称。</p>
<p>获取当前线程对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static native Thread currentThread();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day9;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class my01 implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        my01 m1 = new my01();</span><br><span class="line">        new Thread(m1,&quot;A&quot;).start();</span><br><span class="line">        new Thread(m1,&quot;B&quot;).start();</span><br><span class="line">        new Thread(m1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程在哪里？</p>
<p>每一个jvm运行就是一个进程（当用户执行java命令执行一个类的时候就表示启动了一个jvm进程，而主方法就是这个进程上的一个线程）</p>
<p><img src="/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20210811150419324.png" alt="image-20210811150419324"></p>
<p>如果等待子线程完成？</p>
<p>（主线程的第n个操作任务需要子线程处理后的结果）</p>
<p>需要引入线程等待和唤醒机制</p>
<p>线程休眠</p>
<p>当一个线程启动后会按照既定的结构快速的执行完毕，如果需要暂缓线程的执行速度，就可以利用thread类中提供的休眠方法完成。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public static native void sleep(long millis) throws InterruptedException;</td>
<td>普通</td>
<td>设置线程休眠的毫秒数，时间一到自动唤醒。</td>
</tr>
<tr>
<td>public static void sleep(long millis, int nanos) throws InterruptedException</td>
<td>普通</td>
<td>设置线程休眠的毫秒数和纳秒数，时间一到自动唤醒</td>
</tr>
</tbody></table>
<p>在进行休眠的有可能产生中断异常InterruptedException，程序中必须强制性的进程该异常的捕获与处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Runnable run = () -&gt; &#123;</span><br><span class="line">            for (int x = 0; x &lt; 10;x++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int y = 0; y &lt; 5; y++) &#123;</span><br><span class="line">            new Thread(run,&quot;thread--&quot;+y).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程中断</p>
<p>在线程在执行过程中也可以被另外一个线程中断执行。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean isInterrupted()</td>
<td>普通</td>
<td>判断线程是否被中断</td>
</tr>
<tr>
<td>public void interrupt()</td>
<td>普通</td>
<td>中断线程执行</td>
</tr>
</tbody></table>
<p>eg：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">public class Threadinterrupt &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">           System.out.println(&quot;准备睡觉，10秒钟之内不要打扰我我！&quot;);</span><br><span class="line">           try &#123;</span><br><span class="line">               Thread.sleep(10000);</span><br><span class="line">               System.out.println(&quot;睡醒了，开始学习！！&quot;);</span><br><span class="line">           &#125;catch (InterruptedException e)&#123;</span><br><span class="line">               System.out.println(&quot;睡觉被打扰了，好烦！！！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        if (!thread.isInterrupted())&#123;</span><br><span class="line">            System.out.println(&quot;在你睡觉的旁边敲锣打鼓！&quot;);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程强制执行</p>
<p>在多线程并发执行中每一个线程对象都会交替执行，如果这个时候某个线程对象需要优先执行完成，则可以设置为强制执行，也就是等这个线程执行完毕了再执行其他线程。</p>
<p>线程强制执行的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void join() throws InterruptedException</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">public class enforcement &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread main = Thread.currentThread();</span><br><span class="line">        Thread thread = new Thread(() -&gt;&#123;</span><br><span class="line">            for (int x = 0;x&lt;10;x++)&#123;</span><br><span class="line">                if(x == 3)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        main.join();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(200);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;执行：  &quot;+x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;随便一个线程！&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        for(int x=0;x&lt;10;x++)&#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            System.out.println(&quot;霸道的mian线程= &quot;+x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本程序启动了两个线程，main和子线程，在不满足条件时，两个线程交替执行，满足时，主线程执行完毕之后再执行子线程中的内容。</p>
<p>线程礼让</p>
<p>满足某些条件，可以将当前调度给其他线程执行，自己等待下次调度再执行。</p>
<p>线程礼让</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static native void yield();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">public class Threadcomity &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Thread thread = new Thread(()-&gt;&#123;</span><br><span class="line">           for (int x= 0;x&lt;10;x++)&#123;</span><br><span class="line">               if (x % 3==0 )&#123;</span><br><span class="line">                   Thread.yield();</span><br><span class="line">                   System.out.println(&quot;礼让！&quot;+Thread.currentThread().getName());</span><br><span class="line">               &#125;</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(100);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+&quot;执行：  &quot;+x);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,&quot;随意的一个线程&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        for (int x=0;x&lt;10;x++)&#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            System.out.println(&quot;main线程：&quot;+x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程优先级</p>
<p>在Java线程操作中，所有线程在运行前都是就绪状态，此时设置优先级，进行资源调度。</p>
<table>
<thead>
<tr>
<th>方法或常量</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public static final int MIN_PRIORITY</td>
<td>常量</td>
<td>最低优先级，1</td>
</tr>
<tr>
<td>public static final int NORM_PRIORITY</td>
<td>常量</td>
<td>中等优先级，5</td>
</tr>
<tr>
<td>public static final int MAX_PRIORITY</td>
<td>常量</td>
<td>最高优先级，10</td>
</tr>
<tr>
<td>public final void setPriority(int newPriority)</td>
<td>方法</td>
<td>设置线程优先级</td>
</tr>
<tr>
<td>public final int getPriority()</td>
<td>方法</td>
<td>取得线程优先级</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">public class threadpriority &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable run = () -&gt;&#123;</span><br><span class="line">            for (int x=0;x&lt;10;x++)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;：&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(run,&quot;线程A&quot;);</span><br><span class="line">        Thread t2 = new Thread(run,&quot;线程B&quot;);</span><br><span class="line">        Thread t3 = new Thread(run,&quot;线程C&quot;);</span><br><span class="line">        Thread t4 = new Thread(run,&quot;线程D&quot;);</span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t4.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t3.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        System.out.println(&quot;===========&quot;);</span><br><span class="line">        t1.getPriority();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程同步与死锁：</p>
<p>多线程访问同一资源，一定会出现某些问题，例如，资源操作的完整性。</p>
<p>卖票问题：</p>
<p>假设现在剩下最后一张票，当第一个线程满足条件时，其他的线程也满足，同时进行自减，就有可能造成负数。</p>
<p>线程同步处理：</p>
<p>造成并发资源访问不同步的主要原因在于没有将若干个逻辑单元进行整体锁定。也就是判断数据和修改数据时只允许一个线程进行处理，而其他线程需要等待当前线程执行完毕之后才可以继续执行，这样就使得在同一个时间段内，只允许一个线程执行操作，从而实现同步处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized</span><br></pre></td></tr></table></figure>

<p>关键字实现同步处理，同步的关键时要加锁，对于锁的操作方式有两种，同步代码块，同步方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">    private int ticket = 20;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            synchronized (this)&#123;</span><br><span class="line">                if (ticket &gt; 0)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;卖票：  &quot;+this.ticket--);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    System.out.println(&quot;卖光了！！！&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Threadsynchronization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread mt = new MyThread();</span><br><span class="line">        new Thread(mt,&quot;售票员A&quot;).start();</span><br><span class="line">        new Thread(mt,&quot;售票员B&quot;).start();</span><br><span class="line">        new Thread(mt,&quot;售票员C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步会导致性能下降</p>
<p>同步操作的本质在于同一给时间段内只有一个线程，所以在此线程对象执行完之前其他的线程对象将处于一个就绪状态，这样就会导致性能下降。</p>
<p>同步方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">    private int ticket = 20;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (this.sale())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized boolean sale()&#123;</span><br><span class="line">        if(this.ticket&gt;0)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;  &quot;+this.ticket--);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;卖光了！！&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Threadsynchronization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread mt = new MyThread();</span><br><span class="line">        new Thread(mt,&quot;售票员A&quot;).start();</span><br><span class="line">        new Thread(mt,&quot;售票员B&quot;).start();</span><br><span class="line">        new Thread(mt,&quot;售票员C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程死锁：</p>
<p>同步指的是一个线程要等待另一个线程执行完才会继续执行的一种操作，虽然同步可以保证资源共享的正确性，但是过多同步也会产生一些问题。</p>
<p>例如：王老五想要小鹏的一本书，小鹏想要王老五的一口饭，两个人都在等待回复，最终都得不到自己想要的东西，这实际上就是死锁的概念。</p>
<p>所谓的死锁，指的是两个线程都在等待对方先完成，造成程序的停滞，一般程序的死锁都是在小程序运行时出现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">class Book&#123;</span><br><span class="line">    public synchronized void tell(Food food)&#123;</span><br><span class="line">        System.out.println(&quot;王老五对小鹏说，把你的书给我，我就给你一口饭吃！不给书就不给你饭吃&quot;);</span><br><span class="line">        food.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get()&#123;</span><br><span class="line">        System.out.println(&quot;王老五得到了小鹏的书！开始仔细阅读！发现是本无字天书！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Food&#123;</span><br><span class="line">    public synchronized void tell(Book book)&#123;</span><br><span class="line">        System.out.println(&quot;小鹏对王老五说，给我一口饭吃，我就把书给你，不给饭吃不给你书！&quot;);</span><br><span class="line">        book.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get()&#123;</span><br><span class="line">        System.out.println(&quot;小鹏得到了一口饭，吃的老香了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class threaddeadlock implements Runnable&#123;</span><br><span class="line">    private Book book = new Book();</span><br><span class="line">    private Food food = new Food();</span><br><span class="line"></span><br><span class="line">    public threaddeadlock() &#123;</span><br><span class="line">        new Thread(this::run).start();</span><br><span class="line">        book.tell(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        food.tell(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new threaddeadlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程等待与唤醒：</p>
<p><img src="/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20210812164151743.png" alt="image-20210812164151743"></p>
<p>优雅的停止线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">import javax.xml.stream.FactoryConfigurationError;</span><br><span class="line"></span><br><span class="line">public class threadstop &#123;</span><br><span class="line">    public static boolean flag = true;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">           long num = 0;</span><br><span class="line">           while (flag)&#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(50);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+&quot;running &quot;+num++);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,&quot;线程AA&quot;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        flag = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台守护线程：</p>
<p>java中的线程分为两类，用户线程和守护线程。守护线程运行在后台，当全部用户线程消失，守护线程消失。</p>
<p>Java中有一个gc自动垃圾回收机制，其实就是守护线程。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public final void setDaemon(boolean on)</td>
<td>普通</td>
<td>设置为守护线程</td>
</tr>
<tr>
<td>public final boolean isDaemon()</td>
<td>普通</td>
<td>判断是否为守护线程</td>
</tr>
</tbody></table>
<p>volative关键字</p>
<p>在多线程中，线程为了实现公共资源的操作，为复制相对应的变量的副本，等待操作完成之后，再把副本和原始变量进行同步处理。开发者不希望通过怕副本数据进行操作，就可以在原始变量声明时，使用关键字。</p>
<p>volative和同步的区别：<br>关键字无法处理同步问题，他是一种直接内存的处理避免副本操作。同步是处理并发资源访问，关键字主要在属性上使用，同步在代码块和方法体上使用。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类与接口</title>
    <url>/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>抽象类与接口：有效拆分大型系统，避免产生耦合。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>类继承主要是为了扩充已有的类功能，子类可以根据需要决定是否覆写父类中的方法，所以一个设计完善的父类是无法对子类做出任何强制性的覆写约定。为了解决这个问题，抽象类的概念就诞生了，抽象类和普通类相比唯一增加的就是抽象方法，同时抽象类在使用时要求必须被继承，而且必须全部覆写抽象类中的抽象方法。</p>
<p>普通类只是一个设计完善，可以直接产生实例化对象并且调用类中的属性和方法，抽象类最大特点，就是必须被子类继承，并且抽象类本身无法进行实例化。在实际项目中，往往很少设计普通类，大多都会选择继承抽象类。</p>
<p>抽象类基本定义：抽象类是为了方法覆写而提供的类结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class javademo01&#123;</span><br><span class="line">    private String type;</span><br><span class="line">    public abstract String getconn();</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本实例中利用abstract关键字声明了抽象类与抽象方法：</p>
<p>1、抽象方法与普通方法不一样，抽象方法不能有方法体{}</p>
<p>2、抽象类不是一个完整的类，抽象类必须提供子类，子类继承依然用extends关键字</p>
<p>3、子类（非抽象类）一定要覆写抽象类中的全部抽象方法</p>
<p>4、抽象类的对象实例化可以通过子类向上转型来实现</p>
<p>抽象类的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class javademo01&#123;</span><br><span class="line">    private String type;</span><br><span class="line">    public abstract String getconn();</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class javademo02 extends javademo01&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getconn()&#123;</span><br><span class="line">        return super.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo13  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        javademo01 j1 = new javademo02();</span><br><span class="line">        j1.setType(&quot;mm&quot;);</span><br><span class="line">        System.out.println(j1.getconn());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类最大特点的是自己无法对象实例化，所以说在实际项目中，抽象类用来当中间过渡，当我们想要使用抽象类中，往往是为了解决继承中带来的代码重复处理。</p>
<p>抽象类的说明</p>
<p>1、抽象类必须有子类继承，抽象方法必须被覆写，所以抽象类定义时，不允许final定义抽象类和抽象方法。</p>
<p>2、抽象类也可以定义成员属性和普通方法，为了给抽象类的成员属性初始化，我们可以给抽象类设计构造方法，子类在继承时会调用抽象类的无参构造，如果抽象类没有提供，那么就需要super关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract  class javademo01&#123;</span><br><span class="line">    private String type;</span><br><span class="line">    public abstract  String getconn();</span><br><span class="line"></span><br><span class="line">    public javademo01(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class javademo02 extends javademo01&#123;</span><br><span class="line"></span><br><span class="line">    public javademo02(String type) &#123;</span><br><span class="line">        super(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getconn()&#123;</span><br><span class="line">        return super.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo13  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        javademo01 j1 = new javademo02(&quot;mm&quot;);</span><br><span class="line">        System.out.println(j1.getconn());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类中可以没有抽象方法，即使没有抽象方法，也不能使用new关键字实例化对象。</p>
<p>抽象类中可以使用static定义静态方法，直接通过类名调用，毫无影响。</p>
<span id="more"></span>

<h2 id="模板设计模式（servlet）："><a href="#模板设计模式（servlet）：" class="headerlink" title="模板设计模式（servlet）："></a>模板设计模式（servlet）：</h2><p>类的作用是对一类事物的特征进行抽象化，从设计上来说，抽象类的级别比普通类要高。抽象类是对类的进一步抽象。</p>
<p>机器人：充电+工作</p>
<p>人：吃饭+睡觉+工作</p>
<p>猪：吃饭+睡觉</p>
<p>这三个类有公共的行为可以抽象，这时候就可以利用抽象类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.ForkJoinWorkerThread;</span><br><span class="line"></span><br><span class="line">abstract class Action&#123;</span><br><span class="line">    public static final int EAT = 1;</span><br><span class="line">    public static final int SLEEP = 5;</span><br><span class="line">    public static final int WORK = 10;</span><br><span class="line">    public void command (int code)&#123;</span><br><span class="line">        switch (code)&#123;</span><br><span class="line">            case EAT:&#123;</span><br><span class="line">                this.eat();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case SLEEP:&#123;</span><br><span class="line">                this.sleep();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case WORK:&#123;</span><br><span class="line">                this.work();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case EAT+SLEEP+WORK:&#123;</span><br><span class="line">                this.eat();</span><br><span class="line">                this.sleep();</span><br><span class="line">                this.work();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void eat();</span><br><span class="line">    public abstract void sleep();</span><br><span class="line">    public abstract void work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Robot extends Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;机器人需要充电&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;机器人开始工作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person11 extends Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;饿的时候吃饭！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;困的时候睡觉！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;穷的时候去工作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pig extends Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃饲料！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;倒地就睡！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo14 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Action robot = new Robot();</span><br><span class="line">        Action person = new Person11();</span><br><span class="line">        Action pig = new Pig();</span><br><span class="line">        System.out.println(&quot;----------------Robot-----------------&quot;);</span><br><span class="line">        robot.command(Action.EAT);</span><br><span class="line">        robot.command(Action.WORK);</span><br><span class="line">        System.out.println(&quot;---------------person------------------&quot;);</span><br><span class="line">        person.command(Action.EAT);</span><br><span class="line">        person.command(Action.SLEEP);</span><br><span class="line">        person.command(Action.WORK);</span><br><span class="line">        System.out.println(&quot;--------------pig----------------------&quot;);</span><br><span class="line">        pig.command(Action.EAT);</span><br><span class="line">        pig.command(Action.SLEEP);</span><br><span class="line">        System.out.println(&quot;--------------no pig================&quot;);</span><br><span class="line">        person.command(Action.EAT+Action.SLEEP+ Action.WORK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类定义了3个子类，这三个子类会根据需要进行方法的覆写，对于暂时不需要的功能，以空方法体进行实现。</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>为了统一参数类型，需要针对基本数据类型进行引用传递，所以java提供了包装类的概念。</p>
<p>java是一门面向对象的语言，但是基本数据类型和这一理念冲突。</p>
<p>利用类的结构对基本数据类型进行包装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Int &#123;   // 定义了一个包装类</span><br><span class="line">    private int data;  // 包装了一个基本数据类型</span><br><span class="line"></span><br><span class="line">    public Int(int data) &#123; //构造方法设置基本数据类型</span><br><span class="line">        this.data = data;   // 保存基本数据类型</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int intValue()&#123;  // 从包装类中获取基本数据类型</span><br><span class="line">        return this.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object obj = new Int(10); // 装箱,将基本数据类型保存在包装类中</span><br><span class="line">        int x = ((Int) obj).intValue(); //拆箱，从包装类对象中取出基本数据类型</span><br><span class="line">        System.out.println(x * 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面对这样的设计缺陷，java也有自己的方案，设计了8个包装类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i1 = new Integer(10);</span><br><span class="line">int num = i1.intValue(); </span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<p>如上就是针对int数据类型的装箱、拆箱操作。</p>
<p>如上的操作，在jdk5之前必须做，但是5之后，java提供了自动装箱和拆箱的机制，并且包装类的对象可以自行计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i2 = 10;</span><br><span class="line">int num1 = i2;</span><br><span class="line">System.out.println(num1);</span><br></pre></td></tr></table></figure>

<p>这个其实就已经和string类型差不多了，因为他有两种实例化方式，一个是构造方法，一个是直接赋值，其实和string一样，直接赋值直接入池，反之。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer i1 = new Integer(10);</span><br><span class="line">int num = i1.intValue();</span><br><span class="line">System.out.println(num);</span><br><span class="line"></span><br><span class="line">Integer i2 = 10;</span><br><span class="line">int num1 = i2;</span><br><span class="line">System.out.println(num1);</span><br><span class="line"></span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>除此之外，还要注意一点。</p>
<p>自动装箱的相等判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer ii1 = 100;</span><br><span class="line">Integer ii2 = 100;</span><br><span class="line">System.out.println(ii1 == ii2);</span><br><span class="line"></span><br><span class="line">Integer ii3 = 130;</span><br><span class="line">Integer ii4 = 130;</span><br><span class="line"></span><br><span class="line">System.out.println(ii3 == ii4);</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>这里要注意，不再-128~127范围内的数，通过==比较返回的就是false。</p>
<p>自动装箱中，如果范围属于-128到127，可以自动实现堆内存的引用，否则不行。</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>将字符串转化为int</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line">int num = Integer.parseInt(str);</span><br><span class="line">System.out.println(num + num);</span><br></pre></td></tr></table></figure>

<p>如果含有非数字，就会抛出异常。</p>
<p>Exception in thread “main” java.lang.NumberFormatException</p>
<p>字符串转boolean（不是true或者false，统一返回false）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = &quot;1sa23&quot;;</span><br><span class="line">boolean b1 = Boolean.parseBoolean(str);</span><br><span class="line">System.out.println(b1);</span><br></pre></td></tr></table></figure>



<p>基本数据类型转string</p>
<p>+连接符连接一个空字符串就可以了</p>
<h2 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h2><p>比抽象类更重要，定义开发标准。</p>
<p>接口是一个特殊的类，通过interface关键字定义，在接口中可以定义全局常量、抽象方法（访问权限必须是public）、default方法以及static方法。</p>
<p>定义标准接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface IMessage &#123;</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、接口中存在抽象方法，因此无法被实例化。</p>
<p>2、接口需要被子类实现，子类通过implements关键字实现多个父接口</p>
<p>3、子类如果不是抽象类，子类一定要覆写全部的抽象方法</p>
<p>4、接口对象可以利用子类对象实现向上转型</p>
<p>继承和实现的顺序：先继承后实现接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface IMessage &#123;</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class fff &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class sss extends fff implements IMessage&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口的基本使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface face01&#123;</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class demo16_1 implements face01&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return &quot;i love mm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        face01 f1 = new demo16_1();</span><br><span class="line">        System.out.println(f1.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本程序利用关键字定义了接口子类，并且利用子类对象向上转型实例化了接口对象。</p>
<p>子类实现多个父接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义接口</span><br><span class="line">interface face01&#123;</span><br><span class="line">//    全局常量</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">//    抽象方法</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">interface face02&#123;</span><br><span class="line">//    抽象方法</span><br><span class="line">    public abstract boolean conn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现多个接口</span><br><span class="line">class demo16_1 implements face01,face02&#123;</span><br><span class="line">    </span><br><span class="line">//    方法覆写</span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        if(this.conn())&#123;</span><br><span class="line">            return &quot;i love mm&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;default&quot;+face01.INFO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean conn() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        face01 f1 = new demo16_1();</span><br><span class="line">        System.out.println(f1.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result: i love mm</span><br></pre></td></tr></table></figure>

<p>本程序在子类上实现了两个父接口，这样就必须全部覆写接口中的抽象方法，因此实际上子类是object与这两个父接口的实例。</p>
<p>观察接口实例转换:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        face01 f1 = new demo16_1();</span><br><span class="line">        Object obj = f1;</span><br><span class="line">        face02 f2 = (face02) obj;</span><br><span class="line">        System.out.println(f2.conn());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有子类，那么object与两个父接口是没有任何关系的，但是由于子类同时实现了这些接口并且默认继承了object父类，所以该实例就可以进行任意父接口的转型。</p>
<p>关于接口的简化定义</p>
<p>完整定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义接口</span><br><span class="line">interface face01&#123;</span><br><span class="line">//    全局常量</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">//    抽象方法</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface face03&#123;</span><br><span class="line">    String INFO =&quot;i love mm&quot;;</span><br><span class="line">    String getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两种定义的作用完全相同，但是从实际的开发程序来讲，在接口中定义抽象方法时建议保留public的声明，这样的接口定义会更加的清楚。</p>
<p>在面向对象设计中，抽象类也是必不可少的一种结构，利用抽象类可以实现一些公共方法的定义，可以利用extends先继承父类再利用implements实现若干父接口的顺序完成子类定义。</p>
<p>java中的extends关键字除了具有类继承的作用外，也可以在接口上使用以实现接口的继承关系，并且可以同时实现多个父接口。</p>
<p>接口之间的继承，不存在任何强制性的覆写，类无法继承接口，只能实现。</p>
<p>接口的使用分析：在面向对象设计中，接口的核心用处是为了实现方法名的暴露与子类的隐藏。</p>
<hr>
<p>接口定义加强</p>
<p>接口是java诞生之初就提出的设计结构，其最初的组成就是抽象方法与全局常量，但是随着技术发展，在8之后的接口组成除了提供有全局常量和抽象方法之外，还可以定义普通方法或者静态方法。</p>
<p>这就使得接口中不仅仅只有抽象方法，同时这些普通方法也可以直接被子类继承。</p>
<p>接口中定义普通方法的意义：</p>
<p>便于扩充接口功能，同时简化设计结构</p>
<p>在设计中，接口主要是为了进行公共标准的定义，但是随着技术的发展，接口的设计也有可能得到更新，那么此时假设有一个早期版本的接口，并且随着发展，他已经有了很多个子类。如果现在需要对接口中新增一个方法，并且所有的子类对于此方法的实现完全相同的时候，就需要修改所有定义的子类，重复复制实现方法，这样就会导致代码的可维护性降低，在8之前的时候，为了解决这个问题，我们可以定义一个中间的过渡抽象类，由抽象类去继承接口，然后子类继承抽象类。接口中追加方法，在抽象类中做出实现，最后子类再继承抽象类。那么接口再扩充公共方法时，就只需要修改抽象类，所以为了解决这样的设计，在8之后就提供了普通方法的支持，同时，如果子类发现父接口中公共的方法功能不足时，也可以进行覆写。</p>
<p>普通方法需要通过接口实例化对象才可以调用，为了避免实例化对象的依赖，在接口中也可以使用static定义静态方法，此方法可以直接利用接口名称调用。</p>
<p>友情提示：个人认为，虽然接口中普通方法和静态方法很大程度上与抽象类的作用有一些重叠，但是要注意开发中尽量的在接口与子类之中，建立一个过渡抽象类。不要着急定义子类。</p>
<p>定义接口标准</p>
<p>项目功能设计中接口往往是最先定义的，这样就定义好了操作的标准。对于接口而言，最重要的就是进行标准的定义，实际上在日常中，你也会听到许多接口的名词，例如：usb接口，鼠标接口等等，这样接口实际上都是属于标准的定义与应用。</p>
<p>以usb的程序为例，计算机上可以插入各种usb的设备，所以计算上认识的知识usb标准，而不关心这个标准的具体子类。</p>
<p>利用接口定义标准：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface face_usb&#123;</span><br><span class="line">    public boolean check();</span><br><span class="line">    public void work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class computer&#123;</span><br><span class="line">    public void plugin(face_usb usb)&#123;</span><br><span class="line">        if (usb.check())&#123;</span><br><span class="line">            usb.work();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;There are some problems here!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class keyboard implements face_usb&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean check() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;starting study!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo17 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        computer c1 = new computer();</span><br><span class="line">        c1.plugin(new keyboard());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>工厂设计模式：</p>
<p>接口在实际开发过程中主要特点是进行标准的定义，而标准的定义是一个灵活的概念，也就是说，标准不应该与具体的子类绑在一起，为了解决代码耦合的问题，在开发中针对接口对象的获得，往往通过工厂设计模式来呈现。</p>
<p><img src="/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20210803003800286.png" alt="工厂设计模式"></p>
<p>一个工厂类，在此类中提供一个静态方法返回接口实例化对象，这样在主类调用时，就不需要关注具体的接口子类，只需要传入指定的类型标记就可以获取接口对象。</p>
<p>当然也存在许多问题，比如当接口扩产子类时都需要修改工厂类，这样的子类一旦很多，工厂类的代码就会很多。如果有若干接口都需要工厂类来获取实例，对于工厂类需要追加大量的static方法，一个项目可能只需要某个接口的特定子类，这个子类往往可以通过配置文件的形式进行定义，修改时也可以通过配置文件的修改而更换子类，所以这种固定标记的做法可能导致代码的混乱。</p>
<p>代理设计模式</p>
<p>为了实现核心业务与辅助功能的细分，可以通过代理设计模式。</p>
<p>这是java开发中使用较多的一种模式，是指一个代理主题来操作真实主题，真实主题执行具体的业务操作，而代理主题则负责其他相关业务的办理，简单理解，你现在肚子饿了，如果你只会吃饭而不会做饭的话，肯定要去外面吃，而饭店会为你吃饭做一些辅助的业务（例如，买菜，买盘子等等），而你只负责吃就可以了。</p>
<p><img src="/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20210803123739591.png" alt="代理设计模式"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IEat &#123;</span><br><span class="line">    public void get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatReal implements IEat &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        System.out.println(&quot;得到一份食物，开始吃饭！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatProxy implements IEat &#123;</span><br><span class="line"></span><br><span class="line">    private IEat eat;</span><br><span class="line"></span><br><span class="line">    public EatProxy(IEat eat) &#123;</span><br><span class="line">        this.eat = eat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        this.prepare();</span><br><span class="line">        this.eat.get();</span><br><span class="line">        this.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void prepare()&#123;</span><br><span class="line">        System.out.println(&quot;1、购买食材&quot;);</span><br><span class="line">        System.out.println(&quot;2、处理食材&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        System.out.println(&quot;3、洗盘子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo18 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IEat eat = new EatProxy(new EatReal());</span><br><span class="line">        eat.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本程序为接口实现了两个子类，真实主题类和代理主题类，真实主题类只有在代理类提供支持的情况下才可以正常完成核心业务，但是对于主类而言，所关注的只是接口执行标准，而具体实现那一个子类并不去关注。</p>
<p>代理设计模式结合工厂设计模式</p>
<p>以上程序中，直接在主类中实例化了主类，这其实是不符合要求的，所有自定义的接口对象都应该通过工厂获得，修改后：</p>
<p><img src="/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20210803125650132.png" alt="工厂设计模式与代理设计模式整合"></p>
<p>修改代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IEat &#123;</span><br><span class="line">    public void get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatReal implements IEat &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        System.out.println(&quot;得到一份食物，开始吃饭！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatProxy implements IEat &#123;</span><br><span class="line"></span><br><span class="line">    private IEat eat;</span><br><span class="line"></span><br><span class="line">    public EatProxy(IEat eat) &#123;</span><br><span class="line">        this.eat = eat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        this.prepare();</span><br><span class="line">        this.eat.get();</span><br><span class="line">        this.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void prepare()&#123;</span><br><span class="line">        System.out.println(&quot;1、购买食材&quot;);</span><br><span class="line">        System.out.println(&quot;2、处理食材&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        System.out.println(&quot;3、洗盘子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static IEat get()&#123;</span><br><span class="line">        return new EatProxy(new EatReal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo18 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IEat eat = Factory.get();</span><br><span class="line">        eat.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>抽象类与接口的区别：</p>
<table>
<thead>
<tr>
<th>no</th>
<th>区别</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>关键字</td>
<td>abstract class</td>
<td>interface</td>
</tr>
<tr>
<td>2</td>
<td>组成</td>
<td>常量、变量、抽象方法、普通方法、静态方法</td>
<td>全局常量、抽象方法、普通方法、静态方法</td>
</tr>
<tr>
<td>3</td>
<td>权限</td>
<td>各种权限</td>
<td>只能是public</td>
</tr>
<tr>
<td>4</td>
<td>关系</td>
<td>一个抽象类可以实现多个接口</td>
<td>接口不能继承抽象类，可以继承多接口</td>
</tr>
<tr>
<td>5</td>
<td>使用</td>
<td>子类使用extends继承抽象类</td>
<td>子类使用implements实现接口</td>
</tr>
<tr>
<td></td>
<td></td>
<td>抽象类和接口都是利用对象多态性的向上转型，进行接口或者抽象类的实例化操作</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>设计模式</td>
<td>模板设计模式</td>
<td>工厂设计模式、代理设计模式</td>
</tr>
<tr>
<td>7</td>
<td>局限</td>
<td>一个子类只能继承一个抽象类</td>
<td>一个子类可以实现多个接口</td>
</tr>
</tbody></table>
<p>接口是在类之上的定义</p>
<p>一个简短的分析：<br>想要我们想要定义一个动物，那么动物肯定是一个公共的标准，而这个公共标准就可以通过接口来完成，动物中又分为两类，哺乳动物和卵生动物，而这个标准属于对动物标准的进一步细化，应该称为子标准，所以此种关系可以使用接口的继承来表示，而哺乳动物又可以继续划分为人、狗、猫不同的类型，由于这些类型不表示具体的实物标准，因此使用抽象类表示。如果要表示出工人或者是学生这样的概念，那么就肯定是一个具体的定义，则使用类的方式，然而每一个学生和工人都是具体的，那么就通过对象来表示。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2021/07/28/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>继承</p>
<p>面向对象的优点：模块化设计和代码重用，而依靠单一的类与对象是很难实现效果的。</p>
<p>（例如，学生类，人类，学生类本就属于人类，但是学生表示的范围比人又要小，因此人类是无法满足需求的）</p>
<p>在面向对象设计中，类是基本的逻辑单元，而对于基本的逻辑单元之间需要考虑到重用的问题，所以提供了继承，来实现类的重用。</p>
<p>严格来讲，类的继承是扩充一个类原有的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java中，实现继承的语法。</p>
<p>在继承结构里，很多时候会把子类叫做派生类，父类叫做超类。</p>
<p>继承的小例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son s1= new Son();</span><br><span class="line">        s1.setName(&quot;mm&quot;);</span><br><span class="line">        System.out.println(s1.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：子类没有定义任何结构，但是实例化对象之后能直接调用父类的方法与属性，证明子类重用了父类中的结构，同时可以根据子类功能进行调整。</p>
<p>在子类中扩充父类的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Son extends Father&#123;</span><br><span class="line">    private String school;</span><br><span class="line"></span><br><span class="line">    public String getSchool() &#123;</span><br><span class="line">        return school;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSchool(String school) &#123;</span><br><span class="line">        this.school = school;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son s1= new Son();</span><br><span class="line">        s1.setName(&quot;mm&quot;);</span><br><span class="line">        s1.setSchool(&quot;宇宙联合大学&quot;);</span><br><span class="line">        System.out.println(s1.getName()+&quot;\t&quot;+s1.getSchool());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类在父类基础上扩充了新的属性和方法，相比于父类，他更加的具体。</p>
<p>子类对象实例化流程：</p>
<p>继承关系中会产生父类和子类两种实例化对象。</p>
<p>子类调用父类的结构，所以说在进行子类对象实例化之前，我们会默认的调用父类的无参构造方法，为父类对象实例化（属性初始化），而后再进行子类构造调用，为子类对象实例化（属性初始化）。</p>
<p>子类对象实例化（无参构造调用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Father1 &#123;</span><br><span class="line">    public Father1()&#123;</span><br><span class="line">        System.out.println(&quot;父类构造方法正在调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son1 extends Father1&#123;</span><br><span class="line">    public Son1()&#123;</span><br><span class="line">        System.out.println(&quot;子类构造方法正在调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son1 s1 = new Son1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父类构造方法正在调用！</span><br><span class="line">子类构造方法正在调用！</span><br></pre></td></tr></table></figure>

<p>总结：程序只调用了子类的构造方法，结果发现，父类构造方法会默认的调用，执行完毕之后再执行子类的构造，所以得出结论，子类对象实例化一定会实例化父类对象，实际上相当于子类的构造方法隐含了一个super()的形式。</p>
<p>观察子类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Son1 extends Father1&#123;</span><br><span class="line">    public Son1()&#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;子类构造方法正在调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super的作用表示在子类中明确调用父类的构造方法，不写也会默认调用，对于super在子类构造方法中的定义，要注意，一定要写在第一行。</p>
<p>如果父类没有提供无参的构造方法，就可以通过super(参数)的形式调用指定参数的构造方法。</p>
<p>明确调用父类构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Father1 &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Father1(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son1 extends Father1 &#123;</span><br><span class="line">    private String school;</span><br><span class="line"></span><br><span class="line">    public Son1(String name, int age, String school) &#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.school = school;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son1 s1 = new Son1(&quot;mm&quot;,7,&quot;宇宙小学&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序里，父类就不再提供无参的构造方法了，这样在子类中就必须通过super关键字去明确子类要调用的父类结构，并且该语句必须放在首行。</p>
<p>子类一定要调用父类构造嘛？</p>
<p>一定的。</p>
<p>换一种说法，先有父母，才有子女。先有父类出生，才有子类出生。</p>
<p>继承限制</p>
<p>虽然，继承可以实现代码重用，但是这并不代表他是没有限制的。</p>
<p>1、单继承，一个子类只能继承一个父类。</p>
<p>首先，其他语言中存在多继承，也就是一个子类可以继承多个父类，在java中也可以实现这样的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public A(String name)&#123;</span><br><span class="line">        System.out.println(&quot;name:&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public B(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B&#123;</span><br><span class="line">    public C(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C类实际上是孙类，B类继承了A类的属性，C类继承了B类的属性，这就相当于了C类继承了A和B类的属性和方法，这样的操作叫<strong>多层继承</strong>，在java中只允许多层继承，不允许多重继承。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class D extends A,B,C&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：继承层数不要太多，太多影响到代码的阅读。</p>
<p>2、子类在继承时，会继承父类所有的属性和方法，包括私有属性。但是，对非私有的，属于显式继承（直接能用对象操作），私有的叫隐式继承（间接完成）。</p>
<p>没有继承私有属性，但继承了getter和setter方法。（间接完成）</p>
<p>覆写</p>
<p>在继承关系中，父类是最基础的存在，定义的结构都是为了本类的需要，但是有时候子类有一些特殊的需要，有可能会定义和父类相同名的属性和方法，这种情况就被称为覆写。</p>
<p>方法覆写</p>
<p>子类继承父类的全部方法，当父类中有些方法无法满足，就可以对这个方法进行扩充，这时，子类中定义一个方法名、返回值类型、参数类型和个数完全相同的方法的时候，就被称为方法覆写。</p>
<p>方法覆写基本实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;父类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DataBaese extends Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;子类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataBaese d1 = new DataBaese();</span><br><span class="line">        d1.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法覆写主要为了定义子类个性化的方法，同时保持了父类结构。</p>
<p>如果说，我们想要调用父类被覆写之后的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.xml.parsers.SAXParser;</span><br><span class="line"></span><br><span class="line">class Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;父类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DataBaese extends Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        super.connect();</span><br><span class="line">        System.out.println(&quot;子类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataBaese d1 = new DataBaese();</span><br><span class="line">        d1.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此处，用this替代super则会报栈溢出的错误。</p>
<p>Exception in thread “main” java.lang.StackOverflowError</p>
<p>所以说，我们可以得出结论，同样是调用类结构，super不会查找自身，直接调用父类。</p>
<p>方法覆写限制</p>
<p>子类中覆写的方法不能比父类的方法具有更严格的控制权限。</p>
<p>private&lt;default&lt;public</p>
<p>子类的权限大于等于父类权限</p>
<p>注意：父类方法定义为private时，子类无法覆写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Channel&#123;</span><br><span class="line">    private void connect()&#123;</span><br><span class="line">        System.out.println(&quot;父类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void m1()&#123;</span><br><span class="line">        this.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DataBaese extends Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;子类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataBaese d1 = new DataBaese();</span><br><span class="line">        d1.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重载与覆写：</p>
<p>重载：方法名相同、其他可以不同、没有权限要求、发生了一个类中</p>
<p>覆写：方法名、参数、返回值都想同、子类覆写的方法权限要大于等于父类方法、发生在继承关系中。</p>
<p>属性覆盖</p>
<p>子类依据自身需求对父类属性进行重命名定义。</p>
<p>要注意：private属性无效。</p>
<p>只需要属性名一致即可，数据类型可以不一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class animal&#123;</span><br><span class="line">    double age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class person11 extends animal&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    public void info()&#123;</span><br><span class="line">        System.out.println(this.age);</span><br><span class="line">        System.out.println(super.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        person11 p1 = new person11();</span><br><span class="line">        p1.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super和this</p>
<p>super：表示父类对象、父类操作，属性，方法，（）构造方法、调用父类构造，放在首行、由子类查找父类</p>
<p>this：表示本类对象、本类操作，属性，方法，（）构造方法、调用本来构造，放在首行、从本类查找、表示当前对象</p>
<p>final关键字</p>
<p>为了保护父类定义</p>
<p>final在java描述为终接器。</p>
<p>定义不能继承的类，不能覆写的方法，常量（全局常量）。</p>
<p>关于常量和字符串连接的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demo09 &#123;</span><br><span class="line"></span><br><span class="line">    public static final String str1 = &quot;mm&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str2 = &quot;ilovemm&quot;;</span><br><span class="line">        String str3 = &quot;ilove&quot;+str1;</span><br><span class="line">        System.out.println(str2==str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>annotation注解(明确声明，为了良好的代码阅读)</p>
<p>1、准确覆写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class F &#123;</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class S extends F &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;子类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解就可以在不清楚父类结构的情况下，分析哪些是覆写方法，哪些是自定义方法，此处还可以在编译时检测因为子类拼写造成的方法覆写错误。</p>
<p>2、过期声明</p>
<p>程序是不断更新的，有时候会有一些不再推荐使用的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class F &#123;</span><br><span class="line">    </span><br><span class="line">    @Deprecated</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void m3()&#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class S extends F &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;子类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合理开发时，不要使用已经被注解之后的，弃用结构，不利于后期更新。</p>
<p>3、压制警告</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class F &#123;</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">    @SuppressWarnings(value = &#123;&quot;deprecation&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new F().m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证代码的合理性，在编译时会抛出警告，但是有些错误不必要，为了防止这些信息出现，就可以用压制警告注解。</p>
<p>deprecation：使用了不赞成的类或方法。</p>
<p>多态</p>
<p>同一种结构会根据不同形式展示出不同的效果。</p>
<p>方法的多态性：</p>
<p>重载：同一方法，根据传入参数不同实现不同功能</p>
<p>覆写：同一个方法根据子类不同实现不同功能</p>
<p>对象的多态性：</p>
<p>父类与子类的转换</p>
<p>向上转型：父类 父类实例 = 子类实例 （自动转换）</p>
<p>向下转型：子类 子类实例 = （子类）父类实例 （强制转换完成）</p>
<p>参考意见：实际的转型处理上看，向上转型用的比较多，向下转型往往都在使用子类特殊功能的时候，还有不转型使用（例如：String类）</p>
<p>父类定义标准，子类定义个性化。（覆写）</p>
<p>向上转型：子类对象实例化之前一定会实例化父类对象，这个时候如果我们把子类对象的实例通过父类来接受，即可实现对象的向上转型。而此时的本质还是子类实例，所以说，一旦调用子类覆写了父类的方法，调用的一定是覆写之后的方法。</p>
<p>最大的特点在于可以通过父类对象接受子类实例，这一原则有助于实现方法接受或返回参数的统一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class animal &#123;</span><br><span class="line">    public double age = 7;</span><br><span class="line">    public void info()&#123;</span><br><span class="line">        System.out.println(&quot;父类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class person11 extends animal &#123;</span><br><span class="line">    public int age = 7;</span><br><span class="line"></span><br><span class="line">    public void info() &#123;</span><br><span class="line">       System.out.println(&quot;子类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        animal a1 = new person11();</span><br><span class="line">        a1.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不要看类名称，看实例化对象的类。关键看调用哪个类的构造。（new后的内容，不看左边看右边）</p>
<p>最大的特点在于可以通过父类对象接受子类实例，这一原则有助于实现方法接受或返回参数的统一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class kafka extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am kafka&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mq extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am mq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class database&#123;</span><br><span class="line">    /*</span><br><span class="line">     * 接受message对象，由于存在自动向上转型的机制，所以可以接受所有的子类实例</span><br><span class="line">     */</span><br><span class="line">    public static void m3(message m1)&#123;</span><br><span class="line">        m1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        database.m3(new kafka());</span><br><span class="line">        database.m3(new mq());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本类中定义的m3方法，参数类型是message，这就意味着所有message以及子类对象都可以接受，相当于统一了参数类型。</p>
<p>向上转型主要是为了实现操作标准的统一性。</p>
<p>向下转型：保持子类实例的个性化</p>
<p>子类继承父类之后可以对已经有的功能进行扩充（覆写，新加），对于子类之中扩充的方法只有具体的子类实例才可以调用，在这样的情况下，如果子类发生了向上转型呐？</p>
<p>需要通过强制向下转型来实现子类扩充方法的调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class kafka extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am kafka&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print2()&#123;</span><br><span class="line">        System.out.println(&quot;i am java 11&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mq extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am mq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        message m1 = new kafka();</span><br><span class="line">        m1.print();</span><br><span class="line">        kafka k1 = (kafka) m1;</span><br><span class="line">        k1.print2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，通过kafka子类接收了message对象，此时m1只能调用本类或者是m1父类的方法，如果此时需要调用子类中扩充的方法，就必须强制转换为指定的子类类型。</p>
<p>要先发生向上转型，才可以进行向下转型。</p>
<p>父类实例是不可能强者转换成任意子类实例的，因为两者之间没有联系。必须先通过子类实例，利用向上转型让父类对象和子类实例发生关系才可以向下转型，否则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    message m1 = new message();</span><br><span class="line">    kafka k1 = (kafka) m1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException</span><br></pre></td></tr></table></figure>

<p>这里就是message对象并没有和kafka子类产生联系，所以无法强制转换。向下转换永远都存在安全隐患。</p>
<p>为了保证转换的安全性，给出了instanceof关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    message m1 = new kafka();</span><br><span class="line">    kafka k1 = (kafka) m1;</span><br><span class="line">    System.out.println(m1 instanceof message);</span><br><span class="line">    System.out.println(k1 instanceof message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>所以说，我们可以通过先判断再转换的方式去进行转型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class kafka extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am kafka&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print2()&#123;</span><br><span class="line">        System.out.println(&quot;i am java 11&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mq extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am mq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        message m1 = new kafka();</span><br><span class="line">        m1.print();</span><br><span class="line">        if (m1 instanceof kafka)&#123;</span><br><span class="line">            kafka k1 = (kafka) m1;</span><br><span class="line">            k1.print2();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>object类</p>
<p>在java里是最重要的程序类，也是所有类的父类。</p>
<p>方便操作类型的统一，方便每一个类定义一些公共操作，专门设计了一个公共的object父类，object是唯一一个没有父类的类。但是却是所有类的父类，所有利用class关键字定义的类默认都全部继承于object类，因此：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class message extends Object&#123;</span><br><span class="line">class message &#123;</span><br></pre></td></tr></table></figure>

<p>这两种类定义的效果都是一样的。</p>
<p>所有类都是object的子类，那么就代表所有类对象都可以利用向上转型为obejct类对象实例化。</p>
<p>这样优势在于，当某些操作需要接受或者返回任意类型时候，最适合的参数类型就是object。</p>
<p>object除了能接收所有的类实例之外，还可以接收所有的引用数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object a1 = new int[]&#123;1,2,3&#125;;</span><br><span class="line">    if (a1 instanceof int[])&#123;</span><br><span class="line">        int data [] = (int[]) a1;</span><br><span class="line">        for (int temp: data) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取对象信息</p>
<p>在object类中有一个tostring（）方法，利用这个方法可以实现对象信息的获取，同时这个方法在进行对象输出被默认调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object a1 = new int[]&#123;1,2,3&#125;;</span><br><span class="line">System.out.println(a1.toString());</span><br><span class="line">System.out.println(a1);</span><br></pre></td></tr></table></figure>

<p>具体中，我们可以根据需要覆写tostring方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class message &#123;</span><br><span class="line">    private int length;</span><br><span class="line"></span><br><span class="line">    public int getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLength(int length) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public message(int length) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;队列长度:&quot; + this.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object a1 = new message(12);</span><br><span class="line">        System.out.println(a1.toString());</span><br><span class="line">        System.out.println(a1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本例中，定义了length属性，覆写了tostring方法，而后调用时，就会实现我们自己实现的方法体内的内容。</p>
<p>对象比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class demo extends Object&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public demo(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj)&#123;</span><br><span class="line">        if (!(obj instanceof demo))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this == obj)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        demo d1 = (demo) obj;</span><br><span class="line">        return this.name.equals(d1.name) &amp;&amp; this.age == d1.age;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo12 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo d1 = new demo(&quot;mm&quot;,7);</span><br><span class="line">        demo d2 = new demo(&quot;mm&quot;,7);</span><br><span class="line">        System.out.println(d1.equals(d2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>html学习笔记01</title>
    <url>/2021/09/10/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h2 id="1、html"><a href="#1、html" class="headerlink" title="1、html"></a>1、html</h2><p>html作为一门超文本标记语言，包括一系列的标签，它通过这些标签将网络文档结构统一化，通过浏览器进行解析与阅读。</p>
<p>html文本是由html（htm）为后缀的由html命令组成的描述性文本，通过对标签的使用，可以描述文字，图形，动画，声音，表格，链接等等。</p>
<h2 id="2、position"><a href="#2、position" class="headerlink" title="2、position"></a>2、position</h2><p>dom position属性。</p>
<p>position属性把元素放置到一个静态的、相对的、绝对的、固定的的位置中去。</p>
<p>要理解这个属性，首先应该明白什么是流？</p>
<p>所谓的文档流，指的其实就是元素排版布局过程中，元素会自动从左到右，从上往下的流式排列。并最终窗体自上而下分成一行行，并在每行中按从左至右的排放元素。</p>
<p>顺便说一下，除了设置position的属性值为absolute与fixed之外，float对象也会<strong>打乱这个队列</strong>，这些都会暂时脱离流的存在，clear之后才会回到流之中（单指float）。</p>
<p>（float：right显然会打乱文档流，但是float：left也有这样的效果：其实是因为子元素设置了float属性，然而父元素没有设置（或者保持了默认的static），则子元素会从父元素中溢出，（最明显的表现就是，父元素不会随着子元素的扩大而扩大），因为当元素设置了float这个属性之后，其他没有设置float属性的盒子或者是标签会无视这个属性，也就是其他没有设置浮动的元素会和他进行叠加，这就可以当作脱离了文档流。但是要注意一点的就是，与position：absolute不同的是，其他盒子内的元素依然会为了float元素让出位置，因此不会出现互相叠加的情况。这种情况下消除浮动就可以解决）</p>
<p>其中，默认得到html流属性其实就是static，默认布局，这种布局，是没有定位的，而且不会继承父元素的属性，w3c的文档里提到，忽略top、bottom、left、right或者z-index声明，他是存在于流里面的。除此之外还有relative，相对布局，假如父元素采用了这种布局，那么子元素就是相对于父元素的绝对定位，一般会配合到top、right、bottom、left来使用，这种布局其实也是存在于流里面的。但是fixed浮动布局，是相对于浏览器窗口的绝对布局（上下滚动页面），一般同样配合上下左右来使用，这个布局是脱离了流的存在的。（！！ie不兼容这种模式！！）</p>
<p>absolute布局，绝对布局，相对于页面的绝对布局（上下滚动），同样配合四方使用，脱离了流的存在，最后一种我用的比较少，inherit布局，w3c的文档规定他是继承了父元素position的值。</p>
<p><strong>如果我们想在页面上固定元素，毫无疑问，选择absolute，他是以页面左上角为（0，0），根据tblr来布局的，与fixed不同，f是当前窗口布局，也是左上角为（0，0），但是会根据滚动条一起滚动，相对于当前窗口的位置不变。relative是相对位置，指的是子节点和父节点的关系，当一个子节点在父节点中的时候，默认的position就是relative，在子节点包含在父节点中，这个时候就算我们设置的子节点是absolute，也会成为relative，也就是相对于父节点的左上角排版。</strong></p>
<p><strong>总结：在html中，永远没有绝对，只有相对。所有元素都是document的子元素。</strong></p>
<h2 id="3、相对路径与绝对路径"><a href="#3、相对路径与绝对路径" class="headerlink" title="3、相对路径与绝对路径"></a>3、相对路径与绝对路径</h2><p><strong>参照物不同</strong>，导致的差别。</p>
<p>在计算机中，这是一个避免不了问题，无论是path环境变量还是classpath类加载路径都是源自于这两个路径的差别。他们的差别也很简单，绝对路径以磁盘为参照物，而相对路径则以当前路径为参照。</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>js函数高级</title>
    <url>/2021/09/12/js%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><ul>
<li>所有函数都有一个特别的属性:<ul>
<li><code>prototype</code> : 显式原型属性</li>
</ul>
</li>
<li>所有实例对象都有一个特别的属性:<ul>
<li><code>__proto__</code> : 隐式原型属性</li>
</ul>
</li>
<li>显式原型与隐式原型的关系<ul>
<li>函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象</li>
<li>实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li>
<li>原型对象即为当前实例对象的父对象</li>
</ul>
</li>
<li>原型链<ul>
<li>所有的实例对象都有__proto__属性, 它指向的就是原型对象</li>
<li>这样通过__proto__属性就形成了一个链的结构—-&gt;原型链</li>
<li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li>
<li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</li>
</ul>
</li>
</ul>
<h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><ul>
<li>变量提升与函数提升<ul>
<li>变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)</li>
<li>函数提升: 在函数定义语句之前, 就执行该函数</li>
<li>先有变量提升, 再有函数提升</li>
</ul>
</li>
<li>理解<ul>
<li>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性</li>
<li>执行上下文栈: 用来管理产生的多个执行上下文</li>
</ul>
</li>
<li>分类:<ul>
<li>全局: window</li>
<li>函数: 对程序员来说是透明的</li>
</ul>
</li>
<li>生命周期<ul>
<li>全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡</li>
<li>函数 : 调用函数时产生, 函数执行完时死亡</li>
</ul>
</li>
<li>包含哪些属性:<ul>
<li>全局 : <ul>
<li>用var定义的全局变量  ==&gt;undefined</li>
<li>使用function声明的函数   ===&gt;function</li>
<li>this   ===&gt;window</li>
</ul>
</li>
<li>函数<ul>
<li>用var定义的局部变量  ==&gt;undefined</li>
<li>使用function声明的函数   ===&gt;function</li>
<li>this   ===&gt; 调用函数的对象, 如果没有指定就是window </li>
<li>形参变量   ===&gt;对应实参值</li>
<li>arguments ===&gt;实参列表的伪数组</li>
</ul>
</li>
</ul>
</li>
<li>执行上下文创建和初始化的过程<ul>
<li>全局:<ul>
<li>在全局代码执行前最先创建一个全局执行上下文(window)</li>
<li>收集一些全局变量, 并初始化</li>
<li>将这些变量设置为window的属性</li>
</ul>
</li>
<li>函数:<ul>
<li>在调用函数时, 在执行函数体之前先创建一个函数执行上下文</li>
<li>收集一些局部变量, 并初始化</li>
<li>将这些变量设置为执行上下文的属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><ul>
<li>理解:<ul>
<li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li>
<li>作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量</li>
</ul>
</li>
<li>分类:<ul>
<li>全局</li>
<li>函数</li>
<li>js没有块作用域(在ES6之前)</li>
</ul>
</li>
<li>作用<ul>
<li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li>
<li>作用域链: 查找变量</li>
</ul>
</li>
<li>区别作用域与执行上下文<ul>
<li>作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了</li>
<li>执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失</li>
<li>联系: 执行上下文环境是在对应的作用域中的</li>
</ul>
</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><p>理解:</p>
<ul>
<li>当嵌套的内部函数引用了外部函数的变量时就产生了闭包</li>
<li>通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性</li>
</ul>
</li>
<li><p>作用:</p>
<ul>
<li>延长局部变量的生命周期</li>
<li>让函数外部能操作内部的局部变量</li>
</ul>
</li>
<li><p>写一个闭包程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  function fn2() &#123;</span><br><span class="line">    a++;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  return fn2;</span><br><span class="line">&#125;</span><br><span class="line">var f = fn1();</span><br><span class="line">f();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></li>
<li><p>闭包应用:</p>
<ul>
<li>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为</li>
<li>循环遍历加监听</li>
<li>JS框架(jQuery)大量使用了闭包</li>
</ul>
</li>
<li><p>缺点:</p>
<ul>
<li>变量占用内存的时间可能会过长</li>
<li>可能导致内存泄露</li>
<li>解决:<ul>
<li>及时释放 : f = null; //让内部函数对象成为垃圾对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><ol>
<li>内存溢出</li>
</ol>
<ul>
<li>一种程序运行出现的错误</li>
<li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li>
</ul>
<ol start="2">
<li>内存泄露</li>
</ol>
<ul>
<li>占用的内存没有及时释放</li>
<li>内存泄露积累多了就容易导致内存溢出</li>
<li>常见的内存泄露:<ul>
<li>意外的全局变量</li>
<li>没有及时清理的计时器或回调函数</li>
<li>闭包</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础总结深入</title>
    <url>/2021/09/12/js%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<h2 id="数据类型的分类和判断"><a href="#数据类型的分类和判断" class="headerlink" title="数据类型的分类和判断"></a>数据类型的分类和判断</h2><ul>
<li>基本(值)类型<ul>
<li>Number —– 任意数值 ——– typeof</li>
<li>String —– 任意字符串 —— typeof</li>
<li>Boolean —- true/false —– typeof</li>
<li>undefined — undefined —– typeof/===</li>
<li>null ——– null ———- ===</li>
</ul>
</li>
<li>对象(引用)类型<ul>
<li>Object —– typeof/instanceof</li>
<li>Array —— instanceof</li>
<li>Function —- typeof</li>
</ul>
</li>
</ul>
<h2 id="数据-变量-内存的理解"><a href="#数据-变量-内存的理解" class="headerlink" title="数据,变量, 内存的理解"></a>数据,变量, 内存的理解</h2><ul>
<li>什么是数据?<ul>
<li>在内存中可读的, 可传递的保存了特定信息的’东东’</li>
<li>一切皆数据, 函数也是数据</li>
<li>在内存中的所有操作的目标: 数据</li>
</ul>
</li>
<li>什么是变量?<ul>
<li>在程序运行过程中它的值是允许改变的量</li>
<li>一个变量对应一块小内存, 它的值保存在此内存中  </li>
</ul>
</li>
<li>什么是内存?<ul>
<li>内存条通电后产生的存储空间(临时的)</li>
<li>一块内存包含2个方面的数据<ul>
<li>内部存储的数据</li>
<li>地址值数据</li>
</ul>
</li>
<li>内存空间的分类<ul>
<li>栈空间: 全局变量和局部变量</li>
<li>堆空间: 对象 </li>
</ul>
</li>
</ul>
</li>
<li>内存,数据, 变量三者之间的关系<ul>
<li>内存是容器, 用来存储不同数据</li>
<li>变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  </li>
</ul>
</li>
</ul>
<h2 id="对象的理解和使用"><a href="#对象的理解和使用" class="headerlink" title="对象的理解和使用"></a>对象的理解和使用</h2><ul>
<li><p>什么是对象?</p>
<ul>
<li>多个数据(属性)的集合</li>
<li>用来保存多个数据(属性)的容器</li>
</ul>
</li>
<li><p>属性组成:</p>
<ul>
<li>属性名 : 字符串(标识)</li>
<li>属性值 : 任意类型</li>
</ul>
</li>
<li><p>属性的分类:</p>
<ul>
<li>一般 : 属性值不是function  描述对象的状态</li>
<li>方法 : 属性值为function的属性  描述对象的行为</li>
</ul>
</li>
<li><p>特别的对象</p>
<ul>
<li>数组: 属性名是0,1,2,3之类的索引</li>
<li>函数: 可以执行的</li>
</ul>
</li>
<li><p>如何操作内部属性(方法)</p>
<ul>
<li><p>.属性名</p>
</li>
<li><p>[‘属性名’]: 属性名有特殊字符/属性名是一个变量</p>
</li>
</ul>
</li>
</ul>
<h2 id="函数的理解和使用"><a href="#函数的理解和使用" class="headerlink" title="函数的理解和使用"></a>函数的理解和使用</h2><ul>
<li><p>什么是函数?</p>
<ul>
<li>用来实现特定功能的, n条语句的封装体</li>
<li>只有函数类型的数据是可以执行的, 其它的都不可以</li>
</ul>
</li>
<li><p>为什么要用函数?</p>
<ul>
<li>提高复用性</li>
<li>便于阅读交流</li>
</ul>
</li>
<li><p>函数也是对象</p>
<ul>
<li>instanceof Object===true</li>
<li>函数有属性: prototype</li>
<li>函数有方法: call()/apply()</li>
<li>可以添加新的属性/方法</li>
</ul>
</li>
<li><p>函数的3种不同角色</p>
<ul>
<li>一般函数 : 直接调用</li>
<li>构造函数 : 通过new调用</li>
<li>对象 : 通过.调用内部的属性/方法</li>
</ul>
</li>
<li><p>函数中的this</p>
<ul>
<li>显式指定谁: obj.xxx()</li>
<li>通过call/apply指定谁调用: xxx.call(obj)</li>
<li>不指定谁调用: xxx()  : window</li>
<li>回调函数: 看背后是通过谁来调用的: window/其它</li>
</ul>
</li>
<li><p>匿名函数自调用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function(w, obj)&#123;</span><br><span class="line">  //实现代码</span><br><span class="line">&#125;)(window, obj)</span><br></pre></td></tr></table></figure>

<ul>
<li>专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式                          </li>
</ul>
</li>
<li><p>回调函数的理解</p>
<ul>
<li>什么函数才是回调函数?<ul>
<li>你定义的</li>
<li>你没有调用</li>
<li>但它最终执行了(在一定条件下或某个时刻)</li>
</ul>
</li>
<li>常用的回调函数<ul>
<li>dom事件回调函数</li>
<li>定时器回调函数</li>
<li>ajax请求回调函数</li>
<li>生命周期回调函数</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>js对象高级</title>
    <url>/2021/09/12/js%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><ul>
<li><p>Object构造函数模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.name = &#x27;Tom&#x27;</span><br><span class="line">obj.setName = function(name)&#123;this.name=name&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对象字面量模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name : &#x27;Tom&#x27;,</span><br><span class="line">  setName : function(name)&#123;this.name = name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Person(&#x27;tom&#x27;, 12);</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数+原型的组合模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">new Person(&#x27;tom&#x27;, 12);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><ul>
<li><p>原型链继承 : 得到方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent()&#123;&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line">function Child()&#123;&#125;</span><br><span class="line">Child.prototype = new Parent(); // 子类型的原型指向父类型实例</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line">var child = new Child(); //有test()</span><br></pre></td></tr></table></figure></li>
<li><p>借用构造函数 : 得到属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">var child = new Child(&#x27;a&#x27;, &#x27;b&#x27;);  //child.xxx为&#x27;a&#x27;, 但child没有test()</span><br></pre></td></tr></table></figure></li>
<li><p>组合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent(); //得到test()</span><br><span class="line">var child = new Child(); //child.xxx为&#x27;a&#x27;, 也有test()</span><br></pre></td></tr></table></figure></li>
<li><p>new一个对象背后做了些什么?</p>
<ul>
<li>创建一个空对象</li>
<li>给对象设置__proto__, 值为构造函数对象的prototype属性值   this.<strong>proto</strong> = Fn.prototype</li>
<li>执行构造函数体(给对象添加属性/方法)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>alta数据治理</title>
    <url>/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/</url>
    <content><![CDATA[<h1 id="使用-Apache-Atlas-进行数据治理"><a href="#使用-Apache-Atlas-进行数据治理" class="headerlink" title="使用 Apache Atlas 进行数据治理"></a>使用 Apache Atlas 进行数据治理</h1><h2 id="数据治理"><a href="#数据治理" class="headerlink" title="数据治理"></a>数据治理</h2><p>数据治理意义重大，传统的数据治理采用文档的形式进行管理，已经无法满足大数据下的数据治理需要。而适合于Hadoop大数据生态体系的数据治理就非常的重要了。</p>
<blockquote>
<p>大数据下的数据治理作为很多企业的一个巨大的难题，能找到的数据的解决方案并不多，但是好在近几年，很多公司已经进行了尝试并开源了出来，本文将详细分析这些数据发现平台，在国外已经有了十几种的实现方案。<br>数据发现平台可以解决的问题<br>为什么需要一个数据发现平台？<br>在数据治理过程中，经常会遇到这些问题：</p>
<p>数据都存在哪？</p>
<p>该如何使用这些数据？</p>
<p>数据是做什么的？</p>
<p>数据是如何创建的？</p>
<p>数据是如何更新的？</p>
</blockquote>
<p><strong>数据发现平台的目的就是为了解决上面的问题，帮助更好的查找，理解和使用数据。</strong></p>
<blockquote>
<p>Facebook的Nemo就使用了全文检索技术，这样可以快速的搜索到目标数据。</p>
<p>es（搜索引擎）</p>
</blockquote>
<h3 id="各平台对比"><a href="#各平台对比" class="headerlink" title="各平台对比"></a>各平台对比</h3><p><img src="/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/image-20210915093419300.png" alt="image-20210915093419300"></p>
<p>开源的有五家：Amundsen Datahub Metacat Marquez Atlas</p>
<p>有文档的有三家：Amundsen Datahub Atlas</p>
<p>搜索功能较强 ：Amundsen</p>
<p>有数据血统功能：Datahub Atlas</p>
<p>考虑到项目的周期，实施性等情况，还是建议大家从Atlas入门，打开数据治理的探索之路。</p>
<h2 id="alta"><a href="#alta" class="headerlink" title="alta"></a>alta</h2><blockquote>
<p>面对海量且持续增加的各式各样的数据对象，你是否有信心知道哪些数据从哪里来以及它如何随时间而变化？采用Hadoop必须考虑数据管理的实际情况，元数据与数据治理成为企业级数据湖的重要部分。</p>
<p>为寻求数据治理的开源解决方案，Hortonworks 公司联合其他厂商与用户于2015年发起数据治理倡议，包括数据分类、集中策略引擎、数据血缘、安全和生命周期管理等方面。Apache Atlas 项目就是这个倡议的结果，社区伙伴持续的为该项目提供新的功能和特性。该项目用于管理共享元数据、数据分级、审计、安全性以及数据保护等方面，努力与Apache Ranger整合，用于数据权限控制策略。</p>
</blockquote>
<p>Atlas 是一个可扩展和可扩展的核心基础治理服务集 - 使企业能够有效地和高效地满足 Hadoop 中的合规性要求，并允许与整个企业数据生态系统的集成。</p>
<p><img src="/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/1253350-20180509182903076-1452084256.jpg" alt="alta数据治理"></p>
<p>Atlas 的组件可以分为以下主要类别：</p>
<h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p>此类别包含实现 Atlas 功能核心的组件，包括：</p>
<p>Type System：Atlas 允许用户为他们想要管理的元数据对象定义一个模型。该模型由称为 “类型” 的定义组成。”类型” 的 实例被称为 “实体” 表示被管理的实际元数据对象。类型系统是一个组件，允许用户定义和管理类型和实体。由 Atlas 管理的所有元数据对象（例如Hive表）都使用类型进行建模，并表示为实体。要在 Atlas 中存储新类型的元数据，需要了解类型系统组件的概念。</p>
<p>需要注意的一个关键点是，Atlas 中建模的通用性质允许数据管理员和集成者定义技术元数据和业务元数据。也可以使用 Atlas 的特征来定义两者之间的丰富关系。</p>
<p>Ingest / Export：Ingest 组件允许将元数据添加到 Atlas。类似地，Export 组件暴露由 Atlas 检测到的元数据更改，以作为事件引发，消费者可以使用这些更改事件来实时响应元数据更改。</p>
<p>Graph Engine ：在内部，Atlas 通过使用图形模型管理元数据对象。以实现元数据对象之间的巨大灵活性和丰富的关系。图形引擎是负责在类型系统的类型和实体之间进行转换的组件，以及基础图形模型。除了管理图形对象之外，图形引擎还为元数据对象创建适当的索引，以便有效地搜索它们。</p>
<p>Titan：目前，Atlas 使用 Titan 图数据库来存储元数据对象。 Titan 使用两个存储：默认情况下元数据存储配置为 HBase ，索引存储配置为 Solr。也可以通过构建相应的配置文件将元数据存储作为 BerkeleyDB 和 Index 存储使用为 ElasticSearch。元数据存储用于存储元数据对象本身，并且索引存储用于存储元数据属性的索引，其允许高效搜索。</p>
<h2 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h2><p>用户可以使用两种方法管理 Atlas 中的元数据：</p>
<p>API：Atlas 的所有功能通过 REST API 提供给最终用户，允许创建，更新和删除类型和实体。它也是查询和发现通过 Atlas 管理的类型和实体的主要方法。</p>
<p>Messaging：除了 API 之外，用户还可以选择使用基于 Kafka 的消息接口与 Atlas 集成。这对于将元数据对象传输到 Atlas 以及从 Atlas 使用可以构建应用程序的元数据更改事件都非常有用。如果希望使用与 Atlas 更松散耦合的集成，这可以允许更好的可扩展性，可靠性等，消息传递接口是特别有用的。Atlas 使用 Apache Kafka 作为通知服务器用于钩子和元数据通知事件的下游消费者之间的通信。事件由钩子和 Atlas 写到不同的 Kafka 主题。</p>
<h3 id="元数据源"><a href="#元数据源" class="headerlink" title="元数据源"></a>元数据源</h3><p>Atlas 支持与许多元数据源的集成。将来还会添加更多集成。目前，Atlas 支持从以下来源获取和管理元数据：</p>
<p><a href="http://atlas.apache.org/StormAtlasHook.html">HiveSqoopFalconStorm</a></p>
<p>与其它元数据源集成意味着两件事：有一些元数据模型，Atlas 定义本机来表示这些组件的对象。 Atlas 提供了从这些组件中通过实时或批处理模式获取元数据对象的组件。</p>
<h2 id="Apps"><a href="#Apps" class="headerlink" title="Apps"></a>Apps</h2><p>由 Atlas 管理的元数据各种应用程序使用，满足许多治理用例。</p>
<p>Atlas Admin UI：该组件是一个基于 Web 的应用程序，允许数据管理员和科学家发现和注释元数据。这里最重要的是搜索界面和 SQL 样的查询语言，可以用来查询由 Atlas 管理的元数据类型和对象。管理 UI 使用 Atlas 的 REST API 来构建其功能。</p>
<p>Tag Based Policies：Apache Ranger 是针对 Hadoop 生态系统的高级安全管理解决方案，与各种 Hadoop 组件具有广泛的集成。通过与 Atlas 集成，Ranger 允许安全管理员定义元数据驱动的安全策略，以实现有效的治理。 Ranger 是由 Atlas 通知的元数据更改事件的消费者。</p>
<p>Business Taxonomy：从元数据源获取到 Atlas 的元数据对象主要是一种技术形式的元数据。为了增强可发现性和治理能力，Atlas 提供了一个业务分类界面，允许用户首先定义一组代表其业务域的业务术语，并将其与 Atlas 管理的元数据实体相关联。业务分类法是一种 Web 应用程序，目前是 Atlas Admin UI 的一部分，并且使用 REST API 与 Atlas 集成。</p>
<h2 id="Type-System"><a href="#Type-System" class="headerlink" title="Type System"></a>Type System</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Atlas 允许用户为他们想要管理的元数据对象定义一个模型。该模型由称为 “类型” 的定义组成。被称为 “实体” 的 “类型” 实例表示被管理的实际元数据对象。类型系统是一个组件，允许用户定义和管理类型和实体。由 Atlas 管理的所有元数据对象（例如Hive表）都使用类型进行建模，并表示为实体。要在Atlas中存储新类型的元数据，需要了解类型系统组件的概念。</p>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Atlas中的 “类型” 定义了如何存储和访问特定类型的元数据对象。类型表示了所定义元数据对象的一个或多个属性集合。具有开发背景的用户可以将 “类型” 理解成面向对象的编程语言的 “类” 定义的或关系数据库的 “表模式”。</p>
<p>与 Atlas 本地定义的类型的示例是 Hive 表。 Hive 表用这些属性定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name: hive_table</span><br><span class="line"> MetaType: Class</span><br><span class="line"> SuperTypes: DataSet</span><br><span class="line"> Attributes:</span><br><span class="line">     name: String (name of the table)</span><br><span class="line">     db: Database object of type hive_db</span><br><span class="line">     owner: String</span><br><span class="line">     createTime: Date</span><br><span class="line">     lastAccessTime: Date</span><br><span class="line">     comment: String</span><br><span class="line">     retention: int</span><br><span class="line">     sd: Storage Description object of type hive_storagedesc</span><br><span class="line">     partitionKeys: Array of objects of type hive_column</span><br><span class="line">     aliases: Array of strings</span><br><span class="line">     columns: Array of objects of type hive_column</span><br><span class="line">     parameters: Map of String keys to String values</span><br><span class="line">     viewOriginalText: String</span><br><span class="line">     viewExpandedText: String</span><br><span class="line">     tableType: String</span><br><span class="line">     temporary: Boolean</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以注意到以下几点：</p>
<ul>
<li>Atlas中的类型由 “name” 唯一标识，</li>
<li>类型具有元类型。元类型表示 Atlas 中此模型的类型。 Atlas 有以下几种类型：<ul>
<li>基本元类型： Int，String，Boolean等。</li>
<li>枚举元类型</li>
<li>集合元类型：例如Array，Map</li>
<li>复合元类型：Class，Struct，Trait</li>
</ul>
</li>
<li>类型可以从称为 “supertype” 的父类型 “extend” - 凭借这一点，它将包含在 “supertype” 中定义的属性。这允许模型在一组相关类型等之间定义公共属性。这再次类似于面向对象语言如何定义类的超类的概念。 Atlas 中的类型也可以从多个超类型扩展。<ul>
<li>在该示例中，每个 hive 表从预定义的超类型（称为 “DataSet”）扩展。稍后将提供关于此预定义类型的更多细节。</li>
</ul>
</li>
<li>具有 “Class”，”Struct” 或 “Trait” 的元类型的类型可以具有属性集合。每个属性都有一个名称（例如 “name”）和一些其他关联的属性。可以使用表达式 type_name.attribute_name 来引用属性。还要注意，属性本身是使用 Atlas 元类型定义的。<ul>
<li>在这个例子中，hive_table.name 是一个字符串，hive_table.aliases 是一个字符串数组，hive_table.db 引用一个类型的实例称为 hive_db 等等。</li>
</ul>
</li>
<li>在属性中键入引用（如hive_table.db）。使用这样的属性，我们可以在 Atlas 中定义的两种类型之间的任意关系，从而构建丰富的模型。注意，也可以收集一个引用列表作为属性类型（例如 hive_table.cols，它表示从 hive_table 到 hive_column 类型的引用列表）</li>
</ul>
<h3 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h3><p>Atlas中的 “实体” 是类 “类型” 的特定值或实例，因此表示真实世界中的特定元数据对象。 回顾我们的面向对象编程语言的类比，”实例” 是某个 “类” 的 “对象”。</p>
<p>实体的示例将是特定的 Hive 表。 说 “Hive” 在 “默认” 数据库中有一个名为 “customers” 的表。 此表将是类型为 hive_table 的 Atlas 中的 “实体”。 通过作为类类型的实例，它将具有作为 Hive 表 “类型” 的一部分的每个属性的值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id: &quot;9ba387dd-fa76-429c-b791-ffc338d3c91f&quot;</span><br><span class="line"> typeName: “hive_table”</span><br><span class="line"> values:</span><br><span class="line">     name: &quot;customers&quot;</span><br><span class="line">     db: &quot;b42c6cfc-c1e7-42fd-a9e6-890e0adf33bc&quot;</span><br><span class="line">     owner: &quot;admin&quot;</span><br><span class="line">     createTime: &quot;2016-06-20T06:13:28.000Z&quot;</span><br><span class="line">     lastAccessTime: &quot;2016-06-20T06:13:28.000Z&quot;</span><br><span class="line">     comment: null</span><br><span class="line">     retention: 0</span><br><span class="line">     sd: &quot;ff58025f-6854-4195-9f75-3a3058dd8dcf&quot;</span><br><span class="line">     partitionKeys: null</span><br><span class="line">     aliases: null</span><br><span class="line">     columns: [&quot;65e2204f-6a23-4130-934a-9679af6a211f&quot;, &quot;d726de70-faca-46fb-9c99-cf04f6b579a6&quot;, ...]</span><br><span class="line">     parameters: &#123;&quot;transient_lastDdlTime&quot;: &quot;1466403208&quot;&#125;</span><br><span class="line">     viewOriginalText: null</span><br><span class="line">     viewExpandedText: null</span><br><span class="line">     tableType: &quot;MANAGED_TABLE&quot;</span><br><span class="line">     temporary: false</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以注意到以下几点：</p>
<ul>
<li>作为 Class Type 实例的每个实体都由唯一标识符 GUID 标识。此 GUID 由 Atlas 服务器在定义对象时生成，并在实体的整个生命周期内保持不变。在任何时间点，可以使用其 GUID 来访问该特定实体。<ul>
<li>在本示例中，默认数据库中的 “customers” 表由GUID “9ba387dd-fa76-429c-b791-ffc338d3c91f” 唯一标识</li>
</ul>
</li>
<li>实体具有给定类型，并且类型的名称与实体定义一起提供。<ul>
<li>在这个例子中，”customers” 表是一个 “hive_table”。</li>
</ul>
</li>
<li>此实体的值是所有属性名称及其在 hive_table 类型定义中定义的属性的值的映射。</li>
<li>属性值将根据属性的元类型。<ul>
<li>基本元类型：整数，字符串，布尔值。例如。 ‘name’=’customers’，’Temporary’=’false’</li>
<li>集合元类型：包含元类型的值的数组或映射。例如。 parameters = {“transient_lastDdlTime”：”1466403208”}</li>
<li>复合元类型：对于类，值将是与该特定实体具有关系的实体。例如。hive 表 “customers” 存在于称为 “default” 的数据库中。</li>
</ul>
</li>
</ul>
<p>表和数据库之间的关系通过 “db” 属性捕获。因此，”db” 属性的值将是一个唯一标识 hive_db 实体的 GUID，称为 “default”对于实体的这个想法，我们现在可以看到 Class 和 Struct 元类型之间的区别。类和结构体都组成其他类型的属性。但是，类类型的实体具有 Id 属性（具有GUID值）并且可以从其他实体引用（如 hive_db 实体从 hive_table 实体引用）。 Struct 类型的实例没有自己的身份，Struct 类型的值是在实体本身内嵌入的属性的集合。</p>
<h3 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h3><p>我们已经看到属性在复合元类型（如 Class 和 Struct）中定义。 但是我们简单地将属性称为具有名称和元类型值。 然而， Atlas 中的属性还有一些属性，定义了与类型系统相关的更多概念。</p>
<p>属性具有以下属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: string,</span><br><span class="line">  dataTypeName: string,</span><br><span class="line">  isComposite: boolean,</span><br><span class="line">  isIndexable: boolean,</span><br><span class="line">  isUnique: boolean,</span><br><span class="line">  multiplicity: enum,</span><br><span class="line">  reverseAttributeName: string</span><br></pre></td></tr></table></figure>

<p>以上属性具有以下含义：</p>
<ul>
<li>name - 属性的名称</li>
<li>dataTypeName - 属性的元类型名称（本机，集合或复合）</li>
<li>isComposite - 是否复合<ul>
<li>此标志指示建模的一个方面。如果一个属性被定义为复合，它意味着它不能有一个生命周期与它所包含的实体无关。这个概念的一个很好的例子是构成 hive 表一部分的一组列。由于列在 hive 表之外没有意义，它们被定义为组合属性。</li>
<li>必须在 Atlas 中创建复合属性及其所包含的实体。即，必须与 hive 表一起创建 hive 列。</li>
</ul>
</li>
<li>isIndexable - 是否索引<ul>
<li>此标志指示此属性是否应该索引，以便可以使用属性值作为谓词来执行查找，并且可以有效地执行查找。</li>
</ul>
</li>
<li>isUnique - 是否唯一<ul>
<li>此标志再次与索引相关。如果指定为唯一，这意味着为 Titan 中的此属性创建一个特殊索引，允许基于等式的查找。</li>
<li>具有此标志的真实值的任何属性都被视为主键，以将此实体与其他实体区分开。因此，应注意确保此属性在现实世界中模拟独特的属性。<ul>
<li>例如，考虑 hive_table 的 name 属性。孤立地，名称不是 hive_table 的唯一属性，因为具有相同名称的表可以存在于多个数据库中。如果 Atlas 在多个集群中存储 hive 表的元数据，即使一对（数据库名称，表名称）也不是唯一的。只有集群位置，数据库名称和表名称可以在物理世界中被视为唯一。</li>
</ul>
</li>
</ul>
</li>
<li>multiplicity - 指示此属性是（必需的／可选的／还是可以是多值）的。如果实体的属性值的定义与类型定义中的多重性声明不匹配，则这将是一个约束违反，并且实体添加将失败。因此，该字段可以用于定义元数据信息上的一些约束。</li>
</ul>
<p>使用上面的内容，让我们扩展下面的 hive 表的属性之一的属性定义。让我们看看称为 “db” 的属性，它表示 hive 表所属的数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db:</span><br><span class="line">    &quot;dataTypeName&quot;: &quot;hive_db&quot;,</span><br><span class="line">    &quot;isComposite&quot;: false,</span><br><span class="line">    &quot;isIndexable&quot;: true,</span><br><span class="line">    &quot;isUnique&quot;: false,</span><br><span class="line">    &quot;multiplicity&quot;: &quot;required&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;db&quot;,</span><br><span class="line">    &quot;reverseAttributeName&quot;: null</span><br></pre></td></tr></table></figure>

<p>注意多重性的 “multiplicity” = “required” 约束。 如果没有 db 引用，则不能发送表实体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">columns:</span><br><span class="line">    &quot;dataTypeName&quot;: &quot;array&lt;hive_column&gt;&quot;,</span><br><span class="line">    &quot;isComposite&quot;: true,</span><br><span class="line">    &quot;isIndexable&quot;: true,</span><br><span class="line">    “isUnique&quot;: false,</span><br><span class="line">    &quot;multiplicity&quot;: &quot;optional&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;columns&quot;,</span><br><span class="line">    &quot;reverseAttributeName&quot;: null</span><br></pre></td></tr></table></figure>

<p>请注意列的 “isComposite” = true 值。通过这样做，我们指示定义的列实体应该始终绑定到它们定义的表实体。</p>
<p>从这个描述和示例中，您将能够意识到属性定义可以用于影响 Atlas 系统要执行的特定建模行为（约束，索引等）。</p>
<h3 id="系统特定类型及其意义"><a href="#系统特定类型及其意义" class="headerlink" title="系统特定类型及其意义"></a>系统特定类型及其意义</h3><p>Atlas 提供了一些预定义的系统类型。我们在前面的章节中看到了一个例子（DataSet）。在本节中，我们将看到所有这些类型并了解它们的意义。</p>
<p>Referenceable：此类型表示可使用名为 qualifiedName 的唯一属性搜索的所有实体。</p>
<p>Asset：此类型包含名称，说明和所有者等属性。名称是必需属性（multiplicity = required），其他是可选的。可引用和资源的目的是为定型器提供在定义和查询其自身类型的实体时强制一致性的方法。拥有这些固定的属性集允许应用程序和用户界面基于约定基于默认情况下他们可以期望的属性的假设。</p>
<p>Infrastructure：此类型扩展了可引用和资产，通常可用于基础设施元数据对象（如群集，主机等）的常用超类型。</p>
<p>DataSet：此类型扩展了可引用和资产。在概念上，它可以用于表示存储数据的类型。在 Atlas 中，hive表，Sqoop RDBMS表等都是从 DataSet 扩展的类型。扩展 DataSet 的类型可以期望具有模式，它们将具有定义该数据集的属性的属性。例如， hive_table 中的 columns 属性。另外，扩展 DataSet 的实体类型的实体参与数据转换，这种转换可以由 Atlas 通过 lineage（或 provenance）生成图形。</p>
<p>Process：此类型扩展了可引用和资产。在概念上，它可以用于表示任何数据变换操作。例如，将原始数据的 hive 表转换为存储某个聚合的另一个 hive 表的 ETL 过程可以是扩展过程类型的特定类型。流程类型有两个特定的属性，输入和输出。输入和输出都是 DataSet 实体的数组。因此，Process 类型的实例可以使用这些输入和输出来捕获 DataSet 的 lineage 如何演变。</p>
<h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>Atlas 支持以下 2 种方式搜索元数据:</p>
<ul>
<li>Search using DSL</li>
<li>Full-text search</li>
</ul>
<p><a href="http://atlas.apache.org/Bridge-Hive.html">Hive Atlas Bridge</a></p>
<h3 id="Hive-Model"><a href="#Hive-Model" class="headerlink" title="Hive Model"></a>Hive Model</h3><p>默认 hive 建模在 org.apache.atlas.hive.model.HiveDataModelGenerator 中可用。 它定义以下类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive_db(ClassType) - super types [Referenceable] - attributes [name, clusterName, description, locationUri, parameters, ownerName, ownerType]</span><br><span class="line">hive_storagedesc(ClassType) - super types [Referenceable] - attributes [cols, location, inputFormat, outputFormat, compressed, numBuckets, serdeInfo, bucketCols, sortCols, parameters, storedAsSubDirectories]</span><br><span class="line">hive_column(ClassType) - super types [Referenceable] - attributes [name, type, comment, table]</span><br><span class="line">hive_table(ClassType) - super types [DataSet] - attributes [name, db, owner, createTime, lastAccessTime, comment, retention, sd, partitionKeys, columns, aliases, parameters, viewOriginalText, viewExpandedText, tableType, temporary]</span><br><span class="line">hive_process(ClassType) - super types [Process] - attributes [name, startTime, endTime, userName, operationType, queryText, queryPlan, queryId]</span><br><span class="line">hive_principal_type(EnumType) - values [USER, ROLE, GROUP]</span><br><span class="line">hive_order(StructType) - attributes [col, order]</span><br><span class="line">hive_serde(StructType) - attributes [name, serializationLib, parameters]</span><br></pre></td></tr></table></figure>

<p>使用唯一的限定名称创建和去重复实体。它们提供命名空间，也可以用于 query／lineage。请注意，dbName，tableName 和 columnName 应为小写。 clusterName 解释如下。</p>
<ul>
<li>hive_db - attribute qualifiedName - <dbName>@<clusterName></clusterName></dbName></li>
<li>hive_table - attribute qualifiedName - <dbName>.<tableName>@<clusterName></clusterName></tableName></dbName></li>
<li>hive_column - attribute qualifiedName - <dbName>.<tableName>.<columnName>@<clusterName></clusterName></columnName></tableName></dbName></li>
<li>hive_process - attribute name - <queryString> - 小写的修剪查询字符串</queryString></li>
</ul>
<h3 id="导入-Hive-Metadata"><a href="#导入-Hive-Metadata" class="headerlink" title="导入 Hive Metadata"></a>导入 Hive Metadata</h3><p>org.apache.atlas.hive.bridge.HiveMetaStoreBridge 使用 org.apache.atlas.hive.model.HiveDataModelGenerator 中定义的模型将 Hive 元数据导入 Atlas。 import-hive.sh 命令可以用来方便这一点。脚本需要 Hadoop 和 Hive 类路径 jar。 对于 Hadoop jar，请确保环境变量 HADOOP_CLASSPATH 已设置。另一种方法是将 HADOOP_HOME 设置为指向 Hadoop 安装的根目录同样，对于 Hive jar，将 HIVE_HOME 设置为 Hive 安装的根目录将环境变量 HIVE_CONF_DIR 设置为 Hive 配置目录复制 ${atlas-conf}/atlas-application.properties 到 hive conf 目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: &lt;atlas package&gt;/hook-bin/import-hive.sh</span><br></pre></td></tr></table></figure>

<p>日志位于 ${atlas package}/logs/import-hive.log</p>
<p>如果要在 kerberized 集群中导入元数据，则需要运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;atlas package&gt;/hook-bin/import-hive.sh -Dsun.security.jgss.debug=true -Djavax.security.auth.useSubjectCredsOnly=false -Djava.security.krb5.conf=[krb5.conf location] -Djava.security.auth.login.config=[jaas.conf location]</span><br></pre></td></tr></table></figure>

<ul>
<li>krb5.conf is typically found at /etc/krb5.conf</li>
<li>for details about jaas.conf and a suggested location see the <a href="http://atlas.apache.org/Security.html">atlas security documentation</a></li>
</ul>
<h3 id="Hive-Hook"><a href="#Hive-Hook" class="headerlink" title="Hive Hook"></a>Hive Hook</h3><p>Hive 在使用 hive hook 的 hive 命令执行上支持侦听器。 这用于在 Atlas 中使用 org.apache.atlas.hive.model.HiveDataModelGenerator 中定义的模型添加/更新/删除实体。 hive hook 将请求提交给线程池执行器，以避免阻塞命令执行。 线程将实体作为消息提交给通知服务器，并且服务器读取这些消息并注册实体。 按照 hive 设置中的这些说明为 Atlas 添加 hive hook ：</p>
<ul>
<li>Set-up atlas hook in hive-site.xml of your hive configuration:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.exec.post.hooks&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.atlas.hive.hook.HiveHook&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;atlas.cluster.name&lt;/name&gt;</span><br><span class="line">&lt;value&gt;primary&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Add ‘export HIVE_AUX_JARS_PATH=<atlas package>/hook/hive’ in hive-env.sh of your hive configuration</atlas></li>
<li>Copy <atlas-conf>/atlas-application.properties to the hive conf directory.</atlas-conf></li>
</ul>
<p>在<atlas-conf> /atlas-application.properties中的以下属性控制线程池和通知详细信息：</atlas-conf></p>
<ul>
<li>atlas.hook.hive.synchronous - boolean，true来同步运行钩子。 默认false。 建议设置为false，以避免 hive 查询完成中的延迟。</li>
<li>atlas.hook.hive.numRetries - 通知失败的重试次数。 默认值 3</li>
<li>atlas.hook.hive.minThreads - 核心线程数。 默认值 5</li>
<li>atlas.hook.hive.maxThreads - 最大线程数。 默认值 5</li>
<li>atlas.hook.hive.keepAliveTime - 保持活动时间以毫秒为单位。 默认 10</li>
<li>atlas.hook.hive.queueSize - 线程池的队列大小。 默认 10000</li>
</ul>
<p>参考 <a href="http://atlas.apache.org/Configuration.html">Configuration</a> 通知相关配置</p>
<h3 id="Column-Level-Lineage"><a href="#Column-Level-Lineage" class="headerlink" title="Column Level Lineage"></a>Column Level Lineage</h3><p>从 atlas-0.8-incubating 版本开始，在 Atlas 中捕获列 lineage</p>
<h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><ul>
<li>ColumnLineageProcess 类型是 Process 的子类</li>
<li>这将输出列与一组输入列或输入表相关联</li>
<li>Lineage 还捕获 Dependency 的类型：当前的值是 SIMPLE，EXPRESSION，SCRIPT<ul>
<li>SIMPLE依赖： 意味着输出列具有与输入相同的值</li>
<li>EXPRESSION依赖： 意味着输出列被输入列上的运行时中的一些表达式（例如Hive SQL表达式）转换。</li>
<li>SCRIPT依赖： 表示输出列由用户提供的脚本转换。</li>
</ul>
</li>
<li>在 EXPRESSION 依赖的情况下，表达式属性包含字符串形式的表达式</li>
<li>由于 Process 链接输入和输出 DataSet，我们使 Column 成为 DataSet 的子类</li>
</ul>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p>对于下面的简单 CTAS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table t2 as select id, name from T1</span><br></pre></td></tr></table></figure>

<p>lineage 为</p>
<p><img src="/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/1253350-20180509182917037-667288476.jpg" alt="img"></p>
<h4 id="Extracting-Lineage-from-Hive-commands"><a href="#Extracting-Lineage-from-Hive-commands" class="headerlink" title="Extracting Lineage from Hive commands"></a>Extracting Lineage from Hive commands</h4><ul>
<li>HiveHook 将 HookContext 中的 LineageInfo 映射到 Column lineage 实例</li>
<li>Hive 中的 LineageInfo 为最终的 FileSinkOperator 提供 Column lineage ，将它们链接到 Hive 查询中的输入列</li>
</ul>
<h4 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h4><p>在将 <a href="https://issues.apache.org/jira/browse/HIVE-13112">HIVE-13112</a> 的补丁应用于 Hive 源之后，列级别 lineage 与 Hive 版本1.2.1配合使用</p>
<h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><ul>
<li>由于数据库名，表名和列名在 hive 中不区分大小写，因此实体中的对应名称为小写。 因此，任何搜索 API 都应该在查询实体名称时使用小写</li>
<li>以下 hive 操作由 hive hook 当前捕获<ul>
<li>create database</li>
<li>create table/view, create table as select</li>
<li>load, import, export</li>
<li>DMLs (insert)</li>
<li>alter database</li>
<li>alter table (skewed table information, stored as, protection is not supported)</li>
<li>alter view</li>
</ul>
</li>
</ul>
<h2 id="Sqoop-Atlas-Bridge"><a href="#Sqoop-Atlas-Bridge" class="headerlink" title="Sqoop Atlas Bridge"></a>Sqoop Atlas Bridge</h2><h3 id="Sqoop-Model"><a href="#Sqoop-Model" class="headerlink" title="Sqoop Model"></a>Sqoop Model</h3><p>默认的 Sqoop 建模在 org.apache.atlas.sqoop.model.SqoopDataModelGenerator 中可用。 它定义以下类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop_operation_type(EnumType) - values [IMPORT, EXPORT, EVAL]</span><br><span class="line">  sqoop_dbstore_usage(EnumType) - values [TABLE, QUERY, PROCEDURE, OTHER]</span><br><span class="line">  sqoop_process(ClassType) - super types [Process] - attributes [name, operation, dbStore, hiveTable, commandlineOpts, startTime, endTime, userName]</span><br><span class="line">  sqoop_dbdatastore(ClassType) - super types [DataSet] - attributes [name, dbStoreType, storeUse, storeUri, source, description, ownerName]</span><br></pre></td></tr></table></figure>

<p>使用唯一的限定名称创建和去重复实体。 它们提供命名空间，也可以用于查询：sqoop_process - attribute name - sqoop-dbStoreType-storeUri-endTime sqoop_dbdatastore - attribute name - dbStoreType-connectorUrl-source</p>
<h3 id="Sqoop-Hook"><a href="#Sqoop-Hook" class="headerlink" title="Sqoop Hook"></a>Sqoop Hook</h3><p>Sqoop 添加了一个 SqoopJobDataPublisher，在完成导入作业后将数据发布到 Atlas。 现在 sqoopHook 只支持hiveImport。 这用于使用 org.apache.atlas.sqoop.model.SqoopDataModelGenerator 中定义的模型在 Atlas 中添加实体。 按照 sqoop 设置中的以下说明在 ${sqoop-conf}/sqoop-site.xml 中为 Atlas 添加 sqoop 钩子：</p>
<ul>
<li>Sqoop Job publisher class. Currently only one publishing class is supported</li>
</ul>
<p>sqoop.job.data.publish.class org.apache.atlas.sqoop.hook.SqoopHook</p>
<ul>
<li>Atlas cluster name</li>
</ul>
<p>atlas.cluster.name</p>
<ul>
<li>复制 ${atlas-conf}/atlas-application.properties 到 sqoop 的配置文件夹 ${sqoop-conf}/</li>
<li>Link ${atlas-home}/hook/sqoop/*.jar in sqoop libRefer <a href="http://atlas.apache.org/Configuration.html">Configuration</a> for notification related configurations</li>
</ul>
<h3 id="Limitations-1"><a href="#Limitations-1" class="headerlink" title="Limitations"></a>Limitations</h3><ul>
<li>目前 sqoop hook 只支持 hiveImport 这一种 sqoop 操作</li>
</ul>
<h2 id="Falcon-Atlas-Bridge"><a href="#Falcon-Atlas-Bridge" class="headerlink" title="Falcon Atlas Bridge"></a>Falcon Atlas Bridge</h2><h3 id="Falcon-Model"><a href="#Falcon-Model" class="headerlink" title="Falcon Model"></a>Falcon Model</h3><p>默认的falcon建模在 org.apache.atlas.falcon.model.FalconDataModelGenerator. 它可以定义以下类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">falcon_cluster(ClassType) - super types [Infrastructure] - attributes [timestamp, colo, owner, tags]</span><br><span class="line">falcon_feed(ClassType) - super types [DataSet] - attributes [timestamp, stored-in, owner, groups, tags]</span><br><span class="line">falcon_feed_creation(ClassType) - super types [Process] - attributes [timestamp, stored-in, owner]</span><br><span class="line">falcon_feed_replication(ClassType) - super types [Process] - attributes [timestamp, owner]</span><br><span class="line">falcon_process(ClassType) - super types [Process] - attributes [timestamp, runs-on, owner, tags, pipelines, workflow-properties]</span><br></pre></td></tr></table></figure>

<p>为 falcon 进程定义的每个集群创建一个 falcon_process 实体。</p>
<p>使用唯一的 qualifiedName 属性创建和去重复实体。 它们提供命名空间，也可以用于查询/沿袭。 唯一的属性是：</p>
<ul>
<li>falcon_process - <process name>@<cluster name></cluster></process></li>
<li>falcon_cluster - <cluster name></cluster></li>
<li>falcon_feed - <feed name>@<cluster name></cluster></feed></li>
<li>falcon_feed_creation - <feed name></feed></li>
<li>falcon_feed_replication - <feed name></feed></li>
</ul>
<h3 id="Falcon-Hook"><a href="#Falcon-Hook" class="headerlink" title="Falcon Hook"></a>Falcon Hook</h3><p>Falcon 支持在 falcon 实体提交上的侦听器。 这用于在 Atlas 中使用 org.apache.atlas.falcon.model.FalconDataModelGenerator 中定义的模型添加实体。 hook 将请求提交给线程池执行器，以避免阻塞命令执行。 线程将实体作为消息提交给通知服务器，并且服务器读取这些消息并注册实体。</p>
<ul>
<li>Add ‘org.apache.atlas.falcon.service.AtlasService’ to application.services in ${falcon-conf}/startup.properties</li>
<li>Link falcon hook jars in falcon classpath - ‘ln -s atlas−home/hook/falcon/∗{falcon-home}/server/webapp/falcon/WEB-INF/lib/‘</li>
<li>In ${falcon_conf}/falcon-env.sh, set an environment variable as follows:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export FALCON_SERVER_OPTS=&quot;&lt;atlas_home&gt;/hook/falcon/*:$FALCON_SERVER_OPTS&quot;</span><br></pre></td></tr></table></figure>

<p>The following properties in ${atlas-conf}/atlas-application.properties control the thread pool and notification details:</p>
<ul>
<li>atlas.hook.falcon.synchronous - boolean, true to run the hook synchronously. default false</li>
<li>atlas.hook.falcon.numRetries - number of retries for notification failure. default 3</li>
<li>atlas.hook.falcon.minThreads - core number of threads. default 5</li>
<li>atlas.hook.falcon.maxThreads - maximum number of threads. default 5</li>
<li>atlas.hook.falcon.keepAliveTime - keep alive time in msecs. default 10</li>
<li>atlas.hook.falcon.queueSize - queue size for the threadpool. default 10000</li>
</ul>
<p>Refer <a href="http://atlas.apache.org/Configuration.html">Configuration</a> for notification related configurations</p>
<h3 id="Limitations-2"><a href="#Limitations-2" class="headerlink" title="Limitations"></a>Limitations</h3><ul>
<li>在 falcon 集群实体中，使用的集群名称应该跨诸如 hive，falcon，sqoop 等组件是统一的。如果与 ambari 一起使用，则应该使用 ambari 集群名称用于集群实体</li>
</ul>
<h2 id="Storm-Atlas-Bridge"><a href="#Storm-Atlas-Bridge" class="headerlink" title="Storm Atlas Bridge"></a>Storm Atlas Bridge</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Apache Storm 是一个分布式实时计算系统。 Storm 使得容易可靠地处理无界的数据流，为实时处理 Hadoop 对批处理所做的工作。 该过程实质上是节点的 DAG，其被称为 topology。</p>
<p>Apache Atlas 是一个元数据存储库，支持端到端数据沿袭，搜索和关联业务分类。</p>
<p>这种集成的目的是推动操作 topology 元数据以及基础数据源，目标，推导过程和任何可用的业务上下文，以便 Atlas 可以捕获此 topology 的 lineage。</p>
<p>在此过程中有2个部分详述如下：</p>
<ul>
<li>Data model to represent the concepts in Storm</li>
<li>Storm Atlas Hook to update metadata in Atlas</li>
</ul>
<h3 id="Storm-Data-Model"><a href="#Storm-Data-Model" class="headerlink" title="Storm Data Model"></a>Storm Data Model</h3><p>数据模型在 Atlas 中表示为 Types。 它包含 topology 图中各种节点的描述，例如 spouts 和 bolts 以及相应的生产者和消费者类型。</p>
<p>在Atlas中添加以下类型。</p>
<ul>
<li>storm_topology - 表示粗粒度拓扑。storm_topology 来自于 Atlas 过程类型，因此可用于通知 Atlas 关于 lineage。</li>
<li>添加以下数据集 - kafka_topic，jms_topic，hbase_table，hdfs_data_set。 这些都来自Atlas Dataset类型，因此形成谱系图的端点。</li>
<li>storm_spout - 具有输出的数据生产者，通常为Kafka，JMS</li>
<li>storm_bolt - 具有输入和输出的数据使用者，通常为Hive，HBase，HDFS等。</li>
</ul>
<p>Storm Atlas hook自动注册依赖模型，如Hive数据模型，如果它发现这些是不为Atlas服务器所知。</p>
<p>每个类型的数据模型在类定义org.apache.atlas.storm.model.StormDataModel中描述。</p>
<h3 id="Storm-Atlas-Hook"><a href="#Storm-Atlas-Hook" class="headerlink" title="Storm Atlas Hook"></a>Storm Atlas Hook</h3><p>当在 Storm 中成功注册新 topology 时，通知 Atlas。 Storm 在 Storm 客户端提供了一个钩子，backtype.storm.ISubmitterHook，用于提交一个 Storm topology。</p>
<p>Storm Atlas hook 拦截 hook 后执行，并从 topology 中提取元数据，并使用定义的类型更新 Atlas。 Atlas 在org.apache.atlas.storm.hook.StormAtlasHook 中实现了 Storm 客户端 hook 接口。</p>
<h3 id="Limitations-3"><a href="#Limitations-3" class="headerlink" title="Limitations"></a>Limitations</h3><p>以下内容适用于集成的第一个版本。</p>
<ul>
<li>只有新的 topology 提交已注册到 Atlas，任何生命周期变化都不会反映在 Atlas 中。</li>
<li>当为要捕获的元数据提交 Storm topology 时，Atlas 服务器需要在线。</li>
<li>hook 目前不支持捕获自定义 spouts 和 bolts 的 lineage。</li>
</ul>
<h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>Storm Atlas Hook 需要在客户端手动安装在 Storm 在：$ATLAS_PACKAGE/hook/storm</p>
<p>Storm Atlas Hook 需要复制到 $STORM_HOME/extlib。 使用 storm 安装路径替换 STORM_HOME。</p>
<p>在将安装了 atlas hook 到 Storm 后重新启动所有守护进程。</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><h4 id="Storm-Configuration"><a href="#Storm-Configuration" class="headerlink" title="Storm Configuration"></a>Storm Configuration</h4><p>Storm Atlas Hook 需要在 Storm 客户端 $STORM_HOME/conf/storm.yaml 进行配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">storm.topology.submission.notifier.plugin.class: &quot;org.apache.atlas.storm.hook.StormAtlasHook&quot;</span><br></pre></td></tr></table></figure>

<p>还设置一个 “集群名称”，将用作在 Atlas 中注册的对象的命名空间。 此名称将用于命名 Storm topology，spouts 和 bolts。</p>
<p>其他对象（如 Dataset）应该理想地用生成它们的组件的集群名称来标识。 例如， Hive 表和数据库应该使用在 Hive 中设置的集群名称来标识。 如果 Hive 配置在客户端上提交的 Storm topology jar 中可用，并且在那里定义了集群名称，Storm Atlas hook 将选择此选项。 对于 HBase 数据集，这种情况类似。 如果此配置不可用，将使用在 Storm 配置中设置的集群名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atlas.cluster.name: &quot;cluster_name&quot;</span><br></pre></td></tr></table></figure>

<p>在 $STORM_HOME/conf/storm_env.ini 中, 设置以下环境变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STORM_JAR_JVM_OPTS:&quot;-Datlas.conf=$ATLAS_HOME/conf/&quot;</span><br></pre></td></tr></table></figure>

<p>将 ATLAS_HOME 指向 ATLAS 的安装目录.</p>
<p>你也可以通过程序对 Storm 进行如下配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Config stormConf = new Config();</span><br><span class="line">  ...</span><br><span class="line">  stormConf.put(Config.STORM_TOPOLOGY_SUBMISSION_NOTIFIER_PLUGIN,</span><br><span class="line">  org.apache.atlas.storm.hook.StormAtlasHook.class.getName());</span><br></pre></td></tr></table></figure>

<h2 id="容错和高可用"><a href="#容错和高可用" class="headerlink" title="容错和高可用"></a>容错和高可用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Apache Atlas 使用各种系统并与其交互，为数据管理员提供元数据管理和数据 lineage。 通过适当地选择和配置这些依赖关系，可以使用 Atlas 实现高度的服务可用性。 本文档介绍了 Atlas 的高可用性支持状态，包括其功能和当前限制，以及实现此级别高可用性所需的配置。</p>
<h3 id="Atlas-Web-Service"><a href="#Atlas-Web-Service" class="headerlink" title="Atlas Web Service"></a>Atlas Web Service</h3><p>目前，Atlas Web 服务有一个限制，它一次只能有一个活动实例。在早期版本的 Atlas 中，可以配置和保持备份实例。但是，需要手动故障转移才能使此备份实例处于活动状态。</p>
<p>从这个版本开始，Atlas 将支持带有自动故障转移的 主动/被动 配置中的 Atlas Web 服务的多个实例。这意味着用户可以在不同的物理主机上同时部署和启动 Atlas Web 服务的多个实例。其中一个实例将被自动选择为 “活动” 实例来为用户请求提供服务。其他人将自动被视为 “被动”。如果 “活动” 实例由于故意停止或由于意外故障而变得不可用，则其他实例之一将自动选为 “活动” 实例，并开始为用户请求提供服务。</p>
<p>“活动” 实例是能够正确响应用户请求的唯一实例。它可以创建，删除，修改或响应元数据对象上的查询。 “被动” 实例将接受用户请求，但会使用 HTTP 重定向将其重定向到当前已知的 “活动” 实例。具体来说，被动实例本身不会响应对元数据对象的任何查询。但是，所有实例（包括主动和被动）都将响应返回有关该实例的信息的管理请求。</p>
<p>当配置为高可用性模式时，用户可以获得以下操作优势：</p>
<ul>
<li>在维护间隔期间不间断服务：如果需要停用 Atlas Web 服务的活动实例进行维护，则另一个实例将自动变为活动状态并可以为请求提供服务。</li>
<li>在意外故障事件中的不间断服务：如果由于软件或硬件错误，Atlas Web 服务的活动实例失败，另一个实例将自动变为活动状态并可以为请求提供服务。</li>
</ul>
<p>在以下小节中，我们将介绍为 Atlas Web 服务设置高可用性所需的步骤。 我们还描述了如何设计部署和客户端以利用此功能。 最后，我们描述一些底层实现的细节。</p>
<h4 id="Setting-up-the-High-Availability-feature-in-Atlas"><a href="#Setting-up-the-High-Availability-feature-in-Atlas" class="headerlink" title="Setting up the High Availability feature in Atlas"></a>Setting up the High Availability feature in Atlas</h4><p>设置高可用性功能必须满足以下先决条件。</p>
<ul>
<li>确保在一组计算机上安装 Apache Zookeeper（建议至少使用3台服务器进行生产）。</li>
<li>选择 2 个或更多物理机以在其上运行 Atlas Web Service 实例。这些机器定义了我们称为 Atlas 的 “服务器集合”。</li>
</ul>
<p>要在 Atlas 中设置高可用性，必须在 atlas-application.properties 文件中定义一些配置选项。虽然配置项的完整列表在配置页中定义，但本节列出了几个主要选项。</p>
<ul>
<li><p>高可用性是 Atlas 的可选功能。因此，必须通过将配置选项 atlas.server.ha.enabled 设置为 true 来启用。</p>
</li>
<li><p>接下来，定义标识符列表，为您为 Atlas Web Service 实例选择的每个物理机器分配一个标识符。这些标识符可以是简单的字符串，如id1，id2等。它们应该是唯一的，不应包含逗号。</p>
</li>
<li><p>将这些标识符的逗号分隔列表定义为选项 atlas.server.ids 的值。</p>
</li>
<li><p>对于每个物理机，请列出IP地址/主机名和端口作为配置 atlas.server.address.id 的值，其中 id 指的是此物理机的标识符字符串。</p>
<ul>
<li><p>例如，如果您选择了 2 台主机名为 和 的计算机，则可以如下定义配置选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atlas.server.ids=id1,id2</span><br><span class="line">atlas.server.address.id1=host1.company.com:21000</span><br><span class="line">atlas.server.address.id2=host2.company.com:21000</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>定义使用的 Zookeeper 为 Atlas 提供高可用性功能</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atlas.server.ha.zookeeper.connect=zk1.company.com:2181,zk2.company.com:2181,zk3.company.com:2181</span><br></pre></td></tr></table></figure>

<ul>
<li>您可以查看为高可用性功能定义的其他配置选项，并根据需要在 atlas-application.properties 文件中进行设置。</li>
<li>对于生产环境，Atlas 所依赖的组件也必须在高可用性模式下设置。 这将在以下部分中详细描述。 按照这些说明设置和配置它们。</li>
<li>在选定的物理机器上安装 Atlas 软件。</li>
<li>将使用上述步骤创建的 atlas-application.properties 文件复制到所有计算机的配置目录。</li>
<li>启动相关组件。</li>
<li>启动 Atlas Web 服务的每个实例。</li>
</ul>
<p>要验证高可用性是否正常工作，请在安装了 Atlas Web Service 的每个实例上运行以下脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ATLAS_HOME/bin/atlas_admin.py -status</span><br></pre></td></tr></table></figure>

<p>此脚本可以打印以下值之一作为响应：</p>
<ul>
<li>ACTIVE：此实例处于活动状态，可以响应用户请求。</li>
<li>PASSIVE：此实例为 PASSIVE。它会将它收到的任何用户请求重定向到当前活动实例。</li>
<li>BECOMING_ACTIVE：如果服务器正在转换为 ACTIVE 实例，则将打印此消息。在此状态下，服务器无法处理任何元数据用户请求。</li>
<li>BECOMING_PASSIVE：如果服务器正在转换为 PASSIVE 实例，则将打印此消息。在此状态下，服务器无法处理任何元数据用户请求。</li>
</ul>
<p>在正常操作情况下，只有其中一个实例应该打印 ACTIVE 值作为对脚本的响应，而其他实例将打印 PASSIVE。</p>
<h4 id="配置客户端以使用高可用性功能"><a href="#配置客户端以使用高可用性功能" class="headerlink" title="配置客户端以使用高可用性功能"></a>配置客户端以使用高可用性功能</h4><p>Atlas Web 服务可以通过两种方式访问：</p>
<ul>
<li>使用 Atlas Web UI：这是一个基于浏览器的客户端，可用于查询存储在Atlas中的元数据。</li>
<li>使用 Atlas REST API：由于 Atlas 公开了一个 RESTful API，因此可以使用任何标准的 REST 客户端，包括其他应用程序中的库。事实上，Atlas 附带了一个名为 AtlasClient 的客户端，可以用作创建 REST 客户端访问的示例。</li>
</ul>
<p>为了利用客户端中的高可用性功能，可以有两个选项。</p>
<h4 id="使用中间代理"><a href="#使用中间代理" class="headerlink" title="使用中间代理"></a>使用中间代理</h4><p>启用高可用性访问 Atlas 的最简单的解决方案是安装和配置一些中间代理，其具有基于状态透明地切换服务的能力。一个这样的代理解决方案是 HAProxy。</p>
<p>下面是一个可以使用的 HAProxy 配置示例。注意，这只是为了说明，而不是作为推荐的生产配置。为此，请参阅 HAProxy文档以获取相应的说明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frontend atlas_fe</span><br><span class="line">  bind *:41000</span><br><span class="line">  default_backend atlas_be</span><br><span class="line"></span><br><span class="line">backend atlas_be</span><br><span class="line">  mode http</span><br><span class="line">  option httpchk get /api/atlas/admin/status</span><br><span class="line">  http-check expect string ACTIVE</span><br><span class="line">  balance roundrobin</span><br><span class="line">  server host1_21000 host1:21000 check</span><br><span class="line">  server host2_21000 host2:21000 check backup</span><br><span class="line"></span><br><span class="line">listen atlas</span><br><span class="line">  bind localhost:42000</span><br></pre></td></tr></table></figure>

<p>以上配置绑定 HAProxy 侦听端口 41000 传入客户端连接。然后根据 HTTP 状态检查将连接路由到主机 host1 或 host2 中的任一个。状态检查是使用 REST URL / api / atlas / admin / status 上的 HTTP GET 完成的，只有当 HTTP 响应包含字符串ACTIVE 时，才认为成功。</p>
<h4 id="使用活动实例的自动检测"><a href="#使用活动实例的自动检测" class="headerlink" title="使用活动实例的自动检测"></a>使用活动实例的自动检测</h4><p>如果不想设置和管理单独的代理，则使用高可用性功能的另一个选项是构建能够检测状态和重试操作的客户端应用程序。在这样的设置中，可以使用形成集合的所有 Atlas Web 服务实例的 URL 启动客户端应用程序。然后，客户端应调用其中每一个上的 REST URL / api / atlas / admin / status，以确定哪个是活动实例。来自 Active 实例的响应将具有 {Status：ACTIVE}的形式。此外，当客户端在操作过程中遇到任何异常时，它应该再次确定哪些剩余的URL是活动的并重试该操作。</p>
<p>Atlas 附带的 AtlasClient 类可以用作一个示例客户端库，它实现了使用集合并选择正确的Active服务器实例的逻辑。</p>
<p>Atlas 中的实用程序（如quick_start.py和import-hive.sh）可以配置为使用多个服务器URL运行。当在此模式下启动时，AtlasClient 自动选择并使用当前活动实例。如果在之间设置了代理，则可以在运行 quick_start.py 或 import-hive.sh 时使用其地址。</p>
<h4 id="实现-Atlas-高可用"><a href="#实现-Atlas-高可用" class="headerlink" title="实现 Atlas 高可用"></a>实现 Atlas 高可用</h4><p>Atlas 高可用性工作在主 JIRA <a href="https://issues.apache.org/jira/browse/ATLAS-510">ATLAS-510</a> 下进行跟踪。根据其提交的 JIRA 具有关于高可用性功能如何实现的详细信息。在高级别可以调出以下几点：</p>
<ul>
<li>活动实例的自动选择以及到新的活动实例的自动故障转移通过领导者选择算法发生。</li>
<li>对于领导选举，我们使用 Apache Curator 的 Leader Latch Recipe。</li>
<li>Active 实例是唯一一个在后端存储中初始化，修改或读取状态以保持它们一致的实例。</li>
<li>此外，当实例被选为活动时，它会刷新后端存储中的任何缓存信息以获取最新信息。</li>
<li>servlet 过滤器确保只有活动的实例服务用户请求。如果被动实例接收到这些请求，它会自动将它们重定向到当前活动实例。</li>
</ul>
<h4 id="Metadata-Store"><a href="#Metadata-Store" class="headerlink" title="Metadata Store"></a>Metadata Store</h4><p>如上所述，Atlas 使用 Titan 来存储它管理的元数据。默认情况下，Atlas 使用独立的 HBase 实例作为 Titan 的后备存储。为了为元数据存储提供 HA，我们建议将 Atlas 配置为使用分布式 HBase 作为 Titan 的后备存储。这意味着您可以从 HBase 提供的 HA 保证中受益。为了将 Atlas 配置为在 HA 模式下使用 HBase，请执行以下操作：</p>
<ul>
<li>选择在HA模式中设置的现有 HBase 集群以在 Atlas（OR）中配置在 <a href="http://hbase.apache.org/book.html#quickstart_fully_distributed">HA模式</a> 下设置新的 HBase 集群。<ul>
<li>如果为 Atlas 设置 HBase，请按照 <a href="http://atlas.apache.org/InstallationSteps.html">Installation Steps</a> 中列出的用于设置 HBase 的说明进行操作。</li>
</ul>
</li>
<li>我们建议在使用 Zookeeper 协调的不同物理主机上的集群中使用多个 HBase 主机（至少2个），以提供 HBase的 冗余和高可用性。<ul>
<li>有关在 atlas.properties 中配置的选项的 <a href="http://atlas.apache.org/Configuration.html">Configuration page</a> ，请参考配置页面，以便使用 HBase 设置 Atlas。</li>
</ul>
</li>
</ul>
<h3 id="Index-Store"><a href="#Index-Store" class="headerlink" title="Index Store"></a>Index Store</h3><p>如上所述，Atlas 通过 Titan 索引元数据以支持全文搜索查询。 为了为索引存储提供 HA，我们建议将 Atlas 配置为使用 Solr作为 Titan 的后备索引存储。 为了将 Atlas 配置为在 HA 模式下使用 Solr，请执行以下操作：</p>
<ul>
<li>在 HA 模式下选择现有的 SolrCloud 群集设置以在 Atlas（OR）中配置设置新的 SolrCloud 群集。<ul>
<li>确保 Solr 在至少 2 个物理主机上启动以实现冗余，并且每个主机运行 Solr 节点。</li>
<li>我们建议将冗余数设置为至少 2。</li>
</ul>
</li>
<li>创建 Atlas 所需的 SolrCloud 集合，如安装步骤中所述</li>
<li>请参阅配置页面以了解在 atlas.properties 中配置的选项，以使用 Solr 设置 Atlas。</li>
</ul>
<h3 id="Notification-Server"><a href="#Notification-Server" class="headerlink" title="Notification Server"></a>Notification Server</h3><p>来自 Hook 的元数据通知事件通过写入到名为 ATLAS_HOOK 的 Kafka topic 发送到 Atlas 。类似地，从 Atlas 到其他集成组件（如Ranger）的事件写入名为 ATLAS_ENTITIES 的 Kafka topic。由于 Kafka 会保留这些消息，即使消费者在发送事件时失败，事件也不会丢失。此外，我们建议 Kafka 也设置容错，以便它具有更高的可用性保证。为了配置 Atlas 在 HA 模式下使用 Kafka，请执行以下操作：</p>
<ul>
<li><p>选择在 HA 模式中设置的现有 Kafka 集群以在 Atlas（OR）中配置设置新的 Kafka 集群。</p>
</li>
<li><p>我们建议在不同物理主机上的群集中有多个 Kafka 代理，它们使用 Zookeeper 协调，以提供 Kafka 的冗余和高可用性。</p>
<ul>
<li>设置至少 2 个物理主机以实现冗余，每个托管一个 Kafka 代理。</li>
</ul>
</li>
<li><p>为 Atlas 使用设置 Kafka 主题：</p>
<ul>
<li>ATLAS 主题的分区数应设置为1（numPartitions）</li>
<li>确定 Kafka 主题的副本数量：将此值设置为至少 2 以进行冗余。</li>
<li>运行以下命令：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper &lt;list of zookeeper host:port entries&gt; --topic ATLAS_HOOK --replication-factor &lt;numReplicas&gt; --partitions 1</span><br><span class="line">$KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper &lt;list of zookeeper host:port entries&gt; --topic ATLAS_ENTITIES --replication-factor &lt;numReplicas&gt; --partitions 1</span><br><span class="line">Here KAFKA_HOME points to the Kafka installation directory.</span><br></pre></td></tr></table></figure>

<ul>
<li>在 atlas-application.properties 中进行如下配置:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atlas.notification.embedded=false</span><br><span class="line">atlas.kafka.zookeeper.connect=&lt;comma separated list of servers forming Zookeeper quorum used by Kafka&gt;</span><br><span class="line">atlas.kafka.bootstrap.servers=&lt;comma separated list of Kafka broker endpoints in host:port form&gt; - Give at least 2 for redundancy.</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Known-Issues"><a href="#Known-Issues" class="headerlink" title="Known Issues"></a>Known Issues</h3><ul>
<li>如果托管 Atlas ‘titan’ HTable 的 HBase region servers 停机，Atlas 将无法在 HBase 恢复联机之前从 HBase 存储或检索元数据。</li>
</ul>
]]></content>
      <categories>
        <category>hadoop</category>
      </categories>
      <tags>
        <tag>hadoop 转载</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy基础入门</title>
    <url>/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="NumPy-简单入门教程"><a href="#NumPy-简单入门教程" class="headerlink" title="NumPy 简单入门教程"></a>NumPy 简单入门教程</h1><p>NumPy是Python中的一个运算速度非常快的一个数学库，它非常重视数组。它允许你在Python中进行向量和矩阵计算，并且由于许多底层函数实际上是用C编写的，因此你可以体验在原生Python中永远无法体验到的速度。</p>
<p>NumPy绝对是科学Python成功的关键之一，如果你想要进入Python中的数据科学/机器学习，你就要必须学习它。在我看来，NumPy的API设计得很好，所以我们要开始使用它并不困难。</p>
<h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h3><p>NumPy围绕这些称为数组的事物展开。实际上它被称之为 <code>ndarrays</code>，你不知道没事儿。使用NumPy提供的这些数组，我们就可以以闪电般的速度执行各种有用的操作，如矢量和矩阵、线性代数等数学运算！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1D Array</span></span><br><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = np.array((<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">c = np.arange(<span class="number">5</span>)</span><br><span class="line">d = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># &gt;&gt;&gt;[ 0.          1.57079633  3.14159265  4.71238898  6.28318531]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>]) <span class="comment"># &gt;&gt;&gt;3</span></span><br></pre></td></tr></table></figure>

<p>上面的代码显示了创建数组的4种不同方法。最基本的方法是将序列传递给NumPy的array()函数; 你可以传递任何序列（类数组），而不仅仅是常见的列表（list）数据类型。</p>
<p>请注意，当我们打印具有不同长度数字的数组时，它会自动将它们填充出来。这对于查看矩阵很有用。对数组进行索引就像列表或任何其他Python序列一样。 你也可以对它们进行切片，我不打算在这里切片一维数组。</p>
<p>上面的数组示例是如何使用NumPy表示向量的，接下来我们将看看如何使用多维数组表示矩阵和更多的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MD Array,</span></span><br><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">4</span>]) <span class="comment"># &gt;&gt;&gt;25</span></span><br></pre></td></tr></table></figure>

<p>为了创建一个2D（二维）数组，我们传递一个列表的列表（或者是一个序列的序列）给array()函数。如果我们想要一个3D（三维）数组，我们就要传递一个列表的列表的列表，如果是一个4D（四维）数组，那就是列表的列表的列表的列表，以此类推。</p>
<p>请注意2D（二维）数组（在我们的朋友空格键的帮助下）是如何按行和列排列的。要索引2D（二维）数组，我们只需引用行数和列数即可。</p>
<h3 id="它背后的一些数学知识"><a href="#它背后的一些数学知识" class="headerlink" title="它背后的一些数学知识"></a>它背后的一些数学知识</h3><p>要正确理解这一点，我们应该真正了解一下矢量和矩阵是什么。</p>
<p>矢量是具有方向和幅度的量。它们通常用于表示速度，加速度和动量等事物。向量可以用多种方式编写，尽管对我们最有用的是它们被写为n元组的形式，如（1,4,6,9）。这就是我们在NumPy中表示他们的方式。</p>
<p>矩阵类似于矢量，除了它由行和列组成; 很像一个网格。可以通过给出它所在的行和列来引用矩阵中的值。在NumPy中，我们通过传递一系列序列来制作数组，就像我们之前所做的那样。</p>
<p><img src="/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/numpy_maths1-1.jpg" alt="简单线性代数图示"></p>
<h3 id="多维数组切片"><a href="#多维数组切片" class="headerlink" title="多维数组切片"></a>多维数组切片</h3><p>切片多维数组比1D数组复杂一点，并且在使用NumPy时你也会经常需要使用到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>:<span class="number">4</span>]) <span class="comment"># &gt;&gt;&gt;[12 13 14]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">4</span>, <span class="number">0</span>]) <span class="comment"># &gt;&gt;&gt;[16 21 26]</span></span><br><span class="line"><span class="built_in">print</span>(a[::<span class="number">2</span>,::<span class="number">2</span>]) <span class="comment"># &gt;&gt;&gt;[[11 13 15]</span></span><br><span class="line">                  <span class="comment">#     [21 23 25]</span></span><br><span class="line">                  <span class="comment">#     [31 33 35]]</span></span><br><span class="line"><span class="built_in">print</span>(a[:, <span class="number">1</span>]) <span class="comment"># &gt;&gt;&gt;[12 17 22 27 32]</span></span><br></pre></td></tr></table></figure>

<p>如你所见，通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于2D数组，我们的第一片定义了行的切片，第二片定义了列的切片。</p>
<p>注意，只需输入数字就可以指定行或列。上面的第一个示例从数组中选择第0列。</p>
<p>下面的图表说明了给定的示例切片是如何进行工作的。</p>
<p><img src="/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/numpy_2D_slicing_diagram-1.jpg" alt="numpy数组切片工作原理"></p>
<h3 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h3><p>在使用 NumPy 时，你会想知道数组的某些信息。很幸运，在这个包里边包含了很多便捷的方法，可以给你想要的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &gt;&gt;&gt;&lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a.dtype) <span class="comment"># &gt;&gt;&gt;int64</span></span><br><span class="line"><span class="built_in">print</span>(a.size) <span class="comment"># &gt;&gt;&gt;25</span></span><br><span class="line"><span class="built_in">print</span>(a.shape) <span class="comment"># &gt;&gt;&gt;(5, 5)</span></span><br><span class="line"><span class="built_in">print</span>(a.itemsize) <span class="comment"># &gt;&gt;&gt;8</span></span><br><span class="line"><span class="built_in">print</span>(a.ndim) <span class="comment"># &gt;&gt;&gt;2</span></span><br><span class="line"><span class="built_in">print</span>(a.nbytes) <span class="comment"># &gt;&gt;&gt;200</span></span><br></pre></td></tr></table></figure>

<p>正如你在上面的代码中看到的，NumPy数组实际上被称为ndarray。我不知道为什么他妈的它叫ndarray，如果有人知道请留言！我猜它代表n维数组。</p>
<p>数组的形状是它有多少行和列，上面的数组有5行和5列，所以它的形状是(5，5)。</p>
<p><code>itemsize</code>属性是每个项占用的字节数。这个数组的数据类型是int 64，一个int 64中有64位，一个字节中有8位，除以64除以8，你就可以得到它占用了多少字节，在本例中是8。</p>
<p><code>ndim</code> 属性是数组的维数。这个有2个。例如，向量只有1。</p>
<p><code>nbytes</code> 属性是数组中的所有数据消耗掉的字节数。你应该注意到，这并不计算数组的开销，因此数组占用的实际空间将稍微大一点。</p>
<h2 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h2><h3 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h3><p>只是能够从数组中创建和检索元素和属性不能满足你的需求，你有时也需要对它们进行数学运算。 你完全可以使用四则运算符 +、- 、/ 来完成运算操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Basic Operators</span></span><br><span class="line">a = np.arange(<span class="number">25</span>)</span><br><span class="line">a = a.reshape((<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">b = np.array([<span class="number">10</span>, <span class="number">62</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">56</span>, <span class="number">79</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">45</span>,</span><br><span class="line">              <span class="number">4</span>, <span class="number">92</span>, <span class="number">5</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">6</span>, <span class="number">53</span>, <span class="number">24</span>,</span><br><span class="line">              <span class="number">56</span>, <span class="number">3</span>, <span class="number">56</span>, <span class="number">44</span>, <span class="number">78</span>])</span><br><span class="line">b = b.reshape((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="built_in">print</span>(a - b)</span><br><span class="line"><span class="built_in">print</span>(a * b)</span><br><span class="line"><span class="built_in">print</span>(a / b)</span><br><span class="line"><span class="built_in">print</span>(a ** <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a &lt; b) <span class="built_in">print</span>(a &gt; b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.dot(b))</span><br></pre></td></tr></table></figure>

<p>除了 dot() 之外，这些操作符都是对数组进行逐元素运算。比如 (a, b, c) + (d, e, f) 的结果就是 (a+d, b+e, c+f)。它将分别对每一个元素进行配对，然后对它们进行运算。它返回的结果是一个数组。注意，当使用逻辑运算符比如 “&lt;” 和 “&gt;” 的时候，返回的将是一个布尔型数组，这点有一个很好的用处，后边我们会提到。</p>
<p>dot() 函数计算两个数组的点积。它返回的是一个标量（只有大小没有方向的一个值）而不是数组。</p>
<h3 id="它背后的一些数学知识-1"><a href="#它背后的一些数学知识-1" class="headerlink" title="它背后的一些数学知识"></a>它背后的一些数学知识</h3><p>dot()函数称为点积。理解这一点的最好方法是看下图，下图将表示它是如何进行计算的。</p>
<p><img src="/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/numpy_maths2-1.jpg" alt="点积运算原理"></p>
<h3 id="数组特殊运算符"><a href="#数组特殊运算符" class="headerlink" title="数组特殊运算符"></a>数组特殊运算符</h3><p>NumPy还提供了一些别的用于处理数组的好用的运算符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>()) <span class="comment"># &gt;&gt;&gt;45</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>()) <span class="comment"># &gt;&gt;&gt;0</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>()) <span class="comment"># &gt;&gt;&gt;9</span></span><br><span class="line"><span class="built_in">print</span>(a.cumsum()) <span class="comment"># &gt;&gt;&gt;[ 0  1  3  6 10 15 21 28 36 45]</span></span><br></pre></td></tr></table></figure>

<p>sum()、min()和max()函数的作用非常明显。将所有元素相加，找出最小和最大元素。</p>
<p>然而，cumsum()函数就不那么明显了。它将像sum()这样的每个元素相加，但是它首先将第一个元素和第二个元素相加，并将计算结果存储在一个列表中，然后将该结果添加到第三个元素中，然后再将该结果存储在一个列表中。这将对数组中的所有元素执行此操作，并返回作为列表的数组之和的运行总数。</p>
<h2 id="索引进阶"><a href="#索引进阶" class="headerlink" title="索引进阶"></a>索引进阶</h2><h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><p><code>花式索引</code> 是获取数组中我们想要的特定元素的有效方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fancy indexing</span></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">indices = [<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>]</span><br><span class="line">b = a[indices]</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &gt;&gt;&gt;[ 0 10 20 30 40 50 60 70 80 90]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;[10 50 90]</span></span><br></pre></td></tr></table></figure>

<p>正如你在上面的示例中所看到的，我们使用我们想要检索的特定索引序列对数组进行索引。这反过来返回我们索引的元素的列表。</p>
<h3 id="布尔屏蔽"><a href="#布尔屏蔽" class="headerlink" title="布尔屏蔽"></a>布尔屏蔽</h3><p>布尔屏蔽是一个有用的功能，它允许我们根据我们指定的条件检索数组中的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Boolean masking</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">b = np.sin(a)</span><br><span class="line">plt.plot(a,b)</span><br><span class="line">mask = b &gt;= <span class="number">0</span></span><br><span class="line">plt.plot(a[mask], b[mask], <span class="string">&#x27;bo&#x27;</span>)</span><br><span class="line">mask = (b &gt;= <span class="number">0</span>) &amp; (a &lt;= np.pi / <span class="number">2</span>)</span><br><span class="line">plt.plot(a[mask], b[mask], <span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>上面的示例显示了如何进行布尔屏蔽。你所要做的就是将数组传递给涉及数组的条件，它将为你提供一个值的数组，为该条件返回true。</p>
<p>该示例生成以下图：</p>
<p><img src="/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/numpy_masking-1.png" alt="布尔掩码结果图"></p>
<p>我们利用这些条件来选择图上的不同点。蓝色点(在图中还包括绿点，但绿点掩盖了蓝色点)，显示值大于0的所有点。绿色点表示值大于0且小于一半π的所有点。</p>
<h3 id="缺省索引"><a href="#缺省索引" class="headerlink" title="缺省索引"></a>缺省索引</h3><p>不完全索引是从多维数组的第一个维度获取索引或切片的一种方便方法。例如，如果数组a=[1，2，3，4，5]，[6，7，8，9，10]，那么[3]将在数组的第一个维度中给出索引为3的元素，这里是值4。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Incomplete Indexing</span></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">b = a[:<span class="number">5</span>]</span><br><span class="line">c = a[a &gt;= <span class="number">50</span>]</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;[ 0 10 20 30 40]</span></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># &gt;&gt;&gt;[50 60 70 80 90]</span></span><br></pre></td></tr></table></figure>

<h3 id="Where-函数"><a href="#Where-函数" class="headerlink" title="Where 函数"></a>Where 函数</h3><p>where() 函数是另外一个根据条件返回数组中的值的有效方法。只需要把条件传递给它，它就会返回一个使得条件为真的元素的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Where</span></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">b = np.where(a &lt; <span class="number">50</span>) </span><br><span class="line">c = np.where(a &gt;= <span class="number">50</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;(array([0, 1, 2, 3, 4]),)</span></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># &gt;&gt;&gt;[5 6 7 8 9]</span></span><br></pre></td></tr></table></figure>

<p>这就是NumPy，没那么难吧？当然，这篇文章只涵盖了入门的基础知识，在NumPy中你还可以做许多其他好玩的事情，当你已经熟悉了NumPy的基础知识，你就可以开始自由的探索NumPy的世界了。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy教程</title>
    <url>/2021/09/18/numpy%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Python、Numpy-教程"><a href="#Python、Numpy-教程" class="headerlink" title="Python、Numpy 教程"></a>Python、Numpy 教程</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python是一种高级动态类型的多范式编程语言。Python代码通常被称为可运行的伪代码，因为它允许你在非常少的代码行中表达非常强大的想法，同时具有非常可读性。作为示例，这里是Python中经典快速排序算法的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(quicksort([<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># Prints &quot;[1, 1, 2, 3, 6, 8, 10]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Python-的版本"><a href="#Python-的版本" class="headerlink" title="Python 的版本"></a>Python 的版本</h3><p>目前有两种不同的受支持版本的Python，分别是2.7和3.9。有点令人困惑的是，Python 3.0引入了许多向后兼容的语言更改，因此为2.7编写的代码可能无法在3.9下运行，反之亦然。所以我们下面所有的示例的代码都使用Python 3.9来编程。</p>
<p>你可以通过运行 <code>python -version</code> 在命令行中查看Python的版本。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>与大多数语言一样，Python有许多基本类型，包括整数，浮点数，布尔值和字符串。这些数据类型的行为方式与其他编程语言相似。</p>
<p>**Numbers(数字类型)**：代表的是整数和浮点数，它原理与其他语言相同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x)) <span class="comment"># Prints &quot;&lt;class &#x27;int&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x)       <span class="comment"># Prints &quot;3&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">1</span>)   <span class="comment"># Addition; prints &quot;4&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x - <span class="number">1</span>)   <span class="comment"># Subtraction; prints &quot;2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x * <span class="number">2</span>)   <span class="comment"># Multiplication; prints &quot;6&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x ** <span class="number">2</span>)  <span class="comment"># Exponentiation; prints &quot;9&quot;</span></span><br><span class="line">x += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># Prints &quot;4&quot;</span></span><br><span class="line">x *= <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># Prints &quot;8&quot;</span></span><br><span class="line">y = <span class="number">2.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(y)) <span class="comment"># Prints &quot;&lt;class &#x27;float&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(y, y + <span class="number">1</span>, y * <span class="number">2</span>, y ** <span class="number">2</span>) <span class="comment"># Prints &quot;2.5 3.5 5.0 6.25&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，与许多语言不同，Python没有一元增量(<code>x+</code>)或递减(<code>x-</code>)运算符。</p>
<p>Python还有用于复数的内置类型；你可以在<a href="https://docs.python.org/3.9/library/stdtypes.html#numeric-types-int-float-complex">这篇文档（python官网doc）</a>中找到所有的详细信息。</p>
<p><strong>Booleans(布尔类型)</strong>: Python实现了所有常用的布尔逻辑运算符，但它使用的是英文单词而不是符号 (<code>&amp;&amp;</code>, <code>||</code>, etc.)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="literal">True</span></span><br><span class="line">f = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t)) <span class="comment"># Prints &quot;&lt;class &#x27;bool&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">and</span> f) <span class="comment"># Logical AND; prints &quot;False&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">or</span> f)  <span class="comment"># Logical OR; prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> t)   <span class="comment"># Logical NOT; prints &quot;False&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t != f)  <span class="comment"># Logical XOR; prints &quot;True&quot;</span></span><br></pre></td></tr></table></figure>

<p>**Strings(字符串类型)**：Python对字符串有很好的支持：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hello = <span class="string">&#x27;hello&#x27;</span>    <span class="comment"># String literals can use single quotes</span></span><br><span class="line">world = <span class="string">&quot;world&quot;</span>    <span class="comment"># or double quotes; it does not matter.</span></span><br><span class="line"><span class="built_in">print</span>(hello)       <span class="comment"># Prints &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(hello))  <span class="comment"># String length; prints &quot;5&quot;</span></span><br><span class="line">hw = hello + <span class="string">&#x27; &#x27;</span> + world  <span class="comment"># String concatenation</span></span><br><span class="line"><span class="built_in">print</span>(hw)  <span class="comment"># prints &quot;hello world&quot;</span></span><br><span class="line">hw12 = <span class="string">&#x27;%s %s %d&#x27;</span> % (hello, world, <span class="number">12</span>)  <span class="comment"># sprintf style string formatting</span></span><br><span class="line"><span class="built_in">print</span>(hw12)  <span class="comment"># prints &quot;hello world 12&quot;</span></span><br></pre></td></tr></table></figure>

<p>String对象有许多有用的方法；例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.capitalize())  <span class="comment"># Capitalize a string; prints &quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.upper())       <span class="comment"># Convert a string to uppercase; prints &quot;HELLO&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rjust(<span class="number">7</span>))      <span class="comment"># Right-justify a string, padding with spaces; prints &quot;  hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">7</span>))     <span class="comment"># Center a string, padding with spaces; prints &quot; hello &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;(ell)&#x27;</span>))  <span class="comment"># Replace all instances of one substring with another;</span></span><br><span class="line">                                <span class="comment"># prints &quot;he(ell)(ell)o&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;  world &#x27;</span>.strip())  <span class="comment"># Strip leading and trailing whitespace; prints &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>你可以在<a href="https://docs.python.org/3.9/library/stdtypes.html#string-methods">这篇文档（python官网doc）</a>中找到所有String方法的列表。</p>
<h3 id="容器-Containers"><a href="#容器-Containers" class="headerlink" title="容器(Containers)"></a>容器(Containers)</h3><p>Python包含几种内置的容器类型：列表、字典、集合和元组。</p>
<h4 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表(Lists)"></a>列表(Lists)</h4><p>列表其实就是Python中的数组，但是可以它可以动态的调整大小并且可以包含不同类型的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xs = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]    <span class="comment"># Create a list</span></span><br><span class="line"><span class="built_in">print</span>(xs, xs[<span class="number">2</span>])  <span class="comment"># Prints &quot;[3, 1, 2] 2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(xs[-<span class="number">1</span>])     <span class="comment"># Negative indices count from the end of the list; prints &quot;2&quot;</span></span><br><span class="line">xs[<span class="number">2</span>] = <span class="string">&#x27;foo&#x27;</span>     <span class="comment"># Lists can contain elements of different types</span></span><br><span class="line"><span class="built_in">print</span>(xs)         <span class="comment"># Prints &quot;[3, 1, &#x27;foo&#x27;]&quot;</span></span><br><span class="line">xs.append(<span class="string">&#x27;bar&#x27;</span>)  <span class="comment"># Add a new element to the end of the list</span></span><br><span class="line"><span class="built_in">print</span>(xs)         <span class="comment"># Prints &quot;[3, 1, &#x27;foo&#x27;, &#x27;bar&#x27;]&quot;</span></span><br><span class="line">x = xs.pop()      <span class="comment"># Remove and return the last element of the list</span></span><br><span class="line"><span class="built_in">print</span>(x, xs)      <span class="comment"># Prints &quot;bar [3, 1, &#x27;foo&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>

<p>像往常一样，你可以在<a href="https://docs.python.org/3.9/tutorial/datastructures.html#more-on-lists">这篇文档</a>中找到有关列表的所有详细信息。</p>
<p><strong>切片(Slicing)</strong>: 除了一次访问一个列表元素之外，Python还提供了访问子列表的简明语法; 这被称为切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))     <span class="comment"># range is a built-in function that creates a list of integers</span></span><br><span class="line"><span class="built_in">print</span>(nums)               <span class="comment"># Prints &quot;[0, 1, 2, 3, 4]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:<span class="number">4</span>])          <span class="comment"># Get a slice from index 2 to 4 (exclusive); prints &quot;[2, 3]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:])           <span class="comment"># Get a slice from index 2 to the end; prints &quot;[2, 3, 4]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[:<span class="number">2</span>])           <span class="comment"># Get a slice from the start to index 2 (exclusive); prints &quot;[0, 1]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[:])            <span class="comment"># Get a slice of the whole list; prints &quot;[0, 1, 2, 3, 4]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[:-<span class="number">1</span>])          <span class="comment"># Slice indices can be negative; prints &quot;[0, 1, 2, 3]&quot;</span></span><br><span class="line">nums[<span class="number">2</span>:<span class="number">4</span>] = [<span class="number">8</span>, <span class="number">9</span>]        <span class="comment"># Assign a new sublist to a slice</span></span><br><span class="line"><span class="built_in">print</span>(nums)               <span class="comment"># Prints &quot;[0, 1, 8, 9, 4]&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们将在numpy数组的上下文中再次看到切片。</p>
<p><strong>(循环)Loops</strong>: 你可以循环遍历列表的元素，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    <span class="built_in">print</span>(animal)</span><br><span class="line"><span class="comment"># Prints &quot;cat&quot;, &quot;dog&quot;, &quot;monkey&quot;, each on its own line.</span></span><br></pre></td></tr></table></figure>

<p>如果要访问循环体内每个元素的索引，请使用内置的 <code>enumerate</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line</span></span><br></pre></td></tr></table></figure>

<p><strong>列表推导式(List comprehensions)</strong>: 编程时，我们经常想要将一种数据转换为另一种数据。 举个简单的例子，思考以下计算平方数的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">    squares.append(x ** <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(squares)   <span class="comment"># Prints [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<p>你可以使用 <strong>列表推导式</strong> 使这段代码更简单:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums]</span><br><span class="line"><span class="built_in">print</span>(squares)   <span class="comment"># Prints [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<p>列表推导还可以包含条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">even_squares = [x ** 2 for x in nums if x % 2 == 0]</span><br><span class="line">print(even_squares)  # Prints &quot;[0, 4, 16]&quot;</span><br></pre></td></tr></table></figure>

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典存储（键，值）对，类似于Java中的<code>Map</code>或Javascript中的对象。你可以像这样使用它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;cat&#x27;</span>: <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>: <span class="string">&#x27;furry&#x27;</span>&#125;  <span class="comment"># Create a new dictionary with some data</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;cat&#x27;</span>])       <span class="comment"># Get an entry from a dictionary; prints &quot;cute&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> d)     <span class="comment"># Check if a dictionary has a given key; prints &quot;True&quot;</span></span><br><span class="line">d[<span class="string">&#x27;fish&#x27;</span>] = <span class="string">&#x27;wet&#x27;</span>     <span class="comment"># Set an entry in a dictionary</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;fish&#x27;</span>])      <span class="comment"># Prints &quot;wet&quot;</span></span><br><span class="line"><span class="comment"># print(d[&#x27;monkey&#x27;])  # KeyError: &#x27;monkey&#x27; not a key of d</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;monkey&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># Get an element with a default; prints &quot;N/A&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;fish&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))    <span class="comment"># Get an element with a default; prints &quot;wet&quot;</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;fish&#x27;</span>]         <span class="comment"># Remove an element from a dictionary</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;fish&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>)) <span class="comment"># &quot;fish&quot; is no longer a key; prints &quot;N/A&quot;</span></span><br></pre></td></tr></table></figure>

<p>你可以在<a href="https://docs.python.org/3.9/library/stdtypes.html#dict">这篇文档</a>中找到有关字典的所有信息。</p>
<p><strong>(循环)Loops</strong>: 迭代词典中的键很容易：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;person&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spider&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> d:</span><br><span class="line">    legs = d[animal]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A %s has %d legs&#x27;</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果要访问键及其对应的值，请使用<code>items</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;person&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spider&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal, legs <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A %s has %d legs&#x27;</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>字典推导式(Dictionary comprehensions)</strong>: 类似于列表推导式，可以让你轻松构建词典数据类型。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">even_num_to_square = &#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(even_num_to_square)  <span class="comment"># Prints &quot;&#123;0: 0, 2: 4, 4: 16&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h4><p>集合是不同元素的无序集合。举个简单的例子，请思考下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = &#123;<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> animals)   <span class="comment"># Check if an element is in a set; prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fish&#x27;</span> <span class="keyword">in</span> animals)  <span class="comment"># prints &quot;False&quot;</span></span><br><span class="line">animals.add(<span class="string">&#x27;fish&#x27;</span>)       <span class="comment"># Add an element to a set</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fish&#x27;</span> <span class="keyword">in</span> animals)  <span class="comment"># Prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(animals))       <span class="comment"># Number of elements in a set; prints &quot;3&quot;</span></span><br><span class="line">animals.add(<span class="string">&#x27;cat&#x27;</span>)        <span class="comment"># Adding an element that is already in the set does nothing</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(animals))       <span class="comment"># Prints &quot;3&quot;</span></span><br><span class="line">animals.remove(<span class="string">&#x27;cat&#x27;</span>)     <span class="comment"># Remove an element from a set</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(animals))       <span class="comment"># Prints &quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>与往常一样，你想知道的关于集合的所有内容都可以在<a href="https://docs.python.org/3.9/library/stdtypes.html#set">这篇文档</a>中找到。</p>
<p><strong>循环(Loops)</strong>: 遍历集合的语法与遍历列表的语法相同；但是，由于集合是无序的，因此不能假设访问集合元素的顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = &#123;<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>集合推导式(Set comprehensions)</strong>: 就像列表和字典一样，我们可以很容易地使用集合理解来构造集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">nums = &#123;<span class="built_in">int</span>(sqrt(x)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(nums)  <span class="comment"># Prints &quot;&#123;0, 1, 2, 3, 4, 5&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="元组-Tuples"><a href="#元组-Tuples" class="headerlink" title="元组(Tuples)"></a>元组(Tuples)</h4><p>元组是（不可变的）有序值列表。 元组在很多方面类似于列表; 其中一个最重要的区别是元组可以用作字典中的键和集合的元素，而列表则不能。 这是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;(x, x + <span class="number">1</span>): x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;  <span class="comment"># Create a dictionary with tuple keys</span></span><br><span class="line">t = (<span class="number">5</span>, <span class="number">6</span>)        <span class="comment"># Create a tuple</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t))    <span class="comment"># Prints &quot;&lt;class &#x27;tuple&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d[t])       <span class="comment"># Prints &quot;5&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d[(<span class="number">1</span>, <span class="number">2</span>)])  <span class="comment"># Prints &quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/3.9/tutorial/datastructures.html#tuples-and-sequences">这篇文档</a>包含有关元组的更多信息。</p>
<h3 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数(Functions)"></a>函数(Functions)</h3><p>Python函数使用<code>def</code>关键字定义。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;positive&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;negative&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;zero&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">    <span class="built_in">print</span>(sign(x))</span><br><span class="line"><span class="comment"># Prints &quot;negative&quot;, &quot;zero&quot;, &quot;positive&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们经常定义函数来获取可选的关键字参数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name, loud=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> loud:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;HELLO, %s!&#x27;</span> % name.upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line">hello(<span class="string">&#x27;Bob&#x27;</span>) <span class="comment"># Prints &quot;Hello, Bob&quot;</span></span><br><span class="line">hello(<span class="string">&#x27;Fred&#x27;</span>, loud=<span class="literal">True</span>)  <span class="comment"># Prints &quot;HELLO, FRED!&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/3.9/tutorial/controlflow.html#defining-functions">这篇文档</a>中有更多关于Python函数的信息。</p>
<h3 id="类-Classes"><a href="#类-Classes" class="headerlink" title="类(Classes)"></a>类(Classes)</h3><p>在Python中定义类的语法很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name  <span class="comment"># Create an instance variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instance method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">self, loud=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> loud:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;HELLO, %s!&#x27;</span> % self.name.upper())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">g = Greeter(<span class="string">&#x27;Fred&#x27;</span>)  <span class="comment"># Construct an instance of the Greeter class</span></span><br><span class="line">g.greet()            <span class="comment"># Call an instance method; prints &quot;Hello, Fred&quot;</span></span><br><span class="line">g.greet(loud=<span class="literal">True</span>)   <span class="comment"># Call an instance method; prints &quot;HELLO, FRED!&quot;</span></span><br></pre></td></tr></table></figure>

<p>你可以在<a href="https://docs.python.org/3.9/tutorial/classes.html">这篇文档</a>中阅读更多关于Python类的内容。</p>
<h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>Numpy是Python中科学计算的核心库。它提供了一个高性能的多维数组对象，以及用于处理这些数组的工具。</p>
<h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h3><p>numpy数组是一个值网格，所有类型都相同，并由非负整数元组索引。 维数是数组的排名; 数组的形状是一个整数元组，给出了每个维度的数组大小。</p>
<p>我们可以从嵌套的Python列表初始化numpy数组，并使用方括号访问元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])   <span class="comment"># Create a rank 1 array</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))            <span class="comment"># Prints &quot;&lt;class &#x27;numpy.ndarray&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)            <span class="comment"># Prints &quot;(3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])   <span class="comment"># Prints &quot;1 2 3&quot;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                  <span class="comment"># Change an element of the array</span></span><br><span class="line"><span class="built_in">print</span>(a)                  <span class="comment"># Prints &quot;[5, 2, 3]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])    <span class="comment"># Create a rank 2 array</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)                     <span class="comment"># Prints &quot;(2, 3)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])   <span class="comment"># Prints &quot;1 2 4&quot;</span></span><br></pre></td></tr></table></figure>

<p>Numpy还提供了许多创建数组的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))   <span class="comment"># Create an array of all zeros</span></span><br><span class="line"><span class="built_in">print</span>(a)              <span class="comment"># Prints &quot;[[ 0.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  0.]]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))    <span class="comment"># Create an array of all ones</span></span><br><span class="line"><span class="built_in">print</span>(b)              <span class="comment"># Prints &quot;[[ 1.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># Create a constant array</span></span><br><span class="line"><span class="built_in">print</span>(c)               <span class="comment"># Prints &quot;[[ 7.  7.]</span></span><br><span class="line">                       <span class="comment">#          [ 7.  7.]]&quot;</span></span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)         <span class="comment"># Create a 2x2 identity matrix</span></span><br><span class="line"><span class="built_in">print</span>(d)              <span class="comment"># Prints &quot;[[ 1.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))  <span class="comment"># Create an array filled with random values</span></span><br><span class="line"><span class="built_in">print</span>(e)                     <span class="comment"># Might print &quot;[[ 0.91940167  0.08143941]</span></span><br><span class="line">                             <span class="comment">#               [ 0.68744134  0.87236687]]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h3><p>Numpy提供了几种索引数组的方法。</p>
<p><strong>切片(Slicing)</strong>: 与Python列表类似，可以对numpy数组进行切片。由于数组可能是多维的，因此必须为数组的每个维指定一个切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use slicing to pull out the subarray consisting of the first 2 rows</span></span><br><span class="line"><span class="comment"># and columns 1 and 2; b is the following array of shape (2, 2):</span></span><br><span class="line"><span class="comment"># [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># A slice of an array is a view into the same data, so modifying it</span></span><br><span class="line"><span class="comment"># will modify the original array.</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;2&quot;</span></span><br><span class="line">b[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">77</span>     <span class="comment"># b[0, 0] is the same piece of data as a[0, 1]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;77&quot;</span></span><br></pre></td></tr></table></figure>

<p>你还可以将整数索引与切片索引混合使用。 但是，这样做会产生比原始数组更低级别的数组。 请注意，这与MATLAB处理数组切片的方式完全不同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two ways of accessing the data in the middle row of the array.</span></span><br><span class="line"><span class="comment"># Mixing integer indexing with slices yields an array of lower rank,</span></span><br><span class="line"><span class="comment"># while using only slices yields an array of the same rank as the</span></span><br><span class="line"><span class="comment"># original array:</span></span><br><span class="line">row_r1 = a[<span class="number">1</span>, :]    <span class="comment"># Rank 1 view of the second row of a</span></span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>, :]  <span class="comment"># Rank 2 view of the second row of a</span></span><br><span class="line"><span class="built_in">print</span>(row_r1, row_r1.shape)  <span class="comment"># Prints &quot;[5 6 7 8] (4,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(row_r2, row_r2.shape)  <span class="comment"># Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can make the same distinction when accessing columns of an array:</span></span><br><span class="line">col_r1 = a[:, <span class="number">1</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(col_r1, col_r1.shape)  <span class="comment"># Prints &quot;[ 2  6 10] (3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(col_r2, col_r2.shape)  <span class="comment"># Prints &quot;[[ 2]</span></span><br><span class="line">                             <span class="comment">#          [ 6]</span></span><br><span class="line">                             <span class="comment">#          [10]] (3, 1)&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>整数数组索引</strong>: 使用切片索引到numpy数组时，生成的数组视图将始终是原始数组的子数组。 相反，整数数组索引允许你使用另一个数组中的数据构造任意数组。 这是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># An example of integer array indexing.</span></span><br><span class="line"><span class="comment"># The returned array will have shape (3,) and</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The above example of integer array indexing is equivalent to this:</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When using integer array indexing, you can reuse the same</span></span><br><span class="line"><span class="comment"># element from the source array:</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalent to the previous integer array indexing example</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">1</span>], a[<span class="number">0</span>, <span class="number">1</span>]]))  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br></pre></td></tr></table></figure>

<p>整数数组索引的一个有用技巧是从矩阵的每一行中选择或改变一个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new array from which we will select elements</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[ 1,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5,  6],</span></span><br><span class="line">          <span class="comment">#                [ 7,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 11, 12]])&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array of indices</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select one element from each row of a using the indices in b</span></span><br><span class="line"><span class="built_in">print</span>(a[np.arange(<span class="number">4</span>), b])  <span class="comment"># Prints &quot;[ 1  6  7 11]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mutate one element from each row of a using the indices in b</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[11,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5, 16],</span></span><br><span class="line">          <span class="comment">#                [17,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 21, 12]])</span></span><br></pre></td></tr></table></figure>

<p><strong>布尔数组索引</strong>: 布尔数组索引允许你选择数组的任意元素。通常，这种类型的索引用于选择满足某些条件的数组元素。下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)   <span class="comment"># Find the elements of a that are bigger than 2;</span></span><br><span class="line">                     <span class="comment"># this returns a numpy array of Booleans of the same</span></span><br><span class="line">                     <span class="comment"># shape as a, where each slot of bool_idx tells</span></span><br><span class="line">                     <span class="comment"># whether that element of a is &gt; 2.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bool_idx)      <span class="comment"># Prints &quot;[[False False]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We use boolean array indexing to construct a rank 1 array</span></span><br><span class="line"><span class="comment"># consisting of the elements of a corresponding to the True values</span></span><br><span class="line"><span class="comment"># of bool_idx</span></span><br><span class="line"><span class="built_in">print</span>(a[bool_idx])  <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can do all of the above in a single concise statement:</span></span><br><span class="line"><span class="built_in">print</span>(a[a &gt; <span class="number">2</span>])     <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>每个numpy数组都是相同类型元素的网格。Numpy提供了一组可用于构造数组的大量数值数据类型。Numpy在创建数组时尝试猜测数据类型，但构造数组的函数通常还包含一个可选参数来显式指定数据类型。这是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)         <span class="comment"># Prints &quot;int64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)             <span class="comment"># Prints &quot;float64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)   <span class="comment"># Force a particular datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)                         <span class="comment"># Prints &quot;int64&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="数组中的数学"><a href="#数组中的数学" class="headerlink" title="数组中的数学"></a>数组中的数学</h3><p>基本数学函数在数组上以元素方式运行，既可以作为运算符重载，也可以作为numpy模块中的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise sum; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 6.0  8.0]</span></span><br><span class="line"><span class="comment">#  [10.0 12.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise difference; both produce the array</span></span><br><span class="line"><span class="comment"># [[-4.0 -4.0]</span></span><br><span class="line"><span class="comment">#  [-4.0 -4.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x - y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise product; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 5.0 12.0]</span></span><br><span class="line"><span class="comment">#  [21.0 32.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x * y)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise division; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 0.2         0.33333333]</span></span><br><span class="line"><span class="comment">#  [ 0.42857143  0.5       ]]</span></span><br><span class="line"><span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="built_in">print</span>(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise square root; produces the array</span></span><br><span class="line"><span class="comment"># [[ 1.          1.41421356]</span></span><br><span class="line"><span class="comment">#  [ 1.73205081  2.        ]]</span></span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br></pre></td></tr></table></figure>

<p>请注意，与MATLAB不同，<code>*</code>是元素乘法，而不是矩阵乘法。 我们使用<code>dot</code>函数来计算向量的内积，将向量乘以矩阵，并乘以矩阵。 <code>dot</code>既可以作为numpy模块中的函数，也可以作为数组对象的实例方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inner product of vectors; both produce 219</span></span><br><span class="line"><span class="built_in">print</span>(v.dot(w))</span><br><span class="line"><span class="built_in">print</span>(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / vector product; both produce the rank 1 array [29 67]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(v))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / matrix product; both produce the rank 2 array</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(y))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))</span><br></pre></td></tr></table></figure>

<p>Numpy为在数组上执行计算提供了许多有用的函数；其中最有用的函数之一是 <code>SUM</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x))  <span class="comment"># Compute sum of all elements; prints &quot;10&quot;</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>))  <span class="comment"># Compute sum of each column; prints &quot;[4 6]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>))  <span class="comment"># Compute sum of each row; prints &quot;[3 7]&quot;</span></span><br></pre></td></tr></table></figure>

<p>除了使用数组计算数学函数外，我们经常需要对数组中的数据进行整形或其他操作。这种操作的最简单的例子是转置一个矩阵；要转置一个矩阵，只需使用一个数组对象的<code>T</code>属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)    <span class="comment"># Prints &quot;[[1 2]</span></span><br><span class="line">            <span class="comment">#          [3 4]]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x.T)  <span class="comment"># Prints &quot;[[1 3]</span></span><br><span class="line">            <span class="comment">#          [2 4]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that taking the transpose of a rank 1 array does nothing:</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(v)    <span class="comment"># Prints &quot;[1 2 3]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(v.T)  <span class="comment"># Prints &quot;[1 2 3]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="广播-Broadcasting"><a href="#广播-Broadcasting" class="headerlink" title="广播(Broadcasting)"></a>广播(Broadcasting)</h3><p>广播是一种强大的机制，它允许numpy在执行算术运算时使用不同形状的数组。通常，我们有一个较小的数组和一个较大的数组，我们希望多次使用较小的数组来对较大的数组执行一些操作。</p>
<p>例如，假设我们要向矩阵的每一行添加一个常数向量。我们可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.empty_like(x)   <span class="comment"># Create an empty matrix with the same shape as x</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the vector v to each row of the matrix x with an explicit loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now y is the following</span></span><br><span class="line"><span class="comment"># [[ 2  2  4]</span></span><br><span class="line"><span class="comment">#  [ 5  5  7]</span></span><br><span class="line"><span class="comment">#  [ 8  8 10]</span></span><br><span class="line"><span class="comment">#  [11 11 13]]</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>

<p>这会凑效; 但是当矩阵 <code>x</code> 非常大时，在Python中计算显式循环可能会很慢。注意，向矩阵 <code>x</code> 的每一行添加向量 <code>v</code> 等同于通过垂直堆叠多个 <code>v</code> 副本来形成矩阵 <code>vv</code>，然后执行元素的求和<code>x</code> 和 <code>vv</code>。 我们可以像如下这样实现这种方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">vv = np.tile(v, (<span class="number">4</span>, <span class="number">1</span>))   <span class="comment"># Stack 4 copies of v on top of each other</span></span><br><span class="line"><span class="built_in">print</span>(vv)                 <span class="comment"># Prints &quot;[[1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]]&quot;</span></span><br><span class="line">y = x + vv  <span class="comment"># Add x and vv elementwise</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># Prints &quot;[[ 2  2  4</span></span><br><span class="line">          <span class="comment">#          [ 5  5  7]</span></span><br><span class="line">          <span class="comment">#          [ 8  8 10]</span></span><br><span class="line">          <span class="comment">#          [11 11 13]]&quot;</span></span><br></pre></td></tr></table></figure>

<p>Numpy广播允许我们在不实际创建<code>v</code>的多个副本的情况下执行此计算。考虑这个需求，使用广播如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = x + v  <span class="comment"># Add v to each row of x using broadcasting</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># Prints &quot;[[ 2  2  4]</span></span><br><span class="line">          <span class="comment">#          [ 5  5  7]</span></span><br><span class="line">          <span class="comment">#          [ 8  8 10]</span></span><br><span class="line">          <span class="comment">#          [11 11 13]]&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>y=x+v</code>行即使<code>x</code>具有形状<code>(4，3)</code>和<code>v</code>具有形状<code>(3,)</code>，但由于广播的关系，该行的工作方式就好像<code>v</code>实际上具有形状<code>(4，3)</code>，其中每一行都是<code>v</code>的副本，并且求和是按元素执行的。</p>
<p>将两个数组一起广播遵循以下规则：</p>
<ol>
<li>如果数组不具有相同的rank，则将较低等级数组的形状添加1，直到两个形状具有相同的长度。</li>
<li>如果两个数组在维度上具有相同的大小，或者如果其中一个数组在该维度中的大小为1，则称这两个数组在维度上是兼容的。</li>
<li>如果数组在所有维度上兼容，则可以一起广播。</li>
<li>广播之后，每个数组的行为就好像它的形状等于两个输入数组的形状的元素最大值。</li>
<li>在一个数组的大小为1且另一个数组的大小大于1的任何维度中，第一个数组的行为就像沿着该维度复制一样</li>
</ol>
<p>以下是广播的一些应用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute outer product of vectors</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># v has shape (3,)</span></span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])    <span class="comment"># w has shape (2,)</span></span><br><span class="line"><span class="comment"># To compute an outer product, we first reshape v to be a column</span></span><br><span class="line"><span class="comment"># vector of shape (3, 1); we can then broadcast it against w to yield</span></span><br><span class="line"><span class="comment"># an output of shape (3, 2), which is the outer product of v and w:</span></span><br><span class="line"><span class="comment"># [[ 4  5]</span></span><br><span class="line"><span class="comment">#  [ 8 10]</span></span><br><span class="line"><span class="comment">#  [12 15]]</span></span><br><span class="line"><span class="built_in">print</span>(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) * w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a vector to each row of a matrix</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span></span><br><span class="line"><span class="comment"># giving the following matrix:</span></span><br><span class="line"><span class="comment"># [[2 4 6]</span></span><br><span class="line"><span class="comment">#  [5 7 9]]</span></span><br><span class="line"><span class="built_in">print</span>(x + v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a vector to each column of a matrix</span></span><br><span class="line"><span class="comment"># x has shape (2, 3) and w has shape (2,).</span></span><br><span class="line"><span class="comment"># If we transpose x then it has shape (3, 2) and can be broadcast</span></span><br><span class="line"><span class="comment"># against w to yield a result of shape (3, 2); transposing this result</span></span><br><span class="line"><span class="comment"># yields the final result of shape (2, 3) which is the matrix x with</span></span><br><span class="line"><span class="comment"># the vector w added to each column. Gives the following matrix:</span></span><br><span class="line"><span class="comment"># [[ 5  6  7]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11]]</span></span><br><span class="line"><span class="built_in">print</span>((x.T + w).T)</span><br><span class="line"><span class="comment"># Another solution is to reshape w to be a column vector of shape (2, 1);</span></span><br><span class="line"><span class="comment"># we can then broadcast it directly against x to produce the same</span></span><br><span class="line"><span class="comment"># output.</span></span><br><span class="line"><span class="built_in">print</span>(x + np.reshape(w, (<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiply a matrix by a constant:</span></span><br><span class="line"><span class="comment"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span></span><br><span class="line"><span class="comment"># these can be broadcast together to shape (2, 3), producing the</span></span><br><span class="line"><span class="comment"># following array:</span></span><br><span class="line"><span class="comment"># [[ 2  4  6]</span></span><br><span class="line"><span class="comment">#  [ 8 10 12]]</span></span><br><span class="line"><span class="built_in">print</span>(x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>广播通常会使你的代码更简洁，效率更高，因此你应该尽可能地使用它。</p>
<h2 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h2><p>Numpy提供了一个高性能的多维数组和基本工具来计算和操作这些数组。 而<a href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>以此为基础，提供了大量在numpy数组上运行的函数，可用于不同类型的科学和工程应用程序。</p>
<p>熟悉SciPy的最佳方法是浏览<a href="https://docs.scipy.org/doc/scipy/reference/index.html">它的文档</a>。我们将重点介绍SciPy有关的对你有价值的部分内容。</p>
<h3 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h3><p>SciPy提供了一些处理图像的基本函数。例如，它具有将映像从磁盘读入numpy数组、将numpy数组作为映像写入磁盘以及调整映像大小的功能。下面是一个演示这些函数的简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread, imsave, imresize</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read an JPEG image into a numpy array</span></span><br><span class="line">img = imread(<span class="string">&#x27;assets/cat.jpg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(img.dtype, img.shape)  <span class="comment"># Prints &quot;uint8 (400, 248, 3)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can tint the image by scaling each of the color channels</span></span><br><span class="line"><span class="comment"># by a different scalar constant. The image has shape (400, 248, 3);</span></span><br><span class="line"><span class="comment"># we multiply it by the array [1, 0.95, 0.9] of shape (3,);</span></span><br><span class="line"><span class="comment"># numpy broadcasting means that this leaves the red channel unchanged,</span></span><br><span class="line"><span class="comment"># and multiplies the green and blue channels by 0.95 and 0.9</span></span><br><span class="line"><span class="comment"># respectively.</span></span><br><span class="line">img_tinted = img * [<span class="number">1</span>, <span class="number">0.95</span>, <span class="number">0.9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize the tinted image to be 300 by 300 pixels.</span></span><br><span class="line">img_tinted = imresize(img_tinted, (<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the tinted image back to disk</span></span><br><span class="line">imsave(<span class="string">&#x27;assets/cat_tinted.jpg&#x27;</span>, img_tinted)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/cat.jpg" alt="猫咪"> <img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/cat_tinted.jpg" alt="猫咪"></p>
<p>左：原始图像。右：着色和调整大小的图像。</p>
<h3 id="MATLAB-文件"><a href="#MATLAB-文件" class="headerlink" title="MATLAB 文件"></a>MATLAB 文件</h3><p>函数 <code>scipy.io.loadmat</code> 和 <code>scipy.io.savemat</code> 允许你读取和写入MATLAB文件。你可以在<a href="https://docs.scipy.org/doc/scipy/reference/io.html">这篇文档</a>中学习相关操作。</p>
<h3 id="点之间的距离"><a href="#点之间的距离" class="headerlink" title="点之间的距离"></a>点之间的距离</h3><p>SciPy定义了一些用于计算点集之间距离的有用函数。</p>
<p>函数<code>scipy.spatial.distance.pdist</code>计算给定集合中所有点对之间的距离：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist, squareform</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following array where each row is a point in 2D space:</span></span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [1 0]</span></span><br><span class="line"><span class="comment">#  [2 0]]</span></span><br><span class="line">x = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the Euclidean distance between all rows of x.</span></span><br><span class="line"><span class="comment"># d[i, j] is the Euclidean distance between x[i, :] and x[j, :],</span></span><br><span class="line"><span class="comment"># and d is the following array:</span></span><br><span class="line"><span class="comment"># [[ 0.          1.41421356  2.23606798]</span></span><br><span class="line"><span class="comment">#  [ 1.41421356  0.          1.        ]</span></span><br><span class="line"><span class="comment">#  [ 2.23606798  1.          0.        ]]</span></span><br><span class="line">d = squareform(pdist(x, <span class="string">&#x27;euclidean&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p><a href="https://matplotlib.org/">Matplotlib</a>是一个绘图库。本节简要介绍 <code>matplotlib.pyplot</code> 模块，该模块提供了类似于MATLAB的绘图系统。</p>
<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>matplotlib中最重要的功能是<code>plot</code>，它允许你绘制2D数据的图像。这是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the x and y coordinates for points on a sine curve</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the points using matplotlib</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()  <span class="comment"># You must call plt.show() to make graphics appear.</span></span><br></pre></td></tr></table></figure>

<p>运行此代码会生成以下图表：</p>
<p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/sine.png" alt="sine"></p>
<p>通过一些额外的工作，我们可以轻松地一次绘制多条线，并添加标题，图例和轴标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the x and y coordinates for points on sine and cosine curves</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the points using matplotlib</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x axis label&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y axis label&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Sine and Cosine&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Sine&#x27;</span>, <span class="string">&#x27;Cosine&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/sine_cosine.png" alt="sine_cosine"></p>
<h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>你可以使用<code>subplot</code>函数在同一个图中绘制不同的东西。 这是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the x and y coordinates for points on sine and cosine curves</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a subplot grid that has height 2 and width 1,</span></span><br><span class="line"><span class="comment"># and set the first such subplot as active.</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make the first plot</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.title(<span class="string">&#x27;Sine&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the second subplot as active, and make the second plot.</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.title(<span class="string">&#x27;Cosine&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the figure.</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/sine_cosine_subplot.png" alt="sine_cosine_subplot"></p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>你可以使用 <code>imshow</code> 函数来显示一张图片。 这是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread, imresize</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = imread(<span class="string">&#x27;assets/cat.jpg&#x27;</span>)</span><br><span class="line">img_tinted = img * [<span class="number">1</span>, <span class="number">0.95</span>, <span class="number">0.9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the original image</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the tinted image</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A slight gotcha with imshow is that it might give strange results</span></span><br><span class="line"><span class="comment"># if presented with data that is not uint8. To work around this, we</span></span><br><span class="line"><span class="comment"># explicitly cast the image to uint8 before displaying it.</span></span><br><span class="line">plt.imshow(np.uint8(img_tinted))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/cat_tinted_imshow.png" alt="cat_tinted_imshow"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm框架（一）</title>
    <url>/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ssm框架原理（一）"><a href="#ssm框架原理（一）" class="headerlink" title="ssm框架原理（一）"></a>ssm框架原理（一）</h1><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>ssm框架实际上就是一个框架整合，包含了spring、spring mvc以及mybatis框架。是一种标准的mvc模式的体现，ssm框架将系统划分为表现层、控制层、服务层、以及DAO层。其中，我们使用spring mvc负责请求的转发和视图管理、spring实现业务对象管理、mybatis作为数据持久化引擎。（db）</p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><h3 id="SpringMVC："><a href="#SpringMVC：" class="headerlink" title="SpringMVC："></a>SpringMVC：</h3><p>1.客户端发送请求到DispacherServlet（分发器）</p>
<p>2.由DispacherServlet控制器查询HanderMapping，找到处理请求的Controller</p>
<p>3.Controller调用业务逻辑处理后，返回ModelAndView</p>
<p>4.DispacherSerclet查询视图解析器，找到ModelAndView指定的视图</p>
<p>5.视图负责将结果显示到客户端<br><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/20151118190949363.png" alt="img"></p>
<h3 id="Spring："><a href="#Spring：" class="headerlink" title="Spring："></a>Spring：</h3><p>我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们Java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。</p>
<h3 id="Mybatis："><a href="#Mybatis：" class="headerlink" title="Mybatis："></a>Mybatis：</h3><p>mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</p>
<h3 id="要完成一个功能："><a href="#要完成一个功能：" class="headerlink" title="要完成一个功能："></a>要完成一个功能：</h3><p>先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。<br>写Mapper.xml（Mybatis），其中定义你的功能，对应要对数据库进行的那些操作，比如 insert、selectAll、select ByKey、delete、update等。<br>写Mapper.java，将Mapper.xml中的操作按照id映射成Java函数。<br>写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。<br>写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。<br>写JSP页面调用，请求哪些参数，需要获取什么数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DataBase ===&gt; Entity ===&gt; Mapper.xml ===&gt; Mapper.Java ===&gt; Service.java ===&gt; Controller.java ===&gt; Jsp.  </span><br></pre></td></tr></table></figure>

<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>拥有控制器，作用跟Struts类似，接收外部请求，解析参数传给服务层<br>Spring 容器属于协调上下文，管理对象间的依赖，提供事务机制<br>mybatis 属于orm持久层框架，将业务实体 与数据表联合 起来</p>
<p>Spring MVC  控制层，想当与 Struts的作用<br>Spring 控制反转和依赖注入  创建对象交由容器管理，达到了解耦的作用<br>mybatis 主要用来操作数据库（数据库的增删改查）</p>
<h3 id="IOC-控制反转"><a href="#IOC-控制反转" class="headerlink" title="IOC:控制反转"></a>IOC:控制反转</h3><p>是一种降低对象之间耦合关系的设计思想，面试的时候最好能说出来个例子，加深理解。例子：租房子，以前租房子需要一个房子一个房子找，费时费力，然后现在加入一个房屋中介，把你需要的房型告诉中介，就可以直接选到需要的房子，中介就相当于spring容器。</p>
<h3 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP:面向切面编程"></a>AOP:面向切面编程</h3><p>是面向对象开发的一种补充，它允许开发人员在不改变原来模型的基础上动态的修改模型以满足新的需求，如：动态的增加日志、安全或异常处理等。AOP使业务逻辑各部分间的耦合度降低，提高程序可重用性，提高开发效率。</p>
<h3 id="持久层：DAO层（mapper）"><a href="#持久层：DAO层（mapper）" class="headerlink" title="持久层：DAO层（mapper）"></a>持久层：DAO层（mapper）</h3><p>DAO层：DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，<br>DAO层的设计首先是设计DAO的接口，<br>然后在Spring的配置文件中定义此接口的实现类，<br>然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，<br>DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。</p>
<h3 id="业务层：Service层"><a href="#业务层：Service层" class="headerlink" title="业务层：Service层"></a>业务层：Service层</h3><p>Service层：Service层主要负责业务模块的逻辑应用设计。<br>首先设计接口，再设计其实现的类<br>接着再在Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。<br>Service层的业务实现，具体要调用到已定义的DAO层的接口，<br>封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。</p>
<h3 id="表现层：Controller层（Handler层）"><a href="#表现层：Controller层（Handler层）" class="headerlink" title="表现层：Controller层（Handler层）"></a>表现层：Controller层（Handler层）</h3><p>Controller层:Controller层负责具体的业务模块流程的控制，<br>在此层里面要调用Service层的接口来控制业务流程，<br>控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。</p>
<h3 id="View层"><a href="#View层" class="headerlink" title="View层"></a>View层</h3><p>View层 此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示.</p>
<h3 id="各层联系"><a href="#各层联系" class="headerlink" title="各层联系"></a>各层联系</h3><p>DAO层，Service层这两个层次都可以单独开发，互相的耦合度很低，完全可以独立进行，这样的一种模式在开发大项目的过程中尤其有优势<br>Controller，View层因为耦合度比较高，因而要结合在一起开发，但是也可以看作一个整体独立于前两个层进行开发。这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，一切显得非常清晰简单。</p>
<h3 id="Service逻辑层设计"><a href="#Service逻辑层设计" class="headerlink" title="Service逻辑层设计"></a>Service逻辑层设计</h3><p>Service层是建立在DAO层之上的，建立了DAO层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。</p>
<h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>​        Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>​        Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。</p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>​       MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。</p>
<h2 id="开发环境搭建以及创建Maven-Web项目"><a href="#开发环境搭建以及创建Maven-Web项目" class="headerlink" title="开发环境搭建以及创建Maven Web项目"></a>开发环境搭建以及创建Maven Web项目</h2><blockquote>
<p>Eclipse+Tomcat+MAVEN+SVN项目完整环境搭建</p>
</blockquote>
<h3 id="1-JDK的安装"><a href="#1-JDK的安装" class="headerlink" title="1.JDK的安装"></a>1.JDK的安装</h3><p>​    首先下载JDK，这个从sun公司官网可以下载，根据自己的系统选择64位还是32位，安装过程就是next一路到底。安装完成之后当然要配置环境变量了。</p>
<p>——————————————————————————————————————————————</p>
<blockquote>
<p>1.1新建变量名：JAVA_HOME  变量值：E:\Java\jdk1.6.0_43（这是我的jdk安装路径）</p>
<p>1.2编辑变量名：Path 在后面加上：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</p>
<p>1.3 新建变量名：CLASSPATH 变量值： .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</p>
</blockquote>
<p>（注意：在设置变量的末尾时不要加上“；”）</p>
<p>——————————————————————————————————————————————</p>
<p>设置完成之后我们当然需要测试，打开“运行”–&gt;输入“CMD”–&gt;在命令行上面输入：java，然后回车；输入javac，回车，输入java -version，回车，如果出现下列三个画面，那么JDK配置成功，否则就需要检查环境变量的配置。</p>
<img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/image-20210921213621372.png" alt="image-20210921213621372" style="zoom:50%;">

<img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/image-20210921213640935.png" alt="image-20210921213640935" style="zoom:50%;">

<img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/image-20210921213714443.png" alt="image-20210921213714443" style="zoom:50%;">

<h3 id="2-Eclipse的安装"><a href="#2-Eclipse的安装" class="headerlink" title="2.Eclipse的安装"></a>2.Eclipse的安装</h3><p>   下载地址：<a href="http://www.eclipse.org/downloads/">http://www.eclipse.org/downloads/</a>  版本自行选择  </p>
<p>   完成之后我们启动Eclipse，设置好工作路径，也可以直接默认。我们打开window–&gt;preference输入jre，安装下图。</p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828185304219-909517504.png" alt="img"></p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828190251437-403272735.png" alt="img"></p>
<p> 此时我们可以随便建立一个JAVA项目，然后编写一个helloworld来测试一下是否正确。</p>
<h3 id="Tomcat8的安装"><a href="#Tomcat8的安装" class="headerlink" title="Tomcat8的安装"></a>Tomcat8的安装</h3><p>​    Tomcat使用的版本是8，大家可以到apache的官网上去下载，<a href="http://tomcat.apache.org/download-80.cgi">http://tomcat.apache.org</a>，下载直接解压就行。</p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828190448875-2048839166.png" alt="img"></p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828190629703-89662533.png" alt="img"></p>
<h3 id="Maven安装配置"><a href="#Maven安装配置" class="headerlink" title="Maven安装配置"></a>Maven安装配置</h3><h4 id="maven配置环境变量"><a href="#maven配置环境变量" class="headerlink" title="maven配置环境变量"></a>maven配置环境变量</h4><p> 下载maven，就是一个包：apache-maven-3.2.1，我用的版本是3.2.1，解压到一个路径，然后配置环境变量：</p>
<p>——————————————————————————————————————————————————</p>
<blockquote>
<p>   5.1 新建变量名：MAVEN_HOME  变量值：D:\server\apache-maven-3.2.1（这是我的MAVEN路径）</p>
<p>   编辑变量名：Path 在最前面加上：%MAVEN_HOME%\bin;（注意，最后要有个”;”作为分隔符）</p>
</blockquote>
<p>——————————————————————————————————————————————</p>
<p>完成之后，在命令行输入：mvn -version查看是否有以下内容，如果有表示配置成功。</p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828190819234-882295285.png" alt="img"></p>
<h4 id="Maven数据仓库的配置"><a href="#Maven数据仓库的配置" class="headerlink" title="Maven数据仓库的配置"></a>Maven数据仓库的配置</h4><p>MAVEN中还有一个重要的配置就是数据仓库的路径配置，我们找到MAVEN的安装路径，进入conf–&gt;打开settings.xml，找到localRepository标签，此时是被注释掉的，我们解除注释，然后配置一个路径，例如：E:\Dev\Java\maven\repo，这样以后MAVEN管理下载的jar包都会在这个路径下。当然我们需要建这样一个目录结构，然后还要讲settings.xml复制一份到E:\Dev\Java\maven下，这个在与Eclipse集成时会用到。<strong>修改默认保存路径</strong></p>
<p><strong><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829203627344-2088280037.png" alt="img"></strong></p>
<h3 id="Eclipse中集成Maven"><a href="#Eclipse中集成Maven" class="headerlink" title="Eclipse中集成Maven"></a>Eclipse中集成Maven</h3><p>在preferences中进行配置，如图：</p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204010922-1975818603.png" alt="img"></p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204215719-809768030.png" alt="img"></p>
<p> 此时，点击File–&gt;new–&gt;other–&gt;输入maven–&gt;–&gt;Maven Project，如果可以看到这些，证明配置成功，已经可以建立Maven项目了。</p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204454765-1161572702.png" alt="img"><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204928656-1589383472.png" alt="img"></p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204944172-1087694389.png" alt="img"><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204953047-22835249.png" alt="img"></p>
<p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829205005375-1380967534.png" alt="img"></p>
<p>如果indexjsp 提示有错误需要在pom.xml中导入  javaee-api.jar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="SVN安装"><a href="#SVN安装" class="headerlink" title="SVN安装"></a>SVN安装</h3><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829205515859-847674917.png" alt="img"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm框架（二）</title>
    <url>/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="ssm框架（二）"><a href="#ssm框架（二）" class="headerlink" title="ssm框架（二）"></a>ssm框架（二）</h1><h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><p> 下面主要介绍三大框架的整合，至于环境的搭建以及项目的创建。这次整合我分了2个配置文件，分别是spring-mybatis.xml，包含spring和mybatis的配置文件，还有个是spring-mvc的配置文件，此外有2个资源文件：jdbc.propertis和log4j.properties。</p>
<h3 id="使用框架的版本："><a href="#使用框架的版本：" class="headerlink" title="使用框架的版本："></a>使用框架的版本：</h3><pre><code>   Spring 4.0.2 RELEASE

   Spring MVC 4.0.2 RELEASE

   MyBatis 3.2.6
</code></pre>
<h3 id="Maven引入需要的JAR包"><a href="#Maven引入需要的JAR包" class="headerlink" title="Maven引入需要的JAR包"></a>Maven引入需要的JAR包</h3><p>​    在pom.xml中引入jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.javen.maven01&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven01&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;maven01 Maven Webapp&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;  </span><br><span class="line">        &lt;!-- spring版本号 --&gt;  </span><br><span class="line">        &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt;  </span><br><span class="line">        &lt;!-- mybatis版本号 --&gt;  </span><br><span class="line">        &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt;  </span><br><span class="line">        &lt;!-- log4j日志文件管理包版本 --&gt;  </span><br><span class="line">        &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;  </span><br><span class="line">        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;  </span><br><span class="line">    &lt;/properties&gt; </span><br><span class="line">    </span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">             &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt;  </span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt; --&gt;</span><br><span class="line">        </span><br><span class="line">         &lt;!-- spring核心包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- mybatis核心包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">         &lt;!-- mybatis/spring包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        </span><br><span class="line">         &lt;!-- 导入java ee jar 包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;javax&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;7.0&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        </span><br><span class="line">         &lt;!-- 导入Mysql数据库链接jar包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;5.1.36&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        </span><br><span class="line">        &lt;!-- JSTL标签类 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;jstl&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;jstl&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.2&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- 日志文件管理包 --&gt;  </span><br><span class="line">        &lt;!-- log start --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​          </span><br><span class="line"></span><br><span class="line">        &lt;!-- 格式化对象，方便输出日志 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.1.41&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- log end --&gt;  </span><br><span class="line">        &lt;!-- 映入JSON --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.9.13&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- 上传组件包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.3.1&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;commons-io&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;2.4&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;commons-codec&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.9&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">    </span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;maven01&lt;/finalName&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;9.2.8.v20150217&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;httpConnector&gt;</span><br><span class="line">                        &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">                    &lt;/httpConnector&gt;</span><br><span class="line">                    &lt;stopKey&gt;shutdown&lt;/stopKey&gt;</span><br><span class="line">                    &lt;stopPort&gt;9966&lt;/stopPort&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<h3 id="整合SpringMVC"><a href="#整合SpringMVC" class="headerlink" title="整合SpringMVC"></a>整合SpringMVC</h3><h4 id="配置spring-mvc-xml"><a href="#配置spring-mvc-xml" class="headerlink" title="配置spring-mvc.xml"></a>配置spring-mvc.xml</h4><p>配置里面的注释也很详细，主要是自动扫描控制器，视图模式，注解的启动这三个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;  </span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;  </span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    </span><br><span class="line">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    </span><br><span class="line">                        http://www.springframework.org/schema/context    </span><br><span class="line">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd    </span><br><span class="line">                        http://www.springframework.org/schema/mvc    </span><br><span class="line">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;  </span><br><span class="line">    &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;  </span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.javen.controller&quot; /&gt;  </span><br><span class="line">    &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven/&gt;</span><br><span class="line">    &lt;!-- 静态资源处理  css js imgs --&gt;</span><br><span class="line">    &lt;mvc:resources location=&quot;/resources/**&quot; mapping=&quot;/resources&quot;/&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot;  </span><br><span class="line">        class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;supportedMediaTypes&quot;&gt;  </span><br><span class="line">            &lt;list&gt;  </span><br><span class="line">                &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;  </span><br><span class="line">            &lt;/list&gt;  </span><br><span class="line">        &lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">    &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt;  </span><br><span class="line">    &lt;bean  </span><br><span class="line">        class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;messageConverters&quot;&gt;  </span><br><span class="line">            &lt;list&gt;  </span><br><span class="line">                &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt; &lt;!-- JSON转换器 --&gt;  </span><br><span class="line">            &lt;/list&gt;  </span><br><span class="line">        &lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;multipartResolver&quot;    </span><br><span class="line">        class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    </span><br><span class="line">        &lt;!-- 默认编码 --&gt;  </span><br><span class="line">        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt;    </span><br><span class="line">        &lt;!-- 文件大小最大值 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt;    </span><br><span class="line">        &lt;!-- 内存中的最大值 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt;    </span><br><span class="line">        &lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt;</span><br><span class="line">        &lt;property name=&quot;resolveLazily&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;   </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。   InternalResourceViewResolver 放在最后--&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;mediaTypes&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt;</span><br><span class="line">                &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;</span><br><span class="line">                &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;</span><br><span class="line">                &lt;entry key=&quot;htm&quot; value=&quot;text/htm&quot; /&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;defaultViews&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;!-- ModelAndView里的数据变成JSON --&gt;</span><br><span class="line">                &lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJacksonJsonView&quot; /&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt;  </span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;  </span><br><span class="line">        &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt;  </span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;  </span><br></pre></td></tr></table></figure>

<h4 id="配置web-xml文件"><a href="#配置web-xml文件" class="headerlink" title="配置web.xml文件"></a>配置web.xml文件</h4><p> 配置的spring-mvc的Servlet就是为了完成SpringMVC+MAVEN的整合。</p>
<p>web.xml  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </span><br><span class="line">    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;  </span><br><span class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;  </span><br><span class="line">    version=&quot;3.0&quot;&gt;  </span><br><span class="line">    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  </span><br><span class="line">    &lt;!-- Spring和mybatis的配置文件 --&gt;  </span><br><span class="line">   &lt;!--  &lt;context-param&gt;  </span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class="line">        &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt;  </span><br><span class="line">    &lt;/context-param&gt;   --&gt;</span><br><span class="line">    &lt;!-- 编码过滤器 --&gt;  </span><br><span class="line">    &lt;filter&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  </span><br><span class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;  </span><br><span class="line">        &lt;init-param&gt;  </span><br><span class="line">            &lt;param-name&gt;encoding&lt;/param-name&gt;  </span><br><span class="line">            &lt;param-value&gt;UTF-8&lt;/param-value&gt;  </span><br><span class="line">        &lt;/init-param&gt;  </span><br><span class="line">    &lt;/filter&gt;  </span><br><span class="line">    &lt;filter-mapping&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/filter-mapping&gt;  </span><br><span class="line">    &lt;!-- Spring监听器 --&gt;  </span><br><span class="line">   &lt;!--  &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;   --&gt;</span><br><span class="line">    &lt;!-- 防止Spring内存溢出监听器 --&gt;  </span><br><span class="line">    &lt;!-- &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;  --&gt; </span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring MVC servlet --&gt;  </span><br><span class="line">    &lt;servlet&gt;  </span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;  </span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  </span><br><span class="line">        &lt;init-param&gt;  </span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class="line">            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;  </span><br><span class="line">        &lt;/init-param&gt;  </span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  </span><br><span class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;  </span><br><span class="line">    &lt;/servlet&gt;  </span><br><span class="line">    &lt;servlet-mapping&gt;  </span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;  </span><br><span class="line">        &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt;  </span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/servlet-mapping&gt;  </span><br><span class="line">    &lt;welcome-file-list&gt;  </span><br><span class="line">        &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt;  </span><br><span class="line">    &lt;/welcome-file-list&gt;  </span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;  </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="Log4j的配置"><a href="#Log4j的配置" class="headerlink" title="Log4j的配置"></a>Log4j的配置</h3><p>   为了方便调试，一般都会使用日志来输出信息，Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p>
<pre><code>  Log4j的配置很简单，而且也是通用的，下面给出一个基本的配置，换到其他项目中也无需做多大的调整，如果想做调整或者想了解Log4j的各种配置，参看我转载的一篇博文，很详细：http://blog.csdn.net/zhshulin/article/details/37937365
</code></pre>
<p>下面给出配置文件目录：</p>
<p>log4j.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO,Console,File  </span><br><span class="line">#定义日志输出目的地为控制台  </span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender  </span><br><span class="line">log4j.appender.Console.Target=System.out  </span><br><span class="line">#可以灵活地指定日志输出格式，下面一行是指定具体的格式  </span><br><span class="line">log4j.appender.Console.layout = org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n  </span><br><span class="line"></span><br><span class="line">#文件大小到达指定尺寸的时候产生一个新的文件  </span><br><span class="line">log4j.appender.File = org.apache.log4j.RollingFileAppender  </span><br><span class="line">#指定输出目录  </span><br><span class="line">log4j.appender.File.File = logs/ssm.log  </span><br><span class="line">#定义文件最大大小  </span><br><span class="line">log4j.appender.File.MaxFileSize = 10MB  </span><br><span class="line"></span><br><span class="line">输出所以日志，如果换成DEBUG表示输出DEBUG以上级别日志  </span><br><span class="line"></span><br><span class="line">log4j.appender.File.Threshold = ALL  </span><br><span class="line">log4j.appender.File.layout = org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c]%m%n  </span><br></pre></td></tr></table></figure>

<h3 id="使用Jetty测试"><a href="#使用Jetty测试" class="headerlink" title="使用Jetty测试"></a>使用Jetty测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javen.model;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    private String userName;</span><br><span class="line">    </span><br><span class="line">    private String password;</span><br><span class="line">    </span><br><span class="line">    private Integer age;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName == null ? null : userName.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password == null ? null : password.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [id=&quot; + id + &quot;, userName=&quot; + userName + &quot;, password=&quot;</span><br><span class="line">                + password + &quot;, age=&quot; + age + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javen.controller;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Controller;  </span><br><span class="line">import org.springframework.ui.Model;  </span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;  </span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import com.javen.model.User;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller  </span><br><span class="line">@RequestMapping(&quot;/user&quot;)  </span><br><span class="line">// /user/**</span><br><span class="line">public class UserController &#123;  </span><br><span class="line">    private static Logger log=LoggerFactory.getLogger(UserController.class);</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // /user/test?id=1</span><br><span class="line">    @RequestMapping(value=&quot;/test&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String test(HttpServletRequest request,Model model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(request.getParameter(&quot;id&quot;));  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user=null;</span><br><span class="line">        if (userId==1) &#123;</span><br><span class="line">             user = new User();  </span><br><span class="line">             user.setAge(11);</span><br><span class="line">             user.setId(1);</span><br><span class="line">             user.setPassword(&quot;123&quot;);</span><br><span class="line">             user.setUserName(&quot;javen&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.addAttribute(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;index&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>​                               </p>
<p>在浏览器中输入：<a href="http://localhost/user/test?id=1">http://localhost/user/test?id=1</a></p>
<p>到此 SpringMVC+Maven 整合完毕</p>
<h2 id="Spring与MyBatis的整合"><a href="#Spring与MyBatis的整合" class="headerlink" title="Spring与MyBatis的整合"></a>Spring与MyBatis的整合</h2><p>   取消3.2.2 web.xml中注释的代码 </p>
<h3 id="建立JDBC属性文件"><a href="#建立JDBC属性文件" class="headerlink" title="建立JDBC属性文件"></a>建立JDBC属性文件</h3><p>jdbc.properties（文件编码修改为utf-8）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/maven</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">#定义初始连接数  </span><br><span class="line">initialSize=0  </span><br><span class="line">#定义最大连接数  </span><br><span class="line">maxActive=20  </span><br><span class="line">#定义最大空闲  </span><br><span class="line">maxIdle=20  </span><br><span class="line">#定义最小空闲  </span><br><span class="line">minIdle=1  </span><br><span class="line">#定义最长等待时间  </span><br><span class="line">maxWait=60000 </span><br></pre></td></tr></table></figure>

<h4 id="建立spring-mybatis-xml配置文件"><a href="#建立spring-mybatis-xml配置文件" class="headerlink" title="建立spring-mybatis.xml配置文件"></a>建立spring-mybatis.xml配置文件</h4><p>​    这个文件就是用来完成spring和mybatis的整合的。这里面也没多少行配置，主要的就是自动扫描，自动注入，配置数据库。注释也很详细，大家看看就明白了。</p>
<p>spring-mybatis.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;  </span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;  </span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    </span><br><span class="line">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    </span><br><span class="line">                        http://www.springframework.org/schema/context    </span><br><span class="line">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd    </span><br><span class="line">                        http://www.springframework.org/schema/mvc    </span><br><span class="line">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;  </span><br><span class="line">    &lt;!-- 自动扫描 --&gt;  </span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.javen&quot; /&gt;  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入配置文件 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;propertyConfigurer&quot;  </span><br><span class="line">        class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;  </span><br><span class="line">        destroy-method=&quot;close&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;  </span><br><span class="line">        &lt;!-- 初始化连接大小 --&gt;  </span><br><span class="line">        &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">        &lt;!-- 连接池最大数量 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">        &lt;!-- 连接池最大空闲 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">        &lt;!-- 连接池最小空闲 --&gt;  </span><br><span class="line">        &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;minIdle&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">        &lt;!-- 获取连接最大等待时间 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;maxWait&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  </span><br><span class="line">        &lt;!-- 自动扫描mapping.xml文件 --&gt;  </span><br><span class="line">        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/javen/mapping/*.xml&quot;&gt;&lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;  </span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;com.javen.dao&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;  </span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot;  </span><br><span class="line">        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;  </span><br></pre></td></tr></table></figure>

<h3 id="JUnit测试"><a href="#JUnit测试" class="headerlink" title="JUnit测试"></a>JUnit测试</h3><p>  经过以上步骤，我们已经完成了Spring和mybatis的整合，这样我们就可以编写一段测试代码来试试是否成功了。</p>
<h2 id="创建测试用表"><a href="#创建测试用表" class="headerlink" title="创建测试用表"></a>创建测试用表</h2><p>既然我们需要测试，那么我们就需要建立在数据库中建立一个测试表，这个表建的很简单，SQL语句为：</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Table structure for `user_t`</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `user_t`;</span><br><span class="line">CREATE TABLE `user_t` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_name` varchar(40) NOT NULL,</span><br><span class="line">  `password` varchar(255) NOT NULL,</span><br><span class="line">  `age` int(4) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">-- Records of user_t</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">INSERT INTO `user_t` VALUES (&#x27;1&#x27;, &#x27;测试&#x27;, &#x27;345&#x27;, &#x27;24&#x27;);</span><br><span class="line">INSERT INTO `user_t` VALUES (&#x27;2&#x27;, &#x27;javen&#x27;, &#x27;123&#x27;, &#x27;10&#x27;);</span><br></pre></td></tr></table></figure>

<p>利用MyBatis Generator自动创建代码</p>
<p>参考博文：<a href="http://blog.csdn.net/zhshulin/article/details/23912615">http://blog.csdn.net/zhshulin/article/details/23912615</a></p>
<p> 这个可根据表自动创建实体类、MyBatis映射文件以及DAO接口，当然，我习惯将生成的接口名改为IUserDao，而不是直接用它生成的UserMapper。如果不想麻烦就可以不改。完成后将文件复制到工程中。如图：</p>
<p>​                                                                  </p>
<h2 id="建立Service接口和实现类"><a href="#建立Service接口和实现类" class="headerlink" title="建立Service接口和实现类"></a>建立Service接口和实现类</h2><p>​                                                                 </p>
<p>下面给出具体的内容：</p>
<p>IUserService.jave</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javen.service;  </span><br><span class="line"></span><br><span class="line">import com.javen.model.User;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface IUserService &#123;  </span><br><span class="line">    public User getUserById(int userId);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">UserServiceImpl.java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.javen.service.impl;</span><br><span class="line">import javax.annotation.Resource;  </span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Service;  </span><br><span class="line">import com.javen.dao.IUserDao;</span><br><span class="line">import com.javen.model.User;</span><br><span class="line">import com.javen.service.IUserService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service(&quot;userService&quot;)  </span><br><span class="line">public class UserServiceImpl implements IUserService &#123;  </span><br><span class="line">    @Resource  </span><br><span class="line">    private IUserDao userDao;  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    public User getUserById(int userId) &#123;  </span><br><span class="line">        // TODO Auto-generated method stub  </span><br><span class="line">        return this.userDao.selectByPrimaryKey(userId);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="建立测试类"><a href="#建立测试类" class="headerlink" title="建立测试类"></a>建立测试类</h3><p> 测试类在src/test/java中建立，下面测试类中注释掉的部分是不使用Spring时，一般情况下的一种测试方法；如果使用了Spring那么就可以使用注解的方式来引入配置文件和类，然后再将service接口对象注入，就可以进行测试了。</p>
<blockquote>
<p>   如果测试成功，表示Spring和Mybatis已经整合成功了。输出信息使用的是Log4j打印到控制台。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javen.testmybatis;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;  </span><br><span class="line"></span><br><span class="line">import org.apache.log4j.Logger;  </span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;  </span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;  </span><br><span class="line">import com.alibaba.fastjson.JSON;  </span><br><span class="line">import com.javen.model.User;</span><br><span class="line">import com.javen.service.IUserService;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)     //表示继承了SpringJUnit4ClassRunner类  </span><br><span class="line">@ContextConfiguration(locations = &#123;&quot;classpath:spring-mybatis.xml&quot;&#125;)  </span><br><span class="line"></span><br><span class="line">public class TestMyBatis &#123;  </span><br><span class="line">    private static Logger logger = Logger.getLogger(TestMyBatis.class);  </span><br><span class="line">//  private ApplicationContext ac = null;  </span><br><span class="line">    @Resource  </span><br><span class="line">    private IUserService userService = null;  </span><br><span class="line"></span><br><span class="line">//  @Before  </span><br><span class="line">//  public void before() &#123;  </span><br><span class="line">//      ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);  </span><br><span class="line">//      userService = (IUserService) ac.getBean(&quot;userService&quot;);  </span><br><span class="line">//  &#125;  </span><br><span class="line"></span><br><span class="line">    @Test  </span><br><span class="line">    public void test1() &#123;  </span><br><span class="line">        User user = userService.getUserById(1);  </span><br><span class="line">        // System.out.println(user.getUserName());  </span><br><span class="line">        // logger.info(&quot;值：&quot;+user.getUserName());  </span><br><span class="line">        logger.info(JSON.toJSONString(user));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>测试结果 </p>
<p> <img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/441423-20150830173453859-1226139271.png" alt="img"></p>
<h3 id="建立UserController类"><a href="#建立UserController类" class="headerlink" title="建立UserController类"></a>建立UserController类</h3><p>UserController.java  控制器   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.javen.controller;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.io.FileUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.http.ResponseEntity;</span><br><span class="line">import org.springframework.stereotype.Controller;  </span><br><span class="line">import org.springframework.ui.Model;  </span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;  </span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import com.javen.model.User;</span><br><span class="line">import com.javen.service.IUserService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller  </span><br><span class="line">@RequestMapping(&quot;/user&quot;)  </span><br><span class="line">// /user/**</span><br><span class="line">public class UserController &#123;  </span><br><span class="line">    private static Logger log=LoggerFactory.getLogger(UserController.class);</span><br><span class="line">     @Resource  </span><br><span class="line">     private IUserService userService;     </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // /user/test?id=1</span><br><span class="line">    @RequestMapping(value=&quot;/test&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String test(HttpServletRequest request,Model model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(request.getParameter(&quot;id&quot;));  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user=null;</span><br><span class="line">        if (userId==1) &#123;</span><br><span class="line">             user = new User();  </span><br><span class="line">             user.setAge(11);</span><br><span class="line">             user.setId(1);</span><br><span class="line">             user.setPassword(&quot;123&quot;);</span><br><span class="line">             user.setUserName(&quot;javen&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.addAttribute(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;index&quot;;  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    // /user/showUser?id=1</span><br><span class="line">    @RequestMapping(value=&quot;/showUser&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String toIndex(HttpServletRequest request,Model model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(request.getParameter(&quot;id&quot;));  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.addAttribute(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;showUser&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"> // /user/showUser2?id=1</span><br><span class="line">    @RequestMapping(value=&quot;/showUser2&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String toIndex2(@RequestParam(&quot;id&quot;) String id,Model model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(id);  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.addAttribute(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;showUser&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // /user/showUser3/&#123;id&#125;</span><br><span class="line">    @RequestMapping(value=&quot;/showUser3/&#123;id&#125;&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String toIndex3(@PathVariable(&quot;id&quot;)String id,Map&lt;String, Object&gt; model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(id);  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.put(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;showUser&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"> // /user/&#123;id&#125;</span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public @ResponseBody User getUserInJson(@PathVariable String id,Map&lt;String, Object&gt; model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(id);  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.info(user.toString());</span><br><span class="line">        return user;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // /user/&#123;id&#125;</span><br><span class="line">    @RequestMapping(value=&quot;/jsontype/&#123;id&#125;&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public ResponseEntity&lt;User&gt;  getUserInJson2(@PathVariable String id,Map&lt;String, Object&gt; model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(id);  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.info(user.toString());</span><br><span class="line">        return new ResponseEntity&lt;User&gt;(user,HttpStatus.OK);  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    //文件上传、</span><br><span class="line">    @RequestMapping(value=&quot;/upload&quot;)</span><br><span class="line">    public String showUploadPage()&#123;</span><br><span class="line">        return &quot;user_admin/file&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value=&quot;/doUpload&quot;,method=RequestMethod.POST)</span><br><span class="line">    public String doUploadFile(@RequestParam(&quot;file&quot;)MultipartFile file) throws IOException&#123;</span><br><span class="line">        if (!file.isEmpty()) &#123;</span><br><span class="line">            log.info(&quot;Process file:&#123;&#125;&quot;,file.getOriginalFilename());</span><br><span class="line">        &#125;</span><br><span class="line">        FileUtils.copyInputStreamToFile(file.getInputStream(), new File(&quot;E:\\&quot;,System.currentTimeMillis()+file.getOriginalFilename()));</span><br><span class="line">        return &quot;succes&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="新建jsp页面"><a href="#新建jsp页面" class="headerlink" title="新建jsp页面"></a>新建jsp页面</h3><p>file.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;</span><br><span class="line">    pageEncoding=&quot;utf-8&quot;%&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;上传文件&lt;/h1&gt;</span><br><span class="line">    &lt;form method=&quot;post&quot; action=&quot;/user/doUpload&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>index.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">showUser.jsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;  </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;  </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">  &lt;head&gt;  </span><br><span class="line">    &lt;title&gt;测试&lt;/title&gt;  </span><br><span class="line">  &lt;/head&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;body&gt;  </span><br><span class="line">    $&#123;user.userName&#125;  </span><br><span class="line">  &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;  </span><br></pre></td></tr></table></figure>

<p>至此，完成Spring+SpingMVC+mybatis这三大框架整合完成。</p>
<pre><code>参考博客：http://blog.csdn.net/gebitan505/article/details/44455235
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy-dnc，rnn，lstm</title>
    <url>/2021/09/21/numpy-dnc%EF%BC%8Crnn%EF%BC%8Clstm/</url>
    <content><![CDATA[<h1 id="NumPy-中的微分神经计算"><a href="#NumPy-中的微分神经计算" class="headerlink" title="NumPy 中的微分神经计算"></a>NumPy 中的微分神经计算</h1><p>可微分神经计算 <a href="https://www.nature.com/article/nature20101">https://www.nature.com/article/nature20101</a> 的实现尽可能接近于本文的描述。任务：char-level 预测。报告还包括简单RNN(RNN-numpy.py)和LSTM(LSTM-numpy.py)。一些外部数据(ptb、wiki)需要单独下载。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python dnc-debug.py</span><br></pre></td></tr></table></figure>

<p>这些版本已完成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python rnn-numpy.py</span><br><span class="line">python lstm-numpy.py</span><br><span class="line">python dnc-numpy.py</span><br></pre></td></tr></table></figure>

<h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><p>RNN代码基于A.Karpath(min-char-rnn.py)的原始工作</p>
<p>gist: <a href="https://gist.github.com/karpathy/d4dee566867f8291f086">https://gist.github.com/karpathy/d4dee566867f8291f086</a></p>
<p>文章: <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">http://karpathy.github.io/2015/05/21/rnn-effectiveness/</a></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>RNN版本仍然依赖numpy</li>
<li>添加批处理</li>
<li>将RNN修改为LSTM</li>
<li>包括梯度检测</li>
</ul>
<h3 id="DNC"><a href="#DNC" class="headerlink" title="DNC"></a>DNC</h3><p><strong>实施</strong></p>
<ul>
<li>LSTM控制器</li>
<li>2D存储器数组</li>
<li>内容可寻址的读/写</li>
</ul>
<p><strong>问题</strong></p>
<p>关键相似度的softmax会导致崩溃（除以0） - 如果遇到这种情况，需要重新启动</p>
<p><strong>将要做</strong></p>
<ul>
<li>动态内存分配/自由</li>
<li>更快的实现（使用PyTorch？）</li>
<li>保存模型</li>
<li>例子</li>
</ul>
<h3 id="示例输出："><a href="#示例输出：" class="headerlink" title="示例输出："></a>示例输出：</h3><p>时间，迭代，BPC（预测误差 - &gt;每个字符的位数，越低越好），处理速度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="number">4163.009</span> s, <span class="built_in">iter</span> <span class="number">104800</span>, <span class="number">1.2808</span> BPC, <span class="number">1488.38</span> char/s</span><br></pre></td></tr></table></figure>

<h3 id="模型中的样本（alice29-txt）："><a href="#模型中的样本（alice29-txt）：" class="headerlink" title="模型中的样本（alice29.txt）："></a>模型中的样本（alice29.txt）：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> e garden <span class="keyword">as</span> she very dunced.</span><br><span class="line">                  </span><br><span class="line">  Alice fighting be it.  The breats?</span><br><span class="line">              here on likegs voice withoup.</span><br><span class="line">                                                                               </span><br><span class="line">  `You minced more hal disheze, <span class="keyword">and</span> I done hippertyou-sage, who say it<span class="string">&#x27;s a look down whales that</span></span><br><span class="line"><span class="string">his meckling moruste!&#x27;</span> said Alice<span class="string">&#x27;s can younderen, in they puzzled to them!&#x27;</span></span><br><span class="line">     </span><br><span class="line">  `Of betinkling reple bade to, punthery pormoved the piose himble, of to he see foudhed</span><br><span class="line">just rounds, seef wance side pigs, it addeal sumprked.</span><br><span class="line">                                                                                    </span><br><span class="line">  `As <span class="keyword">or</span> the Gryphon,<span class="string">&#x27; Alice said,</span></span><br><span class="line"><span class="string">Fith didn&#x27;</span>t begun, <span class="keyword">and</span> she garden <span class="keyword">as</span> <span class="keyword">in</span> a who tew.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">  Hat hed think after as marman as much the pirly</span></span><br><span class="line"><span class="string">startares to dreaps</span></span><br><span class="line"><span class="string">was one poon it                                                                           </span></span><br><span class="line"><span class="string">out him were brived they                                                        </span></span><br><span class="line"><span class="string">proce?                                                                                    </span></span><br><span class="line"><span class="string">                                                                                 </span></span><br><span class="line"><span class="string">                                                                                          </span></span><br><span class="line"><span class="string">  CHAT, I fary,&#x27;</span> said the Hat,<span class="string">&#x27; said the Divery tionly to himpos.&#x27;</span>               </span><br><span class="line">                                                                                          </span><br><span class="line">  `Com, planere?<span class="string">&quot;&#x27;                                                               </span></span><br><span class="line"><span class="string">                                                                                          </span></span><br><span class="line"><span class="string">  `Ica--&#x27;                                                                        </span></span><br><span class="line"><span class="string">            Onlice IN&#x27;s tread!  Wonderieving again, `but her rist,&#x27; said Alice.           </span></span><br><span class="line"><span class="string">                                                                                 </span></span><br><span class="line"><span class="string">                                                                                          </span></span><br><span class="line"><span class="string">  She                                                                            </span></span><br><span class="line"><span class="string">sea do voice.                                                                             </span></span><br><span class="line"><span class="string">                                                                                 </span></span><br><span class="line"><span class="string">  `I&#x27;mm the Panthing alece of the when beaning must anquerrouted not reclow, sobs to      </span></span><br><span class="line"><span class="string">                                                                                 </span></span><br><span class="line"><span class="string">  `In of queer behind her houn&#x27;t seemed                                                   </span></span><br></pre></td></tr></table></figure>

<h3 id="检查反向传递的数值梯度（最右边的列应该具有值-lt-1e-4）"><a href="#检查反向传递的数值梯度（最右边的列应该具有值-lt-1e-4）" class="headerlink" title="检查反向传递的数值梯度（最右边的列应该具有值&lt;1e-4）;"></a>检查反向传递的数值梯度（最右边的列应该具有值&lt;1e-4）;</h3><p>中间列具有计算的分析和数值梯度范围（这些应该更多/更少）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">----</span><br><span class="line">GRAD CHECK</span><br><span class="line"></span><br><span class="line">Wxh:            n = [-<span class="number">1.828500e-02</span>, <span class="number">5.292866e-03</span>]       <span class="built_in">min</span> <span class="number">3.005175e-09</span>, <span class="built_in">max</span> <span class="number">3.505012e-07</span></span><br><span class="line">                a = [-<span class="number">1.828500e-02</span>, <span class="number">5.292865e-03</span>]       mean <span class="number">5.158434e-08</span> <span class="comment"># 10/4</span></span><br><span class="line">Whh:            n = [-<span class="number">3.614049e-01</span>, <span class="number">6.580141e-01</span>]       <span class="built_in">min</span> <span class="number">1.549311e-10</span>, <span class="built_in">max</span> <span class="number">4.349188e-08</span></span><br><span class="line">                a = [-<span class="number">3.614049e-01</span>, <span class="number">6.580141e-01</span>]       mean <span class="number">9.340821e-09</span> <span class="comment"># 10/10</span></span><br><span class="line">Why:            n = [-<span class="number">9.868277e-02</span>, <span class="number">7.518284e-02</span>]       <span class="built_in">min</span> <span class="number">2.378911e-09</span>, <span class="built_in">max</span> <span class="number">1.901067e-05</span></span><br><span class="line">                a = [-<span class="number">9.868276e-02</span>, <span class="number">7.518284e-02</span>]       mean <span class="number">1.978080e-06</span> <span class="comment"># 10/10</span></span><br><span class="line">Whr:            n = [-<span class="number">3.652128e-02</span>, <span class="number">1.372321e-01</span>]       <span class="built_in">min</span> <span class="number">5.520914e-09</span>, <span class="built_in">max</span> <span class="number">6.750276e-07</span></span><br><span class="line">                a = [-<span class="number">3.652128e-02</span>, <span class="number">1.372321e-01</span>]       mean <span class="number">1.299713e-07</span> <span class="comment"># 10/10</span></span><br><span class="line">Whv:            n = [-<span class="number">1.065475e+00</span>, <span class="number">4.634808e-01</span>]       <span class="built_in">min</span> <span class="number">6.701966e-11</span>, <span class="built_in">max</span> <span class="number">1.462031e-08</span></span><br><span class="line">                a = [-<span class="number">1.065475e+00</span>, <span class="number">4.634808e-01</span>]       mean <span class="number">4.161271e-09</span> <span class="comment"># 10/10</span></span><br><span class="line">Whw:            n = [-<span class="number">1.677826e-01</span>, <span class="number">1.803906e-01</span>]       <span class="built_in">min</span> <span class="number">5.559963e-10</span>, <span class="built_in">max</span> <span class="number">1.096433e-07</span></span><br><span class="line">                a = [-<span class="number">1.677826e-01</span>, <span class="number">1.803906e-01</span>]       mean <span class="number">2.434751e-08</span> <span class="comment"># 10/10</span></span><br><span class="line">Whe:            n = [-<span class="number">2.791997e-02</span>, <span class="number">1.487244e-02</span>]       <span class="built_in">min</span> <span class="number">3.806438e-08</span>, <span class="built_in">max</span> <span class="number">8.633199e-06</span></span><br><span class="line">                a = [-<span class="number">2.791997e-02</span>, <span class="number">1.487244e-02</span>]       mean <span class="number">1.085696e-06</span> <span class="comment"># 10/10</span></span><br><span class="line">Wrh:            n = [-<span class="number">7.319636e-02</span>, <span class="number">9.466716e-02</span>]       <span class="built_in">min</span> <span class="number">4.183225e-09</span>, <span class="built_in">max</span> <span class="number">1.369062e-07</span></span><br><span class="line">                a = [-<span class="number">7.319636e-02</span>, <span class="number">9.466716e-02</span>]       mean <span class="number">3.677372e-08</span> <span class="comment"># 10/10</span></span><br><span class="line">Wry:            n = [-<span class="number">1.191088e-01</span>, <span class="number">5.271329e-01</span>]       <span class="built_in">min</span> <span class="number">1.168224e-09</span>, <span class="built_in">max</span> <span class="number">1.568242e-04</span></span><br><span class="line">                a = [-<span class="number">1.191088e-01</span>, <span class="number">5.271329e-01</span>]       mean <span class="number">2.827306e-05</span> <span class="comment"># 10/10</span></span><br><span class="line">bh:             n = [-<span class="number">1.363950e+00</span>, <span class="number">9.144058e-01</span>]       <span class="built_in">min</span> <span class="number">2.473756e-10</span>, <span class="built_in">max</span> <span class="number">5.217119e-08</span></span><br><span class="line">                a = [-<span class="number">1.363950e+00</span>, <span class="number">9.144058e-01</span>]       mean <span class="number">7.066159e-09</span> <span class="comment"># 10/10</span></span><br><span class="line">by:             n = [-<span class="number">5.594528e-02</span>, <span class="number">5.814085e-01</span>]       <span class="built_in">min</span> <span class="number">1.604237e-09</span>, <span class="built_in">max</span> <span class="number">1.017124e-05</span></span><br><span class="line">                a = [-<span class="number">5.594528e-02</span>, <span class="number">5.814085e-01</span>]       mean <span class="number">1.026833e-06</span> <span class="comment"># 10/10</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy-k均值聚类</title>
    <url>/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="NumPy-实现k均值聚类算法（k-means）"><a href="#NumPy-实现k均值聚类算法（k-means）" class="headerlink" title="NumPy 实现k均值聚类算法（k-means）"></a>NumPy 实现k均值聚类算法（k-means）</h1><p>机器学习算法与Python实践这个系列主要是参考《机器学习实战》这本书。因为自己想学习Python，然后也想对一些机器学习算法加深下了解，所以就想通过Python来实现几个比较常用的机器学习算法。恰好遇见这本同样定位的书籍，所以就参考这本书的过程来学习了。</p>
<p>机器学习中有两类的大问题，一个是分类，一个是聚类。分类是根据一些给定的已知类别标号的样本，训练某种学习机器，使它能够对未知类别的样本进行分类。这属于supervised learning（监督学习）。而聚类指事先并不知道任何样本的类别标号，希望通过某种算法来把一组未知类别的样本划分成若干类别，这在机器学习中被称作 unsupervised learning （无监督学习）。在本文中，我们关注其中一个比较简单的聚类算法：k-means算法。</p>
<h2 id="k-means算法简介"><a href="#k-means算法简介" class="headerlink" title="k-means算法简介"></a>k-means算法简介</h2><p>通常，人们根据样本间的某种距离或者相似性来定义聚类，即把相似的（或距离近的）样本聚为同一类，而把不相似的（或距离远的）样本归在其他类。</p>
<p>我们以一个二维的例子来说明下聚类的目的。如下图左所示，假设我们的n个样本点分布在图中所示的二维空间。从数据点的大致形状可以看出它们大致聚为三个cluster，其中两个紧凑一些，剩下那个松散一些。我们的目的是为这些数据分组，以便能区分出属于不同的簇的数据，如果按照分组给它们标上不同的颜色，就是像下图右边的图那样：</p>
<p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226190225921.png" alt="聚类对比图"></p>
<p>如果人可以看到像上图那样的数据分布，就可以轻松进行聚类。但我们怎么教会计算机按照我们的思维去做同样的事情呢？这里就介绍个集简单和经典于一身的k-means算法。</p>
<p>k-means算法是一种很常见的聚类算法，它的基本思想是：通过迭代寻找k个聚类的一种划分方案，使得用这k个聚类的均值来代表相应各类样本时所得的总体误差最小。</p>
<p>k-means算法的基础是最小误差平方和准则。其代价函数是：</p>
<p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226190316156.png" alt="代价函数"></p>
<p>上式中，μc(i)表示第i个聚类的均值。我们希望代价函数最小，直观的来说，各类内的样本越相似，其与该类均值间的误差平方越小，对所有类所得到的误差平方求和，即可验证分为k类时，各聚类是否是最优的。</p>
<p>上式的代价函数无法用解析的方法最小化，只能有迭代的方法。k-means算法是将样本聚类成 k个簇（cluster），其中k是用户给定的，其求解过程非常直观简单，具体算法描述如下：</p>
<ol>
<li>随机选取 k个聚类质心点</li>
<li>重复下面过程直到收敛<ul>
<li>对于每一个样例 i，计算其应该属于的类： <img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191250687.png" alt="计算其应该属于的类"></li>
<li>对于每一个类 j，重新计算该类的质心： <img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191306718.png" alt="重新计算质心"></li>
</ul>
</li>
</ol>
<p>下图展示了对n个样本点进行K-means聚类的效果，这里k取2。</p>
<p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191321406.png" alt="聚类效果"></p>
<p>其伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建k个点作为初始的质心点（随机选择）</span><br><span class="line">当任意一个点的簇分配结果发生改变时</span><br><span class="line">    对数据集中的每一个数据点</span><br><span class="line">        对每一个质心</span><br><span class="line">            计算质心与数据点的距离</span><br><span class="line">        将数据点分配到距离最近的簇</span><br><span class="line">    对每一个簇，计算簇中所有点的均值，并将均值作为质心</span><br></pre></td></tr></table></figure>

<h2 id="Numpy-实现"><a href="#Numpy-实现" class="headerlink" title="Numpy 实现"></a>Numpy 实现</h2><p>我使用的Python是2.7.5版本的。附加的库有Numpy和Matplotlib。具体的安装和配置见前面的博文。在代码中已经有了比较详细的注释了。不知道有没有错误的地方，如果有，还望大家指正（每次的运行结果都有可能不同）。里面我写了个可视化结果的函数，但只能在二维的数据上面使用。直接贴代码：</p>
<p>kmeans.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment"># kmeans: k-means cluster</span></span><br><span class="line"><span class="comment"># Author : zouxy</span></span><br><span class="line"><span class="comment"># Date   : 2013-12-25</span></span><br><span class="line"><span class="comment"># HomePage : http://blog.csdn.net/zouxy09</span></span><br><span class="line"><span class="comment"># Email  : zouxy09@qq.com</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate Euclidean distance</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclDistance</span>(<span class="params">vector1, vector2</span>):</span></span><br><span class="line">	<span class="keyword">return</span> sqrt(<span class="built_in">sum</span>(power(vector2 - vector1, <span class="number">2</span>)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># init centroids with random samples</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCentroids</span>(<span class="params">dataSet, k</span>):</span></span><br><span class="line">	numSamples, dim = dataSet.shape</span><br><span class="line">	centroids = zeros((k, dim))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">		index = <span class="built_in">int</span>(random.uniform(<span class="number">0</span>, numSamples))</span><br><span class="line">		centroids[i, :] = dataSet[index, :]</span><br><span class="line">	<span class="keyword">return</span> centroids</span><br><span class="line"> </span><br><span class="line"><span class="comment"># k-means cluster</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span>(<span class="params">dataSet, k</span>):</span></span><br><span class="line">	numSamples = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">	<span class="comment"># first column stores which cluster this sample belongs to,</span></span><br><span class="line">	<span class="comment"># second column stores the error between this sample and its centroid</span></span><br><span class="line">	clusterAssment = mat(zeros((numSamples, <span class="number">2</span>)))</span><br><span class="line">	clusterChanged = <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">## step 1: init centroids</span></span><br><span class="line">	centroids = initCentroids(dataSet, k)</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> clusterChanged:</span><br><span class="line">		clusterChanged = <span class="literal">False</span></span><br><span class="line">		<span class="comment">## for each sample</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> xrange(numSamples):</span><br><span class="line">			minDist  = <span class="number">100000.0</span></span><br><span class="line">			minIndex = <span class="number">0</span></span><br><span class="line">			<span class="comment">## for each centroid</span></span><br><span class="line">			<span class="comment">## step 2: find the centroid who is closest</span></span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">				distance = euclDistance(centroids[j, :], dataSet[i, :])</span><br><span class="line">				<span class="keyword">if</span> distance &lt; minDist:</span><br><span class="line">					minDist  = distance</span><br><span class="line">					minIndex = j</span><br><span class="line">			</span><br><span class="line">			<span class="comment">## step 3: update its cluster</span></span><br><span class="line">			<span class="keyword">if</span> clusterAssment[i, <span class="number">0</span>] != minIndex:</span><br><span class="line">				clusterChanged = <span class="literal">True</span></span><br><span class="line">				clusterAssment[i, :] = minIndex, minDist**<span class="number">2</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">## step 4: update centroids</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">			pointsInCluster = dataSet[nonzero(clusterAssment[:, <span class="number">0</span>].A == j)[<span class="number">0</span>]]</span><br><span class="line">			centroids[j, :] = mean(pointsInCluster, axis = <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;Congratulations, cluster complete!&#x27;</span></span><br><span class="line">	<span class="keyword">return</span> centroids, clusterAssment</span><br><span class="line"> </span><br><span class="line"><span class="comment"># show your cluster only available with 2-D data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showCluster</span>(<span class="params">dataSet, k, centroids, clusterAssment</span>):</span></span><br><span class="line">	numSamples, dim = dataSet.shape</span><br><span class="line">	<span class="keyword">if</span> dim != <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;Sorry! I can not draw because the dimension of your data is not 2!&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">	mark = [<span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;ob&#x27;</span>, <span class="string">&#x27;og&#x27;</span>, <span class="string">&#x27;ok&#x27;</span>, <span class="string">&#x27;^r&#x27;</span>, <span class="string">&#x27;+r&#x27;</span>, <span class="string">&#x27;sr&#x27;</span>, <span class="string">&#x27;dr&#x27;</span>, <span class="string">&#x27;&lt;r&#x27;</span>, <span class="string">&#x27;pr&#x27;</span>]</span><br><span class="line">	<span class="keyword">if</span> k &gt; <span class="built_in">len</span>(mark):</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;Sorry! Your k is too large! please contact Zouxy&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment"># draw all samples</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> xrange(numSamples):</span><br><span class="line">		markIndex = <span class="built_in">int</span>(clusterAssment[i, <span class="number">0</span>])</span><br><span class="line">		plt.plot(dataSet[i, <span class="number">0</span>], dataSet[i, <span class="number">1</span>], mark[markIndex])</span><br><span class="line"> </span><br><span class="line">	mark = [<span class="string">&#x27;Dr&#x27;</span>, <span class="string">&#x27;Db&#x27;</span>, <span class="string">&#x27;Dg&#x27;</span>, <span class="string">&#x27;Dk&#x27;</span>, <span class="string">&#x27;^b&#x27;</span>, <span class="string">&#x27;+b&#x27;</span>, <span class="string">&#x27;sb&#x27;</span>, <span class="string">&#x27;db&#x27;</span>, <span class="string">&#x27;&lt;b&#x27;</span>, <span class="string">&#x27;pb&#x27;</span>]</span><br><span class="line">	<span class="comment"># draw the centroids</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">		plt.plot(centroids[i, <span class="number">0</span>], centroids[i, <span class="number">1</span>], mark[i], markersize = <span class="number">12</span>)</span><br><span class="line"> </span><br><span class="line">	plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试数据是二维的，共80个样本。有4个类。如下：</p>
<h3 id="testSet-txt："><a href="#testSet-txt：" class="headerlink" title="testSet.txt："></a>testSet.txt：</h3><p>测试结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.658985</span>	<span class="number">4.285136</span></span><br><span class="line">-<span class="number">3.453687</span>	<span class="number">3.424321</span></span><br><span class="line"><span class="number">4.838138</span>	-<span class="number">1.151539</span></span><br><span class="line">-<span class="number">5.379713</span>	-<span class="number">3.362104</span></span><br><span class="line"><span class="number">0.972564</span>	<span class="number">2.924086</span></span><br><span class="line">-<span class="number">3.567919</span>	<span class="number">1.531611</span></span><br><span class="line"><span class="number">0.450614</span>	-<span class="number">3.302219</span></span><br><span class="line">-<span class="number">3.487105</span>	-<span class="number">1.724432</span></span><br><span class="line"><span class="number">2.668759</span>	<span class="number">1.594842</span></span><br><span class="line">-<span class="number">3.156485</span>	<span class="number">3.191137</span></span><br><span class="line"><span class="number">3.165506</span>	-<span class="number">3.999838</span></span><br><span class="line">-<span class="number">2.786837</span>	-<span class="number">3.099354</span></span><br><span class="line"><span class="number">4.208187</span>	<span class="number">2.984927</span></span><br><span class="line">-<span class="number">2.123337</span>	<span class="number">2.943366</span></span><br><span class="line"><span class="number">0.704199</span>	-<span class="number">0.479481</span></span><br><span class="line">-<span class="number">0.392370</span>	-<span class="number">3.963704</span></span><br><span class="line"><span class="number">2.831667</span>	<span class="number">1.574018</span></span><br><span class="line">-<span class="number">0.790153</span>	<span class="number">3.343144</span></span><br><span class="line"><span class="number">2.943496</span>	-<span class="number">3.357075</span></span><br><span class="line">-<span class="number">3.195883</span>	-<span class="number">2.283926</span></span><br><span class="line"><span class="number">2.336445</span>	<span class="number">2.875106</span></span><br><span class="line">-<span class="number">1.786345</span>	<span class="number">2.554248</span></span><br><span class="line"><span class="number">2.190101</span>	-<span class="number">1.906020</span></span><br><span class="line">-<span class="number">3.403367</span>	-<span class="number">2.778288</span></span><br><span class="line"><span class="number">1.778124</span>	<span class="number">3.880832</span></span><br><span class="line">-<span class="number">1.688346</span>	<span class="number">2.230267</span></span><br><span class="line"><span class="number">2.592976</span>	-<span class="number">2.054368</span></span><br><span class="line">-<span class="number">4.007257</span>	-<span class="number">3.207066</span></span><br><span class="line"><span class="number">2.257734</span>	<span class="number">3.387564</span></span><br><span class="line">-<span class="number">2.679011</span>	<span class="number">0.785119</span></span><br><span class="line"><span class="number">0.939512</span>	-<span class="number">4.023563</span></span><br><span class="line">-<span class="number">3.674424</span>	-<span class="number">2.261084</span></span><br><span class="line"><span class="number">2.046259</span>	<span class="number">2.735279</span></span><br><span class="line">-<span class="number">3.189470</span>	<span class="number">1.780269</span></span><br><span class="line"><span class="number">4.372646</span>	-<span class="number">0.822248</span></span><br><span class="line">-<span class="number">2.579316</span>	-<span class="number">3.497576</span></span><br><span class="line"><span class="number">1.889034</span>	<span class="number">5.190400</span></span><br><span class="line">-<span class="number">0.798747</span>	<span class="number">2.185588</span></span><br><span class="line"><span class="number">2.836520</span>	-<span class="number">2.658556</span></span><br><span class="line">-<span class="number">3.837877</span>	-<span class="number">3.253815</span></span><br><span class="line"><span class="number">2.096701</span>	<span class="number">3.886007</span></span><br><span class="line">-<span class="number">2.709034</span>	<span class="number">2.923887</span></span><br><span class="line"><span class="number">3.367037</span>	-<span class="number">3.184789</span></span><br><span class="line">-<span class="number">2.121479</span>	-<span class="number">4.232586</span></span><br><span class="line"><span class="number">2.329546</span>	<span class="number">3.179764</span></span><br><span class="line">-<span class="number">3.284816</span>	<span class="number">3.273099</span></span><br><span class="line"><span class="number">3.091414</span>	-<span class="number">3.815232</span></span><br><span class="line">-<span class="number">3.762093</span>	-<span class="number">2.432191</span></span><br><span class="line"><span class="number">3.542056</span>	<span class="number">2.778832</span></span><br><span class="line">-<span class="number">1.736822</span>	<span class="number">4.241041</span></span><br><span class="line"><span class="number">2.127073</span>	-<span class="number">2.983680</span></span><br><span class="line">-<span class="number">4.323818</span>	-<span class="number">3.938116</span></span><br><span class="line"><span class="number">3.792121</span>	<span class="number">5.135768</span></span><br><span class="line">-<span class="number">4.786473</span>	<span class="number">3.358547</span></span><br><span class="line"><span class="number">2.624081</span>	-<span class="number">3.260715</span></span><br><span class="line">-<span class="number">4.009299</span>	-<span class="number">2.978115</span></span><br><span class="line"><span class="number">2.493525</span>	<span class="number">1.963710</span></span><br><span class="line">-<span class="number">2.513661</span>	<span class="number">2.642162</span></span><br><span class="line"><span class="number">1.864375</span>	-<span class="number">3.176309</span></span><br><span class="line">-<span class="number">3.171184</span>	-<span class="number">3.572452</span></span><br><span class="line"><span class="number">2.894220</span>	<span class="number">2.489128</span></span><br><span class="line">-<span class="number">2.562539</span>	<span class="number">2.884438</span></span><br><span class="line"><span class="number">3.491078</span>	-<span class="number">3.947487</span></span><br><span class="line">-<span class="number">2.565729</span>	-<span class="number">2.012114</span></span><br><span class="line"><span class="number">3.332948</span>	<span class="number">3.983102</span></span><br><span class="line">-<span class="number">1.616805</span>	<span class="number">3.573188</span></span><br><span class="line"><span class="number">2.280615</span>	-<span class="number">2.559444</span></span><br><span class="line">-<span class="number">2.651229</span>	-<span class="number">3.103198</span></span><br><span class="line"><span class="number">2.321395</span>	<span class="number">3.154987</span></span><br><span class="line">-<span class="number">1.685703</span>	<span class="number">2.939697</span></span><br><span class="line"><span class="number">3.031012</span>	-<span class="number">3.620252</span></span><br><span class="line">-<span class="number">4.599622</span>	-<span class="number">2.185829</span></span><br><span class="line"><span class="number">4.196223</span>	<span class="number">1.126677</span></span><br><span class="line">-<span class="number">2.133863</span>	<span class="number">3.093686</span></span><br><span class="line"><span class="number">4.668892</span>	-<span class="number">2.562705</span></span><br><span class="line">-<span class="number">2.793241</span>	-<span class="number">2.149706</span></span><br><span class="line"><span class="number">2.884105</span>	<span class="number">3.043438</span></span><br><span class="line">-<span class="number">2.967647</span>	<span class="number">2.848696</span></span><br><span class="line"><span class="number">4.479332</span>	-<span class="number">1.764772</span></span><br><span class="line">-<span class="number">4.905566</span>	-<span class="number">2.911070</span></span><br></pre></td></tr></table></figure>

<h3 id="test-kmeans-py"><a href="#test-kmeans-py" class="headerlink" title="test_kmeans.py"></a>test_kmeans.py</h3><p>测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment"># kmeans: k-means cluster</span></span><br><span class="line"><span class="comment"># Author : zouxy</span></span><br><span class="line"><span class="comment"># Date   : 2013-12-25</span></span><br><span class="line"><span class="comment"># HomePage : http://blog.csdn.net/zouxy09</span></span><br><span class="line"><span class="comment"># Email  : zouxy09@qq.com</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment">## step 1: load data</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;step 1: load data...&quot;</span></span><br><span class="line">dataSet = []</span><br><span class="line">fileIn = <span class="built_in">open</span>(<span class="string">&#x27;E:/Python/Machine Learning in Action/testSet.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileIn.readlines():</span><br><span class="line">	lineArr = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">	dataSet.append([<span class="built_in">float</span>(lineArr[<span class="number">0</span>]), <span class="built_in">float</span>(lineArr[<span class="number">1</span>])])</span><br><span class="line"> </span><br><span class="line"><span class="comment">## step 2: clustering...</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;step 2: clustering...&quot;</span></span><br><span class="line">dataSet = mat(dataSet)</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">centroids, clusterAssment = kmeans(dataSet, k)</span><br><span class="line"> </span><br><span class="line"><span class="comment">## step 3: show the result</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;step 3: show the result...&quot;</span></span><br><span class="line">showCluster(dataSet, k, centroids, clusterAssment)</span><br></pre></td></tr></table></figure>

<p>运行的前后结果对比：</p>
<p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191526187.png" alt="结果对比"></p>
<p>不同的类用不同的颜色来表示，其中的大菱形是对应类的均值质心点。</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>k-means算法比较简单，但也有几个比较大的缺点：</p>
<ul>
<li>（1）k值的选择是用户指定的，不同的k得到的结果会有挺大的不同，如下图所示，左边是k=3的结果，这个就太稀疏了，蓝色的那个簇其实是可以再划分成两个簇的。而右图是k=5的结果，可以看到红色菱形和蓝色菱形这两个簇应该是可以合并成一个簇的：</li>
</ul>
<p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191547703.png" alt="不同结果"></p>
<ul>
<li>（2）对k个初始质心的选择比较敏感，容易陷入局部最小值。例如，我们上面的算法运行的时候，有可能会得到不同的结果，如下面这两种情况。K-means也是收敛了，只是收敛到了局部最小值：</li>
</ul>
<p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191601093.png" alt="局部最优解"></p>
<ul>
<li>（3）存在局限性，如下面这种非球状的数据分布就搞不定了：</li>
</ul>
<p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191615171.png" alt="非球状的数据分布"></p>
<ul>
<li>（4）数据库比较大的时候，收敛会比较慢。</li>
</ul>
<p>k-means老早就出现在江湖了。所以以上的这些不足也被世人的目光敏锐的捕捉到，并融入世人的智慧进行了某种程度上的改良。例如问题（1）对k的选择可以先用一些算法分析数据的分布，如重心和密度等，然后选择合适的k。而对问题（2），有人提出了另一个成为二分k均值（bisecting k-means）算法，它对初始的k个质心的选择就不太敏感，这个算法我们下一个博文再分析和实现。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy中的矩阵和向量</title>
    <url>/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<h1 id="NumPy-中的矩阵和向量"><a href="#NumPy-中的矩阵和向量" class="headerlink" title="NumPy 中的矩阵和向量"></a>NumPy 中的矩阵和向量</h1><p>numpy的<code>ndarray</code>类用于表示矩阵和向量。 要在numpy中构造矩阵，我们在列表中列出矩阵的行， 并将该列表传递给numpy数组构造函数。</p>
<p>例如，构造与矩阵对应的numpy数组</p>
<p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA1.png" alt="矩阵1"></p>
<p>我们会这样做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>]])</span><br></pre></td></tr></table></figure>

<p>向量只是具有单列的数组。 例如，构建向量</p>
<p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA2.png" alt="矩阵2"></p>
<p>我们会这样做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = np.array([[<span class="number">2</span>],[<span class="number">1</span>],[<span class="number">3</span>]])</span><br></pre></td></tr></table></figure>

<p>更方便的方法是转置相应的行向量。 例如，为了使上面的矢量，我们可以改为转置行向量</p>
<p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA3.png" alt="矩阵3"></p>
<p>这个代码是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = np.transpose(np.array([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]))</span><br></pre></td></tr></table></figure>

<p>numpy重载数组索引和切片符号以访问矩阵的各个部分。 例如，要打印矩阵A中的右下方条目，我们会这样做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(A[<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>要切出A矩阵中的第二列，我们会这样做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col = A[:,<span class="number">1</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>第一个切片选择A中的所有行，而第二个切片仅选择每行中的中间条目。</p>
<p>要进行矩阵乘法或矩阵向量乘法，我们使用np.dot()方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = np.dot(A,v)</span><br></pre></td></tr></table></figure>

<h2 id="用numpy求解方程组"><a href="#用numpy求解方程组" class="headerlink" title="用numpy求解方程组"></a>用numpy求解方程组</h2><p>线性代数中比较常见的问题之一是求解矩阵向量方程。 这是一个例子。 我们寻找解决方程的向量x</p>
<p><em>A</em> <strong>x</strong> = <strong>b</strong></p>
<p>当</p>
<p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA4.png" alt="矩阵4"></p>
<p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA5.png" alt="矩阵5"></p>
<p>我们首先构建A和b的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">2</span>,<span class="number">1</span>,-<span class="number">2</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]])</span><br><span class="line">b = np.transpose(np.array([[-<span class="number">3</span>,<span class="number">5</span>,-<span class="number">2</span>]]))</span><br></pre></td></tr></table></figure>

<p>为了解决这个系统</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.linalg.solve(A,b)</span><br></pre></td></tr></table></figure>

<h2 id="应用：多元线性回归"><a href="#应用：多元线性回归" class="headerlink" title="应用：多元线性回归"></a>应用：多元线性回归</h2><p>在多元回归问题中，我们寻找一种能够将输入数据点映射到结果值的函数。 每个数据点是<em>特征向量（x1，x2，…，xm）</em>，由两个或多个捕获输入的各种特征的数据值组成。为了表示所有输入数据以及输出值的向量，我们设置了输入矩阵X和输出向量 <strong>y</strong>：</p>
<p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA6.png" alt="矩阵6"></p>
<p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA7.png" alt="矩阵7"></p>
<p>在简单的最小二乘线性回归模型中，我们寻找向量<strong>β</strong>，使得乘积Xβ最接近结果向量 <strong>y</strong>。</p>
<p>一旦我们构建了<strong>β</strong>向量，我们就可以使用它将输入数据映射到预测结果。 给定表单中的输入向量</p>
<p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA8.png" alt="矩阵8"></p>
<p>我们可以计算预测结果值</p>
<p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA9.png" alt="矩阵9"></p>
<p>计算β向量的公式是</p>
<p><strong>β</strong> = (<em>X**T</em> <em>X</em>)-1 <em>X**T</em> <strong>y</strong></p>
<p>在我们的下一个示例程序中，我将使用numpy构造适当的矩阵和向量并求解<strong>β</strong>向量。一旦我们解决了<strong>β</strong>，我们将使用它来预测我们最初从输入数据集中遗漏的一些测试数据点。</p>
<p>假设我们在numpy中构造了输入矩阵X和结果向量<strong>y</strong>，下面的代码将计算<strong>β</strong>向量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Xt = np.transpose(X)</span><br><span class="line">XtX = np.dot(Xt,X)</span><br><span class="line">Xty = np.dot(Xt,y)</span><br><span class="line">beta = np.linalg.solve(XtX,Xty)</span><br></pre></td></tr></table></figure>

<p>最后一行使用<code>np.linalg.solve</code>计算<strong>β</strong>，因为等式是：</p>
<p><strong>β</strong> = (<em>X**T</em> <em>X</em>)-1 <em>X**T</em> <strong>y</strong></p>
<p>在数学上等价于方程组：</p>
<p>(<em>X**T</em> <em>X</em>) <strong>β</strong> = <em>X**T</em> <strong>y</strong></p>
<p>我将用于此示例的数据集是Windsor房价数据集，其中包含有关安大略省温莎市区房屋销售的信息。 输入变量涵盖了可能对房价产生影响的一系列因素，例如批量大小，卧室数量以及各种设施的存在。<a href="http://www2.lawrence.edu/fast/GREGGJ/Python/numpy/Housing.csv">此处</a>提供具有完整数据集的CSV文件。我从<a href="https://vincentarelbundock.github.io/Rdatasets/datasets.html">这个网站</a>下载了数据集，该网站提供了大量涵盖大量主题的数据集。</p>
<p>这里现在是示例程序的源代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readData</span>():</span></span><br><span class="line">    X = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Housing.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        rdr = csv.reader(f)</span><br><span class="line">        <span class="comment"># Skip the header row</span></span><br><span class="line">        <span class="built_in">next</span>(rdr)</span><br><span class="line">        <span class="comment"># Read X and y</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> rdr:</span><br><span class="line">            xline = [<span class="number">1.0</span>]</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> line[:-<span class="number">1</span>]:</span><br><span class="line">                xline.append(<span class="built_in">float</span>(s))</span><br><span class="line">            X.append(xline)</span><br><span class="line">            y.append(<span class="built_in">float</span>(line[-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> (X,y)</span><br><span class="line"></span><br><span class="line">X0,y0 = readData()</span><br><span class="line"><span class="comment"># Convert all but the last 10 rows of the raw data to numpy arrays</span></span><br><span class="line">d = <span class="built_in">len</span>(X0)-<span class="number">10</span></span><br><span class="line">X = np.array(X0[:d])</span><br><span class="line">y = np.transpose(np.array([y0[:d]]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute beta</span></span><br><span class="line">Xt = np.transpose(X)</span><br><span class="line">XtX = np.dot(Xt,X)</span><br><span class="line">Xty = np.dot(Xt,y)</span><br><span class="line">beta = np.linalg.solve(XtX,Xty)</span><br><span class="line"><span class="built_in">print</span>(beta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make predictions for the last 10 rows in the data set</span></span><br><span class="line"><span class="keyword">for</span> data,actual <span class="keyword">in</span> <span class="built_in">zip</span>(X0[d:],y0[d:]):</span><br><span class="line">    x = np.array([data])</span><br><span class="line">    prediction = np.dot(x,beta)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;prediction = &#x27;</span>+<span class="built_in">str</span>(prediction[<span class="number">0</span>,<span class="number">0</span>])+<span class="string">&#x27; actual = &#x27;</span>+<span class="built_in">str</span>(actual))</span><br></pre></td></tr></table></figure>

<p>原始数据集包含500多个条目 为了测试线性回归模型所做预测的准确性，我们使用除最后10个数据条目之外的所有数据条目来构建回归模型并计算<strong>β</strong>。一旦我们构建了<strong>β</strong>向量，我们就用它来预测最后10个输入值，然后将预测的房价与数据集中的实际房价进行比较。</p>
<p>以下是该计划产生的产出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[ -<span class="number">4.14106096e+03</span>]</span><br><span class="line"> [  <span class="number">3.55197583e+00</span>]</span><br><span class="line"> [  <span class="number">1.66328263e+03</span>]</span><br><span class="line"> [  <span class="number">1.45465644e+04</span>]</span><br><span class="line"> [  <span class="number">6.77755381e+03</span>]</span><br><span class="line"> [  <span class="number">6.58750520e+03</span>]</span><br><span class="line"> [  <span class="number">4.44683380e+03</span>]</span><br><span class="line"> [  <span class="number">5.60834856e+03</span>]</span><br><span class="line"> [  <span class="number">1.27979572e+04</span>]</span><br><span class="line"> [  <span class="number">1.24091640e+04</span>]</span><br><span class="line"> [  <span class="number">4.19931185e+03</span>]</span><br><span class="line"> [  <span class="number">9.42215457e+03</span>]]</span><br><span class="line">prediction = <span class="number">97360.6550969</span> actual = <span class="number">82500.0</span></span><br><span class="line">prediction = <span class="number">71774.1659014</span> actual = <span class="number">83000.0</span></span><br><span class="line">prediction = <span class="number">92359.0891976</span> actual = <span class="number">84000.0</span></span><br><span class="line">prediction = <span class="number">77748.2742379</span> actual = <span class="number">85000.0</span></span><br><span class="line">prediction = <span class="number">91015.5903066</span> actual = <span class="number">85000.0</span></span><br><span class="line">prediction = <span class="number">97545.1179047</span> actual = <span class="number">91500.0</span></span><br><span class="line">prediction = <span class="number">97360.6550969</span> actual = <span class="number">94000.0</span></span><br><span class="line">prediction = <span class="number">106006.800756</span> actual = <span class="number">103000.0</span></span><br><span class="line">prediction = <span class="number">92451.6931269</span> actual = <span class="number">105000.0</span></span><br><span class="line">prediction = <span class="number">73458.2949381</span> actual = <span class="number">105000.0</span></span><br></pre></td></tr></table></figure>

<p>总体而言，预测并不是非常好，但是一些预测有点接近正确。从这些数据中做出更好的预测将成为机器学习冬季学期教程的主题。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy数组的不同方式</title>
    <url>/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="创建-Numpy-数组的不同方式"><a href="#创建-Numpy-数组的不同方式" class="headerlink" title="创建 Numpy 数组的不同方式"></a>创建 Numpy 数组的不同方式</h1><p>Numpy库的核心是数组对象或ndarray对象（n维数组）。你将使用Numpy数组执行逻辑，统计和傅里叶变换等运算。作为使用Numpy的一部分，你要做的第一件事就是创建Numpy数组。本指南的主要目的是帮助数据科学爱好者了解可用于创建Numpy数组的不同方式。</p>
<p>创建Numpy数组有三种不同的方法：</p>
<ol>
<li>使用Numpy内部功能函数</li>
<li>从列表等其他Python的结构进行转换</li>
<li>使用特殊的库函数</li>
</ol>
<h2 id="使用Numpy内部功能函数"><a href="#使用Numpy内部功能函数" class="headerlink" title="使用Numpy内部功能函数"></a>使用Numpy内部功能函数</h2><p>Numpy具有用于创建数组的内置函数。 我们将在本指南中介绍其中一些内容。</p>
<h3 id="创建一个一维的数组"><a href="#创建一个一维的数组" class="headerlink" title="创建一个一维的数组"></a>创建一个一维的数组</h3><p>首先，让我们创建一维数组或rank为1的数组。<code>arange</code>是一种广泛使用的函数，用于快速创建数组。将值20传递给<code>arange</code>函数会创建一个值范围为0到19的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.arange(<span class="number">20</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,</span><br><span class="line">       <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line">       <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>,</span><br><span class="line">       <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>])</span><br></pre></td></tr></table></figure>

<p>要验证此数组的维度，请使用shape属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array.shape</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">20</span>,)</span><br></pre></td></tr></table></figure>

<p>由于逗号后面没有值，因此这是一维数组。 要访问此数组中的值，请指定非负索引。 与其他编程语言一样，索引从零开始。 因此，要访问数组中的第四个元素，请使用索引3。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>Numpy的数组是可变的，这意味着你可以在初始化数组后更改数组中元素的值。 使用print函数查看数组的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array[<span class="number">3</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(array)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span> <span class="number">100</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line">   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line">   <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line">   <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>]</span><br></pre></td></tr></table></figure>

<p>与Python列表不同，Numpy数组的内容是同质的。 因此，如果你尝试将字符串值分配给数组中的元素，其数据类型为int，则会出现错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array[<span class="number">3</span>] =<span class="string">&#x27;Numpy&#x27;</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ValueError: invalid literal <span class="keyword">for</span> <span class="built_in">int</span>() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">&#x27;Numpy&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建一个二维数组"><a href="#创建一个二维数组" class="headerlink" title="创建一个二维数组"></a>创建一个二维数组</h3><p>我们来谈谈创建一个二维数组。 如果只使用arange函数，它将输出一维数组。 要使其成为二维数组，请使用reshape函数链接其输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">       [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]])</span><br></pre></td></tr></table></figure>

<p>首先，将创建20个整数，然后将数组转换为具有4行和5列的二维数组。 我们来检查一下这个数组的维数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>由于我们得到两个值，这是一个二维数组。 要访问二维数组中的元素，需要为行和列指定索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array[<span class="number">3</span>][<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure>

<h3 id="创建三维数组及更多维度"><a href="#创建三维数组及更多维度" class="headerlink" title="创建三维数组及更多维度"></a>创建三维数组及更多维度</h3><p>要创建三维数组，请为重塑形状函数指定3个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = np.arange(<span class="number">27</span>).reshape(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">        [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>]]])</span><br></pre></td></tr></table></figure>

<p>需要注意的是：数组中元素的数量（27）必须是其尺寸（3 * 3 * 3）的乘积。 要交叉检查它是否是三维数组，可以使用shape属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array.shape</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>此外，使用<code>arange</code>函数，你可以创建一个在定义的起始值和结束值之间具有特定序列的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>, <span class="number">35</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">34</span>])</span><br></pre></td></tr></table></figure>

<h3 id="使用其他Numpy函数"><a href="#使用其他Numpy函数" class="headerlink" title="使用其他Numpy函数"></a>使用其他Numpy函数</h3><p>除了arange函数之外，你还可以使用其他有用的函数（如 <code>zeros</code> 和 <code>ones</code>）来快速创建和填充数组。</p>
<p>使用<code>zeros</code>函数创建一个填充零的数组。函数的参数表示行数和列数（或其维数）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">2</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<p>使用<code>ones</code>函数创建一个填充了1的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ones((<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<p><code>empty</code>函数创建一个数组。它的初始内容是随机的，取决于内存的状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.65670626</span>, <span class="number">0.52097334</span>, <span class="number">0.99831087</span>],</span><br><span class="line">       [<span class="number">0.07280136</span>, <span class="number">0.4416958</span> , <span class="number">0.06185705</span>]])</span><br></pre></td></tr></table></figure>

<p><code>full</code>函数创建一个填充给定值的n * n数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>

<p><code>eye</code>函数可以创建一个n * n矩阵，对角线为1s，其他为0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.eye(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<p>函数<code>linspace</code>在指定的时间间隔内返回均匀间隔的数字。 例如，下面的函数返回0到10之间的四个等间距数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linspace(<span class="number">0</span>, <span class="number">10</span>, num=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([ <span class="number">0.</span>, <span class="number">3.33333333</span>, <span class="number">6.66666667</span>, <span class="number">10.</span>])</span><br></pre></td></tr></table></figure>

<h2 id="从Python列表转换"><a href="#从Python列表转换" class="headerlink" title="从Python列表转换"></a>从Python列表转换</h2><p>除了使用Numpy函数之外，你还可以直接从Python列表创建数组。将Python列表传递给数组函数以创建Numpy数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">array</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>

<p>你还可以创建Python列表并传递其变量名以创建Numpy数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">array = np.array(<span class="built_in">list</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>

<p>你可以确认变量<code>array</code>和<code>list</code>分别是Python列表和Numpy数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>list</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(array)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Numpy.ndarray</p>
</blockquote>
<p>要创建二维数组，请将一系列列表传递给数组函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = np.array([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)])</span><br><span class="line">array</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">array.shape</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2, 3)</span><br></pre></td></tr></table></figure>

<h2 id="使用特殊的库函数"><a href="#使用特殊的库函数" class="headerlink" title="使用特殊的库函数"></a>使用特殊的库函数</h2><p>你还可以使用特殊库函数来创建数组。例如，要创建一个填充0到1之间随机值的数组，请使用<code>random</code>函数。这对于需要随机状态才能开始的问题特别有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.random((<span class="number">2</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">0.1632794</span> , <span class="number">0.34567049</span>],</span><br><span class="line">       [<span class="number">0.03463241</span>, <span class="number">0.70687903</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>创建和填充Numpy数组是使用Numpy执行快速数值数组计算的第一步。使用不同的方式创建数组，你现在可以很好地执行基本的数组操作。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy神经网络</title>
    <url>/2021/09/21/numpy%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="NumPy-与-神经网络"><a href="#NumPy-与-神经网络" class="headerlink" title="NumPy 与 神经网络"></a>NumPy 与 神经网络</h1><p>对我来说用于分类的神经网络是一种非常可怕的机器学习算法。学习神经网络算法时，会给人一种望而生畏的感觉，但当我最终妥协并陷入其中无法自拔的时候，才发现其实它并没有想象中的那么可怕。它们被称为神经网络，是因为它们松散地建立在人类大脑神经元以及神经元工作原理的基础上。但是，它们本质上是一组线性模型。关于这些算法的数学和结构有很多很好的文章来解释它们，所以这些部分我的这篇文章不会提及。相反，我将详细的用numpy库在python中编写一个一个的步骤，并非常清楚地解释它的。这篇文章的代码很大程度上基于<a href="https://s.click.taobao.com/t?e=m=2&s=XIetsYhTCu8cQipKwQzePOeEDrYVVa64K7Vc7tFgwiHjf2vlNIV67pZpQLiTO+hgmSMhGfkQJ77VdTmGfLKGc3msngnYL0uHYhNjQr6GXJQ0IVmWuK+Mt0g0aHp6CeiC6hqtRuAxoUJbnlHS8Kikd9qH4uMbv1iQxgxdTc00KD8=&pvid=10_183.14.30.247_9333_1539405668948">《集体智慧编程》</a>中提供的神经网络代码，只要输入数据格式正确，我就稍微调整它以使其可用于任何数据集。</p>
<p>首先，我们可以将每个神经元视为具有激活功能。此功能确定神经元是 <code>开</code> 还是 <code>关</code> - 是否激活。我们将使用sigmoid函数，在逻辑回归中，它应该是非常见的函数。与逻辑回归不同，我们在使用神经网络时也需要sigmoid函数的导数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"><span class="comment"># derivative of sigmoid</span></span><br><span class="line"><span class="comment"># sigmoid(y) * (1.0 - sigmoid(y))</span></span><br><span class="line"><span class="comment"># the way we use this y is already sigmoided</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dsigmoid</span>(<span class="params">y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> y * (<span class="number">1.0</span> - y)    </span><br></pre></td></tr></table></figure>

<p>就像逻辑回归一样，神经网络中的Sigmoid函数将生成输入的端点(激活)乘以它们的权重。例如，假设我们有两列(特征)的输入数据和一个隐藏节点(神经元)在我们的神经网络。每个特征都会乘以相应的权重值，然后相加，然后通过S形(就像逻辑回归一样)。以这个简单的例子，并把它变成一个神经网络，我们只是添加更多的隐藏单元。除了添加更多的隐藏单元外，我们还将每个输入特性的路径添加到每个隐藏单元，并将其乘以相应的权重。每个隐藏单元取其输入*权值之和，并通过S形传递，从而导致该单元的激活。</p>
<p>接下来，我们将设置数组来保存用于网络的数据，并初始化一些参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP_NeuralNetwork</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">input</span>, hidden, output</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param input: number of input neurons</span></span><br><span class="line"><span class="string">        :param hidden: number of hidden neurons</span></span><br><span class="line"><span class="string">        :param output: number of output neurons</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">input</span> = <span class="built_in">input</span> + <span class="number">1</span> <span class="comment"># add 1 for bias node</span></span><br><span class="line">        self.hidden = hidden</span><br><span class="line">        self.output = output</span><br><span class="line">        <span class="comment"># set up array of 1s for activations</span></span><br><span class="line">        self.ai = [<span class="number">1.0</span>] * self.<span class="built_in">input</span></span><br><span class="line">        self.ah = [<span class="number">1.0</span>] * self.hidden</span><br><span class="line">        self.ao = [<span class="number">1.0</span>] * self.output</span><br><span class="line">        <span class="comment"># create randomized weights</span></span><br><span class="line">        self.wi = np.random.randn(self.<span class="built_in">input</span>, self.hidden) </span><br><span class="line">        self.wo = np.random.randn(self.hidden, self.output) </span><br><span class="line">        <span class="comment"># create arrays of 0 for changes</span></span><br><span class="line">        self.ci = np.zeros((self.<span class="built_in">input</span>, self.hidden))</span><br><span class="line">        self.co = np.zeros((self.hidden, self.output))</span><br></pre></td></tr></table></figure>

<p>我们要用矩阵做所有这些计算，因为它们速度快，而且非常容易阅读。我们的类将接受三个输入：输入层的大小(特性)、隐藏层的大小(要调优的变量参数)和输出层的数量(可能的类的数量)。我们设置一个1数组作为单元激活的占位符，一个0数组作为层更改的占位符。需要注意的一件重要事情是，我们将所有的权重初始化为随机数。重要的是权值是随机的，否则我们将无法调整网络。如果所有的权重是一样的，那么所有隐藏的单位都是一样的，那你的神经网络算法就废了。</p>
<p>所以现在是时候做一些预测的运算操作了。我们要做的是通过随机权重将所有数据通过网络提供给用户，并生成一些(不那么准确的)预测。后来，每次做出预测时，我们都会计算出预测的错误程度，以及为了使预测更好(即误差)，我们需要改变权重的方向。我们会做很多…很多次，当权重被更新时，我们会创建一个前馈函数，这个函数可以被一次又一次地调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feedForward</span>(<span class="params">self, inputs</span>):</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(inputs) != self.<span class="built_in">input</span>-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Wrong number of inputs you silly goose!&#x27;</span>)</span><br><span class="line">    <span class="comment"># input activations</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">input</span> -<span class="number">1</span>): <span class="comment"># -1 is to avoid the bias</span></span><br><span class="line">        self.ai[i] = inputs[i]</span><br><span class="line">    <span class="comment"># hidden activations</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">input</span>):</span><br><span class="line">            <span class="built_in">sum</span> += self.ai[i] * self.wi[i][j]</span><br><span class="line">        self.ah[j] = sigmoid(<span class="built_in">sum</span>)</span><br><span class="line">    <span class="comment"># output activations</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.output):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">            <span class="built_in">sum</span> += self.ah[j] * self.wo[j][k]</span><br><span class="line">        self.ao[k] = sigmoid(<span class="built_in">sum</span>)</span><br><span class="line">    <span class="keyword">return</span> self.ao[:]</span><br></pre></td></tr></table></figure>

<p>输入激活只是输入功能。但是，对于另一层，激活变成了前一层激活的总和乘以它们的相应的权值，反馈到S形中去了。</p>
<p>在第一次运算之后，我们的预测的误差相当大的。所以我们将使用一个非常熟悉的概念，梯度下降。这是我感到兴奋的部分，因为我认为数学真的很聪明。与线性模型的梯度下降不同，我们需要对神经网络使用一点微积分。这就是为什么我们在开始的时候，为S函数的导数写了这个函数。</p>
<p>我们的反向传播算法首先计算我们预测的输出与真实输出的误差。然后我们在输出激活(预测值)上取S形的导数，以得到梯度的方向(斜率)，并将该值乘以误差。这就给了我们误差的大小，隐藏的权值需要改变哪个方向来修正它。然后我们进入到隐藏层，并根据前面计算的幅度和误差计算隐藏层权值的误差。</p>
<p>利用该误差和隐藏层激活的S形导数，我们计算了输入层的权重需要改变多少，以及在哪个方向上需要改变。</p>
<p>现在我们有了价值网络，我们想改变利率的多少，以及在什么方向上，我们真正做到了这一点。我们更新连接每一层的权重。我们通过将当前权重乘以学习速率常数以及相应的权重层的大小和方向来实现这一点。就像在线性模型中一样，我们使用学习速率常数在每一步中做一些小的改变，这样我们就有更好的机会为最小化成本函数的权值找到真正的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backPropagate</span>(<span class="params">self, targets, N</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param targets: y values</span></span><br><span class="line"><span class="string">    :param N: learning rate</span></span><br><span class="line"><span class="string">    :return: updated weights and current error</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(targets) != self.output:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Wrong number of targets you silly goose!&#x27;</span>)</span><br><span class="line">    <span class="comment"># calculate error terms for output</span></span><br><span class="line">    <span class="comment"># the delta tell you which direction to change the weights</span></span><br><span class="line">    output_deltas = [<span class="number">0.0</span>] * self.output</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.output):</span><br><span class="line">        error = -(targets[k] - self.ao[k])</span><br><span class="line">        output_deltas[k] = dsigmoid(self.ao[k]) * error</span><br><span class="line">    <span class="comment"># calculate error terms for hidden</span></span><br><span class="line">    <span class="comment"># delta tells you which direction to change the weights</span></span><br><span class="line">    hidden_deltas = [<span class="number">0.0</span>] * self.hidden</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">        error = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.output):</span><br><span class="line">            error += output_deltas[k] * self.wo[j][k]</span><br><span class="line">        hidden_deltas[j] = dsigmoid(self.ah[j]) * error</span><br><span class="line">    <span class="comment"># update the weights connecting hidden to output</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.output):</span><br><span class="line">            change = output_deltas[k] * self.ah[j]</span><br><span class="line">            self.wo[j][k] -= N * change + self.co[j][k]</span><br><span class="line">            self.co[j][k] = change</span><br><span class="line">    <span class="comment"># update the weights connecting input to hidden</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">input</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">            change = hidden_deltas[j] * self.ai[i]</span><br><span class="line">            self.wi[i][j] -= N * change + self.ci[i][j]</span><br><span class="line">            self.ci[i][j] = change</span><br><span class="line">    <span class="comment"># calculate error</span></span><br><span class="line">    error = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(targets)):</span><br><span class="line">        error += <span class="number">0.5</span> * (targets[k] - self.ao[k]) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> error</span><br></pre></td></tr></table></figure>

<p>好的，让我们把它们链接在一起，创建训练和预测功能。训练网络的步骤是非常直接和直观的。我们首先调用“<code>前馈</code>”函数，它给出我们初始化的随机权值的输出。然后，我们调用反向传播算法来调整和更新权值，以做出更好的预测。然后再调用前馈函数，但这一次它使用了更新后的权值，预测结果略好一些。我们将这个循环保持在一个预先确定的迭代数量中，在此期间，我们应该看到错误下降到接近0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">self, patterns, iterations = <span class="number">3000</span>, N = <span class="number">0.0002</span></span>):</span></span><br><span class="line">    <span class="comment"># N: learning rate</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">        error = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> patterns:</span><br><span class="line">            inputs = p[<span class="number">0</span>]</span><br><span class="line">            targets = p[<span class="number">1</span>]</span><br><span class="line">            self.feedForward(inputs)</span><br><span class="line">            error = self.backPropagate(targets, N)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;error %-.5f&#x27;</span> % error)</span><br></pre></td></tr></table></figure>

<p>最后，对于预测操作。我们只是简单地调用前馈函数，它将返回输出层的激活。记住，每一层的激活是前一层输出的线性组合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    return list of predictions after training algorithm</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    predictions = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> X:</span><br><span class="line">        predictions.append(self.feedForward(p))</span><br><span class="line">    <span class="keyword">return</span> predictions</span><br></pre></td></tr></table></figure>

<p>基本上就是这样！你可以<a href="https://github.com/FlorianMuellerklein/Machine-Learning/blob/master/Old/BackPropagationNN.py">在这里</a>看到完整的代码。</p>
<p>我运行了这个代码的数字识别数据集提供的skLearning，它完成了一个97%的准确性。我要说那是相当成功的！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">          0       0.98      0.96      0.97        49</span><br><span class="line">          1       0.92      0.97      0.95        36</span><br><span class="line">          2       1.00      1.00      1.00        43</span><br><span class="line">          3       0.95      0.88      0.91        41</span><br><span class="line">          4       0.98      1.00      0.99        47</span><br><span class="line">          5       0.96      1.00      0.98        46</span><br><span class="line">          6       1.00      1.00      1.00        47</span><br><span class="line">          7       0.98      0.96      0.97        46</span><br><span class="line">          8       0.93      0.80      0.86        49</span><br><span class="line">          9       1.00      0.91      0.95        46</span><br><span class="line"></span><br><span class="line">avg / total       0.97      0.95      0.96       450</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy数组编程</title>
    <url>/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="使用-NumPy-进行数组编程"><a href="#使用-NumPy-进行数组编程" class="headerlink" title="使用 NumPy 进行数组编程"></a>使用 NumPy 进行数组编程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人们有时会说，与C++这种低级语言相比，Python以运行速度为代价改善了开发时间和效率。幸运的是，有一些方法可以在不牺牲易用性的情况下加速Python中的操作运行时。适用于快速数值运算的一个选项是NumPy，它当之无愧地将自己称为使用Python进行科学计算的基本软件包。</p>
<p>当然，很少有人将50微秒（百万分之五十秒）的东西归类为“慢”。然而，计算机可能会有所不同。运行50微秒（50微秒）的运行时属于微执行领域，可以松散地定义为运行时间在1微秒和1毫秒之间的运算。</p>
<p>为什么速度很重要？微观性能值得监控的原因是运行时的小差异会随着重复的函数调用而放大：增量50μs的开销，重复超过100万次函数调用，转换为50秒的增量运行时间。</p>
<p>在计算方面，实际上有三个概念为NumPy提供了强大的功能：</p>
<ul>
<li>矢量化</li>
<li>广播</li>
<li>索引</li>
</ul>
<p>在本教程中，你将逐步了解<strong>如何利用矢量化和广播</strong>，以便你可以充分使用NumPy。虽然你在这里将使用一些索引，但NumPy的完整索引原理图(它扩展了Python的<a href="https://www.numpy.org.cn/article/advanced/(https://docs.python.org/3/reference/expressions.html?highlight=slice#slicings)">切片语法</a>)是它们自己的工具。如果你想了解有关<a href="https://www.numpy.org.cn/reference/array_objects/indexing.html">NumPy索引</a>的更多信息，请喝点咖啡，然后前往NumPy文档中的索引部分。</p>
<h2 id="进入状态：介绍NumPy数组"><a href="#进入状态：介绍NumPy数组" class="headerlink" title="进入状态：介绍NumPy数组"></a>进入状态：介绍NumPy数组</h2><p>NumPy的基本对象是它的ndarray（或numpy.array），这是一个n维数组，它也以某种形式出现在面向数组的语言中，如Fortran 90、R和MATLAB，以及以前的 APL 和 J。</p>
<p>让我们从形成一个包含36个元素的三维数组开始：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">36</span>).reshape(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>],</span><br><span class="line">        [<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>],</span><br><span class="line">        [<span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>],</span><br><span class="line">        [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>],</span><br><span class="line">        [<span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]]])</span><br></pre></td></tr></table></figure>

<p>在二维中描绘高维数组可能会比较困难。考虑数组形状的一种直观方法是简单地“从左到右读取它”。arr 是一个3乘4乘3的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>在视觉上，arr可以被认为是三个4x3网格（或矩形棱镜）的容器，看起来像这样：</p>
<p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/arr3d.7442cd4e11c6.jpg" alt="NumPy三维数组"></p>
<p>更高维度的数组可能更难以用图像表达出来，但它们仍将遵循这种“数组内的数组”模式。</p>
<p>你在哪里可以看到超过两个维度的数据？</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Panel_data">面板数据</a>可以用三维表示。跟踪个体群组（群体）随时间变化的数据可以被构造为（受访者，日期，属性）。 1979年<a href="https://www.nlsinfo.org/content/cohorts/nlsy79">全国青年纵向调查（iq调查）</a>对27岁以上的12,686名受访者进行了调查。假设每个人每年有大约500个直接询问或派生的数据点，这些数据将具有形状（12686,27,500），总共177,604,000个数据点。</li>
<li>用于多幅图像的彩色图像数据通常存储在四个维度中。每个图像是一个三维数组(高度、宽度、通道)，通道通常是红色、绿色和蓝色(RGB)值。然后，图像的集合就是(图像数、高度、宽度、通道)。1，000张256x256 RGB图像将具有形状(1000，256，256，3)。(扩展的表示是RGBA，其中A-alpha-表示不透明的级别。)。</li>
</ul>
<h2 id="什么是矢量化？"><a href="#什么是矢量化？" class="headerlink" title="什么是矢量化？"></a>什么是矢量化？</h2><p>矢量化是NumPy中的一种强大功能，可以将操作表达为在整个数组上而不是在各个元素上发生。以下是Wes McKinney的简明定义：</p>
<blockquote>
<p>这种用数组表达式替换显式循环的做法通常称为向量化。通常，矢量化数组操作通常比其纯Python等价物快一个或两个（或更多）数量级，在任何类型的数值计算中都具有最大的影响。</p>
</blockquote>
<p>在Python中循环数组或任何数据结构时，会涉及很多开销。 NumPy中的向量化操作将内部循环委托给高度优化的C和Fortran函数，从而实现更清晰，更快速的Python代码。</p>
<h3 id="计数-简单的如：1-2-3…"><a href="#计数-简单的如：1-2-3…" class="headerlink" title="计数: 简单的如：1, 2, 3…"></a>计数: 简单的如：1, 2, 3…</h3><p>作为示例，考虑一个True和False的一维向量，你要为其计算序列中“False to True”转换的数量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.seed(<span class="number">444</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.random.choice([<span class="literal">False</span>, <span class="literal">True</span>], size=<span class="number">100000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>, ...,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>])</span><br></pre></td></tr></table></figure>

<p>使用Python for循环，一种方法是成对地评估序列中每个元素的<a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing">真值</a>以及紧随其后的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">count_transitions</span>(<span class="params">x</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(x[:-<span class="number">1</span>], x[<span class="number">1</span>:]):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> j <span class="keyword">and</span> <span class="keyword">not</span> i:</span><br><span class="line"><span class="meta">... </span>            count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> count</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_transitions(x)</span><br><span class="line"><span class="number">24984</span></span><br></pre></td></tr></table></figure>

<p>在矢量化形式中，没有明确的for循环或直接引用各个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.count_nonzero(x[:-<span class="number">1</span>] &lt; x[<span class="number">1</span>:])</span><br><span class="line"><span class="number">24984</span></span><br></pre></td></tr></table></figure>

<p>这两个等效函数在性能方面有何比较？ 在这种特殊情况下，向量化的NumPy调用胜出约70倍：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setup = <span class="string">&#x27;from __main__ import count_transitions, x; import numpy as np&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = timeit(<span class="string">&#x27;count_transitions(x)&#x27;</span>, setup=setup, number=num)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = timeit(<span class="string">&#x27;np.count_nonzero(x[:-1] &lt; x[1:])&#x27;</span>, setup=setup, number=num)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Speed difference: &#123;:0.1f&#125;x&#x27;</span>.<span class="built_in">format</span>(t1 / t2))</span><br><span class="line">Speed difference: <span class="number">71.0</span>x</span><br></pre></td></tr></table></figure>

<p><strong>技术细节</strong>: 另一个术语是<a href="https://blogs.msdn.microsoft.com/nativeconcurrency/2012/04/12/what-is-vectorization/">矢量处理器</a>，它与计算机的硬件有关。 当我在这里谈论矢量化时，我指的是用数组表达式替换显式for循环的概念，在这种情况下，可以使用低级语言在内部计算。</p>
<h3 id="买低，卖高"><a href="#买低，卖高" class="headerlink" title="买低，卖高"></a>买低，卖高</h3><p>这是另一个激发你胃口的例子。考虑以下经典技术面试问题：</p>
<blockquote>
<p>假定一只股票的历史价格是一个序列，假设你只允许进行一次购买和一次出售，那么可以获得的最大利润是多少？例如，假设价格=(20，18，14，17，20，21，15)，最大利润将是7，从14买到21卖。</p>
</blockquote>
<p>(对所有金融界人士说：不，卖空是不允许的。)</p>
<p>存在具有n平方<a href="https://www.numpy.org.cn/article/advanced/(https://en.wikipedia.org/wiki/Time_complexity)">时间复杂度</a>的解决方案，其包括采用两个价格的每个组合，其中第二价格“在第一个之后”并且确定最大差异。</p>
<p>然而，还有一个O(n)解决方案，它包括迭代序列一次，找出每个价格和运行最小值之间的差异。 它是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">profit</span>(<span class="params">prices</span>):</span></span><br><span class="line"><span class="meta">... </span>    max_px = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    min_px = prices[<span class="number">0</span>]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> px <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line"><span class="meta">... </span>        min_px = <span class="built_in">min</span>(min_px, px)</span><br><span class="line"><span class="meta">... </span>        max_px = <span class="built_in">max</span>(px - min_px, max_px)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> max_px</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = (<span class="number">20</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>profit(prices)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>这可以用NumPy实现吗？行!没问题。但首先，让我们构建一个准现实的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create mostly NaN array with a few &#x27;turning points&#x27; (local min/max).</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = np.full(<span class="number">100</span>, fill_value=np.nan)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices[[<span class="number">0</span>, <span class="number">25</span>, <span class="number">60</span>, -<span class="number">1</span>]] = [<span class="number">80.</span>, <span class="number">30.</span>, <span class="number">75.</span>, <span class="number">50.</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linearly interpolate the missing values and add some noise.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.arange(<span class="built_in">len</span>(prices))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_valid = ~np.isnan(prices)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = np.interp(x=x, xp=x[is_valid], fp=prices[is_valid])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices += np.random.randn(<span class="built_in">len</span>(prices)) * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>下面是matplotlib的示例。俗话说：买低(绿)，卖高(红)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Warning! This isn&#x27;t a fully correct solution, but it works for now.</span></span><br><span class="line"><span class="comment"># If the absolute min came after the absolute max, you&#x27;d have trouble.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mn = np.argmin(prices)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mx = mn + np.argmax(prices[mn:])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwargs = &#123;<span class="string">&#x27;markersize&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;linestyle&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fig, ax = plt.subplots()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.plot(prices)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_title(<span class="string">&#x27;Price History&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_xlabel(<span class="string">&#x27;Time&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_ylabel(<span class="string">&#x27;Price&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.plot(mn, prices[mn], color=<span class="string">&#x27;green&#x27;</span>, **kwargs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.plot(mx, prices[mx], color=<span class="string">&#x27;red&#x27;</span>, **kwargs)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/prices.664958f44799.png" alt="以序列形式显示股票价格历史的图解"></p>
<p>NumPy实现是什么样的？ 虽然没有np.cummin() “直接”，但NumPy的<a href="https://www.numpy.org.cn/reference/ufuncs/index.html">通用函数（ufuncs）</a>都有一个accumulate()方法，它的名字暗示了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cummin = np.minimum.accumulate</span><br></pre></td></tr></table></figure>

<p>从纯Python示例扩展逻辑，你可以找到每个价格和运行最小值（元素方面）之间的差异，然后获取此序列的最大值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">profit_with_numpy</span>(<span class="params">prices</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Price minus cumulative minimum price, element-wise.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    prices = np.asarray(prices)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> np.<span class="built_in">max</span>(prices - cummin(prices))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>profit_with_numpy(prices)</span><br><span class="line"><span class="number">44.2487532293278</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.allclose(profit_with_numpy(prices), profit(prices))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这两个具有相同理论时间复杂度的操作如何在实际运行时进行比较？ 首先，让我们采取更长的序列。（此时不一定需要是股票价格的时间序列。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, size=<span class="number">100000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq</span><br><span class="line">array([ <span class="number">3</span>, <span class="number">23</span>,  <span class="number">8</span>, <span class="number">67</span>, <span class="number">52</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">72</span>, <span class="number">41</span>, <span class="number">10</span>, ..., <span class="number">46</span>,  <span class="number">8</span>, <span class="number">90</span>, <span class="number">95</span>, <span class="number">93</span>,</span><br><span class="line">       <span class="number">28</span>, <span class="number">24</span>, <span class="number">88</span>, <span class="number">24</span>, <span class="number">49</span>])</span><br></pre></td></tr></table></figure>

<p>现在，对于一个有点不公平的比较：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>setup = (<span class="string">&#x27;from __main__ import profit_with_numpy, profit, seq;&#x27;</span></span><br><span class="line"><span class="meta">... </span>         <span class="string">&#x27; import numpy as np&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">250</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pytime = timeit(<span class="string">&#x27;profit(seq)&#x27;</span>, setup=setup, number=num)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nptime = timeit(<span class="string">&#x27;profit_with_numpy(seq)&#x27;</span>, setup=setup, number=num)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Speed difference: &#123;:0.1f&#125;x&#x27;</span>.<span class="built_in">format</span>(pytime / nptime))</span><br><span class="line">Speed difference: <span class="number">76.0</span>x</span><br></pre></td></tr></table></figure>

<p>在上面，将profit_with_numpy() 视为伪代码（不考虑NumPy的底层机制），实际上有三个遍历序列：</p>
<ul>
<li>cummin(prices) 具有O(n)时间复杂度</li>
<li>prices - cummin(prices) 是 O(n)的时间复杂度</li>
<li>max(…) 是O(n)的时间复杂度</li>
</ul>
<p>这就减少到O(n)，因为O(3n)只剩下O(n)-当n接近无穷大时，n “占主导地位”。</p>
<p>因此，这两个函数具有等价的最坏情况时间复杂度。(不过，顺便提一下，NumPy函数的空间复杂度要高得多。)。但这可能是最不重要的内容。这里我们有一个教训是：虽然理论上的时间复杂性是一个重要的考虑因素，运行时机制也可以发挥很大的作用。NumPy不仅可以委托给C，而且通过一些元素操作和线性代数，它还可以利用多线程中的计算。但是这里有很多因素在起作用，包括所使用的底层库(BLAS/LAPACK/Atlas)，而这些细节完全是另一篇文章的全部内容。</p>
<h2 id="Intermezzo：理解轴符号"><a href="#Intermezzo：理解轴符号" class="headerlink" title="Intermezzo：理解轴符号"></a>Intermezzo：理解轴符号</h2><p>在NumPy中，轴指向多维数组的单个维度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"><span class="meta">... </span>                [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">array([ <span class="number">6</span>, <span class="number">60</span>])</span><br></pre></td></tr></table></figure>

<p>围绕轴的术语和描述它们的方式可能有点不直观。在Pandas(在NumPy之上构建的库)的文档中，你可能经常看到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axis : &#123;&#x27;index&#x27; (0), &#x27;columns&#x27; (1)&#125;</span><br></pre></td></tr></table></figure>

<p>根据这一描述，你可以争辩说，上面的结果应该是“反向的”。但是，关键是轴指向调用函数的轴。杰克·范德普拉斯很好地阐述了这一点：</p>
<blockquote>
<p>此处指定轴的方式可能会让来自其他语言的用户感到困惑。AXIS关键字指定将折叠的数组的维度，而不是将要返回的维度。因此，指定Axis=0意味着第一个轴将折叠：对于二维数组，这意味着每列中的值将被聚合。</p>
</blockquote>
<p>换句话说，如果将AXIS=0的数组相加，则会使用按列计算的方式折叠数组的行。</p>
<p>考虑到这一区别，让我们继续探讨广播的概念。</p>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播是另一个重要的NumPy抽象。你已经看到了两个NumPy数组(大小相等)之间的操作是按元素操作的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">10.</span>, <span class="number">5.</span>, <span class="number">1.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a / b</span><br><span class="line">array([<span class="number">0.15</span>, <span class="number">0.5</span> , <span class="number">3.5</span> ])</span><br></pre></td></tr></table></figure>

<p>但是，大小不相等的数组呢？这就是广播的意义所在：</p>
<blockquote>
<p>术语广播描述了在算术运算期间NumPy如何处理具有不同形状的数组。受某些约束条件的限制，较小的数组会在较大的数组中“广播”，以便它们具有兼容的形状。广播提供了一种向量化数组操作的方法，因此循环是在C而不是Python中进行的。</p>
</blockquote>
<p>当使用两个以上的数组时，广播的实现方式可能会变得乏味。但是，如果只有两个数组，那么可以用两条简短的规则来描述它们的广播能力：</p>
<blockquote>
<p>在对两个数组进行操作时，NumPy按元素对它们的形状进行比较。它从尾随维度开始，然后继续前进。两个维度在下列情况下是兼容的：</p>
<ul>
<li>他们是平等的，或者</li>
<li>其中一个是1</li>
</ul>
</blockquote>
<p>非那样做不行。</p>
<p>让我们以一个例子为例，我们想要减去数组的每个列的平均值，元素的平均值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample = np.random.normal(loc=[<span class="number">2.</span>, <span class="number">20.</span>], scale=[<span class="number">1.</span>, <span class="number">3.5</span>],</span><br><span class="line"><span class="meta">... </span>                          size=(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample</span><br><span class="line">array([[ <span class="number">1.816</span> , <span class="number">23.703</span> ],</span><br><span class="line">       [ <span class="number">2.8395</span>, <span class="number">12.2607</span>],</span><br><span class="line">       [ <span class="number">3.5901</span>, <span class="number">24.2115</span>]])</span><br></pre></td></tr></table></figure>

<p>在统计术语中，样本由两个独立于两个总体的样本(列)组成，平均值分别为2和20。按列分列的方法应该近似于总体方法(尽管是粗略的，因为样本很小)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mu = sample.mean(axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mu</span><br><span class="line">array([ <span class="number">2.7486</span>, <span class="number">20.0584</span>])</span><br></pre></td></tr></table></figure>

<p>现在，减去列意义是很简单的，因为广播规则检查出来了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;sample:&#x27;</span>, sample.shape, <span class="string">&#x27;| means:&#x27;</span>, mu.shape)</span><br><span class="line">sample: (<span class="number">3</span>, <span class="number">2</span>) | means: (<span class="number">2</span>,)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample - mu</span><br><span class="line">array([[-<span class="number">0.9325</span>,  <span class="number">3.6446</span>],</span><br><span class="line">       [ <span class="number">0.091</span> , -<span class="number">7.7977</span>],</span><br><span class="line">       [ <span class="number">0.8416</span>,  <span class="number">4.1531</span>]])</span><br></pre></td></tr></table></figure>

<p>下面是一个减去列意义的示例，其中较小的数组被“拉伸”，以便从较大的数组的每一行中减去它：</p>
<p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/broadcasting.084a0e28dea8.jpg" alt="NumPy数组广播"></p>
<p><strong>技术细节</strong>：较小的数组或标量不是按字面意义上在内存中展开的：重复的是计算本身。</p>
<p>这扩展到<a href="https://en.wikipedia.org/wiki/Standard_score">标准化</a>每个列，使每个单元格相对于其各自的列具有z-score：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(sample - sample.mean(axis=<span class="number">0</span>)) / sample.std(axis=<span class="number">0</span>)</span><br><span class="line">array([[-<span class="number">1.2825</span>,  <span class="number">0.6605</span>],</span><br><span class="line">       [ <span class="number">0.1251</span>, -<span class="number">1.4132</span>],</span><br><span class="line">       [ <span class="number">1.1574</span>,  <span class="number">0.7527</span>]])</span><br></pre></td></tr></table></figure>

<p>但是，如果出于某种原因，要减去行最小值，该怎么办？你会遇到这样的麻烦：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample - sample.<span class="built_in">min</span>(axis=<span class="number">1</span>)</span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">3</span>,<span class="number">2</span>) (<span class="number">3</span>,)</span><br></pre></td></tr></table></figure>

<p>这里的问题是，较小的数组，在其目前的形式，不能“伸展”，以形状与样本兼容。实际上，你需要扩展它的维度，以满足上面的广播规则：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample.<span class="built_in">min</span>(axis=<span class="number">1</span>)[:, <span class="literal">None</span>]  <span class="comment"># 3 minimums across 3 rows</span></span><br><span class="line">array([[<span class="number">1.816</span> ],</span><br><span class="line">       [<span class="number">2.8395</span>],</span><br><span class="line">       [<span class="number">3.5901</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample - sample.<span class="built_in">min</span>(axis=<span class="number">1</span>)[:, <span class="literal">None</span>]</span><br><span class="line">array([[ <span class="number">0.</span>    , <span class="number">21.887</span> ],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">9.4212</span>],</span><br><span class="line">       [ <span class="number">0.</span>    , <span class="number">20.6214</span>]])</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: [:, None]是一种扩展数组维度的方法，用于创建长度为1的轴。<a href="https://www.numpy.org.cn/reference/array_objects/indexing.html#numpy.newaxis">np.newaxis</a>是None的别名。</p>
<p>还有一些更为复杂的案例。下面是任何形状的任意数量的数组可以一起广播的更严格的定义：</p>
<blockquote>
<p>如果以下规则产生有效结果，则一组数组被称为“可广播”到相同的形状，这意味着 <strong>以下之一为真</strong> 时：</p>
<ol>
<li>矩阵都具有完全相同的形状。</li>
<li>矩阵都具有相同数量的维度，每个维度的长度是公共长度或1。</li>
<li>具有太少尺寸的矩列可以使其形状前面具有长度为1的尺寸以满足属性＃2。 </li>
</ol>
</blockquote>
<p>这更容易一步一步走。假设你有以下四个数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.sin(np.arange(<span class="number">10</span>)[:, <span class="literal">None</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.random.randn(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.full_like(a, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>在检查形状之前，NumPy首先将标量转换为具有一个元素的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrays = [np.atleast_1d(arr) <span class="keyword">for</span> arr <span class="keyword">in</span> (a, b, c, d)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> arr <span class="keyword">in</span> arrays:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arr.shape)</span><br><span class="line">...</span><br><span class="line">(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure>

<p>现在我们可以检查标准＃1。如果所有数组具有相同的形状，则它们的一组形状将缩减为一个元素，因为set() 构造函数有效地从其输入中删除重复项。这里显然没有达到这个标准：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">set</span>(arr.shape <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)) == <span class="number">1</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>标准＃2的第一部分也失败了，这意味着整个标准失败：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">set</span>((arr.ndim) <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)) == <span class="number">1</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>最后一个标准更复杂一些：</p>
<blockquote>
<p>具有太少尺寸的矩列可以使其形状前面具有长度为1的尺寸以满足属性＃2。</p>
</blockquote>
<p>为了对此进行编码，你可以首先确定最高维数组的维度，然后将其添加到每个形状元组，直到所有数组具有相同的维度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>maxdim = <span class="built_in">max</span>(arr.ndim <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)  <span class="comment"># Maximum dimensionality</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shapes = np.array([(<span class="number">1</span>,) * (maxdim - arr.ndim) + arr.shape</span><br><span class="line"><span class="meta">... </span>                   <span class="keyword">for</span> arr <span class="keyword">in</span> arrays])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shapes</span><br><span class="line">array([[<span class="number">10</span>,  <span class="number">1</span>],</span><br><span class="line">       [ <span class="number">1</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">10</span>,  <span class="number">1</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>

<p>最后，你需要测试每个维度的长度是否是公共长度，或是1。这样做的一个技巧是首先在“等于”的位置屏蔽“shape-tuples”数组。然后，你可以检查 peak-to-peak（np.ptp()）列方差是否都为零：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>masked = np.ma.masked_where(shapes == <span class="number">1</span>, shapes)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">all</span>(masked.ptp(axis=<span class="number">0</span>) == <span class="number">0</span>)  <span class="comment"># ptp: max - min</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这个逻辑封装在单个函数中，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">can_broadcast</span>(<span class="params">*arrays</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"><span class="meta">... </span>    arrays = [np.atleast_1d(arr) <span class="keyword">for</span> arr <span class="keyword">in</span> arrays]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(arr.shape <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)) == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>((arr.ndim) <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)) == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="meta">... </span>    maxdim = <span class="built_in">max</span>(arr.ndim <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)</span><br><span class="line"><span class="meta">... </span>    shapes = np.array([(<span class="number">1</span>,) * (maxdim - arr.ndim) + arr.shape</span><br><span class="line"><span class="meta">... </span>                       <span class="keyword">for</span> arr <span class="keyword">in</span> arrays])</span><br><span class="line"><span class="meta">... </span>    masked = np.ma.masked_where(shapes == <span class="number">1</span>, shapes)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> np.<span class="built_in">all</span>(masked.ptp(axis=<span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>can_broadcast(a, b, c, d)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>幸运的是，你可以选择一个快捷方式并使用np.cast()来进行这种健全性检查，尽管它并不是为此目的而显式设计的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">can_broadcast</span>(<span class="params">*arrays</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        np.broadcast(*arrays)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>can_broadcast(a, b, c, d)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>对于那些有兴趣深入挖掘的人来说，<a href="https://github.com/numpy/numpy/blob/7dcee7a469ad1bbfef1cd8980dc18bf5869c5391/numpy/core/src/multiarray/iterators.c#L1274">PyArray_Broadcast</a>是封装广播规则的底层C函数。</p>
<h2 id="矩阵编程实际应用：示例"><a href="#矩阵编程实际应用：示例" class="headerlink" title="矩阵编程实际应用：示例"></a>矩阵编程实际应用：示例</h2><p>在以下3个示例中，你将使用矢量化和广播来处理一些实际应用程序。</p>
<h3 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h3><p>机器学习是一个可以经常利用矢量化和广播的领域。 假设你有三角形的顶点（每行是x，y坐标）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tri = np.array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line"><span class="meta">... </span>                [<span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line"><span class="meta">... </span>                [<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>

<p>这个<a href="https://en.wikipedia.org/wiki/Centroid">“簇”</a>的质心是(x, y)坐标，它是每列的算术平均值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroid = tri.mean(axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroid</span><br><span class="line">array([<span class="number">2.</span>    , <span class="number">1.6667</span>])</span><br></pre></td></tr></table></figure>

<p>可视化这有助于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>trishape = plt.Polygon(tri, edgecolor=<span class="string">&#x27;r&#x27;</span>, alpha=<span class="number">0.2</span>, lw=<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.add_patch(trishape)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_ylim([<span class="number">.5</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_xlim([<span class="number">.5</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(*centroid, color=<span class="string">&#x27;g&#x27;</span>, marker=<span class="string">&#x27;D&#x27;</span>, s=<span class="number">70</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(*tri.T, color=<span class="string">&#x27;b&#x27;</span>,  s=<span class="number">70</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/tri.521228ffdca0.png" alt="三角形的图像"></p>
<p>许多<a href="http://scikit-learn.org/stable/modules/clustering.html">聚类算法</a>利用点集合的欧几里德距离，或者指向原点，或者相对于它们的质心。</p>
<p>在笛卡尔坐标下，p点和q点之间的欧几里德距离是：</p>
<p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/euclid.ffdfd280d315.png" alt="点之间欧氏距离的计算公式"></p>
<p>因此，对于上面的三坐标集，每个点到原点(0, 0) 的欧几里德距离是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(tri**<span class="number">2</span>, axis=<span class="number">1</span>) ** <span class="number">0.5</span>  <span class="comment"># Or: np.sqrt(np.sum(np.square(tri), 1))</span></span><br><span class="line">array([<span class="number">1.4142</span>, <span class="number">3.1623</span>, <span class="number">3.6056</span>])</span><br></pre></td></tr></table></figure>

<p>你可能会认识到我们实际上只是在寻找附和欧几里德的规则：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.norm(tri, axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">1.4142</span>, <span class="number">3.1623</span>, <span class="number">3.6056</span>])</span><br></pre></td></tr></table></figure>

<p>你也可以找到相对于三角形质心的每个点的范数，而不是参考原点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.norm(tri - centroid, axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">1.2019</span>, <span class="number">1.2019</span>, <span class="number">1.3333</span>])</span><br></pre></td></tr></table></figure>

<p>最后，让我们更进一步：假设你有一个二维数组X和一个多个(x, y) “建议”质心的二维数组。诸如<a href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html">K-Means聚类的算法</a>)通过随机分配初始“建议”质心，然后将每个数据点重新分配到其最接近的质心来工作。从那里开始，计算新的质心，一旦重新生成的标签（质心的编码）在迭代之间不变，算法就会收敛于解。这个个迭代过程的一部分需要计算每个质心中每个点的欧几里德距离：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.repeat([[<span class="number">5</span>, <span class="number">5</span>], [<span class="number">10</span>, <span class="number">10</span>]], [<span class="number">5</span>, <span class="number">5</span>], axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = X + np.random.randn(*X.shape)  <span class="comment"># 2 distinct &quot;blobs&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroids = np.array([[<span class="number">5</span>, <span class="number">5</span>], [<span class="number">10</span>, <span class="number">10</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X</span><br><span class="line">array([[ <span class="number">3.3955</span>,  <span class="number">3.682</span> ],</span><br><span class="line">       [ <span class="number">5.9224</span>,  <span class="number">5.785</span> ],</span><br><span class="line">       [ <span class="number">5.9087</span>,  <span class="number">4.5986</span>],</span><br><span class="line">       [ <span class="number">6.5796</span>,  <span class="number">3.8713</span>],</span><br><span class="line">       [ <span class="number">3.8488</span>,  <span class="number">6.7029</span>],</span><br><span class="line">       [<span class="number">10.1698</span>,  <span class="number">9.2887</span>],</span><br><span class="line">       [<span class="number">10.1789</span>,  <span class="number">9.8801</span>],</span><br><span class="line">       [ <span class="number">7.8885</span>,  <span class="number">8.7014</span>],</span><br><span class="line">       [ <span class="number">8.6206</span>,  <span class="number">8.2016</span>],</span><br><span class="line">       [ <span class="number">8.851</span> , <span class="number">10.0091</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroids</span><br><span class="line">array([[ <span class="number">5</span>,  <span class="number">5</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure>

<p>换句话说，我们想回答这个问题，X中的每个点所属的质心是什么？ 为了计算X中每个点与质心中每个点之间的欧几里德距离，我们需要进行一些重构以在此处启用广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroids[:, <span class="literal">None</span>]</span><br><span class="line">array([[[ <span class="number">5</span>,  <span class="number">5</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">10</span>, <span class="number">10</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroids[:, <span class="literal">None</span>].shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>这使我们能够使用一个数组<strong>行的组合乘积</strong>，从另一个数组中清清楚楚地减掉这些数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.norm(X - centroids[:, <span class="literal">None</span>], axis=<span class="number">2</span>).<span class="built_in">round</span>(<span class="number">2</span>)</span><br><span class="line">array([[<span class="number">2.08</span>, <span class="number">1.21</span>, <span class="number">0.99</span>, <span class="number">1.94</span>, <span class="number">2.06</span>, <span class="number">6.72</span>, <span class="number">7.12</span>, <span class="number">4.7</span> , <span class="number">4.83</span>, <span class="number">6.32</span>],</span><br><span class="line">       [<span class="number">9.14</span>, <span class="number">5.86</span>, <span class="number">6.78</span>, <span class="number">7.02</span>, <span class="number">6.98</span>, <span class="number">0.73</span>, <span class="number">0.22</span>, <span class="number">2.48</span>, <span class="number">2.27</span>, <span class="number">1.15</span>]])</span><br></pre></td></tr></table></figure>

<p>换句话说，X-质心[:, None]的形状是(2，10，2)，本质上表示两个堆叠的数组，每个数组的大小都为X。接下来，我们希望每个最近的质心的标签(索引号)，从上面的数组找出第0轴上的最小距离：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argmin(np.linalg.norm(X - centroids[:, <span class="literal">None</span>], axis=<span class="number">2</span>), axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>你可以将所有这些以函数形式组合在一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">get_labels</span>(<span class="params">X, centroids</span>) -&gt; np.ndarray:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> np.argmin(np.linalg.norm(X - centroids[:, <span class="literal">None</span>], axis=<span class="number">2</span>),</span><br><span class="line"><span class="meta">... </span>                     axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>labels = get_labels(X, centroids)</span><br></pre></td></tr></table></figure>

<p>让我们来直观地检查一下，用一个颜色映射来绘制两个集群和它们指定的标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1, c2 = [<span class="string">&#x27;#bc13fe&#x27;</span>, <span class="string">&#x27;#be0119&#x27;</span>]  <span class="comment"># https://xkcd.com/color/rgb/</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>llim, ulim  = np.trunc([X.<span class="built_in">min</span>() * <span class="number">0.9</span>, X.<span class="built_in">max</span>() * <span class="number">1.1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(*X.T, c=np.where(labels, c2, c1), alpha=<span class="number">0.4</span>, s=<span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(*centroids.T, c=[c1, c2], marker=<span class="string">&#x27;s&#x27;</span>, s=<span class="number">95</span>,</span><br><span class="line"><span class="meta">... </span>           edgecolor=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_ylim([llim, ulim])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_xlim([llim, ulim])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_title(<span class="string">&#x27;One K-Means Iteration: Predicted Classes&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/classes.cdaa3e38d62f.png" alt="预测类颜色映射"></p>
<h3 id="摊还（分期）表"><a href="#摊还（分期）表" class="headerlink" title="摊还（分期）表"></a>摊还（分期）表</h3><p>矢量化也适用于金融领域。</p>
<p>给定年利率，支付频率（每年的次数），初始贷款余额和贷款期限，你可以以矢量化方式创建包含月贷款余额和付款的摊还表。让我们先设置一些标量常量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>freq = <span class="number">12</span>     <span class="comment"># 12 months per year</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rate = <span class="number">.0675</span>  <span class="comment"># 6.75% annualized</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nper = <span class="number">30</span>     <span class="comment"># 30 years</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pv = <span class="number">200000</span>   <span class="comment"># Loan face value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rate /= freq  <span class="comment"># Monthly basis</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nper *= freq  <span class="comment"># 360 months</span></span><br></pre></td></tr></table></figure>

<p>NumPy预装了一些<a href="https://www.numpy.org.cn/reference/routines/financial.html">财务函数</a>，与<a href="http://www.tvmcalcs.com/index.php/calculators/apps/excel_loan_amortization">Excel表兄弟</a>不同，它们能够以矢量的形式输出。</p>
<p>债务人（或承租人）每月支付一笔由本金和利息部分组成的固定金额。由于未偿还的贷款余额下降，总付款的利息部分随之下降。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>periods = np.arange(<span class="number">1</span>, nper + <span class="number">1</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>principal = np.ppmt(rate, periods, nper, pv)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interest = np.ipmt(rate, periods, nper, pv)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pmt = principal + interest  <span class="comment"># Or: pmt = np.pmt(rate, nper, pv)</span></span><br></pre></td></tr></table></figure>

<p>接下来，你需要计算每月的余额，包括支付前和付款后的余额，可以定义为<a href="http://financeformulas.net/Remaining_Balance_Formula.html">原始余额的未来价值减去年金(支付流)的未来价值</a>，使用折扣因子d：</p>
<p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/fv.7346eb669ac7.png" alt="原始余额未来价值计算的财务公式图"></p>
<p>从功能上看，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">balance</span>(<span class="params">pv, rate, nper, pmt</span>) -&gt; np.ndarray:</span></span><br><span class="line"><span class="meta">... </span>    d = (<span class="number">1</span> + rate) ** nper  <span class="comment"># Discount factor</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> pv * d - pmt * (d - <span class="number">1</span>) / rate</span><br></pre></td></tr></table></figure>

<p>最后，你可以使用Pandas 的 <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html">DataFrame</a> 将其放到表格格式中。小心这里的标志。从债务人的角度看，PMT是一种流出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cols = [<span class="string">&#x27;beg_bal&#x27;</span>, <span class="string">&#x27;prin&#x27;</span>, <span class="string">&#x27;interest&#x27;</span>, <span class="string">&#x27;end_bal&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [balance(pv, rate, periods - <span class="number">1</span>, -pmt),</span><br><span class="line"><span class="meta">... </span>        principal,</span><br><span class="line"><span class="meta">... </span>        interest,</span><br><span class="line"><span class="meta">... </span>        balance(pv, rate, periods, -pmt)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = pd.DataFrame(data, columns=periods, index=cols).T</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table.index.name = <span class="string">&#x27;month&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> pd.option_context(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="number">6</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># Note: Using floats for $$ in production-level code = bad</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(table.<span class="built_in">round</span>(<span class="number">2</span>))</span><br><span class="line">...</span><br><span class="line">         beg_bal     prin  interest    end_bal</span><br><span class="line">month</span><br><span class="line"><span class="number">1</span>      <span class="number">200000.00</span>  -<span class="number">172.20</span>  -<span class="number">1125.00</span>  <span class="number">199827.80</span></span><br><span class="line"><span class="number">2</span>      <span class="number">199827.80</span>  -<span class="number">173.16</span>  -<span class="number">1124.03</span>  <span class="number">199654.64</span></span><br><span class="line"><span class="number">3</span>      <span class="number">199654.64</span>  -<span class="number">174.14</span>  -<span class="number">1123.06</span>  <span class="number">199480.50</span></span><br><span class="line"><span class="meta">... </span>         ...      ...       ...        ...</span><br><span class="line"><span class="number">358</span>      <span class="number">3848.22</span> -<span class="number">1275.55</span>    -<span class="number">21.65</span>    <span class="number">2572.67</span></span><br><span class="line"><span class="number">359</span>      <span class="number">2572.67</span> -<span class="number">1282.72</span>    -<span class="number">14.47</span>    <span class="number">1289.94</span></span><br><span class="line"><span class="number">360</span>      <span class="number">1289.94</span> -<span class="number">1289.94</span>     -<span class="number">7.26</span>      -<span class="number">0.00</span></span><br></pre></td></tr></table></figure>

<p>At the end of year 30, the loan is paid off:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>final_month = periods[-<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.allclose(table.loc[final_month, <span class="string">&#x27;end_bal&#x27;</span>], <span class="number">0</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 虽然使用浮点数代表资金对于脚本环境中的概念说明非常有用，但在生产环境中使用Python浮点数进行财务计算可能会导致计算在某些情况下损失一两分钱。</p>
<h3 id="图像特征提取"><a href="#图像特征提取" class="headerlink" title="图像特征提取"></a>图像特征提取</h3><p>在最后一个例子中，我们将处理1941年10月莱克星顿号航空母舰(CV-2)的<a href="https://www.history.navy.mil/our-collections/photography/numerical-list-of-images/nara-series/80-g/80-G-410000/80-G-416362.html">照片</a>，这艘船的残骸是2018年3月在澳大利亚海岸外发现的。首先，我们可以将图像映射到它的像素值的NumPy数组中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = (<span class="string">&#x27;https://www.history.navy.mil/bin/imageDownload?image=/&#x27;</span></span><br><span class="line"><span class="meta">... </span>       <span class="string">&#x27;content/dam/nhhc/our-collections/photography/images/&#x27;</span></span><br><span class="line"><span class="meta">... </span>       <span class="string">&#x27;80-G-410000/80-G-416362&amp;rendition=cq5dam.thumbnail.319.319.png&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img = io.imread(url, as_grey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fig, ax = plt.subplots()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.grid(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/lex.77b7efabdb0c.png" alt="列克星敦号航空母舰的图像"></p>
<p>为了简单起见，图像是以灰度加载的，结果是一个由64位浮点数组成的2d数组，而不是一个三维mxnx4rgba数组，更低的值表示暗点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.shape</span><br><span class="line">(<span class="number">254</span>, <span class="number">319</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.<span class="built_in">min</span>(), img.<span class="built_in">max</span>()</span><br><span class="line">(<span class="number">0.027450980392156862</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">0</span>, :<span class="number">10</span>]  <span class="comment"># First ten cells of the first row</span></span><br><span class="line">array([<span class="number">0.8078</span>, <span class="number">0.7961</span>, <span class="number">0.7804</span>, <span class="number">0.7882</span>, <span class="number">0.7961</span>, <span class="number">0.8078</span>, <span class="number">0.8039</span>, <span class="number">0.7922</span>,</span><br><span class="line">       <span class="number">0.7961</span>, <span class="number">0.7961</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[-<span class="number">1</span>, -<span class="number">10</span>:]  <span class="comment"># Last ten cells of the last row</span></span><br><span class="line">array([<span class="number">0.0784</span>, <span class="number">0.0784</span>, <span class="number">0.0706</span>, <span class="number">0.0706</span>, <span class="number">0.0745</span>, <span class="number">0.0706</span>, <span class="number">0.0745</span>, <span class="number">0.0784</span>,</span><br><span class="line">       <span class="number">0.0784</span>, <span class="number">0.0824</span>])</span><br></pre></td></tr></table></figure>

<p>在图像分析中，一种常用的中间步骤是贴片提取。顾名思义，这包括从较大的数组中提取较小的重叠子数组，并可用于有利于“去噪”或模糊图像的情况。</p>
<p>这一概念也扩展到其他领域。例如，你可以通过使用具有多个特性(变量)的时间序列的“滚动”窗口来做类似的事情。它甚至对构建<a href="https://bitstorm.org/gameoflife/">康威的“生命游戏”</a>很有用。(不过，与3x3内核的<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve.html">卷积</a>是一种更直接的方法。)</p>
<p>在这里，我们将找到 img 中每个重叠的10x10修补的平均值。以一个微型示例为例，img左上角的第一个3x3修补程序矩阵将是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[:<span class="number">3</span>, :<span class="number">3</span>]</span><br><span class="line">array([[<span class="number">0.8078</span>, <span class="number">0.7961</span>, <span class="number">0.7804</span>],</span><br><span class="line">       [<span class="number">0.8039</span>, <span class="number">0.8157</span>, <span class="number">0.8078</span>],</span><br><span class="line">       [<span class="number">0.7882</span>, <span class="number">0.8</span>   , <span class="number">0.7961</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[:<span class="number">3</span>, :<span class="number">3</span>].mean()</span><br><span class="line"><span class="number">0.7995642701525054</span></span><br></pre></td></tr></table></figure>

<p>用于创建滑动修复方式的纯Python方法将涉及嵌套的for循环。你需要考虑最右边补丁的起始索引是在索引 n - 3 + 1，其中n是数组的宽度。换句话说，如果你从名为arr的10x10数组中提取3x3修复，那么最后一个修复将来自arr[7: 10, 7: 10]。 还要记住，Python的range()不包含其stop参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>size = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m, n = img.shape</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm, nn = m - size + <span class="number">1</span>, n - size + <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patch_means = np.empty((mm, nn))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mm):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line"><span class="meta">... </span>        patch_means[i, j] = img[i: i+size, j: j+size].mean()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fig, ax = plt.subplots()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.imshow(patch_means, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.grid(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/lexblur.0f886a01be97.png" alt="莱克星顿号航空母舰的模糊图像"></p>
<p>有了这个循环，你就会执行很多Python调用。</p>
<p>另一种可扩展到更大RGB或RGBA图像的替代方案是NumPy的stride_tricks。</p>
<p>一个有益的第一步是在给定修补大小和图像形状的情况下，可视化更高维度的修复矩阵。我们有一个2d数组img形状(254, 319)和一个(10, 10)2d 修复。这意味着我们的输出形状（在取每个“内部”* 10x10 *数组的平均值之前）将是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape = (img.shape[<span class="number">0</span>] - size + <span class="number">1</span>, img.shape[<span class="number">1</span>] - size + <span class="number">1</span>, size, size)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape</span><br><span class="line">(<span class="number">245</span>, <span class="number">310</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>你还需要指定新数组的<strong>步长</strong>。数组的步长是一个字节元组，用于在沿数组移动时跳转到每个维度。IMG中的每个像素都是64位(8字节)的浮点，这意味着总的图像大小为<em>254×319×8 = 648, 208</em>字节。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.dtype</span><br><span class="line">dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.nbytes</span><br><span class="line"><span class="number">648208</span></span><br></pre></td></tr></table></figure>

<p>在内部，IMG作为一个连续的648，208字节块保存在内存中。因此，STEAMS是一种类似“元数据”的属性，它告诉我们需要向前跳转多少字节才能沿着每个轴移动到下一个位置。我们沿着行以8字节为单位移动，但需要遍历<em>8x319=2，552</em>字节才能将“向下”从一行移动到另一行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.strides</span><br><span class="line">(<span class="number">2552</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>在我们的示例中，生成的修复程序的步调只会重复img的两次步调：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>strides = <span class="number">2</span> * img.strides</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strides</span><br><span class="line">(<span class="number">2552</span>, <span class="number">8</span>, <span class="number">2552</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>现在，让我们将这些部分与NumPy的<a href="https://www.numpy.org.cn/reference/routines/indexing.html#%E7%B1%BB%E4%BC%BC%E7%B4%A2%E5%BC%95%E7%9A%84%E6%93%8D%E4%BD%9C">stride_tricks</a>结合起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy.lib <span class="keyword">import</span> stride_tricks</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches = stride_tricks.as_strided(img, shape=shape, strides=strides)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches.shape</span><br><span class="line">(<span class="number">245</span>, <span class="number">310</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>Here’s the first <em>10x10</em> patch:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches[<span class="number">0</span>, <span class="number">0</span>].<span class="built_in">round</span>(<span class="number">2</span>)</span><br><span class="line">array([[<span class="number">0.81</span>, <span class="number">0.8</span> , <span class="number">0.78</span>, <span class="number">0.79</span>, <span class="number">0.8</span> , <span class="number">0.81</span>, <span class="number">0.8</span> , <span class="number">0.79</span>, <span class="number">0.8</span> , <span class="number">0.8</span> ],</span><br><span class="line">       [<span class="number">0.8</span> , <span class="number">0.82</span>, <span class="number">0.81</span>, <span class="number">0.79</span>, <span class="number">0.79</span>, <span class="number">0.79</span>, <span class="number">0.78</span>, <span class="number">0.81</span>, <span class="number">0.81</span>, <span class="number">0.8</span> ],</span><br><span class="line">       [<span class="number">0.79</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.79</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.82</span>, <span class="number">0.83</span>, <span class="number">0.79</span>, <span class="number">0.81</span>],</span><br><span class="line">       [<span class="number">0.8</span> , <span class="number">0.79</span>, <span class="number">0.81</span>, <span class="number">0.81</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.78</span>, <span class="number">0.76</span>, <span class="number">0.8</span> , <span class="number">0.79</span>],</span><br><span class="line">       [<span class="number">0.78</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.78</span>, <span class="number">0.8</span> , <span class="number">0.79</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.79</span>, <span class="number">0.79</span>],</span><br><span class="line">       [<span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.81</span>, <span class="number">0.79</span>],</span><br><span class="line">       [<span class="number">0.78</span>, <span class="number">0.77</span>, <span class="number">0.78</span>, <span class="number">0.76</span>, <span class="number">0.77</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.77</span>, <span class="number">0.8</span> , <span class="number">0.8</span> ],</span><br><span class="line">       [<span class="number">0.79</span>, <span class="number">0.76</span>, <span class="number">0.77</span>, <span class="number">0.78</span>, <span class="number">0.77</span>, <span class="number">0.77</span>, <span class="number">0.79</span>, <span class="number">0.78</span>, <span class="number">0.77</span>, <span class="number">0.76</span>],</span><br><span class="line">       [<span class="number">0.78</span>, <span class="number">0.75</span>, <span class="number">0.76</span>, <span class="number">0.76</span>, <span class="number">0.73</span>, <span class="number">0.75</span>, <span class="number">0.78</span>, <span class="number">0.76</span>, <span class="number">0.77</span>, <span class="number">0.77</span>],</span><br><span class="line">       [<span class="number">0.78</span>, <span class="number">0.79</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.77</span>, <span class="number">0.76</span>, <span class="number">0.77</span>, <span class="number">0.77</span>]])</span><br></pre></td></tr></table></figure>

<p>最后一步很棘手。 为了得到每个内部10x10数组的矢量化平均值，我们需要仔细考虑我们现在拥有的维数。结果应该折叠最后两个维度，以便我们留下一个245x310数组。</p>
<p>一种（次优）方式是首先重塑修复，将内部2d数组展平为长度为100的向量，然后计算最终轴上的均值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>veclen = size ** <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches.reshape(*patches.shape[:<span class="number">2</span>], veclen).mean(axis=-<span class="number">1</span>).shape</span><br><span class="line">(<span class="number">245</span>, <span class="number">310</span>)</span><br></pre></td></tr></table></figure>

<p>但是，你也可以将轴指定为元组，计算最后两个轴的平均值，这应该比重新整形更有效：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches.mean(axis=(-<span class="number">1</span>, -<span class="number">2</span>)).shape</span><br><span class="line">(<span class="number">245</span>, <span class="number">310</span>)</span><br></pre></td></tr></table></figure>

<p>让我们通过比较与循环版本的相等性来确保检查。它确实如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>strided_means = patches.mean(axis=(-<span class="number">1</span>, -<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.allclose(patch_means, strided_means)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>如果大步幅的概念让你感到兴奋，请不要激动：Scikit-Learn已经在其feature_extraction模块中很好地<a href="http://scikit-learn.org/stable/modules/feature_extraction.html#image-feature-extraction">嵌入了整个过程</a>。</p>
<h2 id="临别赠言：不要过度优化"><a href="#临别赠言：不要过度优化" class="headerlink" title="临别赠言：不要过度优化"></a>临别赠言：不要过度优化</h2><p>在本文中，我们讨论了利用NumPy中的数组编程来优化运行时。在处理大型数据集时，注意微观性能非常重要。</p>
<p>但是，有一部分案例无法避免使用本机Python for循环。正如Donald Knuth<a href="http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf">所说</a>，“过早优化是所有邪恶的根源。”程序员可能错误地预测他们的代码中会出现瓶颈的地方，花费数小时试图完全矢量化操作，这将导致运行时相对不显着的改进。</p>
<p>在这里或那里都放上for循环也没有任何问题。通常，考虑在更高的抽象级别优化整个脚本的流程和结构，可能会更有效率。</p>
<h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><p>书籍：</p>
<ul>
<li>Travis Oliphant’s <a href="https://realpython.com/asins/151730007X/">Guide to NumPy, 2nd ed</a>. (特拉维斯是NumPy的主要创建者。)</li>
<li>Chapter 2 (“Introduction to NumPy”) of Jake VanderPlas’ <a href="https://realpython.com/asins/1491912057/">Python数据科学手册</a></li>
<li>Chapter 4 (“NumPy Basics”) and Chapter 12 (“Advanced NumPy”) of Wes McKinney’s <a href="https://realpython.com/asins/B075X4LT6K/">Python for Data Analysis 2nd ed</a>.</li>
<li>Chapter 2 (“The Mathematical Building Blocks of Neural Networks”) from François Chollet’s <a href="https://realpython.com/asins/1617294438/">Deep Learning with Python</a></li>
<li>Robert Johansson’s <a href="https://realpython.com/asins/1484205545/">Numerical Python</a></li>
<li>Ivan Idris: <a href="https://realpython.com/asins/1785281968/">Numpy Beginner’s Guide, 3rd ed</a>.</li>
</ul>
<p>其他资源:</p>
<ul>
<li>维基百科: <a href="https://en.wikipedia.org/wiki/Array_programming">数组编程</a></li>
<li>SciPy 课堂讲义: <a href="http://www.scipy-lectures.org/intro/numpy/index.html">Basic</a> and <a href="http://www.scipy-lectures.org/advanced/advanced_numpy/index.html">Advanced</a> NumPy</li>
<li>EricsBroadcastingDoc: <a href="http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc">NumPy中的数组广播</a></li>
<li>SciPy Cookbook: <a href="http://scipy-cookbook.readthedocs.io/items/ViewsVsCopies.html">NumPy中的视图与副本</a></li>
<li>Nicolas Rougier: <a href="http://www.labri.fr/perso/nrougier/from-python-to-numpy/">从Python到Numpy</a> and <a href="http://www.labri.fr/perso/nrougier/teaching/numpy.100/index.html">100 NumPy练习</a></li>
<li>TensorFlow 文档: <a href="https://www.tensorflow.org/performance/xla/broadcasting">广播语法</a></li>
<li>Theano 文档: <a href="http://deeplearning.net/software/theano/tutorial/broadcasting.html">广播</a></li>
<li>Eli Bendersky: <a href="https://eli.thegreenplace.net/2015/broadcasting-arrays-in-numpy/">用Numpy广播数组</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy数据分析练习</title>
    <url>/2021/09/21/numpy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="NumPy-数据分析练习"><a href="#NumPy-数据分析练习" class="headerlink" title="NumPy 数据分析练习"></a>NumPy 数据分析练习</h1><p>Numpy练习的目标仅作为学习numpy的参考，并让你脱离基础性的NumPy使用。这些问题有4个级别的难度，其中L1是最容易的，L4是最难的。</p>
<h2 id="NumPy数据分析问答"><a href="#NumPy数据分析问答" class="headerlink" title="NumPy数据分析问答"></a>NumPy数据分析问答</h2><h3 id="1、导入numpy作为np，并查看版本"><a href="#1、导入numpy作为np，并查看版本" class="headerlink" title="1、导入numpy作为np，并查看版本"></a>1、导入numpy作为np，并查看版本</h3><p><strong>难度等级：</strong>L1 <strong>问题：</strong>将numpy导入为 <code>np</code> 并打印版本号。 <strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.__version__)</span><br><span class="line"><span class="comment"># &gt; 1.13.3</span></span><br></pre></td></tr></table></figure>

<p>你必须将numpy导入np，才能使本练习中的其余代码正常工作。</p>
<p>要安装numpy，建议安装anaconda，里面已经包含了numpy。</p>
<h3 id="2、如何创建一维数组？"><a href="#2、如何创建一维数组？" class="headerlink" title="2、如何创建一维数组？"></a>2、如何创建一维数组？</h3><p><strong>难度等级：</strong>L1 <strong>问题：</strong>创建从0到9的一维数字数组</p>
<p><strong>期望输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure>

<h3 id="3-如何创建一个布尔数组？"><a href="#3-如何创建一个布尔数组？" class="headerlink" title="3. 如何创建一个布尔数组？"></a>3. 如何创建一个布尔数组？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>创建一个numpy数组元素值全为True（真）的数组</p>
<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.full((<span class="number">3</span>, <span class="number">3</span>), <span class="literal">True</span>, dtype=<span class="built_in">bool</span>)</span><br><span class="line"><span class="comment"># &gt; array([[ True,  True,  True],</span></span><br><span class="line"><span class="comment"># &gt;        [ True,  True,  True],</span></span><br><span class="line"><span class="comment"># &gt;        [ True,  True,  True]], dtype=bool)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternate method:</span></span><br><span class="line">np.ones((<span class="number">3</span>,<span class="number">3</span>), dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-如何从一维数组中提取满足指定条件的元素？"><a href="#4-如何从一维数组中提取满足指定条件的元素？" class="headerlink" title="4. 如何从一维数组中提取满足指定条件的元素？"></a>4. 如何从一维数组中提取满足指定条件的元素？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>从 arr 中提取所有的奇数</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([1, 3, 5, 7, 9])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[arr % <span class="number">2</span> == <span class="number">1</span>]</span><br><span class="line"><span class="comment"># &gt; array([1, 3, 5, 7, 9])</span></span><br></pre></td></tr></table></figure>

<h3 id="5-如何用numpy数组中的另一个值替换满足条件的元素项？"><a href="#5-如何用numpy数组中的另一个值替换满足条件的元素项？" class="headerlink" title="5. 如何用numpy数组中的另一个值替换满足条件的元素项？"></a>5. 如何用numpy数组中的另一个值替换满足条件的元素项？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>将arr中的所有奇数替换为-1。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt;  array([ 0, -1,  2, -1,  4, -1,  6, -1,  8, -1])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr[arr % <span class="number">2</span> == <span class="number">1</span>] = -<span class="number">1</span></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([ 0, -1,  2, -1,  4, -1,  6, -1,  8, -1])</span></span><br></pre></td></tr></table></figure>

<h3 id="6-如何在不影响原始数组的情况下替换满足条件的元素项？"><a href="#6-如何在不影响原始数组的情况下替换满足条件的元素项？" class="headerlink" title="6. 如何在不影响原始数组的情况下替换满足条件的元素项？"></a>6. 如何在不影响原始数组的情况下替换满足条件的元素项？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>将arr中的所有奇数替换为-1，而不改变arr。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out</span><br><span class="line"><span class="comment"># &gt;  array([ 0, -1,  2, -1,  4, -1,  6, -1,  8, -1])</span></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt;  array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">out = np.where(arr % <span class="number">2</span> == <span class="number">1</span>, -<span class="number">1</span>, arr)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">out</span><br><span class="line"><span class="comment"># &gt; [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">array([ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">4</span>, -<span class="number">1</span>,  <span class="number">6</span>, -<span class="number">1</span>,  <span class="number">8</span>, -<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="7-如何改变数组的形状？"><a href="#7-如何改变数组的形状？" class="headerlink" title="7. 如何改变数组的形状？"></a>7. 如何改变数组的形状？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>将一维数组转换为2行的2维数组</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># &gt; array([[0, 1, 2, 3, 4],</span><br><span class="line"># &gt;        [5, 6, 7, 8, 9]])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr.reshape(<span class="number">2</span>, -<span class="number">1</span>)  <span class="comment"># Setting to -1 automatically decides the number of cols</span></span><br><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9]])</span></span><br></pre></td></tr></table></figure>

<h3 id="8-如何垂直叠加两个数组？"><a href="#8-如何垂直叠加两个数组？" class="headerlink" title="8. 如何垂直叠加两个数组？"></a>8. 如何垂直叠加两个数组？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>垂直堆叠数组a和数组b</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9],</span></span><br><span class="line"><span class="comment"># &gt;        [1, 1, 1, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [1, 1, 1, 1, 1]])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Answers</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">np.concatenate([a, b], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">np.vstack([a, b])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3:</span></span><br><span class="line">np.r_[a, b]</span><br><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9],</span></span><br><span class="line"><span class="comment"># &gt;        [1, 1, 1, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [1, 1, 1, 1, 1]])</span></span><br></pre></td></tr></table></figure>

<h3 id="9-如何水平叠加两个数组？"><a href="#9-如何水平叠加两个数组？" class="headerlink" title="9. 如何水平叠加两个数组？"></a>9. 如何水平叠加两个数组？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>将数组a和数组b水平堆叠。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4, 1, 1, 1, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9, 1, 1, 1, 1, 1]])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Answers</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">np.concatenate([a, b], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">np.hstack([a, b])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3:</span></span><br><span class="line">np.c_[a, b]</span><br><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4, 1, 1, 1, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9, 1, 1, 1, 1, 1]])</span></span><br></pre></td></tr></table></figure>

<h3 id="10-如何在无硬编码的情况下生成numpy中的自定义序列？"><a href="#10-如何在无硬编码的情况下生成numpy中的自定义序列？" class="headerlink" title="10. 如何在无硬编码的情况下生成numpy中的自定义序列？"></a>10. 如何在无硬编码的情况下生成numpy中的自定义序列？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>创建以下模式而不使用硬编码。只使用numpy函数和下面的输入数组a。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])`</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.r_[np.repeat(a, <span class="number">3</span>), np.tile(a, <span class="number">3</span>)]</span><br><span class="line"><span class="comment"># &gt; array([1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])</span></span><br></pre></td></tr></table></figure>

<h3 id="11-如何获取两个numpy数组之间的公共项？"><a href="#11-如何获取两个numpy数组之间的公共项？" class="headerlink" title="11. 如何获取两个numpy数组之间的公共项？"></a>11. 如何获取两个numpy数组之间的公共项？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>获取数组a和数组b之间的公共项。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = np.array([<span class="number">7</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">2</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = np.array([<span class="number">7</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line">np.intersect1d(a,b)</span><br><span class="line"><span class="comment"># &gt; array([2, 4])</span></span><br></pre></td></tr></table></figure>

<h3 id="12-如何从一个数组中删除存在于另一个数组中的项？"><a href="#12-如何从一个数组中删除存在于另一个数组中的项？" class="headerlink" title="12. 如何从一个数组中删除存在于另一个数组中的项？"></a>12. 如何从一个数组中删除存在于另一个数组中的项？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>从数组a中删除数组b中的所有项。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># From &#x27;a&#x27; remove all of &#x27;b&#x27;</span></span><br><span class="line">np.setdiff1d(a,b)</span><br><span class="line"><span class="comment"># &gt; array([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure>

<h3 id="13-如何得到两个数组元素匹配的位置？"><a href="#13-如何得到两个数组元素匹配的位置？" class="headerlink" title="13. 如何得到两个数组元素匹配的位置？"></a>13. 如何得到两个数组元素匹配的位置？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>获取a和b元素匹配的位置。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = np.array([<span class="number">7</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; (array([1, 3, 5, 7]),)</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = np.array([<span class="number">7</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">np.where(a == b)</span><br><span class="line"><span class="comment"># &gt; (array([1, 3, 5, 7]),)</span></span><br></pre></td></tr></table></figure>

<h3 id="14-如何从numpy数组中提取给定范围内的所有数字？"><a href="#14-如何从numpy数组中提取给定范围内的所有数字？" class="headerlink" title="14. 如何从numpy数组中提取给定范围内的所有数字？"></a>14. 如何从numpy数组中提取给定范围内的所有数字？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>获取5到10之间的所有项目。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">27</span>])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(array([<span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]),)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1</span></span><br><span class="line">index = np.where((a &gt;= <span class="number">5</span>) &amp; (a &lt;= <span class="number">10</span>))</span><br><span class="line">a[index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">index = np.where(np.logical_and(a&gt;=<span class="number">5</span>, a&lt;=<span class="number">10</span>))</span><br><span class="line">a[index]</span><br><span class="line"><span class="comment"># &gt; (array([6, 9, 10]),)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3: (thanks loganzk!)</span></span><br><span class="line">a[(a &gt;= <span class="number">5</span>) &amp; (a &lt;= <span class="number">10</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="15-如何创建一个python函数来处理scalars并在numpy数组上工作？"><a href="#15-如何创建一个python函数来处理scalars并在numpy数组上工作？" class="headerlink" title="15. 如何创建一个python函数来处理scalars并在numpy数组上工作？"></a>15. 如何创建一个python函数来处理scalars并在numpy数组上工作？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>转换适用于两个标量的函数maxx，以处理两个数组。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxx</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get the maximum of two items&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">maxx(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># &gt; 5</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>])</span><br><span class="line">pair_max(a, b)</span><br><span class="line"><span class="comment"># &gt; array([ 6.,  7.,  9.,  8.,  9.,  7.,  5.])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxx</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get the maximum of two items&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">pair_max = np.vectorize(maxx, otypes=[<span class="built_in">float</span>])</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">pair_max(a, b)</span><br><span class="line"><span class="comment"># &gt; array([ 6.,  7.,  9.,  8.,  9.,  7.,  5.])</span></span><br></pre></td></tr></table></figure>

<h3 id="16-如何交换二维numpy数组中的两列？"><a href="#16-如何交换二维numpy数组中的两列？" class="headerlink" title="16. 如何交换二维numpy数组中的两列？"></a>16. 如何交换二维numpy数组中的两列？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>在数组arr中交换列1和2。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[:, [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="comment"># &gt; array([[1, 0, 2],</span></span><br><span class="line"><span class="comment"># &gt;        [4, 3, 5],</span></span><br><span class="line"><span class="comment"># &gt;        [7, 6, 8]])</span></span><br></pre></td></tr></table></figure>

<h3 id="17-如何交换二维numpy数组中的两行？"><a href="#17-如何交换二维numpy数组中的两行？" class="headerlink" title="17. 如何交换二维numpy数组中的两行？"></a>17. 如何交换二维numpy数组中的两行？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>交换数组arr中的第1和第2行：</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>], :]</span><br><span class="line"><span class="comment"># &gt; array([[3, 4, 5],</span></span><br><span class="line"><span class="comment"># &gt;        [0, 1, 2],</span></span><br><span class="line"><span class="comment"># &gt;        [6, 7, 8]])</span></span><br></pre></td></tr></table></figure>

<h3 id="18-如何反转二维数组的行？"><a href="#18-如何反转二维数组的行？" class="headerlink" title="18. 如何反转二维数组的行？"></a>18. 如何反转二维数组的行？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>反转二维数组arr的行。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[::-<span class="number">1</span>]</span><br><span class="line">array([[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="19-如何反转二维数组的列？"><a href="#19-如何反转二维数组的列？" class="headerlink" title="19. 如何反转二维数组的列？"></a>19. 如何反转二维数组的列？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>反转二维数组arr的列。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[:, ::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># &gt; array([[2, 1, 0],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 4, 3],</span></span><br><span class="line"><span class="comment"># &gt;        [8, 7, 6]])</span></span><br></pre></td></tr></table></figure>

<h3 id="20-如何创建包含5到10之间随机浮动的二维数组？"><a href="#20-如何创建包含5到10之间随机浮动的二维数组？" class="headerlink" title="20. 如何创建包含5到10之间随机浮动的二维数组？"></a>20. 如何创建包含5到10之间随机浮动的二维数组？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>创建一个形状为5x3的二维数组，以包含5到10之间的随机十进制数。</p>
<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution Method 1:</span></span><br><span class="line">rand_arr = np.random.randint(low=<span class="number">5</span>, high=<span class="number">10</span>, size=(<span class="number">5</span>,<span class="number">3</span>)) + np.random.random((<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># print(rand_arr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution Method 2:</span></span><br><span class="line">rand_arr = np.random.uniform(<span class="number">5</span>,<span class="number">10</span>, size=(<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(rand_arr)</span><br><span class="line"><span class="comment"># &gt; [[ 8.50061025  9.10531502  6.85867783]</span></span><br><span class="line"><span class="comment"># &gt;  [ 9.76262069  9.87717411  7.13466701]</span></span><br><span class="line"><span class="comment"># &gt;  [ 7.48966403  8.33409158  6.16808631]</span></span><br><span class="line"><span class="comment"># &gt;  [ 7.75010551  9.94535696  5.27373226]</span></span><br><span class="line"><span class="comment"># &gt;  [ 8.0850361   5.56165518  7.31244004]]</span></span><br></pre></td></tr></table></figure>

<h3 id="21-如何在numpy数组中只打印小数点后三位？"><a href="#21-如何在numpy数组中只打印小数点后三位？" class="headerlink" title="21. 如何在numpy数组中只打印小数点后三位？"></a>21. 如何在numpy数组中只打印小数点后三位？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>只打印或显示numpy数组rand_arr的小数点后3位。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rand_arr = np.random.random((<span class="number">5</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">rand_arr = np.random.random((<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the random array</span></span><br><span class="line">rand_arr = np.random.random([<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Limit to 3 decimal places</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">3</span>)</span><br><span class="line">rand_arr[:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># &gt; array([[ 0.443,  0.109,  0.97 ],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.388,  0.447,  0.191],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.891,  0.474,  0.212],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.609,  0.518,  0.403]])</span></span><br></pre></td></tr></table></figure>

<h3 id="22-如何通过e式科学记数法（如1e10）来打印一个numpy数组？"><a href="#22-如何通过e式科学记数法（如1e10）来打印一个numpy数组？" class="headerlink" title="22. 如何通过e式科学记数法（如1e10）来打印一个numpy数组？"></a>22. 如何通过e式科学记数法（如1e10）来打印一个numpy数组？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>通过e式科学记数法来打印rand_arr（如1e10）</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create the random array</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">rand_arr = np.random.random([<span class="number">3</span>,<span class="number">3</span>])/<span class="number">1e3</span></span><br><span class="line">rand_arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; array([[  5.434049e-04,   2.783694e-04,   4.245176e-04],</span></span><br><span class="line"><span class="comment"># &gt;        [  8.447761e-04,   4.718856e-06,   1.215691e-04],</span></span><br><span class="line"><span class="comment"># &gt;        [  6.707491e-04,   8.258528e-04,   1.367066e-04]])</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([[ 0.000543,  0.000278,  0.000425],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.000845,  0.000005,  0.000122],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.000671,  0.000826,  0.000137]])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reset printoptions to default</span></span><br><span class="line">np.set_printoptions(suppress=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the random array</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">rand_arr = np.random.random([<span class="number">3</span>,<span class="number">3</span>])/<span class="number">1e3</span></span><br><span class="line">rand_arr</span><br><span class="line"><span class="comment"># &gt; array([[  5.434049e-04,   2.783694e-04,   4.245176e-04],</span></span><br><span class="line"><span class="comment"># &gt;        [  8.447761e-04,   4.718856e-06,   1.215691e-04],</span></span><br><span class="line"><span class="comment"># &gt;        [  6.707491e-04,   8.258528e-04,   1.367066e-04]])</span></span><br><span class="line">np.set_printoptions(suppress=<span class="literal">True</span>, precision=<span class="number">6</span>)  <span class="comment"># precision is optional</span></span><br><span class="line">rand_arr</span><br><span class="line"><span class="comment"># &gt; array([[ 0.000543,  0.000278,  0.000425],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.000845,  0.000005,  0.000122],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.000671,  0.000826,  0.000137]])</span></span><br></pre></td></tr></table></figure>

<h3 id="23-如何限制numpy数组输出中打印的项目数？"><a href="#23-如何限制numpy数组输出中打印的项目数？" class="headerlink" title="23. 如何限制numpy数组输出中打印的项目数？"></a>23. 如何限制numpy数组输出中打印的项目数？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>将numpy数组a中打印的项数限制为最多6个元素。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([ 0,  1,  2, ..., 12, 13, 14])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.set_printoptions(threshold=<span class="number">6</span>)</span><br><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2, ..., 12, 13, 14])</span></span><br></pre></td></tr></table></figure>

<h3 id="24-如何打印完整的numpy数组而不截断"><a href="#24-如何打印完整的numpy数组而不截断" class="headerlink" title="24. 如何打印完整的numpy数组而不截断"></a>24. 如何打印完整的numpy数组而不截断</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>打印完整的numpy数组a而不截断。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.set_printoptions(threshold=<span class="number">6</span>)</span><br><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2, ..., 12, 13, 14])</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.set_printoptions(threshold=<span class="number">6</span>)</span><br><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">np.set_printoptions(threshold=np.nan)</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure>

<h3 id="25-如何导入数字和文本的数据集保持文本在numpy数组中完好无损？"><a href="#25-如何导入数字和文本的数据集保持文本在numpy数组中完好无损？" class="headerlink" title="25. 如何导入数字和文本的数据集保持文本在numpy数组中完好无损？"></a>25. 如何导入数字和文本的数据集保持文本在numpy数组中完好无损？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>导入鸢尾属植物数据集，保持文本不变。</p>
<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Solution</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the first 3 rows</span></span><br><span class="line">iris[:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># &gt; array([[b&#x27;5.1&#x27;, b&#x27;3.5&#x27;, b&#x27;1.4&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.9&#x27;, b&#x27;3.0&#x27;, b&#x27;1.4&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.7&#x27;, b&#x27;3.2&#x27;, b&#x27;1.3&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;]], dtype=object)</span></span><br></pre></td></tr></table></figure>

<h3 id="26-如何从1维元组数组中提取特定列？"><a href="#26-如何从1维元组数组中提取特定列？" class="headerlink" title="26. 如何从1维元组数组中提取特定列？"></a>26. 如何从1维元组数组中提取特定列？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>从前面问题中导入的一维鸢尾属植物数据集中提取文本列的物种。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_1d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_1d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(iris_1d.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line">species = np.array([row[<span class="number">4</span>] <span class="keyword">for</span> row <span class="keyword">in</span> iris_1d])</span><br><span class="line">species[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># &gt; (150,)</span></span><br><span class="line"><span class="comment"># &gt; array([b&#x27;Iris-setosa&#x27;, b&#x27;Iris-setosa&#x27;, b&#x27;Iris-setosa&#x27;, b&#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        b&#x27;Iris-setosa&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;|S18&#x27;)</span></span><br></pre></td></tr></table></figure>

<h3 id="27-如何将1维元组数组转换为2维numpy数组？"><a href="#27-如何将1维元组数组转换为2维numpy数组？" class="headerlink" title="27. 如何将1维元组数组转换为2维numpy数组？"></a>27. 如何将1维元组数组转换为2维numpy数组？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>通过省略鸢尾属植物数据集种类的文本字段，将一维鸢尾属植物数据集转换为二维数组iris_2d。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_1d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_1d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line"><span class="comment"># Method 1: Convert each row to a list and get the first 4 items</span></span><br><span class="line">iris_2d = np.array([row.tolist()[:<span class="number">4</span>] <span class="keyword">for</span> row <span class="keyword">in</span> iris_1d])</span><br><span class="line">iris_2d[:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alt Method 2: Import only the first 4 columns from source url</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># &gt; array([[ 5.1,  3.5,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.9,  3. ,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.7,  3.2,  1.3,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.6,  3.1,  1.5,  0.2]])</span></span><br></pre></td></tr></table></figure>

<h3 id="28-如何计算numpy数组的均值，中位数，标准差？"><a href="#28-如何计算numpy数组的均值，中位数，标准差？" class="headerlink" title="28. 如何计算numpy数组的均值，中位数，标准差？"></a>28. 如何计算numpy数组的均值，中位数，标准差？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>求出鸢尾属植物萼片长度的平均值、中位数和标准差(第1列)</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">mu, med, sd = np.mean(sepallength), np.median(sepallength), np.std(sepallength)</span><br><span class="line"><span class="built_in">print</span>(mu, med, sd)</span><br><span class="line"><span class="comment"># &gt; 5.84333333333 5.8 0.825301291785</span></span><br></pre></td></tr></table></figure>

<h3 id="29-如何规范化数组，使数组的值正好介于0和1之间？"><a href="#29-如何规范化数组，使数组的值正好介于0和1之间？" class="headerlink" title="29. 如何规范化数组，使数组的值正好介于0和1之间？"></a>29. 如何规范化数组，使数组的值正好介于0和1之间？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>创建一种标准化形式的鸢尾属植物间隔长度，其值正好介于0和1之间，这样最小值为0，最大值为1。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">Smax, Smin = sepallength.<span class="built_in">max</span>(), sepallength.<span class="built_in">min</span>()</span><br><span class="line">S = (sepallength - Smin)/(Smax - Smin)</span><br><span class="line"><span class="comment"># or </span></span><br><span class="line">S = (sepallength - Smin)/sepallength.ptp()  <span class="comment"># Thanks, David Ojeda!</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"><span class="comment"># &gt; [ 0.222  0.167  0.111  0.083  0.194  0.306  0.083  0.194  0.028  0.167</span></span><br><span class="line"><span class="comment"># &gt;   0.306  0.139  0.139  0.     0.417  0.389  0.306  0.222  0.389  0.222</span></span><br><span class="line"><span class="comment"># &gt;   0.306  0.222  0.083  0.222  0.139  0.194  0.194  0.25   0.25   0.111</span></span><br><span class="line"><span class="comment"># &gt;   0.139  0.306  0.25   0.333  0.167  0.194  0.333  0.167  0.028  0.222</span></span><br><span class="line"><span class="comment"># &gt;   0.194  0.056  0.028  0.194  0.222  0.139  0.222  0.083  0.278  0.194</span></span><br><span class="line"><span class="comment"># &gt;   0.75   0.583  0.722  0.333  0.611  0.389  0.556  0.167  0.639  0.25</span></span><br><span class="line"><span class="comment"># &gt;   0.194  0.444  0.472  0.5    0.361  0.667  0.361  0.417  0.528  0.361</span></span><br><span class="line"><span class="comment"># &gt;   0.444  0.5    0.556  0.5    0.583  0.639  0.694  0.667  0.472  0.389</span></span><br><span class="line"><span class="comment"># &gt;   0.333  0.333  0.417  0.472  0.306  0.472  0.667  0.556  0.361  0.333</span></span><br><span class="line"><span class="comment"># &gt;   0.333  0.5    0.417  0.194  0.361  0.389  0.389  0.528  0.222  0.389</span></span><br><span class="line"><span class="comment"># &gt;   0.556  0.417  0.778  0.556  0.611  0.917  0.167  0.833  0.667  0.806</span></span><br><span class="line"><span class="comment"># &gt;   0.611  0.583  0.694  0.389  0.417  0.583  0.611  0.944  0.944  0.472</span></span><br><span class="line"><span class="comment"># &gt;   0.722  0.361  0.944  0.556  0.667  0.806  0.528  0.5    0.583  0.806</span></span><br><span class="line"><span class="comment"># &gt;   0.861  1.     0.583  0.556  0.5    0.944  0.556  0.583  0.472  0.722</span></span><br><span class="line"><span class="comment"># &gt;   0.667  0.722  0.417  0.694  0.667  0.667  0.556  0.611  0.528  0.444]</span></span><br></pre></td></tr></table></figure>

<h3 id="30-如何计算Softmax得分？"><a href="#30-如何计算Softmax得分？" class="headerlink" title="30. 如何计算Softmax得分？"></a>30. 如何计算Softmax得分？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>计算sepallength的softmax分数。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">sepallength = np.array([<span class="built_in">float</span>(row[<span class="number">0</span>]) <span class="keyword">for</span> row <span class="keyword">in</span> iris])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Compute softmax values for each sets of scores in x.</span></span><br><span class="line"><span class="string">    https://stackoverflow.com/questions/34968722/how-to-implement-the-softmax-function-in-python&quot;&quot;&quot;</span></span><br><span class="line">    e_x = np.exp(x - np.<span class="built_in">max</span>(x))</span><br><span class="line">    <span class="keyword">return</span> e_x / e_x.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(softmax(sepallength))</span><br><span class="line"><span class="comment"># &gt; [ 0.002  0.002  0.001  0.001  0.002  0.003  0.001  0.002  0.001  0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.003  0.002  0.002  0.001  0.004  0.004  0.003  0.002  0.004  0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.003  0.002  0.001  0.002  0.002  0.002  0.002  0.002  0.002  0.001</span></span><br><span class="line"><span class="comment"># &gt;   0.002  0.003  0.002  0.003  0.002  0.002  0.003  0.002  0.001  0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.002  0.001  0.001  0.002  0.002  0.002  0.002  0.001  0.003  0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.015  0.008  0.013  0.003  0.009  0.004  0.007  0.002  0.01   0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.002  0.005  0.005  0.006  0.004  0.011  0.004  0.004  0.007  0.004</span></span><br><span class="line"><span class="comment"># &gt;   0.005  0.006  0.007  0.006  0.008  0.01   0.012  0.011  0.005  0.004</span></span><br><span class="line"><span class="comment"># &gt;   0.003  0.003  0.004  0.005  0.003  0.005  0.011  0.007  0.004  0.003</span></span><br><span class="line"><span class="comment"># &gt;   0.003  0.006  0.004  0.002  0.004  0.004  0.004  0.007  0.002  0.004</span></span><br><span class="line"><span class="comment"># &gt;   0.007  0.004  0.016  0.007  0.009  0.027  0.002  0.02   0.011  0.018</span></span><br><span class="line"><span class="comment"># &gt;   0.009  0.008  0.012  0.004  0.004  0.008  0.009  0.03   0.03   0.005</span></span><br><span class="line"><span class="comment"># &gt;   0.013  0.004  0.03   0.007  0.011  0.018  0.007  0.006  0.008  0.018</span></span><br><span class="line"><span class="comment"># &gt;   0.022  0.037  0.008  0.007  0.006  0.03   0.007  0.008  0.005  0.013</span></span><br><span class="line"><span class="comment"># &gt;   0.011  0.013  0.004  0.012  0.011  0.011  0.007  0.009  0.007  0.005]</span></span><br></pre></td></tr></table></figure>

<h3 id="31-如何找到numpy数组的百分位数？"><a href="#31-如何找到numpy数组的百分位数？" class="headerlink" title="31. 如何找到numpy数组的百分位数？"></a>31. 如何找到numpy数组的百分位数？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>找到鸢尾属植物数据集的第5和第95百分位数</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">np.percentile(sepallength, q=[<span class="number">5</span>, <span class="number">95</span>])</span><br><span class="line"><span class="comment"># &gt; array([ 4.6  ,  7.255])</span></span><br></pre></td></tr></table></figure>

<h3 id="32-如何在数组中的随机位置插入值？"><a href="#32-如何在数组中的随机位置插入值？" class="headerlink" title="32. 如何在数组中的随机位置插入值？"></a>32. 如何在数组中的随机位置插入值？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>在iris_2d数据集中的20个随机位置插入np.nan值</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1</span></span><br><span class="line">i, j = np.where(iris_2d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># i, j contain the row numbers and column numbers of 600 elements of iris_x</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">iris_2d[np.random.choice((i), <span class="number">20</span>), np.random.choice((j), <span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print first 10 rows</span></span><br><span class="line"><span class="built_in">print</span>(iris_2d[:<span class="number">10</span>])</span><br><span class="line"><span class="comment"># &gt; [[b&#x27;5.1&#x27; b&#x27;3.5&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;3.0&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.7&#x27; b&#x27;3.2&#x27; b&#x27;1.3&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;5.0&#x27; b&#x27;3.6&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;5.4&#x27; b&#x27;3.9&#x27; b&#x27;1.7&#x27; b&#x27;0.4&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.4&#x27; b&#x27;1.4&#x27; b&#x27;0.3&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;5.0&#x27; b&#x27;3.4&#x27; b&#x27;1.5&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.4&#x27; nan b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]]</span></span><br></pre></td></tr></table></figure>

<h3 id="33-如何在numpy数组中找到缺失值的位置？"><a href="#33-如何在numpy数组中找到缺失值的位置？" class="headerlink" title="33. 如何在numpy数组中找到缺失值的位置？"></a>33. 如何在numpy数组中找到缺失值的位置？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>在iris_2d的sepallength中查找缺失值的数量和位置（第1列）</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of missing values: \n&quot;</span>, np.isnan(iris_2d[:, <span class="number">0</span>]).<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Position of missing values: \n&quot;</span>, np.where(np.isnan(iris_2d[:, <span class="number">0</span>])))</span><br><span class="line"><span class="comment"># &gt; Number of missing values: </span></span><br><span class="line"><span class="comment"># &gt;  5</span></span><br><span class="line"><span class="comment"># &gt; Position of missing values: </span></span><br><span class="line"><span class="comment"># &gt;  (array([ 39,  88,  99, 130, 147]),)</span></span><br></pre></td></tr></table></figure>

<h3 id="34-如何根据两个或多个条件过滤numpy数组？"><a href="#34-如何根据两个或多个条件过滤numpy数组？" class="headerlink" title="34. 如何根据两个或多个条件过滤numpy数组？"></a>34. 如何根据两个或多个条件过滤numpy数组？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>过滤具有petallength（第3列）&gt; 1.5 和 sepallength（第1列）&lt; 5.0 的iris_2d行</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">condition = (iris_2d[:, <span class="number">2</span>] &gt; <span class="number">1.5</span>) &amp; (iris_2d[:, <span class="number">0</span>] &lt; <span class="number">5.0</span>)</span><br><span class="line">iris_2d[condition]</span><br><span class="line"><span class="comment"># &gt; array([[ 4.8,  3.4,  1.6,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.8,  3.4,  1.9,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.7,  3.2,  1.6,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.8,  3.1,  1.6,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.9,  2.4,  3.3,  1. ],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.9,  2.5,  4.5,  1.7]])</span></span><br></pre></td></tr></table></figure>

<h3 id="35-如何从numpy数组中删除包含缺失值的行？"><a href="#35-如何从numpy数组中删除包含缺失值的行？" class="headerlink" title="35. 如何从numpy数组中删除包含缺失值的行？"></a>35. 如何从numpy数组中删除包含缺失值的行？</h3><p><strong>难度等级：</strong>L3:</p>
<p><strong>问题：</strong>选择没有任何nan值的iris_2d行。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># No direct numpy function for this.</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">any_nan_in_row = np.array([~np.<span class="built_in">any</span>(np.isnan(row)) <span class="keyword">for</span> row <span class="keyword">in</span> iris_2d])</span><br><span class="line">iris_2d[any_nan_in_row][:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2: (By Rong)</span></span><br><span class="line">iris_2d[np.<span class="built_in">sum</span>(np.isnan(iris_2d), axis = <span class="number">1</span>) == <span class="number">0</span>][:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># &gt; array([[ 4.9,  3. ,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.7,  3.2,  1.3,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.6,  3.1,  1.5,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 5. ,  3.6,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 5.4,  3.9,  1.7,  0.4]])</span></span><br></pre></td></tr></table></figure>

<h3 id="36-如何找到numpy数组的两列之间的相关性？"><a href="#36-如何找到numpy数组的两列之间的相关性？" class="headerlink" title="36. 如何找到numpy数组的两列之间的相关性？"></a>36. 如何找到numpy数组的两列之间的相关性？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>在iris_2d中找出SepalLength（第1列）和PetalLength（第3列）之间的相关性</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1</span></span><br><span class="line">np.corrcoef(iris[:, <span class="number">0</span>], iris[:, <span class="number">2</span>])[<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2</span></span><br><span class="line"><span class="keyword">from</span> scipy.stats.stats <span class="keyword">import</span> pearsonr  </span><br><span class="line">corr, p_value = pearsonr(iris[:, <span class="number">0</span>], iris[:, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(corr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Correlation coef indicates the degree of linear relationship between two numeric variables.</span></span><br><span class="line"><span class="comment"># It can range between -1 to +1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The p-value roughly indicates the probability of an uncorrelated system producing </span></span><br><span class="line"><span class="comment"># datasets that have a correlation at least as extreme as the one computed.</span></span><br><span class="line"><span class="comment"># The lower the p-value (&lt;0.01), stronger is the significance of the relationship.</span></span><br><span class="line"><span class="comment"># It is not an indicator of the strength.</span></span><br><span class="line"><span class="comment"># &gt; 0.871754157305</span></span><br></pre></td></tr></table></figure>

<h3 id="37-如何查找给定数组是否具有任何空值？"><a href="#37-如何查找给定数组是否具有任何空值？" class="headerlink" title="37. 如何查找给定数组是否具有任何空值？"></a>37. 如何查找给定数组是否具有任何空值？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>找出iris_2d是否有任何缺失值。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">np.isnan(iris_2d).<span class="built_in">any</span>()</span><br><span class="line"><span class="comment"># &gt; False</span></span><br></pre></td></tr></table></figure>

<h3 id="38-如何在numpy数组中用0替换所有缺失值？"><a href="#38-如何在numpy数组中用0替换所有缺失值？" class="headerlink" title="38. 如何在numpy数组中用0替换所有缺失值？"></a>38. 如何在numpy数组中用0替换所有缺失值？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>在numpy数组中将所有出现的nan替换为0</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">iris_2d[np.isnan(iris_2d)] = <span class="number">0</span></span><br><span class="line">iris_2d[:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># &gt; array([[ 5.1,  3.5,  1.4,  0. ],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.9,  3. ,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.7,  3.2,  1.3,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.6,  3.1,  1.5,  0.2]])</span></span><br></pre></td></tr></table></figure>

<h3 id="39-如何在numpy数组中查找唯一值的计数？"><a href="#39-如何在numpy数组中查找唯一值的计数？" class="headerlink" title="39. 如何在numpy数组中查找唯一值的计数？"></a>39. 如何在numpy数组中查找唯一值的计数？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>找出鸢尾属植物物种中的独特值和独特值的数量</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import iris keeping the text column intact</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Extract the species column as an array</span></span><br><span class="line">species = np.array([row.tolist()[<span class="number">4</span>] <span class="keyword">for</span> row <span class="keyword">in</span> iris])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the unique values and the counts</span></span><br><span class="line">np.unique(species, return_counts=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># &gt; (array([b&#x27;Iris-setosa&#x27;, b&#x27;Iris-versicolor&#x27;, b&#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;        dtype=&#x27;|S15&#x27;), array([50, 50, 50]))</span></span><br></pre></td></tr></table></figure>

<h3 id="40-如何将数字转换为分类（文本）数组？"><a href="#40-如何将数字转换为分类（文本）数组？" class="headerlink" title="40. 如何将数字转换为分类（文本）数组？"></a>40. 如何将数字转换为分类（文本）数组？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>将iris_2d的花瓣长度（第3列）加入以形成文本数组，这样如果花瓣长度为：</p>
<ul>
<li>Less than 3 –&gt; ‘small’</li>
<li>3-5 –&gt; ‘medium’</li>
<li>‘&gt;=5 –&gt; ‘large’</li>
</ul>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bin petallength </span></span><br><span class="line">petal_length_bin = np.digitize(iris[:, <span class="number">2</span>].astype(<span class="string">&#x27;float&#x27;</span>), [<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Map it to respective category</span></span><br><span class="line">label_map = &#123;<span class="number">1</span>: <span class="string">&#x27;small&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;medium&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;large&#x27;</span>, <span class="number">4</span>: np.nan&#125;</span><br><span class="line">petal_length_cat = [label_map[x] <span class="keyword">for</span> x <span class="keyword">in</span> petal_length_bin]</span><br><span class="line"></span><br><span class="line"><span class="comment"># View</span></span><br><span class="line">petal_length_cat[:<span class="number">4</span>]</span><br><span class="line">&lt;<span class="comment"># &gt; [&#x27;small&#x27;, &#x27;small&#x27;, &#x27;small&#x27;, &#x27;small&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="41-如何从numpy数组的现有列创建新列？"><a href="#41-如何从numpy数组的现有列创建新列？" class="headerlink" title="41. 如何从numpy数组的现有列创建新列？"></a>41. 如何从numpy数组的现有列创建新列？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>在iris_2d中为卷创建一个新列，其中volume是<code>（pi x petallength x sepal_length ^ 2）/ 3</code></p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Compute volume</span></span><br><span class="line">sepallength = iris_2d[:, <span class="number">0</span>].astype(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line">petallength = iris_2d[:, <span class="number">2</span>].astype(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line">volume = (np.pi * petallength * (sepallength**<span class="number">2</span>))/<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Introduce new dimension to match iris_2d&#x27;s</span></span><br><span class="line">volume = volume[:, np.newaxis]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the new column</span></span><br><span class="line">out = np.hstack([iris_2d, volume])</span><br><span class="line"></span><br><span class="line"><span class="comment"># View</span></span><br><span class="line">out[:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># &gt; array([[b&#x27;5.1&#x27;, b&#x27;3.5&#x27;, b&#x27;1.4&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;, 38.13265162927291],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.9&#x27;, b&#x27;3.0&#x27;, b&#x27;1.4&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;, 35.200498485922445],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.7&#x27;, b&#x27;3.2&#x27;, b&#x27;1.3&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;, 30.0723720777127],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.6&#x27;, b&#x27;3.1&#x27;, b&#x27;1.5&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;, 33.238050274980004]], dtype=object)</span></span><br></pre></td></tr></table></figure>

<h3 id="42-如何在numpy中进行概率抽样？"><a href="#42-如何在numpy中进行概率抽样？" class="headerlink" title="42. 如何在numpy中进行概率抽样？"></a>42. 如何在numpy中进行概率抽样？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>随机抽鸢尾属植物的种类，使得刚毛的数量是云芝和维吉尼亚的两倍</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import iris keeping the text column intact</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import iris keeping the text column intact</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Get the species column</span></span><br><span class="line">species = iris[:, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Approach 1: Generate Probablistically</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.array([<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>])</span><br><span class="line">species_out = np.random.choice(a, <span class="number">150</span>, p=[<span class="number">0.5</span>, <span class="number">0.25</span>, <span class="number">0.25</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Approach 2: Probablistic Sampling (preferred)</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">probs = np.r_[np.linspace(<span class="number">0</span>, <span class="number">0.500</span>, num=<span class="number">50</span>), np.linspace(<span class="number">0.501</span>, <span class="number">.750</span>, num=<span class="number">50</span>), np.linspace(<span class="number">.751</span>, <span class="number">1.0</span>, num=<span class="number">50</span>)]</span><br><span class="line">index = np.searchsorted(probs, np.random.random(<span class="number">150</span>))</span><br><span class="line">species_out = species[index]</span><br><span class="line"><span class="built_in">print</span>(np.unique(species_out, return_counts=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; (array([b&#x27;Iris-setosa&#x27;, b&#x27;Iris-versicolor&#x27;, b&#x27;Iris-virginica&#x27;], dtype=object), array([77, 37, 36]))</span></span><br></pre></td></tr></table></figure>

<p>方法2是首选方法，因为它创建了一个索引变量，该变量可用于取样2维表格数据。</p>
<h3 id="43-如何在按另一个数组分组时获取数组的第二大值？"><a href="#43-如何在按另一个数组分组时获取数组的第二大值？" class="headerlink" title="43. 如何在按另一个数组分组时获取数组的第二大值？"></a>43. 如何在按另一个数组分组时获取数组的第二大值？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>第二长的物种setosa的价值是多少</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import iris keeping the text column intact</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Get the species and petal length columns</span></span><br><span class="line">petal_len_setosa = iris[iris[:, <span class="number">4</span>] == <span class="string">b&#x27;Iris-setosa&#x27;</span>, [<span class="number">2</span>]].astype(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the second last value</span></span><br><span class="line">np.unique(np.sort(petal_len_setosa))[-<span class="number">2</span>]</span><br><span class="line"><span class="comment"># &gt; 1.7</span></span><br></pre></td></tr></table></figure>

<h3 id="44-如何按列对2D数组进行排序"><a href="#44-如何按列对2D数组进行排序" class="headerlink" title="44. 如何按列对2D数组进行排序"></a>44. 如何按列对2D数组进行排序</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>根据sepallength列对虹膜数据集进行排序。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sort by column position 0: SepalLength</span></span><br><span class="line"><span class="built_in">print</span>(iris[iris[:,<span class="number">0</span>].argsort()][:<span class="number">20</span>])</span><br><span class="line"><span class="comment"># &gt; [[b&#x27;4.3&#x27; b&#x27;3.0&#x27; b&#x27;1.1&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.4&#x27; b&#x27;3.2&#x27; b&#x27;1.3&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.4&#x27; b&#x27;3.0&#x27; b&#x27;1.3&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.4&#x27; b&#x27;2.9&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.5&#x27; b&#x27;2.3&#x27; b&#x27;1.3&#x27; b&#x27;0.3&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.6&#x27; b&#x27;1.0&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.4&#x27; b&#x27;1.4&#x27; b&#x27;0.3&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.2&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.7&#x27; b&#x27;3.2&#x27; b&#x27;1.3&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.7&#x27; b&#x27;3.2&#x27; b&#x27;1.6&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.0&#x27; b&#x27;1.4&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.0&#x27; b&#x27;1.4&#x27; b&#x27;0.3&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.4&#x27; b&#x27;1.9&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.4&#x27; b&#x27;1.6&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.1&#x27; b&#x27;1.6&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;2.4&#x27; b&#x27;3.3&#x27; b&#x27;1.0&#x27; b&#x27;Iris-versicolor&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;2.5&#x27; b&#x27;4.5&#x27; b&#x27;1.7&#x27; b&#x27;Iris-virginica&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]]</span></span><br></pre></td></tr></table></figure>

<h3 id="45-如何在numpy数组中找到最常见的值？"><a href="#45-如何在numpy数组中找到最常见的值？" class="headerlink" title="45. 如何在numpy数组中找到最常见的值？"></a>45. 如何在numpy数组中找到最常见的值？</h3><p><strong>难度等级：</strong>L1</p>
<p><strong>问题：</strong>在鸢尾属植物数据集中找到最常见的花瓣长度值（第3列）。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line">vals, counts = np.unique(iris[:, <span class="number">2</span>], return_counts=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(vals[np.argmax(counts)])</span><br><span class="line"><span class="comment"># &gt; b&#x27;1.5&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="46-如何找到第一次出现的值大于给定值的位置？"><a href="#46-如何找到第一次出现的值大于给定值的位置？" class="headerlink" title="46. 如何找到第一次出现的值大于给定值的位置？"></a>46. 如何找到第一次出现的值大于给定值的位置？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>在虹膜数据集的petalwidth第4列中查找第一次出现的值大于1.0的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution: (edit: changed argmax to argwhere. Thanks Rong!)</span></span><br><span class="line">np.argwhere(iris[:, <span class="number">3</span>].astype(<span class="built_in">float</span>) &gt; <span class="number">1.0</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># &gt; 50</span></span><br></pre></td></tr></table></figure>

<h3 id="47-如何将大于给定值的所有值替换为给定的截止值？"><a href="#47-如何将大于给定值的所有值替换为给定的截止值？" class="headerlink" title="47. 如何将大于给定值的所有值替换为给定的截止值？"></a>47. 如何将大于给定值的所有值替换为给定的截止值？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>从数组a中，替换所有大于30到30和小于10到10的值。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.uniform(<span class="number">1</span>,<span class="number">50</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.uniform(<span class="number">1</span>,<span class="number">50</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1: Using np.clip</span></span><br><span class="line">np.clip(a, a_min=<span class="number">10</span>, a_max=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2: Using np.where</span></span><br><span class="line"><span class="built_in">print</span>(np.where(a &lt; <span class="number">10</span>, <span class="number">10</span>, np.where(a &gt; <span class="number">30</span>, <span class="number">30</span>, a)))</span><br><span class="line"><span class="comment"># &gt; [ 27.63  14.64  21.8   30.    10.    10.    30.    30.    10.    29.18  30.</span></span><br><span class="line"><span class="comment"># &gt;   11.25  10.08  10.    11.77  30.    30.    10.    30.    14.43]</span></span><br></pre></td></tr></table></figure>

<h3 id="48-如何从numpy数组中获取最大n值的位置？"><a href="#48-如何从numpy数组中获取最大n值的位置？" class="headerlink" title="48. 如何从numpy数组中获取最大n值的位置？"></a>48. 如何从numpy数组中获取最大n值的位置？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>获取给定数组a中前5个最大值的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.uniform(<span class="number">1</span>,<span class="number">50</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.uniform(<span class="number">1</span>,<span class="number">50</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line"><span class="built_in">print</span>(a.argsort())</span><br><span class="line"><span class="comment"># &gt; [18 7 3 10 15]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2:</span></span><br><span class="line">np.argpartition(-a, <span class="number">5</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># &gt; [15 10  3  7 18]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Below methods will get you the values.</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">a[a.argsort()][-<span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">np.sort(a)[-<span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3:</span></span><br><span class="line">np.partition(a, kth=-<span class="number">5</span>)[-<span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 4:</span></span><br><span class="line">a[np.argpartition(-a, <span class="number">5</span>)][:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h3 id="49-如何计算数组中所有可能值的行数？"><a href="#49-如何计算数组中所有可能值的行数？" class="headerlink" title="49. 如何计算数组中所有可能值的行数？"></a>49. 如何计算数组中所有可能值的行数？</h3><p><strong>难度等级：</strong>L4</p>
<p><strong>问题：</strong>按行计算唯一值的计数。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">11</span>,size=(<span class="number">6</span>, <span class="number">10</span>))</span><br><span class="line">arr</span><br><span class="line">&gt; array([[ <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">4</span>,  <span class="number">8</span>,  <span class="number">8</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">3</span>],</span><br><span class="line">&gt;        [ <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">1</span>, <span class="number">10</span>,  <span class="number">7</span>,  <span class="number">3</span>],</span><br><span class="line">&gt;        [ <span class="number">5</span>,  <span class="number">2</span>,  <span class="number">6</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">5</span>,  <span class="number">4</span>,  <span class="number">8</span>,  <span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">&gt;        [ <span class="number">8</span>,  <span class="number">8</span>,  <span class="number">1</span>,  <span class="number">3</span>, <span class="number">10</span>, <span class="number">10</span>,  <span class="number">4</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">&gt;        [ <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">3</span>,  <span class="number">1</span>,  <span class="number">9</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">2</span>],</span><br><span class="line">&gt;        [ <span class="number">9</span>,  <span class="number">2</span>,  <span class="number">6</span>,  <span class="number">5</span>,  <span class="number">3</span>,  <span class="number">9</span>,  <span class="number">4</span>,  <span class="number">6</span>,  <span class="number">1</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">&gt;  [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">&gt;  [<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">&gt;  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">&gt;  [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">&gt;  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p>输出包含10列，表示从1到10的数字。这些值是各行中数字的计数。 例如，cell(0，2)的值为2，这意味着数字3在第一行中恰好出现了2次。</p>
<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">11</span>,size=(<span class="number">6</span>, <span class="number">10</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([[ 9,  9,  4,  8,  8,  1,  5,  3,  6,  3],</span></span><br><span class="line"><span class="comment"># &gt;        [ 3,  3,  2,  1,  9,  5,  1, 10,  7,  3],</span></span><br><span class="line"><span class="comment"># &gt;        [ 5,  2,  6,  4,  5,  5,  4,  8,  2,  2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 8,  8,  1,  3, 10, 10,  4,  3,  6,  9],</span></span><br><span class="line"><span class="comment"># &gt;        [ 2,  1,  8,  7,  3,  1,  9,  3,  6,  2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 9,  2,  6,  5,  3,  9,  4,  6,  1, 10]])</span></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counts_of_all_values_rowwise</span>(<span class="params">arr2d</span>):</span></span><br><span class="line">    <span class="comment"># Unique values and its counts row wise</span></span><br><span class="line">    num_counts_array = [np.unique(row, return_counts=<span class="literal">True</span>) <span class="keyword">for</span> row <span class="keyword">in</span> arr2d]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Counts of all values row wise</span></span><br><span class="line">    <span class="keyword">return</span>([[<span class="built_in">int</span>(b[a==i]) <span class="keyword">if</span> i <span class="keyword">in</span> a <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> np.unique(arr2d)] <span class="keyword">for</span> a, b <span class="keyword">in</span> num_counts_array])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print</span></span><br><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">counts_of_all_values_rowwise(arr)</span><br><span class="line"><span class="comment"># &gt; [ 1  2  3  4  5  6  7  8  9 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; [[1, 0, 2, 1, 1, 1, 0, 2, 2, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [2, 1, 3, 0, 1, 0, 1, 0, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;  [0, 3, 0, 2, 3, 1, 0, 1, 0, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [1, 0, 2, 1, 0, 1, 0, 2, 1, 2],</span></span><br><span class="line"><span class="comment"># &gt;  [2, 2, 2, 0, 0, 1, 1, 1, 1, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [1, 1, 1, 1, 1, 2, 0, 0, 2, 1]]</span></span><br><span class="line"><span class="comment"># Example 2:</span></span><br><span class="line">arr = np.array([np.array(<span class="built_in">list</span>(<span class="string">&#x27;bill clinton&#x27;</span>)), np.array(<span class="built_in">list</span>(<span class="string">&#x27;narendramodi&#x27;</span>)), np.array(<span class="built_in">list</span>(<span class="string">&#x27;jjayalalitha&#x27;</span>))])</span><br><span class="line"><span class="built_in">print</span>(np.unique(arr))</span><br><span class="line">counts_of_all_values_rowwise(arr)</span><br><span class="line"><span class="comment"># &gt; [&#x27; &#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;r&#x27; &#x27;t&#x27; &#x27;y&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; [[1, 0, 1, 1, 0, 0, 0, 2, 0, 3, 0, 2, 1, 0, 1, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [0, 2, 0, 0, 2, 1, 0, 1, 0, 0, 1, 2, 1, 2, 0, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [0, 4, 0, 0, 0, 0, 1, 1, 2, 2, 0, 0, 0, 0, 1, 1]]</span></span><br></pre></td></tr></table></figure>

<h3 id="50-如何将数组转换为平面一维数组？"><a href="#50-如何将数组转换为平面一维数组？" class="headerlink" title="50. 如何将数组转换为平面一维数组？"></a>50. 如何将数组转换为平面一维数组？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>将array_of_arrays转换为扁平线性1d数组。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">arr1 = np.arange(<span class="number">3</span>)</span><br><span class="line">arr2 = np.arange(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">arr3 = np.arange(<span class="number">7</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">array_of_arrays = np.array([arr1, arr2, arr3])</span><br><span class="line">array_of_arrays</span><br><span class="line"><span class="comment"># &gt; array([array([0, 1, 2]), array([3, 4, 5, 6]), array([7, 8, 9])], dtype=object)</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># **给定：**</span></span><br><span class="line">arr1 = np.arange(<span class="number">3</span>)</span><br><span class="line">arr2 = np.arange(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">arr3 = np.arange(<span class="number">7</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">array_of_arrays = np.array([arr1, arr2, arr3])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array_of_arrays: &#x27;</span>, array_of_arrays)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1</span></span><br><span class="line">arr_2d = np.array([a <span class="keyword">for</span> arr <span class="keyword">in</span> array_of_arrays <span class="keyword">for</span> a <span class="keyword">in</span> arr])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2:</span></span><br><span class="line">arr_2d = np.concatenate(array_of_arrays)</span><br><span class="line"><span class="built_in">print</span>(arr_2d)</span><br><span class="line"><span class="comment"># &gt; array_of_arrays:  [array([0, 1, 2]) array([3, 4, 5, 6]) array([7, 8, 9])]</span></span><br><span class="line"><span class="comment"># &gt; [0 1 2 3 4 5 6 7 8 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="51-如何在numpy中为数组生成单热编码？"><a href="#51-如何在numpy中为数组生成单热编码？" class="headerlink" title="51. 如何在numpy中为数组生成单热编码？"></a>51. 如何在numpy中为数组生成单热编码？</h3><p><strong>难度等级：</strong>L4</p>
<p><strong>问题：</strong>计算一次性编码(数组中每个唯一值的虚拟二进制变量)</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">101</span>) </span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">4</span>, size=<span class="number">6</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([2, 3, 2, 2, 2, 1])</span></span><br></pre></td></tr></table></figure>

<p><strong>期望输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([[ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  0.,  1.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 1.,  0.,  0.]])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">np.random.seed(<span class="number">101</span>) </span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">4</span>, size=<span class="number">6</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([2, 3, 2, 2, 2, 1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot_encodings</span>(<span class="params">arr</span>):</span></span><br><span class="line">    uniqs = np.unique(arr)</span><br><span class="line">    out = np.zeros((arr.shape[<span class="number">0</span>], uniqs.shape[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">for</span> i, k <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">        out[i, k-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">one_hot_encodings(arr)</span><br><span class="line"><span class="comment"># &gt; array([[ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  0.,  1.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 1.,  0.,  0.]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">(arr[:, <span class="literal">None</span>] == np.unique(arr)).view(np.int8)</span><br></pre></td></tr></table></figure>

<h3 id="52-如何创建按分类变量分组的行号？"><a href="#52-如何创建按分类变量分组的行号？" class="headerlink" title="52. 如何创建按分类变量分组的行号？"></a>52. 如何创建按分类变量分组的行号？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>创建按分类变量分组的行号。使用以下来自鸢尾属植物物种的样本作为输入。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">species = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;str&#x27;</span>, usecols=<span class="number">4</span>)</span><br><span class="line">species_small = np.sort(np.random.choice(species, size=<span class="number">20</span>))</span><br><span class="line">species_small</span><br><span class="line"><span class="comment"># &gt; array([&#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;&lt;U15&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">species = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;str&#x27;</span>, usecols=<span class="number">4</span>)</span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">species_small = np.sort(np.random.choice(species, size=<span class="number">20</span>))</span><br><span class="line">species_small</span><br><span class="line"><span class="comment"># &gt; array([&#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-setosa&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;&lt;U15&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> val <span class="keyword">in</span> np.unique(species_small) <span class="keyword">for</span> i, grp <span class="keyword">in</span> <span class="built_in">enumerate</span>(species_small[species_small==val])])</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h3 id="53-如何根据给定的分类变量创建组id？-53-如何根据给定的分类变量创建组ID？"><a href="#53-如何根据给定的分类变量创建组id？-53-如何根据给定的分类变量创建组ID？" class="headerlink" title="53-如何根据给定的分类变量创建组id？)53. 如何根据给定的分类变量创建组ID？"></a>53-如何根据给定的分类变量创建组id？)53. 如何根据给定的分类变量创建组ID？</h3><p><strong>难度等级：</strong>L4</p>
<p><strong>问题：</strong>根据给定的分类变量创建组ID。使用以下来自鸢尾属植物物种的样本作为输入。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">species = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;str&#x27;</span>, usecols=<span class="number">4</span>)</span><br><span class="line">species_small = np.sort(np.random.choice(species, size=<span class="number">20</span>))</span><br><span class="line">species_small</span><br><span class="line"><span class="comment"># &gt; array([&#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;&lt;U15&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2]</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">species = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;str&#x27;</span>, usecols=<span class="number">4</span>)</span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">species_small = np.sort(np.random.choice(species, size=<span class="number">20</span>))</span><br><span class="line">species_small</span><br><span class="line"><span class="comment"># &gt; array([&#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-setosa&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;&lt;U15&#x27;)</span></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line">output = [np.argwhere(np.unique(species_small) == s).tolist()[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">for</span> val <span class="keyword">in</span> np.unique(species_small) <span class="keyword">for</span> s <span class="keyword">in</span> species_small[species_small==val]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution: For Loop version</span></span><br><span class="line">output = []</span><br><span class="line">uniqs = np.unique(species_small)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> uniqs:  <span class="comment"># uniq values in group</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> species_small[species_small==val]:  <span class="comment"># each element in group</span></span><br><span class="line">        groupid = np.argwhere(uniqs == s).tolist()[<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># groupid</span></span><br><span class="line">        output.append(groupid)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"><span class="comment"># &gt; [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="54-如何使用numpy对数组中的项进行排名？-54-如何使用numpy对数组中的项进行排名？"><a href="#54-如何使用numpy对数组中的项进行排名？-54-如何使用numpy对数组中的项进行排名？" class="headerlink" title="54-如何使用numpy对数组中的项进行排名？)54. 如何使用numpy对数组中的项进行排名？"></a>54-如何使用numpy对数组中的项进行排名？)54. 如何使用numpy对数组中的项进行排名？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>为给定的数字数组a创建排名。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">a = np.random.randint(<span class="number">20</span>, size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># &gt; [ 9  4 15  0 17 16 17  8  9  0]</span></span><br></pre></td></tr></table></figure>

<p><strong>期望输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">4</span> <span class="number">2</span> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span> <span class="number">7</span> <span class="number">9</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">a = np.random.randint(<span class="number">20</span>, size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Array: &#x27;</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="built_in">print</span>(a.argsort().argsort())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Array: &#x27;</span>, a)</span><br><span class="line"><span class="comment"># &gt; Array:  [ 9  4 15  0 17 16 17  8  9  0]</span></span><br><span class="line"><span class="comment"># &gt; [4 2 6 0 8 7 9 3 5 1]</span></span><br><span class="line"><span class="comment"># &gt; Array:  [ 9  4 15  0 17 16 17  8  9  0]</span></span><br></pre></td></tr></table></figure>

<h3 id="55-如何使用numpy对多维数组中的项进行排名？-55-如何使用numpy对多维数组中的项进行排名？"><a href="#55-如何使用numpy对多维数组中的项进行排名？-55-如何使用numpy对多维数组中的项进行排名？" class="headerlink" title="55-如何使用numpy对多维数组中的项进行排名？)55. 如何使用numpy对多维数组中的项进行排名？"></a>55-如何使用numpy对多维数组中的项进行排名？)55. 如何使用numpy对多维数组中的项进行排名？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>创建与给定数字数组a相同形状的排名数组。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">a = np.random.randint(<span class="number">20</span>, size=[<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># &gt; [[ 9  4 15  0 17]</span></span><br><span class="line"><span class="comment"># &gt;  [16 17  8  9  0]]</span></span><br></pre></td></tr></table></figure>

<p><strong>期望输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; [[4 2 6 0 8]</span></span><br><span class="line"><span class="comment"># &gt;  [7 9 3 5 1]]</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">a = np.random.randint(<span class="number">20</span>, size=[<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="built_in">print</span>(a.ravel().argsort().argsort().reshape(a.shape))</span><br><span class="line"><span class="comment"># &gt; [[ 9  4 15  0 17]</span></span><br><span class="line"><span class="comment"># &gt;  [16 17  8  9  0]]</span></span><br><span class="line"><span class="comment"># &gt; [[4 2 6 0 8]</span></span><br><span class="line"><span class="comment"># &gt;  [7 9 3 5 1]]</span></span><br></pre></td></tr></table></figure>

<h3 id="56-如何在二维numpy数组的每一行中找到最大值？-56-如何在二维numpy数组的每一行中找到最大值？"><a href="#56-如何在二维numpy数组的每一行中找到最大值？-56-如何在二维numpy数组的每一行中找到最大值？" class="headerlink" title="56-如何在二维numpy数组的每一行中找到最大值？)56. 如何在二维numpy数组的每一行中找到最大值？"></a>56-如何在二维numpy数组的每一行中找到最大值？)56. 如何在二维numpy数组的每一行中找到最大值？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>计算给定数组中每行的最大值。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">1</span>,<span class="number">10</span>, [<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([[9, 9, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [8, 8, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 3, 6],</span></span><br><span class="line"><span class="comment"># &gt;        [3, 3, 3],</span></span><br><span class="line"><span class="comment"># &gt;        [2, 1, 9]])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">1</span>,<span class="number">10</span>, [<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1</span></span><br><span class="line">np.amax(a, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2</span></span><br><span class="line">np.apply_along_axis(np.<span class="built_in">max</span>, arr=a, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># &gt; array([9, 8, 6, 3, 9])</span></span><br></pre></td></tr></table></figure>

<h3 id="57-如何计算二维numpy数组每行的最小值？-57-如何计算二维numpy数组每行的最小值？"><a href="#57-如何计算二维numpy数组每行的最小值？-57-如何计算二维numpy数组每行的最小值？" class="headerlink" title="57-如何计算二维numpy数组每行的最小值？)57. 如何计算二维numpy数组每行的最小值？"></a>57-如何计算二维numpy数组每行的最小值？)57. 如何计算二维numpy数组每行的最小值？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>为给定的二维numpy数组计算每行的最小值。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">1</span>,<span class="number">10</span>, [<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([[9, 9, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [8, 8, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 3, 6],</span></span><br><span class="line"><span class="comment"># &gt;        [3, 3, 3],</span></span><br><span class="line"><span class="comment"># &gt;        [2, 1, 9]])</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">1</span>,<span class="number">10</span>, [<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">np.apply_along_axis(<span class="keyword">lambda</span> x: np.<span class="built_in">min</span>(x)/np.<span class="built_in">max</span>(x), arr=a, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># &gt; array([ 0.44444444,  0.125     ,  0.5       ,  1.        ,  0.11111111])</span></span><br></pre></td></tr></table></figure>

<h3 id="58-如何在numpy数组中找到重复的记录？-58-如何在numpy数组中找到重复的记录？"><a href="#58-如何在numpy数组中找到重复的记录？-58-如何在numpy数组中找到重复的记录？" class="headerlink" title="58-如何在numpy数组中找到重复的记录？)58. 如何在numpy数组中找到重复的记录？"></a>58-如何在numpy数组中找到重复的记录？)58. 如何在numpy数组中找到重复的记录？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>在给定的numpy数组中找到重复的条目(第二次出现以后)，并将它们标记为True。第一次出现应该是False的。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Array: &#x27;</span>, a)</span><br><span class="line"><span class="comment"># &gt; Array: [0 0 3 0 2 4 2 2 2 2]</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; [False  True False  True False False  True  True  True  True]</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Solution</span></span><br><span class="line"><span class="comment"># There is no direct function to do this as of 1.13.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an all True array</span></span><br><span class="line">out = np.full(a.shape[<span class="number">0</span>], <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find the index positions of unique elements</span></span><br><span class="line">unique_positions = np.unique(a, return_index=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mark those positions as False</span></span><br><span class="line">out[unique_positions] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="comment"># &gt; [False  True False  True False False  True  True  True  True]</span></span><br></pre></td></tr></table></figure>

<h3 id="59-如何找出数字的分组均值？-59-如何找出数字的分组均值？"><a href="#59-如何找出数字的分组均值？-59-如何找出数字的分组均值？" class="headerlink" title="59-如何找出数字的分组均值？)59. 如何找出数字的分组均值？"></a>59-如何找出数字的分组均值？)59. 如何找出数字的分组均值？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>在二维数字数组中查找按分类列分组的数值列的平均值</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>理想的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; [[b&#x27;Iris-setosa&#x27;, 3.418],</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;Iris-versicolor&#x27;, 2.770],</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;Iris-virginica&#x27;, 2.974]]</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># No direct way to implement this. Just a version of a workaround.</span></span><br><span class="line">numeric_column = iris[:, <span class="number">1</span>].astype(<span class="string">&#x27;float&#x27;</span>)  <span class="comment"># sepalwidth</span></span><br><span class="line">grouping_column = iris[:, <span class="number">4</span>]  <span class="comment"># species</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List comprehension version</span></span><br><span class="line">[[group_val, numeric_column[grouping_column==group_val].mean()] <span class="keyword">for</span> group_val <span class="keyword">in</span> np.unique(grouping_column)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># For Loop version</span></span><br><span class="line">output = []</span><br><span class="line"><span class="keyword">for</span> group_val <span class="keyword">in</span> np.unique(grouping_column):</span><br><span class="line">    output.append([group_val, numeric_column[grouping_column==group_val].mean()])</span><br><span class="line"></span><br><span class="line">output</span><br><span class="line"><span class="comment"># &gt; [[b&#x27;Iris-setosa&#x27;, 3.418],</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;Iris-versicolor&#x27;, 2.770],</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;Iris-virginica&#x27;, 2.974]]</span></span><br></pre></td></tr></table></figure>

<h3 id="60-如何将PIL图像转换为numpy数组？"><a href="#60-如何将PIL图像转换为numpy数组？" class="headerlink" title="60. 如何将PIL图像转换为numpy数组？"></a>60. 如何将PIL图像转换为numpy数组？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>从以下URL导入图像并将其转换为numpy数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL = &#x27;https://upload.wikimedia.org/wikipedia/commons/8/8b/Denali_Mt_McKinley.jpg&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> PIL, requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import image from URL</span></span><br><span class="line">URL = <span class="string">&#x27;https://upload.wikimedia.org/wikipedia/commons/8/8b/Denali_Mt_McKinley.jpg&#x27;</span></span><br><span class="line">response = requests.get(URL)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read it as Image</span></span><br><span class="line">I = Image.<span class="built_in">open</span>(BytesIO(response.content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optionally resize</span></span><br><span class="line">I = I.resize([<span class="number">150</span>,<span class="number">150</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert to numpy array</span></span><br><span class="line">arr = np.asarray(I)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optionaly Convert it back to an image and show</span></span><br><span class="line">im = PIL.Image.fromarray(np.uint8(arr))</span><br><span class="line">Image.Image.show(im)</span><br></pre></td></tr></table></figure>

<h3 id="61-如何删除numpy数组中所有缺少的值？"><a href="#61-如何删除numpy数组中所有缺少的值？" class="headerlink" title="61. 如何删除numpy数组中所有缺少的值？"></a>61. 如何删除numpy数组中所有缺少的值？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>从一维numpy数组中删除所有NaN值</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,np.nan,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,np.nan])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,np.nan,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,np.nan])</span><br><span class="line">a[~np.isnan(a)]</span><br><span class="line"><span class="comment"># &gt; array([ 1.,  2.,  3.,  5.,  6.,  7.])</span></span><br></pre></td></tr></table></figure>

<h3 id="62-如何计算两个数组之间的欧氏距离？"><a href="#62-如何计算两个数组之间的欧氏距离？" class="headerlink" title="62. 如何计算两个数组之间的欧氏距离？"></a>62. 如何计算两个数组之间的欧氏距离？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>计算两个数组a和数组b之间的欧氏距离。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">dist = np.linalg.norm(a-b)</span><br><span class="line">dist</span><br><span class="line"><span class="comment"># &gt; 6.7082039324993694</span></span><br></pre></td></tr></table></figure>

<h3 id="63-如何在一维数组中找到所有的局部极大值-或峰值-？"><a href="#63-如何在一维数组中找到所有的局部极大值-或峰值-？" class="headerlink" title="63. 如何在一维数组中找到所有的局部极大值(或峰值)？"></a>63. 如何在一维数组中找到所有的局部极大值(或峰值)？</h3><p><strong>难度等级：</strong>L4</p>
<p><strong>问题：</strong>找到一个一维数字数组a中的所有峰值。峰顶是两边被较小数值包围的点。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; array([2, 5])</span></span><br></pre></td></tr></table></figure>

<p>其中，2和5是峰值7和6的位置。</p>
<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">doublediff = np.diff(np.sign(np.diff(a)))</span><br><span class="line">peak_locations = np.where(doublediff == -<span class="number">2</span>)[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">peak_locations</span><br><span class="line"><span class="comment"># &gt; array([2, 5])</span></span><br></pre></td></tr></table></figure>

<h3 id="64-如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去？"><a href="#64-如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去？" class="headerlink" title="64. 如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去？"></a>64. 如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>从2d数组a_2d中减去一维数组b_1D，使得b_1D的每一项从a_2d的相应行中减去。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_2d = np.array([[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]])</span><br><span class="line">b_1d = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; [[2 2 2]</span></span><br><span class="line"><span class="comment"># &gt;  [2 2 2]</span></span><br><span class="line"><span class="comment"># &gt;  [2 2 2]]</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">a_2d = np.array([[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]])</span><br><span class="line">b_1d = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="built_in">print</span>(a_2d - b_1d[:,<span class="literal">None</span>])</span><br><span class="line"><span class="comment"># &gt; [[2 2 2]</span></span><br><span class="line"><span class="comment"># &gt;  [2 2 2]</span></span><br><span class="line"><span class="comment"># &gt;  [2 2 2]]</span></span><br></pre></td></tr></table></figure>

<h3 id="65-如何查找数组中项的第n次重复索引？"><a href="#65-如何查找数组中项的第n次重复索引？" class="headerlink" title="65. 如何查找数组中项的第n次重复索引？"></a>65. 如何查找数组中项的第n次重复索引？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>找出x中数字1的第5次重复的索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1: List comprehension</span></span><br><span class="line">[i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(x) <span class="keyword">if</span> v == <span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2: Numpy version</span></span><br><span class="line">np.where(x == <span class="number">1</span>)[<span class="number">0</span>][n-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># &gt; 8</span></span><br></pre></td></tr></table></figure>

<h3 id="66-如何将numpy的datetime-64对象转换为datetime的datetime对象？"><a href="#66-如何将numpy的datetime-64对象转换为datetime的datetime对象？" class="headerlink" title="66. 如何将numpy的datetime 64对象转换为datetime的datetime对象？"></a>66. 如何将numpy的datetime 64对象转换为datetime的datetime对象？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>将numpy的<code>datetime64</code>对象转换为datetime的datetime对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：** a numpy datetime64 object</span></span><br><span class="line">dt64 = np.datetime64(<span class="string">&#x27;2018-02-25 22:10:10&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **给定：** a numpy datetime64 object</span></span><br><span class="line">dt64 = np.datetime64(<span class="string">&#x27;2018-02-25 22:10:10&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">dt64.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">dt64.astype(datetime)</span><br><span class="line"><span class="comment"># &gt; datetime.datetime(2018, 2, 25, 22, 10, 10)</span></span><br></pre></td></tr></table></figure>

<h3 id="67-如何计算numpy数组的移动平均值？"><a href="#67-如何计算numpy数组的移动平均值？" class="headerlink" title="67. 如何计算numpy数组的移动平均值？"></a>67. 如何计算numpy数组的移动平均值？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>对于给定的一维数组，计算窗口大小为3的移动平均值。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">Z = np.random.randint(<span class="number">10</span>, size=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Source: https://stackoverflow.com/questions/14313510/how-to-calculate-moving-average-using-numpy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moving_average</span>(<span class="params">a, n=<span class="number">3</span></span>) :</span></span><br><span class="line">    ret = np.cumsum(a, dtype=<span class="built_in">float</span>)</span><br><span class="line">    ret[n:] = ret[n:] - ret[:-n]</span><br><span class="line">    <span class="keyword">return</span> ret[n - <span class="number">1</span>:] / n</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">Z = np.random.randint(<span class="number">10</span>, size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array: &#x27;</span>, Z)</span><br><span class="line"><span class="comment"># Method 1</span></span><br><span class="line">moving_average(Z, n=<span class="number">3</span>).<span class="built_in">round</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:  # Thanks AlanLRH!</span></span><br><span class="line"><span class="comment"># np.ones(3)/3 gives equal weights. Use np.ones(4)/4 for window size 4.</span></span><br><span class="line">np.convolve(Z, np.ones(<span class="number">3</span>)/<span class="number">3</span>, mode=<span class="string">&#x27;valid&#x27;</span>) . </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; array:  [8 8 3 7 7 0 4 2 5 2]</span></span><br><span class="line"><span class="comment"># &gt; moving average:  [ 6.33  6.    5.67  4.67  3.67  2.    3.67  3.  ]</span></span><br></pre></td></tr></table></figure>

<h3 id="68-如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列？"><a href="#68-如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列？" class="headerlink" title="68. 如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列？"></a>68. 如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列？</h3><p><strong>难度等级：</strong>L2</p>
<p><strong>问题：</strong>创建长度为10的numpy数组，从5开始，在连续的数字之间的步长为3。</p>
<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">length = <span class="number">10</span></span><br><span class="line">start = <span class="number">5</span></span><br><span class="line">step = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seq</span>(<span class="params">start, length, step</span>):</span></span><br><span class="line">    end = start + (step*length)</span><br><span class="line">    <span class="keyword">return</span> np.arange(start, end, step)</span><br><span class="line"></span><br><span class="line">seq(start, length, step)</span><br><span class="line"><span class="comment"># &gt; array([ 5,  8, 11, 14, 17, 20, 23, 26, 29, 32])</span></span><br></pre></td></tr></table></figure>

<h3 id="69-如何填写不规则系列的numpy日期中的缺失日期？"><a href="#69-如何填写不规则系列的numpy日期中的缺失日期？" class="headerlink" title="69. 如何填写不规则系列的numpy日期中的缺失日期？"></a>69. 如何填写不规则系列的numpy日期中的缺失日期？</h3><p><strong>难度等级：</strong>L3</p>
<p><strong>问题：</strong>给定一系列不连续的日期序列。填写缺失的日期，使其成为连续的日期序列。</p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">dates = np.arange(np.datetime64(<span class="string">&#x27;2018-02-01&#x27;</span>), np.datetime64(<span class="string">&#x27;2018-02-25&#x27;</span>), <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dates)</span><br><span class="line"><span class="comment"># &gt; [&#x27;2018-02-01&#x27; &#x27;2018-02-03&#x27; &#x27;2018-02-05&#x27; &#x27;2018-02-07&#x27; &#x27;2018-02-09&#x27;</span></span><br><span class="line"><span class="comment"># &gt;  &#x27;2018-02-11&#x27; &#x27;2018-02-13&#x27; &#x27;2018-02-15&#x27; &#x27;2018-02-17&#x27; &#x27;2018-02-19&#x27;</span></span><br><span class="line"><span class="comment"># &gt;  &#x27;2018-02-21&#x27; &#x27;2018-02-23&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">dates = np.arange(np.datetime64(<span class="string">&#x27;2018-02-01&#x27;</span>), np.datetime64(<span class="string">&#x27;2018-02-25&#x27;</span>), <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dates)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution ---------------</span></span><br><span class="line">filled_in = np.array([np.arange(date, (date+d)) <span class="keyword">for</span> date, d <span class="keyword">in</span> <span class="built_in">zip</span>(dates, np.diff(dates))]).reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the last day</span></span><br><span class="line">output = np.hstack([filled_in, dates[-<span class="number">1</span>]])</span><br><span class="line">output</span><br><span class="line"></span><br><span class="line"><span class="comment"># For loop version -------</span></span><br><span class="line">out = []</span><br><span class="line"><span class="keyword">for</span> date, d <span class="keyword">in</span> <span class="built_in">zip</span>(dates, np.diff(dates)):</span><br><span class="line">    out.append(np.arange(date, (date+d)))</span><br><span class="line"></span><br><span class="line">filled_in = np.array(out).reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the last day</span></span><br><span class="line">output = np.hstack([filled_in, dates[-<span class="number">1</span>]])</span><br><span class="line">output</span><br><span class="line"><span class="comment"># &gt; [&#x27;2018-02-01&#x27; &#x27;2018-02-03&#x27; &#x27;2018-02-05&#x27; &#x27;2018-02-07&#x27; &#x27;2018-02-09&#x27;</span></span><br><span class="line"><span class="comment"># &gt;  &#x27;2018-02-11&#x27; &#x27;2018-02-13&#x27; &#x27;2018-02-15&#x27; &#x27;2018-02-17&#x27; &#x27;2018-02-19&#x27;</span></span><br><span class="line"><span class="comment"># &gt;  &#x27;2018-02-21&#x27; &#x27;2018-02-23&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; array([&#x27;2018-02-01&#x27;, &#x27;2018-02-02&#x27;, &#x27;2018-02-03&#x27;, &#x27;2018-02-04&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-05&#x27;, &#x27;2018-02-06&#x27;, &#x27;2018-02-07&#x27;, &#x27;2018-02-08&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-09&#x27;, &#x27;2018-02-10&#x27;, &#x27;2018-02-11&#x27;, &#x27;2018-02-12&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-13&#x27;, &#x27;2018-02-14&#x27;, &#x27;2018-02-15&#x27;, &#x27;2018-02-16&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-17&#x27;, &#x27;2018-02-18&#x27;, &#x27;2018-02-19&#x27;, &#x27;2018-02-20&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-21&#x27;, &#x27;2018-02-22&#x27;, &#x27;2018-02-23&#x27;], dtype=&#x27;datetime64[D]&#x27;)</span></span><br></pre></td></tr></table></figure>

<h3 id="70-如何从给定的一维数组创建步长？"><a href="#70-如何从给定的一维数组创建步长？" class="headerlink" title="70. 如何从给定的一维数组创建步长？"></a>70. 如何从给定的一维数组创建步长？</h3><p><strong>难度等级：</strong>L4</p>
<p><strong>问题：</strong>从给定的一维数组arr中，利用步进生成一个二维矩阵，窗口长度为4，步距为2，类似于 <code>[[0,1,2,3], [2,3,4,5], [4,5,6,7]..]</code></p>
<p><strong>给定：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>) </span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure>

<p><strong>期望的输出：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &gt; [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment"># &gt;  [ 2  3  4  5]</span></span><br><span class="line"><span class="comment"># &gt;  [ 4  5  6  7]</span></span><br><span class="line"><span class="comment"># &gt;  [ 6  7  8  9]</span></span><br><span class="line"><span class="comment"># &gt;  [ 8  9 10 11]</span></span><br><span class="line"><span class="comment"># &gt;  [10 11 12 13]]</span></span><br></pre></td></tr></table></figure>

<p><strong>答案：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_strides</span>(<span class="params">a, stride_len=<span class="number">5</span>, window_len=<span class="number">5</span></span>):</span></span><br><span class="line">    n_strides = ((a.size-window_len)//stride_len) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># return np.array([a[s:(s+window_len)] for s in np.arange(0, a.size, stride_len)[:n_strides]])</span></span><br><span class="line">    <span class="keyword">return</span> np.array([a[s:(s+window_len)] <span class="keyword">for</span> s <span class="keyword">in</span> np.arange(<span class="number">0</span>, n_strides*stride_len, stride_len)])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gen_strides(np.arange(<span class="number">15</span>), stride_len=<span class="number">2</span>, window_len=<span class="number">4</span>))</span><br><span class="line"><span class="comment"># &gt; [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment"># &gt;  [ 2  3  4  5]</span></span><br><span class="line"><span class="comment"># &gt;  [ 4  5  6  7]</span></span><br><span class="line"><span class="comment"># &gt;  [ 6  7  8  9]</span></span><br><span class="line"><span class="comment"># &gt;  [ 8  9 10 11]</span></span><br><span class="line"><span class="comment"># &gt;  [10 11 12 13]]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
