<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小世界</title>
  
  <subtitle>永远在路上</subtitle>
  <link href="http://rczmm.github.io/atom.xml" rel="self"/>
  
  <link href="http://rczmm.github.io/"/>
  <updated>2021-08-03T05:12:07.839Z</updated>
  <id>http://rczmm.github.io/</id>
  
  <author>
    <name>rczmm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>抽象类与接口</title>
    <link href="http://rczmm.github.io/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://rczmm.github.io/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-08-01T12:20:38.000Z</published>
    <updated>2021-08-03T05:12:07.839Z</updated>
    
    <content type="html"><![CDATA[<p>抽象类与接口：有效拆分大型系统，避免产生耦合。</p><p>抽象类</p><p>类继承主要是为了扩充已有的类功能，子类可以根据需要决定是否覆写父类中的方法，所以一个设计完善的父类是无法对子类做出任何强制性的覆写约定。为了解决这个问题，抽象类的概念就诞生了，抽象类和普通类相比唯一增加的就是抽象方法，同时抽象类在使用时要求必须被继承，而且必须全部覆写抽象类中的抽象方法。</p><p>普通类只是一个设计完善，可以直接产生实例化对象并且调用类中的属性和方法，抽象类最大特点，就是必须被子类继承，并且抽象类本身无法进行实例化。在实际项目中，往往很少设计普通类，大多都会选择继承抽象类。</p><p>抽象类基本定义：抽象类是为了方法覆写而提供的类结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abstract class javademo01&#123;</span><br><span class="line">    private String type;</span><br><span class="line">    public abstract String getconn();</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本实例中利用abstract关键字声明了抽象类与抽象方法：</p><p>1、抽象方法与普通方法不一样，抽象方法不能有方法体{}</p><p>2、抽象类不是一个完整的类，抽象类必须提供子类，子类继承依然用extends关键字</p><p>3、子类（非抽象类）一定要覆写抽象类中的全部抽象方法</p><p>4、抽象类的对象实例化可以通过子类向上转型来实现</p><p>抽象类的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">abstract class javademo01&#123;</span><br><span class="line">    private String type;</span><br><span class="line">    public abstract String getconn();</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class javademo02 extends javademo01&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getconn()&#123;</span><br><span class="line">        return super.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo13  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        javademo01 j1 = new javademo02();</span><br><span class="line">        j1.setType(&quot;mm&quot;);</span><br><span class="line">        System.out.println(j1.getconn());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类最大特点的是自己无法对象实例化，所以说在实际项目中，抽象类用来当中间过渡，当我们想要使用抽象类中，往往是为了解决继承中带来的代码重复处理。</p><p>抽象类的说明</p><p>1、抽象类必须有子类继承，抽象方法必须被覆写，所以抽象类定义时，不允许final定义抽象类和抽象方法。</p><p>2、抽象类也可以定义成员属性和普通方法，为了给抽象类的成员属性初始化，我们可以给抽象类设计构造方法，子类在继承时会调用抽象类的无参构造，如果抽象类没有提供，那么就需要super关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">abstract  class javademo01&#123;</span><br><span class="line">    private String type;</span><br><span class="line">    public abstract  String getconn();</span><br><span class="line"></span><br><span class="line">    public javademo01(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class javademo02 extends javademo01&#123;</span><br><span class="line"></span><br><span class="line">    public javademo02(String type) &#123;</span><br><span class="line">        super(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getconn()&#123;</span><br><span class="line">        return super.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo13  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        javademo01 j1 = new javademo02(&quot;mm&quot;);</span><br><span class="line">        System.out.println(j1.getconn());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类中可以没有抽象方法，即使没有抽象方法，也不能使用new关键字实例化对象。</p><p>抽象类中可以使用static定义静态方法，直接通过类名调用，毫无影响。</p><span id="more"></span><p>模板设计模式（servlet）：</p><p>类的作用是对一类事物的特征进行抽象化，从设计上来说，抽象类的级别比普通类要高。抽象类是对类的进一步抽象。</p><p>机器人：充电+工作</p><p>人：吃饭+睡觉+工作</p><p>猪：吃饭+睡觉</p><p>这三个类有公共的行为可以抽象，这时候就可以利用抽象类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ForkJoinWorkerThread;</span><br><span class="line"></span><br><span class="line">abstract class Action&#123;</span><br><span class="line">    public static final int EAT = 1;</span><br><span class="line">    public static final int SLEEP = 5;</span><br><span class="line">    public static final int WORK = 10;</span><br><span class="line">    public void command (int code)&#123;</span><br><span class="line">        switch (code)&#123;</span><br><span class="line">            case EAT:&#123;</span><br><span class="line">                this.eat();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case SLEEP:&#123;</span><br><span class="line">                this.sleep();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case WORK:&#123;</span><br><span class="line">                this.work();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case EAT+SLEEP+WORK:&#123;</span><br><span class="line">                this.eat();</span><br><span class="line">                this.sleep();</span><br><span class="line">                this.work();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void eat();</span><br><span class="line">    public abstract void sleep();</span><br><span class="line">    public abstract void work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Robot extends Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;机器人需要充电&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;机器人开始工作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person11 extends Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;饿的时候吃饭！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;困的时候睡觉！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;穷的时候去工作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pig extends Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃饲料！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;倒地就睡！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo14 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Action robot = new Robot();</span><br><span class="line">        Action person = new Person11();</span><br><span class="line">        Action pig = new Pig();</span><br><span class="line">        System.out.println(&quot;----------------Robot-----------------&quot;);</span><br><span class="line">        robot.command(Action.EAT);</span><br><span class="line">        robot.command(Action.WORK);</span><br><span class="line">        System.out.println(&quot;---------------person------------------&quot;);</span><br><span class="line">        person.command(Action.EAT);</span><br><span class="line">        person.command(Action.SLEEP);</span><br><span class="line">        person.command(Action.WORK);</span><br><span class="line">        System.out.println(&quot;--------------pig----------------------&quot;);</span><br><span class="line">        pig.command(Action.EAT);</span><br><span class="line">        pig.command(Action.SLEEP);</span><br><span class="line">        System.out.println(&quot;--------------no pig================&quot;);</span><br><span class="line">        person.command(Action.EAT+Action.SLEEP+ Action.WORK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类定义了3个子类，这三个子类会根据需要进行方法的覆写，对于暂时不需要的功能，以空方法体进行实现。</p><p>包装类</p><p>为了统一参数类型，需要针对基本数据类型进行引用传递，所以java提供了包装类的概念。</p><p>java是一门面向对象的语言，但是基本数据类型和这一理念冲突。</p><p>利用类的结构对基本数据类型进行包装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Int &#123;   // 定义了一个包装类</span><br><span class="line">    private int data;  // 包装了一个基本数据类型</span><br><span class="line"></span><br><span class="line">    public Int(int data) &#123; //构造方法设置基本数据类型</span><br><span class="line">        this.data = data;   // 保存基本数据类型</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int intValue()&#123;  // 从包装类中获取基本数据类型</span><br><span class="line">        return this.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object obj = new Int(10); // 装箱,将基本数据类型保存在包装类中</span><br><span class="line">        int x = ((Int) obj).intValue(); //拆箱，从包装类对象中取出基本数据类型</span><br><span class="line">        System.out.println(x * 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面对这样的设计缺陷，java也有自己的方案，设计了8个包装类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = new Integer(10);</span><br><span class="line">int num = i1.intValue(); </span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure><p>如上就是针对int数据类型的装箱、拆箱操作。</p><p>如上的操作，在jdk5之前必须做，但是5之后，java提供了自动装箱和拆箱的机制，并且包装类的对象可以自行计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i2 = 10;</span><br><span class="line">int num1 = i2;</span><br><span class="line">System.out.println(num1);</span><br></pre></td></tr></table></figure><p>这个其实就已经和string类型差不多了，因为他有两种实例化方式，一个是构造方法，一个是直接赋值，其实和string一样，直接赋值直接入池，反之。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = new Integer(10);</span><br><span class="line">int num = i1.intValue();</span><br><span class="line">System.out.println(num);</span><br><span class="line"></span><br><span class="line">Integer i2 = 10;</span><br><span class="line">int num1 = i2;</span><br><span class="line">System.out.println(num1);</span><br><span class="line"></span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>除此之外，还要注意一点。</p><p>自动装箱的相等判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer ii1 = 100;</span><br><span class="line">Integer ii2 = 100;</span><br><span class="line">System.out.println(ii1 == ii2);</span><br><span class="line"></span><br><span class="line">Integer ii3 = 130;</span><br><span class="line">Integer ii4 = 130;</span><br><span class="line"></span><br><span class="line">System.out.println(ii3 == ii4);</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>这里要注意，不再-128~127范围内的数，通过==比较返回的就是false。</p><p>自动装箱中，如果范围属于-128到127，可以自动实现堆内存的引用，否则不行。</p><p>数据类型转换</p><p>将字符串转化为int</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line">int num = Integer.parseInt(str);</span><br><span class="line">System.out.println(num + num);</span><br></pre></td></tr></table></figure><p>如果含有非数字，就会抛出异常。</p><p>Exception in thread “main” java.lang.NumberFormatException</p><p>字符串转boolean（不是true或者false，统一返回false）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;1sa23&quot;;</span><br><span class="line">boolean b1 = Boolean.parseBoolean(str);</span><br><span class="line">System.out.println(b1);</span><br></pre></td></tr></table></figure><p>基本数据类型转string</p><p>+连接符连接一个空字符串就可以了</p><p>接口：</p><p>比抽象类更重要，定义开发标准。</p><p>接口是一个特殊的类，通过interface关键字定义，在接口中可以定义全局常量、抽象方法（访问权限必须是public）、default方法以及static方法。</p><p>定义标准接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IMessage &#123;</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、接口中存在抽象方法，因此无法被实例化。</p><p>2、接口需要被子类实现，子类通过implements关键字实现多个父接口</p><p>3、子类如果不是抽象类，子类一定要覆写全部的抽象方法</p><p>4、接口对象可以利用子类对象实现向上转型</p><p>继承和实现的顺序：先继承后实现接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface IMessage &#123;</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class fff &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class sss extends fff implements IMessage&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的基本使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface face01&#123;</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class demo16_1 implements face01&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return &quot;i love mm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        face01 f1 = new demo16_1();</span><br><span class="line">        System.out.println(f1.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本程序利用关键字定义了接口子类，并且利用子类对象向上转型实例化了接口对象。</p><p>子类实现多个父接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 定义接口</span><br><span class="line">interface face01&#123;</span><br><span class="line">//    全局常量</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">//    抽象方法</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">interface face02&#123;</span><br><span class="line">//    抽象方法</span><br><span class="line">    public abstract boolean conn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现多个接口</span><br><span class="line">class demo16_1 implements face01,face02&#123;</span><br><span class="line">    </span><br><span class="line">//    方法覆写</span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        if(this.conn())&#123;</span><br><span class="line">            return &quot;i love mm&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;default&quot;+face01.INFO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean conn() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        face01 f1 = new demo16_1();</span><br><span class="line">        System.out.println(f1.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result: i love mm</span><br></pre></td></tr></table></figure><p>本程序在子类上实现了两个父接口，这样就必须全部覆写接口中的抽象方法，因此实际上子类是object与这两个父接口的实例。</p><p>观察接口实例转换:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        face01 f1 = new demo16_1();</span><br><span class="line">        Object obj = f1;</span><br><span class="line">        face02 f2 = (face02) obj;</span><br><span class="line">        System.out.println(f2.conn());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有子类，那么object与两个父接口是没有任何关系的，但是由于子类同时实现了这些接口并且默认继承了object父类，所以该实例就可以进行任意父接口的转型。</p><p>关于接口的简化定义</p><p>完整定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义接口</span><br><span class="line">interface face01&#123;</span><br><span class="line">//    全局常量</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">//    抽象方法</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface face03&#123;</span><br><span class="line">    String INFO =&quot;i love mm&quot;;</span><br><span class="line">    String getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种定义的作用完全相同，但是从实际的开发程序来讲，在接口中定义抽象方法时建议保留public的声明，这样的接口定义会更加的清楚。</p><p>在面向对象设计中，抽象类也是必不可少的一种结构，利用抽象类可以实现一些公共方法的定义，可以利用extends先继承父类再利用implements实现若干父接口的顺序完成子类定义。</p><p>java中的extends关键字除了具有类继承的作用外，也可以在接口上使用以实现接口的继承关系，并且可以同时实现多个父接口。</p><p>接口的使用分析：在面向对象设计中，接口的核心用处是为了实现方法名的暴露与子类的隐藏。</p><hr><p>接口定义加强</p><p>接口是java诞生之初就提出的设计结构，其最初的组成就是抽象方法与全局常量，但是随着技术发展，在8之后的接口组成除了提供有全局常量和抽象方法之外，还可以定义普通方法或者静态方法。</p><p>这就使得接口中不仅仅只有抽象方法，同时这些普通方法也可以直接被子类继承。</p><p>接口中定义普通方法的意义：</p><p>便于扩充接口功能，同时简化设计结构</p><p>在设计中，接口主要是为了进行公共标准的定义，但是随着技术的发展，接口的设计也有可能得到更新，那么此时假设有一个早期版本的接口，并且随着发展，他已经有了很多个子类。如果现在需要对接口中新增一个方法，并且所有的子类对于此方法的实现完全相同的时候，就需要修改所有定义的子类，重复复制实现方法，这样就会导致代码的可维护性降低，在8之前的时候，为了解决这个问题，我们可以定义一个中间的过渡抽象类，由抽象类去继承接口，然后子类继承抽象类。接口中追加方法，在抽象类中做出实现，最后子类再继承抽象类。那么接口再扩充公共方法时，就只需要修改抽象类，所以为了解决这样的设计，在8之后就提供了普通方法的支持，同时，如果子类发现父接口中公共的方法功能不足时，也可以进行覆写。</p><p>普通方法需要通过接口实例化对象才可以调用，为了避免实例化对象的依赖，在接口中也可以使用static定义静态方法，此方法可以直接利用接口名称调用。</p><p>友情提示：个人认为，虽然接口中普通方法和静态方法很大程度上与抽象类的作用有一些重叠，但是要注意开发中尽量的在接口与子类之中，建立一个过渡抽象类。不要着急定义子类。</p><p>定义接口标准</p><p>项目功能设计中接口往往是最先定义的，这样就定义好了操作的标准。对于接口而言，最重要的就是进行标准的定义，实际上在日常中，你也会听到许多接口的名词，例如：usb接口，鼠标接口等等，这样接口实际上都是属于标准的定义与应用。</p><p>以usb的程序为例，计算机上可以插入各种usb的设备，所以计算上认识的知识usb标准，而不关心这个标准的具体子类。</p><p>利用接口定义标准：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">interface face_usb&#123;</span><br><span class="line">    public boolean check();</span><br><span class="line">    public void work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class computer&#123;</span><br><span class="line">    public void plugin(face_usb usb)&#123;</span><br><span class="line">        if (usb.check())&#123;</span><br><span class="line">            usb.work();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;There are some problems here!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class keyboard implements face_usb&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean check() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;starting study!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo17 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        computer c1 = new computer();</span><br><span class="line">        c1.plugin(new keyboard());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂设计模式：</p><p>接口在实际开发过程中主要特点是进行标准的定义，而标准的定义是一个灵活的概念，也就是说，标准不应该与具体的子类绑在一起，为了解决代码耦合的问题，在开发中针对接口对象的获得，往往通过工厂设计模式来呈现。</p><p><img src="/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20210803003800286.png" alt="工厂设计模式"></p><p>一个工厂类，在此类中提供一个静态方法返回接口实例化对象，这样在主类调用时，就不需要关注具体的接口子类，只需要传入指定的类型标记就可以获取接口对象。</p><p>当然也存在许多问题，比如当接口扩产子类时都需要修改工厂类，这样的子类一旦很多，工厂类的代码就会很多。如果有若干接口都需要工厂类来获取实例，对于工厂类需要追加大量的static方法，一个项目可能只需要某个接口的特定子类，这个子类往往可以通过配置文件的形式进行定义，修改时也可以通过配置文件的修改而更换子类，所以这种固定标记的做法可能导致代码的混乱。</p><p>代理设计模式</p><p>为了实现核心业务与辅助功能的细分，可以通过代理设计模式。</p><p>这是java开发中使用较多的一种模式，是指一个代理主题来操作真实主题，真实主题执行具体的业务操作，而代理主题则负责其他相关业务的办理，简单理解，你现在肚子饿了，如果你只会吃饭而不会做饭的话，肯定要去外面吃，而饭店会为你吃饭做一些辅助的业务（例如，买菜，买盘子等等），而你只负责吃就可以了。</p><p><img src="/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20210803123739591.png" alt="代理设计模式"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">interface IEat &#123;</span><br><span class="line">    public void get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatReal implements IEat &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        System.out.println(&quot;得到一份食物，开始吃饭！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatProxy implements IEat &#123;</span><br><span class="line"></span><br><span class="line">    private IEat eat;</span><br><span class="line"></span><br><span class="line">    public EatProxy(IEat eat) &#123;</span><br><span class="line">        this.eat = eat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        this.prepare();</span><br><span class="line">        this.eat.get();</span><br><span class="line">        this.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void prepare()&#123;</span><br><span class="line">        System.out.println(&quot;1、购买食材&quot;);</span><br><span class="line">        System.out.println(&quot;2、处理食材&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        System.out.println(&quot;3、洗盘子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo18 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IEat eat = new EatProxy(new EatReal());</span><br><span class="line">        eat.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本程序为接口实现了两个子类，真实主题类和代理主题类，真实主题类只有在代理类提供支持的情况下才可以正常完成核心业务，但是对于主类而言，所关注的只是接口执行标准，而具体实现那一个子类并不去关注。</p><p>代理设计模式结合工厂设计模式</p><p>以上程序中，直接在主类中实例化了主类，这其实是不符合要求的，所有自定义的接口对象都应该通过工厂获得，修改后：</p><p><img src="/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20210803125650132.png" alt="工厂设计模式与代理设计模式整合"></p><p>修改代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">interface IEat &#123;</span><br><span class="line">    public void get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatReal implements IEat &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        System.out.println(&quot;得到一份食物，开始吃饭！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatProxy implements IEat &#123;</span><br><span class="line"></span><br><span class="line">    private IEat eat;</span><br><span class="line"></span><br><span class="line">    public EatProxy(IEat eat) &#123;</span><br><span class="line">        this.eat = eat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        this.prepare();</span><br><span class="line">        this.eat.get();</span><br><span class="line">        this.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void prepare()&#123;</span><br><span class="line">        System.out.println(&quot;1、购买食材&quot;);</span><br><span class="line">        System.out.println(&quot;2、处理食材&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        System.out.println(&quot;3、洗盘子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static IEat get()&#123;</span><br><span class="line">        return new EatProxy(new EatReal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo18 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IEat eat = Factory.get();</span><br><span class="line">        eat.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类与接口的区别：</p><table><thead><tr><th>no</th><th>区别</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>1</td><td>关键字</td><td>abstract class</td><td>interface</td></tr><tr><td>2</td><td>组成</td><td>常量、变量、抽象方法、普通方法、静态方法</td><td>全局常量、抽象方法、普通方法、静态方法</td></tr><tr><td>3</td><td>权限</td><td>各种权限</td><td>只能是public</td></tr><tr><td>4</td><td>关系</td><td>一个抽象类可以实现多个接口</td><td>接口不能继承抽象类，可以继承多接口</td></tr><tr><td>5</td><td>使用</td><td>子类使用extends继承抽象类</td><td>子类使用implements实现接口</td></tr><tr><td></td><td></td><td>抽象类和接口都是利用对象多态性的向上转型，进行接口或者抽象类的实例化操作</td><td></td></tr><tr><td>6</td><td>设计模式</td><td>模板设计模式</td><td>工厂设计模式、代理设计模式</td></tr><tr><td>7</td><td>局限</td><td>一个子类只能继承一个抽象类</td><td>一个子类可以实现多个接口</td></tr></tbody></table><p>接口是在类之上的定义</p><p>一个简短的分析：<br>想要我们想要定义一个动物，那么动物肯定是一个公共的标准，而这个公共标准就可以通过接口来完成，动物中又分为两类，哺乳动物和卵生动物，而这个标准属于对动物标准的进一步细化，应该称为子标准，所以此种关系可以使用接口的继承来表示，而哺乳动物又可以继续划分为人、狗、猫不同的类型，由于这些类型不表示具体的实物标准，因此使用抽象类表示。如果要表示出工人或者是学生这样的概念，那么就肯定是一个具体的定义，则使用类的方式，然而每一个学生和工人都是具体的，那么就通过对象来表示。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;抽象类与接口：有效拆分大型系统，避免产生耦合。&lt;/p&gt;
&lt;p&gt;抽象类&lt;/p&gt;
&lt;p&gt;类继承主要是为了扩充已有的类功能，子类可以根据需要决定是否覆写父类中的方法，所以一个设计完善的父类是无法对子类做出任何强制性的覆写约定。为了解决这个问题，抽象类的概念就诞生了，抽象类和普通类相比唯一增加的就是抽象方法，同时抽象类在使用时要求必须被继承，而且必须全部覆写抽象类中的抽象方法。&lt;/p&gt;
&lt;p&gt;普通类只是一个设计完善，可以直接产生实例化对象并且调用类中的属性和方法，抽象类最大特点，就是必须被子类继承，并且抽象类本身无法进行实例化。在实际项目中，往往很少设计普通类，大多都会选择继承抽象类。&lt;/p&gt;
&lt;p&gt;抽象类基本定义：抽象类是为了方法覆写而提供的类结构。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abstract class javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private String type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract String getconn();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getType() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setType(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.type = type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;本实例中利用abstract关键字声明了抽象类与抽象方法：&lt;/p&gt;
&lt;p&gt;1、抽象方法与普通方法不一样，抽象方法不能有方法体{}&lt;/p&gt;
&lt;p&gt;2、抽象类不是一个完整的类，抽象类必须提供子类，子类继承依然用extends关键字&lt;/p&gt;
&lt;p&gt;3、子类（非抽象类）一定要覆写抽象类中的全部抽象方法&lt;/p&gt;
&lt;p&gt;4、抽象类的对象实例化可以通过子类向上转型来实现&lt;/p&gt;
&lt;p&gt;抽象类的使用：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abstract class javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private String type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract String getconn();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getType() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setType(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.type = type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class javademo02 extends javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getconn()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return super.getType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class demo13  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        javademo01 j1 = new javademo02();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j1.setType(&amp;quot;mm&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(j1.getconn());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;抽象类最大特点的是自己无法对象实例化，所以说在实际项目中，抽象类用来当中间过渡，当我们想要使用抽象类中，往往是为了解决继承中带来的代码重复处理。&lt;/p&gt;
&lt;p&gt;抽象类的说明&lt;/p&gt;
&lt;p&gt;1、抽象类必须有子类继承，抽象方法必须被覆写，所以抽象类定义时，不允许final定义抽象类和抽象方法。&lt;/p&gt;
&lt;p&gt;2、抽象类也可以定义成员属性和普通方法，为了给抽象类的成员属性初始化，我们可以给抽象类设计构造方法，子类在继承时会调用抽象类的无参构造，如果抽象类没有提供，那么就需要super关键字。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abstract  class javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private String type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract  String getconn();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public javademo01(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.type = type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getType() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setType(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.type = type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class javademo02 extends javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public javademo02(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super(type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getconn()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return super.getType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class demo13  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        javademo01 j1 = new javademo02(&amp;quot;mm&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(j1.getconn());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;抽象类中可以没有抽象方法，即使没有抽象方法，也不能使用new关键字实例化对象。&lt;/p&gt;
&lt;p&gt;抽象类中可以使用static定义静态方法，直接通过类名调用，毫无影响。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="http://rczmm.github.io/2021/07/28/%E7%BB%A7%E6%89%BF/"/>
    <id>http://rczmm.github.io/2021/07/28/%E7%BB%A7%E6%89%BF/</id>
    <published>2021-07-28T14:35:30.000Z</published>
    <updated>2021-07-31T14:44:28.653Z</updated>
    
    <content type="html"><![CDATA[<p>继承</p><p>面向对象的优点：模块化设计和代码重用，而依靠单一的类与对象是很难实现效果的。</p><p>（例如，学生类，人类，学生类本就属于人类，但是学生表示的范围比人又要小，因此人类是无法满足需求的）</p><p>在面向对象设计中，类是基本的逻辑单元，而对于基本的逻辑单元之间需要考虑到重用的问题，所以提供了继承，来实现类的重用。</p><p>严格来讲，类的继承是扩充一个类原有的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java中，实现继承的语法。</p><p>在继承结构里，很多时候会把子类叫做派生类，父类叫做超类。</p><p>继承的小例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son s1= new Son();</span><br><span class="line">        s1.setName(&quot;mm&quot;);</span><br><span class="line">        System.out.println(s1.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：子类没有定义任何结构，但是实例化对象之后能直接调用父类的方法与属性，证明子类重用了父类中的结构，同时可以根据子类功能进行调整。</p><p>在子类中扩充父类的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Son extends Father&#123;</span><br><span class="line">    private String school;</span><br><span class="line"></span><br><span class="line">    public String getSchool() &#123;</span><br><span class="line">        return school;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSchool(String school) &#123;</span><br><span class="line">        this.school = school;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son s1= new Son();</span><br><span class="line">        s1.setName(&quot;mm&quot;);</span><br><span class="line">        s1.setSchool(&quot;宇宙联合大学&quot;);</span><br><span class="line">        System.out.println(s1.getName()+&quot;\t&quot;+s1.getSchool());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类在父类基础上扩充了新的属性和方法，相比于父类，他更加的具体。</p><p>子类对象实例化流程：</p><p>继承关系中会产生父类和子类两种实例化对象。</p><p>子类调用父类的结构，所以说在进行子类对象实例化之前，我们会默认的调用父类的无参构造方法，为父类对象实例化（属性初始化），而后再进行子类构造调用，为子类对象实例化（属性初始化）。</p><p>子类对象实例化（无参构造调用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Father1 &#123;</span><br><span class="line">    public Father1()&#123;</span><br><span class="line">        System.out.println(&quot;父类构造方法正在调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son1 extends Father1&#123;</span><br><span class="line">    public Son1()&#123;</span><br><span class="line">        System.out.println(&quot;子类构造方法正在调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son1 s1 = new Son1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父类构造方法正在调用！</span><br><span class="line">子类构造方法正在调用！</span><br></pre></td></tr></table></figure><p>总结：程序只调用了子类的构造方法，结果发现，父类构造方法会默认的调用，执行完毕之后再执行子类的构造，所以得出结论，子类对象实例化一定会实例化父类对象，实际上相当于子类的构造方法隐含了一个super()的形式。</p><p>观察子类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Son1 extends Father1&#123;</span><br><span class="line">    public Son1()&#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;子类构造方法正在调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super的作用表示在子类中明确调用父类的构造方法，不写也会默认调用，对于super在子类构造方法中的定义，要注意，一定要写在第一行。</p><p>如果父类没有提供无参的构造方法，就可以通过super(参数)的形式调用指定参数的构造方法。</p><p>明确调用父类构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Father1 &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Father1(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son1 extends Father1 &#123;</span><br><span class="line">    private String school;</span><br><span class="line"></span><br><span class="line">    public Son1(String name, int age, String school) &#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.school = school;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son1 s1 = new Son1(&quot;mm&quot;,7,&quot;宇宙小学&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序里，父类就不再提供无参的构造方法了，这样在子类中就必须通过super关键字去明确子类要调用的父类结构，并且该语句必须放在首行。</p><p>子类一定要调用父类构造嘛？</p><p>一定的。</p><p>换一种说法，先有父母，才有子女。先有父类出生，才有子类出生。</p><p>继承限制</p><p>虽然，继承可以实现代码重用，但是这并不代表他是没有限制的。</p><p>1、单继承，一个子类只能继承一个父类。</p><p>首先，其他语言中存在多继承，也就是一个子类可以继承多个父类，在java中也可以实现这样的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public A(String name)&#123;</span><br><span class="line">        System.out.println(&quot;name:&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public B(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B&#123;</span><br><span class="line">    public C(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C类实际上是孙类，B类继承了A类的属性，C类继承了B类的属性，这就相当于了C类继承了A和B类的属性和方法，这样的操作叫<strong>多层继承</strong>，在java中只允许多层继承，不允许多重继承。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class D extends A,B,C&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：继承层数不要太多，太多影响到代码的阅读。</p><p>2、子类在继承时，会继承父类所有的属性和方法，包括私有属性。但是，对非私有的，属于显式继承（直接能用对象操作），私有的叫隐式继承（间接完成）。</p><p>没有继承私有属性，但继承了getter和setter方法。（间接完成）</p><p>覆写</p><p>在继承关系中，父类是最基础的存在，定义的结构都是为了本类的需要，但是有时候子类有一些特殊的需要，有可能会定义和父类相同名的属性和方法，这种情况就被称为覆写。</p><p>方法覆写</p><p>子类继承父类的全部方法，当父类中有些方法无法满足，就可以对这个方法进行扩充，这时，子类中定义一个方法名、返回值类型、参数类型和个数完全相同的方法的时候，就被称为方法覆写。</p><p>方法覆写基本实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;父类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DataBaese extends Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;子类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataBaese d1 = new DataBaese();</span><br><span class="line">        d1.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法覆写主要为了定义子类个性化的方法，同时保持了父类结构。</p><p>如果说，我们想要调用父类被覆写之后的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import javax.xml.parsers.SAXParser;</span><br><span class="line"></span><br><span class="line">class Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;父类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DataBaese extends Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        super.connect();</span><br><span class="line">        System.out.println(&quot;子类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataBaese d1 = new DataBaese();</span><br><span class="line">        d1.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此处，用this替代super则会报栈溢出的错误。</p><p>Exception in thread “main” java.lang.StackOverflowError</p><p>所以说，我们可以得出结论，同样是调用类结构，super不会查找自身，直接调用父类。</p><p>方法覆写限制</p><p>子类中覆写的方法不能比父类的方法具有更严格的控制权限。</p><p>private&lt;default&lt;public</p><p>子类的权限大于等于父类权限</p><p>注意：父类方法定义为private时，子类无法覆写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Channel&#123;</span><br><span class="line">    private void connect()&#123;</span><br><span class="line">        System.out.println(&quot;父类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void m1()&#123;</span><br><span class="line">        this.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DataBaese extends Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;子类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataBaese d1 = new DataBaese();</span><br><span class="line">        d1.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载与覆写：</p><p>重载：方法名相同、其他可以不同、没有权限要求、发生了一个类中</p><p>覆写：方法名、参数、返回值都想同、子类覆写的方法权限要大于等于父类方法、发生在继承关系中。</p><p>属性覆盖</p><p>子类依据自身需求对父类属性进行重命名定义。</p><p>要注意：private属性无效。</p><p>只需要属性名一致即可，数据类型可以不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class animal&#123;</span><br><span class="line">    double age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class person11 extends animal&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    public void info()&#123;</span><br><span class="line">        System.out.println(this.age);</span><br><span class="line">        System.out.println(super.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        person11 p1 = new person11();</span><br><span class="line">        p1.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super和this</p><p>super：表示父类对象、父类操作，属性，方法，（）构造方法、调用父类构造，放在首行、由子类查找父类</p><p>this：表示本类对象、本类操作，属性，方法，（）构造方法、调用本来构造，放在首行、从本类查找、表示当前对象</p><p>final关键字</p><p>为了保护父类定义</p><p>final在java描述为终接器。</p><p>定义不能继承的类，不能覆写的方法，常量（全局常量）。</p><p>关于常量和字符串连接的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class demo09 &#123;</span><br><span class="line"></span><br><span class="line">    public static final String str1 = &quot;mm&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str2 = &quot;ilovemm&quot;;</span><br><span class="line">        String str3 = &quot;ilove&quot;+str1;</span><br><span class="line">        System.out.println(str2==str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>annotation注解(明确声明，为了良好的代码阅读)</p><p>1、准确覆写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class F &#123;</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class S extends F &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;子类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解就可以在不清楚父类结构的情况下，分析哪些是覆写方法，哪些是自定义方法，此处还可以在编译时检测因为子类拼写造成的方法覆写错误。</p><p>2、过期声明</p><p>程序是不断更新的，有时候会有一些不再推荐使用的结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class F &#123;</span><br><span class="line">    </span><br><span class="line">    @Deprecated</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void m3()&#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class S extends F &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;子类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合理开发时，不要使用已经被注解之后的，弃用结构，不利于后期更新。</p><p>3、压制警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class F &#123;</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">    @SuppressWarnings(value = &#123;&quot;deprecation&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new F().m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证代码的合理性，在编译时会抛出警告，但是有些错误不必要，为了防止这些信息出现，就可以用压制警告注解。</p><p>deprecation：使用了不赞成的类或方法。</p><p>多态</p><p>同一种结构会根据不同形式展示出不同的效果。</p><p>方法的多态性：</p><p>重载：同一方法，根据传入参数不同实现不同功能</p><p>覆写：同一个方法根据子类不同实现不同功能</p><p>对象的多态性：</p><p>父类与子类的转换</p><p>向上转型：父类 父类实例 = 子类实例 （自动转换）</p><p>向下转型：子类 子类实例 = （子类）父类实例 （强制转换完成）</p><p>参考意见：实际的转型处理上看，向上转型用的比较多，向下转型往往都在使用子类特殊功能的时候，还有不转型使用（例如：String类）</p><p>父类定义标准，子类定义个性化。（覆写）</p><p>向上转型：子类对象实例化之前一定会实例化父类对象，这个时候如果我们把子类对象的实例通过父类来接受，即可实现对象的向上转型。而此时的本质还是子类实例，所以说，一旦调用子类覆写了父类的方法，调用的一定是覆写之后的方法。</p><p>最大的特点在于可以通过父类对象接受子类实例，这一原则有助于实现方法接受或返回参数的统一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class animal &#123;</span><br><span class="line">    public double age = 7;</span><br><span class="line">    public void info()&#123;</span><br><span class="line">        System.out.println(&quot;父类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class person11 extends animal &#123;</span><br><span class="line">    public int age = 7;</span><br><span class="line"></span><br><span class="line">    public void info() &#123;</span><br><span class="line">       System.out.println(&quot;子类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        animal a1 = new person11();</span><br><span class="line">        a1.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不要看类名称，看实例化对象的类。关键看调用哪个类的构造。（new后的内容，不看左边看右边）</p><p>最大的特点在于可以通过父类对象接受子类实例，这一原则有助于实现方法接受或返回参数的统一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class kafka extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am kafka&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mq extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am mq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class database&#123;</span><br><span class="line">    /*</span><br><span class="line">     * 接受message对象，由于存在自动向上转型的机制，所以可以接受所有的子类实例</span><br><span class="line">     */</span><br><span class="line">    public static void m3(message m1)&#123;</span><br><span class="line">        m1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        database.m3(new kafka());</span><br><span class="line">        database.m3(new mq());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本类中定义的m3方法，参数类型是message，这就意味着所有message以及子类对象都可以接受，相当于统一了参数类型。</p><p>向上转型主要是为了实现操作标准的统一性。</p><p>向下转型：保持子类实例的个性化</p><p>子类继承父类之后可以对已经有的功能进行扩充（覆写，新加），对于子类之中扩充的方法只有具体的子类实例才可以调用，在这样的情况下，如果子类发生了向上转型呐？</p><p>需要通过强制向下转型来实现子类扩充方法的调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class kafka extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am kafka&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print2()&#123;</span><br><span class="line">        System.out.println(&quot;i am java 11&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mq extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am mq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        message m1 = new kafka();</span><br><span class="line">        m1.print();</span><br><span class="line">        kafka k1 = (kafka) m1;</span><br><span class="line">        k1.print2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，通过kafka子类接收了message对象，此时m1只能调用本类或者是m1父类的方法，如果此时需要调用子类中扩充的方法，就必须强制转换为指定的子类类型。</p><p>要先发生向上转型，才可以进行向下转型。</p><p>父类实例是不可能强者转换成任意子类实例的，因为两者之间没有联系。必须先通过子类实例，利用向上转型让父类对象和子类实例发生关系才可以向下转型，否则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    message m1 = new message();</span><br><span class="line">    kafka k1 = (kafka) m1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException</span><br></pre></td></tr></table></figure><p>这里就是message对象并没有和kafka子类产生联系，所以无法强制转换。向下转换永远都存在安全隐患。</p><p>为了保证转换的安全性，给出了instanceof关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    message m1 = new kafka();</span><br><span class="line">    kafka k1 = (kafka) m1;</span><br><span class="line">    System.out.println(m1 instanceof message);</span><br><span class="line">    System.out.println(k1 instanceof message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>所以说，我们可以通过先判断再转换的方式去进行转型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class kafka extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am kafka&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print2()&#123;</span><br><span class="line">        System.out.println(&quot;i am java 11&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mq extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am mq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        message m1 = new kafka();</span><br><span class="line">        m1.print();</span><br><span class="line">        if (m1 instanceof kafka)&#123;</span><br><span class="line">            kafka k1 = (kafka) m1;</span><br><span class="line">            k1.print2();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object类</p><p>在java里是最重要的程序类，也是所有类的父类。</p><p>方便操作类型的统一，方便每一个类定义一些公共操作，专门设计了一个公共的object父类，object是唯一一个没有父类的类。但是却是所有类的父类，所有利用class关键字定义的类默认都全部继承于object类，因此：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class message extends Object&#123;</span><br><span class="line">class message &#123;</span><br></pre></td></tr></table></figure><p>这两种类定义的效果都是一样的。</p><p>所有类都是object的子类，那么就代表所有类对象都可以利用向上转型为obejct类对象实例化。</p><p>这样优势在于，当某些操作需要接受或者返回任意类型时候，最适合的参数类型就是object。</p><p>object除了能接收所有的类实例之外，还可以接收所有的引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object a1 = new int[]&#123;1,2,3&#125;;</span><br><span class="line">    if (a1 instanceof int[])&#123;</span><br><span class="line">        int data [] = (int[]) a1;</span><br><span class="line">        for (int temp: data) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取对象信息</p><p>在object类中有一个tostring（）方法，利用这个方法可以实现对象信息的获取，同时这个方法在进行对象输出被默认调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object a1 = new int[]&#123;1,2,3&#125;;</span><br><span class="line">System.out.println(a1.toString());</span><br><span class="line">System.out.println(a1);</span><br></pre></td></tr></table></figure><p>具体中，我们可以根据需要覆写tostring方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class message &#123;</span><br><span class="line">    private int length;</span><br><span class="line"></span><br><span class="line">    public int getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLength(int length) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public message(int length) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;队列长度:&quot; + this.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object a1 = new message(12);</span><br><span class="line">        System.out.println(a1.toString());</span><br><span class="line">        System.out.println(a1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本例中，定义了length属性，覆写了tostring方法，而后调用时，就会实现我们自己实现的方法体内的内容。</p><p>对象比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class demo extends Object&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public demo(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj)&#123;</span><br><span class="line">        if (!(obj instanceof demo))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this == obj)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        demo d1 = (demo) obj;</span><br><span class="line">        return this.name.equals(d1.name) &amp;&amp; this.age == d1.age;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo12 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo d1 = new demo(&quot;mm&quot;,7);</span><br><span class="line">        demo d2 = new demo(&quot;mm&quot;,7);</span><br><span class="line">        System.out.println(d1.equals(d2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继承&lt;/p&gt;
&lt;p&gt;面向对象的优点：模块化设计和代码重用，而依靠单一的类与对象是很难实现效果的。&lt;/p&gt;
&lt;p&gt;（例如，学生类，人类，学生类本就属于人类，但是学生表示的范围比人又要小，因此人类是无法满足需求的）&lt;/p&gt;
&lt;p&gt;在面向对象设计中，类是基本的逻辑单元，而对于基本</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>String类</title>
    <link href="http://rczmm.github.io/2021/07/27/String%E7%B1%BB/"/>
    <id>http://rczmm.github.io/2021/07/27/String%E7%B1%BB/</id>
    <published>2021-07-27T14:59:04.000Z</published>
    <updated>2021-07-29T08:21:22.872Z</updated>
    
    <content type="html"><![CDATA[<p>String 类</p><p>string在实际开发中，几乎是一个必须使用的程序类，也可以说是项目的核心组件类。</p><p>string用“”双引号定义，可以用+实现字符串连接。</p><p>1、string类对象实例化</p><p>java中基本数据类型不包含string，但是考虑到程序开发的实际需要，就设计了string类，并且这个类的对象可以直接赋值进行实例化。</p><p>java程序中使用双引号定义的内容，都是字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line"></span><br><span class="line">private final byte[] value</span><br></pre></td></tr></table></figure><p>jdk8 保存的是字符数组，jdk9之后字符串源代码实现就是字节数组。</p><p>我们可以得出一个结论，string就是对数组的特殊包装应用，而对数组而言最大的问题是长度的固定。</p><p>string本身是一个系统类，除了可以赋值进行对象实例化之外，还可以使用相关的构造方法来进行对象实例化。</p><p>string类构造方法(之一)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String(String original) &#123;</span><br><span class="line">    this.value = original.value;</span><br><span class="line">    this.coder = original.coder;</span><br><span class="line">    this.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    String str02 = new String(&quot;2222&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，两种定义方式，看起来效果几乎完全一样，但实际上两者是有本质差别的。</p><p>字符串比较</p><p>如果是基本数据类型，在java中，可以使用==比较运算符直接进行比较。</p><p>但是string属于引用数据类型，他的对象名中保存的是堆内存地址，string对象使用==比较的就不再是内容，而是堆内存地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    String str03 = &quot;1111&quot;;</span><br><span class="line">    String str02 = new String(&quot;1111&quot;);</span><br><span class="line">    System.out.println(str02==str01);</span><br><span class="line">    System.out.println(str03==str01);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于自定义类的比较，和字符串一样，都是比较的堆内存地址。</p><p>在string类里，提供了equals（）方法来比较字符串内容（区分大小写）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    String str03 = &quot;1111&quot;;</span><br><span class="line">    String str02 = new String(&quot;1111&quot;);</span><br><span class="line">    System.out.println(str01.equals(str02));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>字符串常量</p><p>常量就是不会修改的内容。</p><p>字符串常量，严格意义上说是string类的匿名对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    System.out.println(&quot;1111&quot;.equals(str01));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的普通方法只有对象能调用，所以我们说字符串常量是string类的匿名对象。</p><p>所谓的直接赋值的操作，实际上就是给匿名对象一个名字而已。</p><p>区别：string类的匿名对象是系统自动生成的，不再由用户自己创建。</p><p>实际问题——字符串比较：</p><p>如果我们要获取用户输入，然后进行字符串比较，但是用户没有输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String input = null;</span><br><span class="line">    if (input.equals(&quot;baidu&quot;))&#123;</span><br><span class="line">        System.out.println(&quot;www。baidu.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></pre></td></tr></table></figure><p>解决途径：（回避）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String input = null;</span><br><span class="line">    if (&quot;baidu&quot;.equals(input))&#123;</span><br><span class="line">        System.out.println(&quot;www。baidu.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中直接调用了字符串常量“baidu”来执行。equals方法，因为字符串<strong>常量</strong>是string对象，所以永远不可能是null，而equals方法的参数又是object，因此这就避免了空指针异常。</p><p>两种实例化方式的比较：</p><p>1、直接赋值：</p><p>在堆内存中开辟一块地址，保存字符串常量，并且栈内存直接引用这一部分的堆内存。</p><p>而且，对同一字符串的多次直接赋值还可以实现对堆内存的重复利用。也就是说采用直接赋值的方式进行string对象实例化，在内容相同（字符串常量一致）的情况下，不会开辟新的堆内存空间，而会直接指向已有的堆内存。</p><p>字符串对象池</p><p><strong>jvm的底层的存在一个对象池</strong>（string只是对象池中的一种类型），当我们使用直接赋值的方式定义了一个string对象之后，字符串所使用的匿名对象入池保存，如果后面我们还有string对象直接赋值定义，并且采用了同一块字符串常量，也就是内容相同，那么就不会开辟新的堆内存空间，而是使用已经有的对象进行引用的分配。</p><p>共享设计模式的应用：（如果有一天，你需要一把剪刀，你出去买了一把，用完之后不可以丢掉，放在家里，等下一次用的时候再继续使用，剪刀放在工具箱里，同样工具箱的东西都可以下一次继续使用）</p><p>构造方法实例化：</p><p>如果要明确的调用string类的构造方法进行实例化string对象，那么一定要使用new关键字，而每当使用new关键字时，就会开辟新的堆内存空间。而这块堆内存的内容就是构造方法传入的字符串常量。</p><p>构造方法定义时：传入的字符串常量会创建一个匿名对象，然后new关键字会开辟一块堆内存空间，也会传入一个字符串常量。那么就相当于一共创建了两块堆内存空间，并且字符串常量也就是匿名对象创建的堆内存只负责实例化string对象，不与构造方法实例化出的string对象有关联。真正使用的堆内存是new开辟的堆内存，而之前定义字符串常量开辟的堆内存空间不会被任何栈内存引用（指向），成为垃圾空间，等待gc回收。</p><p>因此，构造方法创建string对象，会开辟两份空间，并且一块空间成为垃圾。</p><p>除此之外。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = new String(&quot;mm&quot;);</span><br><span class="line">    String str02 = &quot;mm&quot;;</span><br><span class="line">    System.out.println(str01 == str02);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>使用构造方法定义的string对象不会自动入池保存。</p><p>string对象手动入池：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = new String(&quot;mm&quot;).intern();</span><br><span class="line">    String str02 = &quot;mm&quot;;</span><br><span class="line">    System.out.println(str01 == str02);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>所以，实际开发时，尽量的直接赋值定义字符串。</p><p>字符串常量池</p><p>为了防止字符串过多，jdk进行了结构上的优化。（本质是一个动态对象数组），所有直接赋值的字符串对象都可以自动保存在常量池中，方便下次使用。</p><p>静态常量池：</p><p>程序（class）在加载（不是运行）时会把字符串、常量、类、方法全部进行分配</p><p>运行时常量池：</p><p>加载之后，有一些字符串内容是通过拼接的，由于string对象内容可以改变，所以叫做运行时常量池。</p><p>字符串修改：</p><p>常量的内容一旦被定义就无法修改，但是字符串比较特殊，重新实例化来实现修改字符串内容。</p><p>string类关于数据的存储是通过数组，数组本身又是定长的数据类型。实际上就代表了string对象一旦被实例化，内容就无法改变，那么字符串对象内容实际上就是通过改变引用的方式来实现的。</p><p>要注意：这样会产生许多的垃圾空间。</p><p>主方法组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String [] args) &#123;&#125;</span><br></pre></td></tr></table></figure><p>public: 一种访问权限、主方法是一切程序的入口，有且只能有一个，一定是公共的。</p><p>static：程序的执行是通过类，所以这个方法由类直接调用。</p><p>void：主方法是一切程序的起点，程序一旦开始，不需要返回结果。</p><p>main：系统定义好的方法名称，当java执行时，自动寻找。</p><p>String [] args：字符串的数组，可以实现启动参数的接受。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if (args.length == 0)&#123;</span><br><span class="line">            System.out.println(&quot;please input your argments:&quot;);</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for (String temp:args) &#123;</span><br><span class="line">                System.out.println(temp+&quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java demo04 one 2 3 4 5</span><br></pre></td></tr></table></figure><p>string类常用方法：</p><p>1、字符数组转字符串（字节等同理）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char [] char01 =new char[]&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;&#125;;</span><br><span class="line">String str01 = new String(char01);</span><br><span class="line">System.out.println(str01);</span><br></pre></td></tr></table></figure><p>2、指定范围转换（第二个参数是步长）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char [] char01 =new char[]&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;&#125;;</span><br><span class="line">String str01 = new String(char01,0,3);</span><br><span class="line">System.out.println(str01);</span><br></pre></td></tr></table></figure><p>3、获取指定索引的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.charAt(0));</span><br></pre></td></tr></table></figure><p>4、大小写转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.toLowerCase());</span><br><span class="line">System.out.println(str01.toUpperCase());</span><br></pre></td></tr></table></figure><p>5、截取字符串（开始索引到结束索引）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.substring(0,10));</span><br><span class="line">System.out.println(str01.substring(0));</span><br></pre></td></tr></table></figure><p>6、判断是否以指定字符串开头、结尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.startsWith(&quot;12&quot;));</span><br><span class="line">System.out.println(str01.startsWith(&quot;12&quot;,3));</span><br><span class="line">System.out.println(str01.endsWith(&quot;rf&quot;));</span><br></pre></td></tr></table></figure><p>7、字符串替换（全部替换，替换第一个）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.replaceAll(&quot;1&quot;,&quot;mm&quot;));</span><br><span class="line">System.out.println(str01.replaceFirst(&quot;3&quot;,&quot;mm&quot;));</span><br></pre></td></tr></table></figure><p>………..</p><p>java doc文档</p><p>这是java官方提供的关于jdk相关api的文档，文档中详细描述了每一个模块中不同的包里不同的类的相关定义和相关说明信息，以及成员属性介绍，包括构造方法普通方法以及其他的说明摘要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;String 类&lt;/p&gt;
&lt;p&gt;string在实际开发中，几乎是一个必须使用的程序类，也可以说是项目的核心组件类。&lt;/p&gt;
&lt;p&gt;string用“”双引号定义，可以用+实现字符串连接。&lt;/p&gt;
&lt;p&gt;1、string类对象实例化&lt;/p&gt;
&lt;p&gt;java中基本数据类型不包含s</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://rczmm.github.io/2021/07/26/%E6%95%B0%E7%BB%84/"/>
    <id>http://rczmm.github.io/2021/07/26/%E6%95%B0%E7%BB%84/</id>
    <published>2021-07-26T15:31:38.000Z</published>
    <updated>2021-07-27T14:51:33.994Z</updated>
    
    <content type="html"><![CDATA[<p>数组</p><p>数组是程序设计语言里面一门很重要的数据结构，java里，数组是引用数据类型，就必然牵扯到栈内存的开辟和引用传递。</p><p>数组是一门非常基础的线性存储结构，可以实现一组变量的有效关联。</p><p>数组是一些相关变量的集合。如果我现在要定义100个整形变量，</p><p>int i1，i2，i3…i100.</p><p>以上的定义方式可以满足需求，但是每一个变量之间不存在逻辑控制关系，每一个变量完全独立，就会出现不方便管理变量的情况。</p><p>数组：</p><p>声明与开辟：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int listDemo01 [] = new int[10];</span><br><span class="line">int [] listDemo02 = new int[10];</span><br><span class="line">数据类型 [] 数组名称 = new 数据类型[长度]</span><br></pre></td></tr></table></figure><p>声明：</p><p>数据类型 [] 数组名称 = null；</p><p>开辟：</p><p>数据名称 = new 数据类型 [长度]；</p><p>当数组开辟空间之后，就可以通过访问下标，索引的方式去实现查询，修改，删除。所有数组的索引都是从0开始的。如果访问的索引超过了数组下标的长度，那就会抛出异常，（数据越界）</p><p>以上的都是动态初始化的内容，只给了数组长度，如果如上声明，则每一个元素的数据类型都是int，且根据默认值，是0。</p><p>数组是一种顺序结构，长度是固定的，输出的时候采用循环。（for循环）</p><p>java为了方便获取数组长度，提供了此listDemo01.length属性。</p><p>数组的核心：声明并且分配内存空间，而后根据索引进行访问。</p><p>数组和对象：差别就在于堆内存中，对象保存的是属性，数组保存的是信息。</p><p>静态初始化（在开辟内存空间的时候，就给出数组中元素的值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int data [] =null;</span><br><span class="line">data = new int[] &#123;1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure><p>数组最大的方便就是在于可以使用线性结构来存储相同数据类型的变量，但是另一个角度来看，最大的缺陷也正是如此，保存个数固定，因此在实际中，我们会采用类集框架（java提供的数据结构实现）来实现动态数组的操作。但是这并不意味着，我们不会使用数组。</p><p>数组引用传递分析：</p><p>数组属于引用数据类型，在使用是需要new关键字开辟堆内存空间，一个堆内存可以被多个栈内存指向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int data[] = new int[]&#123;10, 20, 30&#125;;</span><br><span class="line">int temp[] = data;</span><br><span class="line">temp[0] = 99;</span><br><span class="line">for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">    System.out.print(data[i]+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">992030</span><br></pre></td></tr></table></figure><p>要注意对数组来说，如果只是声明，没有开辟空间，是无法根据下标访问的，否则会报空指针异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int temp[] = null;</span><br><span class="line">temp[0] = 99;</span><br><span class="line">System.out.println(temp[0]);</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></pre></td></tr></table></figure><p>foreach输出</p><p>数组的输出除了索引和循环之外，还提供了foreach结构。</p><p>数组，定长。</p><p>foreach（加强的for循环）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int data[] = new int[]&#123;10, 20, 30&#125;;</span><br><span class="line"></span><br><span class="line">for (int temp : data) &#123;</span><br><span class="line">    System.out.println(temp+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：没有foreach关键字。</p><p>利用foreach输出，可以避免数组越界异常。</p><p>二维数组：</p><p>两个数组的嵌套。</p><p>之前的数组，一维数组，实际上是一种线性结构。（相当于只描述了一行的内容）</p><p>现在我们要描述多行多列的内容，那就需要用到二维数组。（多维数组）</p><p>动态初始化、静态初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int data [][] = new int [8][8];</span><br><span class="line">int data1 [][] = new int [][] &#123;&#123;1,1,1&#125;,&#123;2,2,2&#125;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int data1 [][] = new int [][] &#123;&#123;1,1,1&#125;,&#123;2,2,2&#125;,&#123;1,2,4,5,6,7&#125;&#125;;</span><br><span class="line">for (int x =0 ;x&lt;data1.length;x++)&#123;</span><br><span class="line">    for (int y=0;y&lt;data1[x].length;y++)&#123;</span><br><span class="line">        System.out.print(data1[x][y]+&quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外层循环控制行，内存循环控制列。</p><p>foreach循环输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int temp[] : data) &#123;</span><br><span class="line">    for (int num: temp) &#123;</span><br><span class="line">        System.out.print(num + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组与方法：</p><p>在数组进行引用传递，最为常见的就是利用方法进行引用数据的处理或者返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int data[][] = new int[][]&#123;&#123;1, 1, 1&#125;, &#123;2, 2, 2&#125;, &#123;1, 2, 4, 5, 6, 7&#125;&#125;;</span><br><span class="line">    printArray(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void printArray(int data[][])&#123;</span><br><span class="line">    for (int temp[] : data) &#123;</span><br><span class="line">        for (int num: temp) &#123;</span><br><span class="line">            System.out.print(num + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void changeArray(int data[][])&#123;</span><br><span class="line">    for (int temp[] : data) &#123;</span><br><span class="line">        for (int num: temp) &#123;</span><br><span class="line">            num *= 2;</span><br><span class="line">            System.out.print(num+&quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int data[] = new int[]&#123;1, 3, 4, 5, 6, 78, 23, 54, 65, 76, 432, 32, 54&#125;;</span><br><span class="line">    Arrays.sort(data);</span><br><span class="line"></span><br><span class="line">    for (int temp : data) &#123;</span><br><span class="line">        System.out.print(temp + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组转置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int data[] = new int[]&#123;1, 3, 4, 5, 6, 78, 23, 54, 65, 76, 432, 32, 54&#125;;</span><br><span class="line">    Arrays.sort(data);</span><br><span class="line"></span><br><span class="line">    int center = data.length / 2; //确定交换次数</span><br><span class="line">    int head = 0;</span><br><span class="line">    int tail = data.length - 1;</span><br><span class="line">    for (int x = 0; x &lt; center; x++) &#123;</span><br><span class="line">        int temp = data[head];</span><br><span class="line">        data[head] = data[tail];</span><br><span class="line">        data[tail] = temp;</span><br><span class="line">        head++;</span><br><span class="line">        tail--;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int temp : data) &#123;</span><br><span class="line">        System.out.print(temp + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组复制：</p><p>是把源数组部分内容复制到另一个数组，但是数组长度不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int data[] = new int[]&#123;1, 3, 4, 5, 6, 78, 23, 54, 65, 76, 432, 32, 54&#125;;</span><br><span class="line">int data1[] = new int[]&#123;1, 3, 4, 5, 6&#125;;</span><br><span class="line"></span><br><span class="line">System.arraycopy(data,4,data1,1,3);</span><br></pre></td></tr></table></figure><p>（源数组名称、源数组开始点、目标数组名、目标数组开始点、长度）</p><p>方法可变参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int sum(int... data) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int temp:data) &#123;</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(sum(data));</span><br><span class="line">System.out.println(sum(1,23,45,65,7543,9));</span><br></pre></td></tr></table></figure><p>为了方便我们灵活的定义方法，避免参数限制，就给出了方便可变参数。</p><p>（参数类型…变量）</p><p>混合参数定义时（既有普通参数，也有可变的参数）</p><p>可变参数一定要写在最后、并且一个方法只能有一个可变参数</p><p>对象数组</p><p>数组内不止可以存放基本数据类型，还可以存放引用数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Person0 &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person0(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return &quot;name:&quot; + this.name + &quot;\tage:&quot; + this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person0 p1[] = new Person0[3];</span><br><span class="line">        p1[0] = new Person0(&quot;mm&quot;, 7);</span><br><span class="line">        p1[1] = new Person0(&quot;mm01&quot;, 4);</span><br><span class="line">        p1[2] = new Person0(&quot;mm01&quot;, 8);</span><br><span class="line">        for (Person0 temp : p1) &#123;</span><br><span class="line">            System.out.println(temp.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用传递应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line">    private Person1 person;</span><br><span class="line"></span><br><span class="line">    public Car(String name, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person1 getPerson() &#123;</span><br><span class="line">        return this.person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPerson(Person1 person) &#123;</span><br><span class="line">        this.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tprice:&quot;+this.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person1&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Car car;</span><br><span class="line"></span><br><span class="line">    public Person1(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Car getCar() &#123;</span><br><span class="line">        return this.car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCar(Car car) &#123;</span><br><span class="line">        this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tage:&quot;+this.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person1 p1 = new Person1(&quot;mm&quot;,7);</span><br><span class="line">        Car c1 = new Car(&quot;mm01&quot;,1223132.32);</span><br><span class="line">        p1.setCar(c1);</span><br><span class="line">        c1.setPerson(p1);</span><br><span class="line">        System.out.println(p1.getCar().getInfo());</span><br><span class="line">        System.out.println(c1.getPerson().getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意87、88.代码链。</p><p>自身类结构关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line">    private Person1 person;</span><br><span class="line"></span><br><span class="line">    public Car(String name, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person1 getPerson() &#123;</span><br><span class="line">        return this.person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPerson(Person1 person) &#123;</span><br><span class="line">        this.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tprice:&quot;+this.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person1&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person1[] getChild() &#123;</span><br><span class="line">        return this.child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setChild(Person1[] child) &#123;</span><br><span class="line">        this.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Car car;</span><br><span class="line">    private Person1 child[];</span><br><span class="line"></span><br><span class="line">    public Person1(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Car getCar() &#123;</span><br><span class="line">        return this.car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCar(Car car) &#123;</span><br><span class="line">        this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tage:&quot;+this.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person1 p1 = new Person1(&quot;mm&quot;,7);</span><br><span class="line">        Person1 child1 = new Person1(&quot;mm01&quot;,7);</span><br><span class="line">        Person1 child2 = new Person1(&quot;mm02&quot;,7);</span><br><span class="line">        child1.setCar(new Car(&quot;法拉克&quot;,121321321.2221));</span><br><span class="line">        child2.setCar(new Car(&quot;卡车拉货&quot;,12132.3231));</span><br><span class="line">        p1.setChild(new Person1[]&#123;child1,child2&#125;);</span><br><span class="line">        Car c1 = new Car(&quot;bbb&quot;,12121.32);</span><br><span class="line">        p1.setCar(c1);</span><br><span class="line">        c1.setPerson(p1);</span><br><span class="line"></span><br><span class="line">        for (int x=0;x&lt;p1.getChild().length;x++)&#123;</span><br><span class="line">            System.out.println(p1.getChild()[x].getInfo());</span><br><span class="line">            System.out.println(p1.getChild()[x].getCar().getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合成设计模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Pc &#123;   //父结构</span><br><span class="line">    private 显示器 对象数组[];  //一台计算机可以连接多个小显示器</span><br><span class="line">    private 主机 对象; //一台计算机只能有一个主机</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 显示器 &#123;  //独立类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 主机 &#123;   //子结构</span><br><span class="line">    private 主板 对象; //一块主板</span><br><span class="line">    private 鼠标 对象1; //一个鼠标</span><br><span class="line">    private 键盘 对象2; //一块键盘</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 主板 &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 鼠标 &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 键盘 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过不同的类实现子结构，然后在父结构中整合。（如上，就是典型的面向对象思想）</p><p>引用数据类型不仅仅是内存的操作形式，更多的是抽象和关联的设计思想</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组&lt;/p&gt;
&lt;p&gt;数组是程序设计语言里面一门很重要的数据结构，java里，数组是引用数据类型，就必然牵扯到栈内存的开辟和引用传递。&lt;/p&gt;
&lt;p&gt;数组是一门非常基础的线性存储结构，可以实现一组变量的有效关联。&lt;/p&gt;
&lt;p&gt;数组是一些相关变量的集合。如果我现在要定义100</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>类与对象</title>
    <link href="http://rczmm.github.io/2021/07/25/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-1/"/>
    <id>http://rczmm.github.io/2021/07/25/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-1/</id>
    <published>2021-07-25T14:49:45.000Z</published>
    <updated>2021-07-26T15:31:23.418Z</updated>
    
    <content type="html"><![CDATA[<p>类与对象</p><p>面向对象，java一大特点之一。</p><p>面向对象三大特性：封装、继承、多态。</p><p>类：成员属性和成员方法组成的，成员属性实际上就是一个变量，方法就是操作上的行为。</p><p>定义类，要根据程序语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    </span><br><span class="line">    public void tell()&#123;</span><br><span class="line">        System.out.println(name+&quot;\t&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点注意，没有static。</p><p>调用形式不同，主类中（public修饰的类）由主方法（main）直接调用的方法必须加static。但是现在tell方法是由对象调用的。</p><p>一个类定义完成之后。并不能直接使用，因为类描述的只是一个广泛的概念，具体的操作要通过对象来执行，类属于引用数据类型。</p><p>对象的定义格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person();</span><br></pre></td></tr></table></figure><p>类名 对象名 = new 类名（）;</p><p>java里引用数据类型是需要进行内存分配，所以在定义的时候必须用new关键字来分配相对应的内存空间，这个过程也被叫实例化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(p1.name);</span><br><span class="line">System.out.println(p1.age);</span><br><span class="line">p1.tell();</span><br></pre></td></tr></table></figure><p>对象内存分析</p><p>引用数据类型必须用new开辟内存，才可以储存成员属性，在引用数据类型操作中最重要的内存有两块。</p><p>heap（堆）：对象的具体信息（成员属性），new开辟的也正是堆内存</p><p>stack（栈）：保存的是堆内存的地址，也就是通过地址找到堆，而后找到对象内容，简单理解就是栈里保存了对象名称。</p><p>方法信息</p><p>类中成员属性是对象私有的，但是方法是对象共有的，方法的信息会保存在全局方法区（公共内存）</p><p>对象引用传递分析</p><p>引用传递是java的核心概念。引用数据类型的核心就是在于堆内存和栈内存的分配与指向处理，同一块堆内存可以指向不同的栈内存。（一个人可以有很有名字）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">p1.name=&quot;mm&quot;;</span><br><span class="line">p1.age=8;</span><br><span class="line">p1.tell();</span><br><span class="line">Person p2=p1;</span><br><span class="line">p2.age=9;</span><br><span class="line">p1.tell();</span><br></pre></td></tr></table></figure><p>引用传递（将p1对象的内存堆地址赋值给p2）这就相当于两个不同的栈内存指向了同一块堆内存。</p><p>引用传递与垃圾产生分析</p><p>内存管理，java——gc机制。</p><p>一块栈只允许一个堆内存地址信息。（如果需要改变，那就存在一个丢弃原有的引用实体，更换新的引用实体的问题。）</p><p>丢弃原始引用实体的时候（产生垃圾）</p><p>所有的垃圾都将等待gc不定期回收释放。</p><p>开发的时候尽量避免垃圾产生。</p><p>成员属性封装</p><p>封装性、本质上就是让内部结构对外不可见。</p><p>如果没有封装，类中的所有成员属性可以直接通过实例化对象在类外部直接调用，但是这样的调用是很不安全的，这时最稳妥的就是使用private关键字对成员属性进行封装处理。</p><p>当使用了private之后，是不允许外部对象直接访问成员属性的。</p><p>此时，访问成员属性，需要用到getter（），setter（）方法。</p><p>实际上，不仅针对成员属性封装，还有方法、内部类封装，这里只说一点点。</p><p>setter和getter的目的，是为了设置和取得属性内容，有时候或许不会用到其中某一个，但是作为一种标准，我们必须全部提供。</p><p>还可以在setter里添加限制条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if (age &gt;= 0 &amp;&amp; age &lt;= 300) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;this age is error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tell() &#123;</span><br><span class="line">        System.out.println(name + &quot;\t&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法与匿名对象</p><p>构造方法是实例化的时候一种重要的结构，一种特殊的方法。在new这个类的时候，默认调用构造方法，功能：主要是为了完成成员属性的初始化操作。</p><p>构造方法名和类名一样，构造方法没有返回值<strong>类型</strong>。</p><p>其实，对象实例化一定要求有构造方法的，java提供了一个默认的构造方法。（这个方法没有参数、没有返回值，如果我们定义了，那就不会生成。）一个类中至少存在一个构造方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的构造方法。</p><p>构造方法虽然特殊，但还是方法，就存在重载。不过构造方法重载的时候只需要考虑参数的类型个数就可以了。</p><p>对象实例化的时候，new关键字主要是进行开辟堆内存，对象名称是为了对堆内存的引用，这样一是为了防止堆内存变成垃圾空间。</p><p>有了构造方法之后，在堆内存开辟的同时就可以对对象进行实例化处理，也就是即使没有栈内存指向，也就是没有对象名称，但是对象至少可以使用一次，对于这种没有指向的对象就叫做匿名对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class demo01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Person(&quot;mm&quot;,7).tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String tempname,int tempage)&#123;</span><br><span class="line">        name = tempname;</span><br><span class="line">        age = tempage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if (age &gt;= 0 &amp;&amp; age &lt;= 300) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;this age is error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tell() &#123;</span><br><span class="line">        System.out.println(name + &quot;\t&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序，因为没有栈内存的指向，所以这个对象在使用了一次之后将成为垃圾空间。</p><p>匿名对象相当于一个一次性饭盒，使用一次就被定义为垃圾空间，等待gc回收，普通对象存在一个引用关系，所以就可以反复操作。</p><p>this关键字</p><p>this描述的是本类结构调用的关键字，java里this可以描述3种结构</p><p>1、类的属性</p><p>2、类的方法</p><p>3、当前对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    char sex;</span><br><span class="line"></span><br><span class="line">    public Person(String name,int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if (age &gt;= 0 &amp;&amp; age &lt;= 300) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;this age is error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tell() &#123;</span><br><span class="line">        System.out.println(this.name + &quot;\t&quot; + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明确的标注了本类属性。</p><p>在日后，为了避免不必要的bug，只要是调用成员属性时，最好加this。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name,int age)&#123;</span><br><span class="line">    this.setName(name);</span><br><span class="line">    setAge(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对于是否使用this没有明确要求，但是从标准出发，采用this.方法名（）</p><p>但一个程序出现多个构造方法时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name,int age)&#123;\</span><br><span class="line">    this();</span><br><span class="line">    this.setName(name);</span><br><span class="line">    setAge(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Person()&#123;</span><br><span class="line">    System.out.println(&quot;this is a person&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，要注意，这里为了避免出现死循环（递归调用），要注意留一个出口。</p><p>this当前对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Person p1 = new Person();</span><br><span class="line">    p1.tell();</span><br><span class="line">    Person p2 = new Person();</span><br><span class="line">    p2.tell();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void tell() &#123;</span><br><span class="line">        System.out.println(this.name + &quot;\t&quot; + this.age);</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里实例化了两个person对象，分别调用了tell方法，通过执行结果得出，this会随着对象不同而表现出不同的实例。</p><p>this.属性，严格意义上来说，这一操作执行的是当前对象的属性。</p><p>static关键字</p><p>属性、方法、代码块</p><p>类的成员，属性和方法，静态的和非静态的。</p><p>对象不同，各自的属性内容也不同。</p><p>静态的含义：类中的某个属性变成公共的。（所有对象都可以去使用），则在声明前加上static关键字。</p><p>static关键字声明后，this调用不了。</p><p>static属性属于类，而不属于对象。</p><p>所以在调用的时候，直接用类名访问。</p><p>static属性存在（全局数据区）</p><p>static方法</p><p>static定义方法时，通过类名来调用。（方法体不能含有当前对象的属性或方法也就是this调用的属性或者方法。）</p><p>static代码块</p><p>主类</p><p>优于主方法执行</p><p>非主类</p><p>优于构造代码块执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;类与对象&lt;/p&gt;
&lt;p&gt;面向对象，java一大特点之一。&lt;/p&gt;
&lt;p&gt;面向对象三大特性：封装、继承、多态。&lt;/p&gt;
&lt;p&gt;类：成员属性和成员方法组成的，成员属性实际上就是一个变量，方法就是操作上的行为。&lt;/p&gt;
&lt;p&gt;定义类，要根据程序语法。&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>方法</title>
    <link href="http://rczmm.github.io/2021/07/25/%E6%96%B9%E6%B3%95/"/>
    <id>http://rczmm.github.io/2021/07/25/%E6%96%B9%E6%B3%95/</id>
    <published>2021-07-25T14:19:54.000Z</published>
    <updated>2021-07-25T14:48:50.370Z</updated>
    
    <content type="html"><![CDATA[<p>方法（method，有时候也被叫做函数），指的是一段可以被重复调用的代码块，利用方法可以实现程序的拆分</p><p>public static void main(String [] args){}</p><p>公共的 静态的 返回值类型 方法名（参数）{</p><p>方法体</p><p>return【返回值】</p><p>}</p><p>定义一个无参数，且无返回值的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void method1()&#123;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">method1();</span><br></pre></td></tr></table></figure><p>return结束方法调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(10);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void method1(int num)&#123;</span><br><span class="line">    if (num &lt;= 10)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(10);</span><br><span class="line">    method1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void method1(int num)&#123;</span><br><span class="line">    if (num &lt;= 10)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void method1()&#123;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：方法名相同，但是参数不同（个数、类型）、返回值类型不同。</p><p>（为了统一标准，一般来说都用同一种返回值类型，当然也可以不用）</p><p>方法递归调用</p><p>一种特殊的方法嵌套形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(100);</span><br><span class="line">    System.out.println(method1(100));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int method1(int num)&#123;</span><br><span class="line">    if (num==1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num + method1(num-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求阶乘和。（由于计算结果过大，所以使用了double类型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(100);</span><br><span class="line">    System.out.println(method1(100));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static double method1(int num)&#123;</span><br><span class="line">    if (num==1)&#123;</span><br><span class="line">        return method2(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return method2(num) + method1(num-1);</span><br><span class="line">&#125;</span><br><span class="line">public static double method2(int num)&#123;</span><br><span class="line">    if (num==1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num * method2(num-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法（method，有时候也被叫做函数），指的是一段可以被重复调用的代码块，利用方法可以实现程序的拆分&lt;/p&gt;
&lt;p&gt;public static void main(String [] args){}&lt;/p&gt;
&lt;p&gt;公共的 静态的 返回值类型 方法名（参数）{&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>程序逻辑控制</title>
    <link href="http://rczmm.github.io/2021/07/24/%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://rczmm.github.io/2021/07/24/%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6/</id>
    <published>2021-07-24T12:52:53.000Z</published>
    <updated>2021-07-25T14:19:30.730Z</updated>
    
    <content type="html"><![CDATA[<p>程序是一场数据的计算游戏，想要让这些数据处理更加具有逻辑性，那么就需要利用分支结构与循环结构来实现控制。</p><p>程序逻辑</p><p>java中的程序结构有三种：顺序结构、分支（选择）结构、循环结构。</p><p>这三种结构的共同点是，他们都只拥有一个入口，也只有一个出口。单一的入口和出口可以让程序更加的易读，好维护，可以减少调试的时间。</p><p>顺序结构</p><p>程序自上而下<strong>逐行</strong>执行，一条语句执行完之后继续执行下一条语句，一直到程序的末尾。</p><p>这是程序设计中最常的使用到的结构，在程序的世界扮演了举足轻重的角色，因为大部分的程序基本上都是按照这种由上而下的流程来设计的。</p><p>分支结构</p><p>选择结构是根据判断条件的成立与否再决定要执行哪些语句的一种结构。</p><p>这种结构可以依据判断条件的结构来决定要执行的语句，当判断条件的值为真的时候，则执行语句，为假的时候，则执行另外的语句。</p><p>循环结构</p><p>根据判断条件的成立与否，决定程序段落的执行次数</p><p>分支结构</p><p>根据布尔表达式的判断结果来决定是否执行某段代码</p><p>java里的分支结构有两种，if分支结构和switch开关结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;else if (true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;else if(true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;else &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch开关结构。</p><p>switch是一种开关语句，它主要根据内容来进行判断。注意一点，switch只能判断int、枚举、string、char类型的数据。不能使用布尔表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">enum Demolist &#123;</span><br><span class="line">//定义一个枚举类型</span><br><span class="line">    a, b, RED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">    Demolist demolist = Demolist.RED;</span><br><span class="line"></span><br><span class="line">    switch (10 | &#x27;a&#x27; | &quot;i miss mm&quot; | demolist) &#123;</span><br><span class="line">        case 1: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 2: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case RED: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if可以判断布尔表达式、switch只能判断内容。</p><p>switch语句默认的会从第一个满足的case语句开始执行全部的语句代码，直到全部执行完或者遇到了break语句。</p><p>循环结构</p><p>while</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while (true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">    </span><br><span class="line">&#125;while (true)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while需要先判断条件再执行，do先执行再判断</p><p>避免死循环。（循环条件一直满足）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">int sum = 0;</span><br><span class="line">while (num &lt;= 100) &#123;</span><br><span class="line">    sum += num;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result:&quot; + sum);</span><br></pre></td></tr></table></figure><p>for</p><p>while是根据判断条件的结果来实现是否执行，for，在明确知道循环次数的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">for (int num = 1; num &lt;= 100; num++) &#123;</span><br><span class="line">    sum += num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result:&quot; + sum);</span><br></pre></td></tr></table></figure><p>for（循环初始化条件 ; 循环判断 ; 循环变更）{</p><p>}</p><p>循环初始化条件：只执行一次</p><p>循环判断：循环前后各执行一次</p><p>循环变更：循环内语句执行完执行一次</p><p>尽量不要这么去写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line"></span><br><span class="line">int sum = 0;</span><br><span class="line">for (;num &lt;= 100;) &#123;</span><br><span class="line">    sum += num;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result:&quot; + sum);</span><br></pre></td></tr></table></figure><p>while：不确定循环次数的情况下、确定循环结束条件的时候用。</p><p>for：确定循环次数。</p><p>循环控制语句</p><p>continue</p><p>break</p><p>循环结构内，只要条件满足，就会一直执行。</p><p>这程序内，提供了两个停止的控制语句，一个continue（退出本次循环），一个break（退出整个循环）。</p><p>循环嵌套</p><p>循环结构可以在内部嵌入若干个循环结构。这样可以实现更加复杂的循环。（注意，时间复杂度）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int x = 1; x &lt;= 9; x++) &#123;</span><br><span class="line">    for (int y = 1; y &lt;= x; y++) &#123;</span><br><span class="line">        System.out.print(y + &quot;*&quot; + x + &quot;=&quot; + (x * y) + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> int line =10;</span><br><span class="line">        for (int x =0;x&lt;line;x++)&#123;</span><br><span class="line">            for(int y =0;y&lt;line-x;y++)&#123;</span><br><span class="line">//                输出空格</span><br><span class="line">                System.out.print(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int y =0;y&lt;x;y++)&#123;</span><br><span class="line">                System.out.print(&quot;* &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;程序是一场数据的计算游戏，想要让这些数据处理更加具有逻辑性，那么就需要利用分支结构与循环结构来实现控制。&lt;/p&gt;
&lt;p&gt;程序逻辑&lt;/p&gt;
&lt;p&gt;java中的程序结构有三种：顺序结构、分支（选择）结构、循环结构。&lt;/p&gt;
&lt;p&gt;这三种结构的共同点是，他们都只拥有一个入口，也只</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>程序基础概念</title>
    <link href="http://rczmm.github.io/2021/07/24/%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://rczmm.github.io/2021/07/24/%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-07-24T07:50:18.000Z</published>
    <updated>2021-07-26T13:51:38.834Z</updated>
    
    <content type="html"><![CDATA[<p>程序都有其各自的代码结构，所以对于代码的命名就需要通过标识符来完成，但是一个完整的程序的核心意义在于数据的处理、那么掌握数据类型的定义以及运算就是最重要的基础知识。</p><p>1、注释</p><p>在程序中，基本组成都是代码，所以考虑到程序可维护性的特点，在编写代码的时候在每段代码上增加若干说明文字，即注释。注释本身不需要被编译器编译。</p><p>java里一共分为3种形式的注释</p><p>单行注释</p><p>多行注释</p><p>文档注释</p><p>2、标识符与关键字</p><p>程序本质是一个逻辑结果的综合体，在java里有很多不同的结构。</p><p>例如：类、方法、变量结构。</p><p>对于这些不同的结构一定要有不同的说明，这些说明就被称为标识符，所以在进行标识的时候一定要采取有意义的名称。</p><p>java中定义标识符的原则，字母、数字、下划线、$美元符号，不能用数字开头、不能使用保留的关键字。</p><p>1、尽量的不要用数字</p><p>2、命名尽量有意义，不要使用类似x y之类的简单标识符。</p><p>3、标识符区分大小写</p><p>4、$ 美元符号有特殊含义（内部类）</p><p>数据类型</p><p>程序严格来讲都是一个数据处理游戏，所有数据的保存就必须有严格的限制，具体就体现在数据类型的划分上。也就是不同的数据类型的保存不同的的数据内容。</p><p>java数据类型基本可以分为基本数据类型、引用数据类型</p><p>基本数据类型：byte、short、int、long、float、double、char、boolean</p><p>引用数据类型在操作的时候必须进行内存的开辟。基本数据类型不牵扯内存分配的问题。</p><p>考虑到语言的严谨性，java需要对每一个变量进行数据类型的定义，这样才方便开辟内存空间，同时在进行变量定义的时候可以通过赋值表达式对变量设置初始化内容。</p><p>整型</p><p>byte、short、int、long</p><p>默认的数据类型是int。（整型常量）</p><p>数据类型转换</p><p>自动转换：范围小——范围大</p><p>强制转换：大——小（数据溢出）</p><p>浮点型 小数 double</p><p>char</p><p>16进制的unicode</p><p>布尔型</p><p>一种逻辑结果，true和false</p><p>string</p><p>string是java提供一个系统类，这个类比较特殊，不是基本数据类型，但是可以像基本数据类型一样直接定义并且使用。</p><p>转义字符：\ \ \t \n &#39; &quot;</p><p>运算符</p><p>&amp;&amp;      ||</p><p>短路与 短路或</p><p>（逻辑运算符）</p><p>boolean || boolean （短路原则）（有假则假）</p><p>&amp;   | （位运算符）</p><p>逻辑与 逻辑或 （按位与、按位或）</p><p>逻辑是从左到右全部判断、短路得到结果就停止。</p><p>3 5</p><p>0011 </p><p>0101</p><p>3 | 5  0111 7</p><p>3 &amp; 5 0001 1</p><p>负数的补码</p><p>&lt;&lt; &gt;&gt; 按位左移 按位右移</p><p>19 </p><p>二进制：原码：0001 0011</p><p>20</p><p>010100</p><p>按位与 都是1，就是1. </p><p>按位或 有一个1，就是1</p><p>异或 相同就是0，不同就是1</p><p>取反</p><p>-20</p><p>二进制原码：1001 0100</p><p>反码：1110 1011 + 1 = 补码</p><p>补码：1110 1100（将原码求反码，每一位不包含符号位第一位，加一）</p><p>按位取反：0001 0011（正数）</p><p>19</p><p>正数的补码、反码、原码都是一样的。</p><p>20</p><p>原码：0001 0100</p><p>按位取反：1110 1011</p><p>取反码：1001 0100</p><p>取补码：1001 0101</p><p>-21</p><p>取反</p><p>1、求补码</p><p>2、按位取反</p><p>3、求补码(最终结果)</p><p>按位左移、按位右移。(负数补1，正数补0)</p><p>20 &lt;&lt; 2</p><p>0000 0000 0001 0100</p><p>0000 0000 0101 0000</p><p>80</p><p>20 &gt;&gt; 2</p><p>0000 0000 0001 0100</p><p>0000 0000 0000 0101</p><p>5</p><p>无符号右移（全部补0）</p><p>20 &gt;&gt;&gt; 2</p><p>~13</p><p>原码、补码：0000 1101</p><p>按位取反：1111 0010</p><p>取反码：1000 1101</p><p>取补码：1000 1110</p><p>-14</p><p>~-27</p><p>原码：1001 1011</p><p>反码：1110 0100</p><p>补码：1110 0101</p><p>按位取反：0001 1010（正数）</p><p>26</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;程序都有其各自的代码结构，所以对于代码的命名就需要通过标识符来完成，但是一个完整的程序的核心意义在于数据的处理、那么掌握数据类型的定义以及运算就是最重要的基础知识。&lt;/p&gt;
&lt;p&gt;1、注释&lt;/p&gt;
&lt;p&gt;在程序中，基本组成都是代码，所以考虑到程序可维护性的特点，在编写代码的</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>搭建java开发环境</title>
    <link href="http://rczmm.github.io/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://rczmm.github.io/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</id>
    <published>2021-07-23T14:35:53.000Z</published>
    <updated>2021-07-23T15:17:06.335Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言执行需要经过编译器编译，而后才可以在jvm上解释字节码程序，这些操作都需要jdk的支持才可以正常完成。</p><p>jdk java开发工具包，java专属的开发工具，也是最底层的技术支持。</p><p>开发者可以直接通过oracle官网（<a href="https://www.oracle.com/cn/java/">Java 软件 | Oracle 中国</a>）获取jdk工具。</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224057138.png" alt="image-20210723224057138"></p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224120031.png" alt="image-20210723224120031"></p><p>进入java se的下载页面时会展示我们下载的jdk类型。</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224213603.png" alt="image-20210723224213603"></p><p>同时，除了jdk，也提供了jre的下载。</p><p>jre java运行时环境，jdk自带。（分两类，一个是server 一个是client），jre本身不支持开发。</p><p>注意选择自己适合的系统版本。</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224534162.png" alt="image-20210723224534162"></p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723224859826.png" alt="image-20210723224859826"></p><p>x86 32位，x64 64位。注意根据自己的电脑系统合理选择。</p><p>jdk的安装与配置</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225353570.png" alt="image-20210723225353570"></p><p>打开我们下载的一个Windows的程序安装包，双击运行即可安装，并出现以上的界面。点击下一步。</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225450635.png" alt="image-20210723225450635"></p><p>选择安装目录，不要带有中文的目录。</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225543007.png" alt="image-20210723225543007"></p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225554851.png" alt="image-20210723225554851"></p><p>显示成功安装。</p><p>打开目录</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225655107.png" alt="image-20210723225655107"></p><p>打开bin目录。</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225716346.png" alt="image-20210723225716346"></p><p>在这个目录里，有两个核心的命令，java.exe and javac.exe</p><p>这两个命令本身不属于Windows本身，如果要在命令行（cmd）里直接使用，那么就必须在Windows系统中进行可执行程序的路径配置，也就是环境变量。</p><p>计算机——属性——高级系统设置</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225913817.png" alt="image-20210723225913817"></p><p>高级——环境变量——系统变量——path</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723225943116.png" alt="image-20210723225943116"></p><p>添加jdk下bin的目录</p><p>E:\Program Files\java-13\bin</p><p>打开cmd窗口。</p><p>输入 java -version</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723230140245.png" alt="image-20210723230140245"></p><p>出现以上内容，表示安装成功。</p><p>Windows命令行</p><p>可以直接在搜索cmd，dos，命令提示符等，</p><p>也可以win +R 打开运行</p><p><img src="/2021/07/23/%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20210723230310972.png" alt="image-20210723230310972"></p><p>搜索cmd。</p><p>如果配置了环境变量，必须重新启动命令行才能加载到最新的环境变量配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java语言执行需要经过编译器编译，而后才可以在jvm上解释字节码程序，这些操作都需要jdk的支持才可以正常完成。&lt;/p&gt;
&lt;p&gt;jdk java开发工具包，java专属的开发工具，也是最底层的技术支持。&lt;/p&gt;
&lt;p&gt;开发者可以直接通过oracle官网（&lt;a href=&quot;</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
    <category term="jdk" scheme="http://rczmm.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>java语言特点</title>
    <link href="http://rczmm.github.io/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/"/>
    <id>http://rczmm.github.io/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/</id>
    <published>2021-07-23T13:53:16.000Z</published>
    <updated>2021-07-23T14:31:55.446Z</updated>
    
    <content type="html"><![CDATA[<p>java语言特点</p><p>java之所以能广泛的活跃在互联网和电子设备上，主要是因为其开发语言简洁并且有完善的生态系统，是一门优秀编程语言。</p><p><img src="/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/u=656404101,826481724&fm=26&fmt=auto&gp=0.jpg" alt="img"></p><p>java不仅拥有完善的编程体系，同时也收到众多软件厂商的追捧——围绕其开发出来了大量的第三方应用，使得java的技术得以迅速的发展壮大，并且被广泛的应用，在长期的技术发展中，java语言的特性也在不断的提升。</p><p>1、简洁有效</p><p>克服了c++中所有的难以理解和容易混淆的特点，比如：头文件、指针、结构、单元、运算符重载和虚拟基础类，java更加的严谨、简洁、因此也足够简单。</p><p>2、可移植性</p><p>一次编写、处处运行。因为java的执行是基于jvm，在源代码编译后形成字节码文件，在不同的os上只需要植入与系统匹配的jvm就可以直接利用jvm的指令集解释程序运行，降低了开发难度，提高了开发效率。</p><p>3、面向对象</p><p>java是面向对象的语言，并且有着良好的程序结构定义，</p><p>4、垃圾回收</p><p><img src="/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/u=3964968350,1272502470&fm=26&fmt=auto&gp=0.jpg" alt="img"></p><p>gc，无用的内存回收，java提供了垃圾回收机制。</p><p>5、引用传递</p><p>指针的代替品，更加简单。（指针虽然高效，但是需要较强的逻辑分析能力）</p><p>6、分布式</p><p>java适合网络编程，适合分布式程序开发，socket（套接字），还包括公共网关接口，cgi等，还有包括nio、aio等。</p><p>7、健壮性</p><p>编译时，有语法检查，异常可以避免错误产生时程序中断运行。</p><p>8、多线程</p><p>线程是轻量级的进程、juc多线程开发框架。</p><p>9、安全性</p><p>jvm安全，jdk更新，jvm也能更新。</p><p>10、函数式编程</p><p>lambda表达式编程</p><p>11、模块化支持</p><p>拉锯（代码名字）、jdk9之后的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java语言特点&lt;/p&gt;
&lt;p&gt;java之所以能广泛的活跃在互联网和电子设备上，主要是因为其开发语言简洁并且有完善的生态系统，是一门优秀编程语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/23/java%E8%AF%AD%E8%A8%80%E7%89%B9%E7</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java发展历史</title>
    <link href="http://rczmm.github.io/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/"/>
    <id>http://rczmm.github.io/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</id>
    <published>2021-07-23T13:35:45.000Z</published>
    <updated>2021-07-23T13:50:48.576Z</updated>
    
    <content type="html"><![CDATA[<p>java发展历史</p><p><img src="/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/u=593216026,135847718&fm=26&fmt=auto&gp=0.jpg" alt="img"></p><p>java语言诞生于20世纪90年代，经过长期的发展，已经成为最流行的编程语言之一，java不但广泛应用在服务端编程上，而且各个移动设备也大量使用java平台。</p><p>java是sun公司开发出来的一套编程语言，来源于一个green的嵌入式程序项目，目的是为了电子消费产品开发一个分布式代码系统，这样子就可以通过网络对家用电器进行控制。</p><p>在green项目最开始，工程师本来是打算c++进行开发，但是考虑到c++语言开发的复杂性，于是就基于c++设计了自己的一套的独立平台oak，这个就被称为是java的前身，是一种用于网络的安全语言，刚好碰到了当时的一个mosaic和netscape项目，这两个项目启发了oak的工程师，于是他们设计了一个hotjava浏览器，触发了java进军互联网，但是由于后来互联网低潮，sun公司被oracle收购。</p><p>java是一门综合性的编程语言，从最初设计的时候就考虑了嵌入式系统开发以及企业平台的支持。</p><p><img src="/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/u=2578611845,4184638346&fm=26&fmt=auto&gp=0.jpg" alt="img"></p><p>实际java开发过程之中，主要有三种方向。</p><p>java se （java标准开发，包含的主要是语言核心类，（jdbc、接口定义、输入输出、网络io）当用户安装jdk之后，就自动支持java se开发）</p><p>java ee（包含了java se部分的类，用于是电子产品的软件开发，但是此类开发已经几乎被安卓替代）</p><p>java me（包含se所有类，并且还包含了开发企业级的应用类。（xml、事务控制、jsp、servlet）、也是目前大型系统和互联网项目开发的主要平台）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java发展历史&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/23/java%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/u=593216026,135847718&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&quot; alt=&quot;img&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>笔趣阁爬虫—scrapy小实例</title>
    <link href="http://rczmm.github.io/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/"/>
    <id>http://rczmm.github.io/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/</id>
    <published>2021-07-21T14:48:42.000Z</published>
    <updated>2021-07-21T15:15:56.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="笔趣阁爬虫—scrapy小实例"><a href="#笔趣阁爬虫—scrapy小实例" class="headerlink" title="笔趣阁爬虫—scrapy小实例"></a>笔趣阁爬虫—scrapy小实例</h1><h2 id="项目环境："><a href="#项目环境：" class="headerlink" title="项目环境："></a>项目环境：</h2><h3 id="基础环境："><a href="#基础环境：" class="headerlink" title="基础环境："></a>基础环境：</h3><p>Windows10主机</p><p>Python 3.9（版本不一，可能写法不同）</p><p>Pycharm 2021.1.3</p><h3 id="外部库："><a href="#外部库：" class="headerlink" title="外部库："></a>外部库：</h3><p>scrapy（注意scrapy基于c语言的异步组件twisted，自行下载）</p><p>Pymysql，连接数据库。</p><h2 id="下载与安装（略）、"><a href="#下载与安装（略）、" class="headerlink" title="下载与安装（略）、"></a>下载与安装（略）、</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>与传统意义的爬虫一样，scrapy也是通过对目标url发起请求来获取响应信息，而后解析这些信息，来得到我们想要的数据，</p><p>但是与传统爬虫不一样的，scrapy使用了c语言编写的异步组件来实现异步请求，从而大大的提高了爬虫的效率，众所周知，python是没有真正的多线程的，因此纯python开发的爬虫在scrapy面前不堪一击。</p><p>异步往往意味着一些不好的事情发生，例如爬取小说网站中最为关注的顺序问题。</p><p>​    同时，scrapy作为一个框架，我们不需要编写全部的代码，同时我们也不能那么去做，就如同一个工厂，我们只需要在里面添加内容就可以了。</p><p>新笔趣阁，这是我们要爬取的目标网站，</p><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image002.png" alt="img"></p><p>与传统小说网站一样，我们需要首先对主页中的全部小说页面发起请求，之后在拿到每一本小说对应的url。</p><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image003.png" alt="img"></p><p>在拿到这样的数据之后，我们继续对这个url进行请求。</p><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image005.png" alt="img"></p><p>发起请求，网站给我们返回了一个章节列表，同样我们需要解析出url地址并且逐个访问。</p><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image007.png" alt="img"></p><p>来到正文页面解析，这里就是我们想要的数据了。</p><h2 id="编写items，确定字段"><a href="#编写items，确定字段" class="headerlink" title="编写items，确定字段"></a>编写items，确定字段</h2><p>这是scrapy中的关键文件之一，首先你要确定自己想要获取的信息，在本例中，设置了三个变量，在分别对应，小说名，章节名以及章节内容。</p><p>当然你也可以选择扩充，不过在这里要提醒你的是，无论我们如何去写，最终的结果都是，数以百万甚至更多的url摆在哪里，我们需要对每个url发送一次请求，要想保证效率，又想要数据的准确性，说实话，items里的数据，全部在最底层的网页中比较好。</p><p>观察如上的网页，我们确定好三个字段。</p><p>Items文件内容如下：</p><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image009.png" alt="img"></p><h2 id="Setting文件，设置编码以及是否遵循robot协议"><a href="#Setting文件，设置编码以及是否遵循robot协议" class="headerlink" title="Setting文件，设置编码以及是否遵循robot协议"></a>Setting文件，设置编码以及是否遵循robot协议</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image011.png" alt="img"></p><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image013.png" alt="img"></p><h2 id="编写管道文件，连接数据库"><a href="#编写管道文件，连接数据库" class="headerlink" title="编写管道文件，连接数据库"></a>编写管道文件，连接数据库</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image015.png" alt="img"></p><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image017.png" alt="img"></p><p>值得一提的是，在管道文件中，写入了异常处理语句，以及插入数据的时候添加的双引号，具体是针对于，某些章节特殊符号的出现，出现写入异常，从而终止了爬虫，添加双引号是为了贴合mysql的规范，避免1064错误。</p><h2 id="真正的爬虫，demo"><a href="#真正的爬虫，demo" class="headerlink" title="真正的爬虫，demo"></a>真正的爬虫，demo</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image019.png" alt="img"></p><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image021.png" alt="img"></p><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image023.png" alt="img"></p><p>这是真正的爬虫主体，我们需要先设置域名，然后确定第一个url，值得一提，我使用了yield这个生成器来逐个发起请求，但是这并不意味着一定的一致性，因为twisted的关系，同样可能会出现数据不一致的情况，所以尽量保证所有数据在最底层的url里。通过逐步解析url，最终得到数据，提交给管道储存。</p><h2 id="Start，编写启动脚本"><a href="#Start，编写启动脚本" class="headerlink" title="Start，编写启动脚本"></a>Start，编写启动脚本</h2><p><img src="/2021/07/21/%E7%AC%94%E8%B6%A3%E9%98%81%E7%88%AC%E8%99%AB%E2%80%94scrapy%E5%B0%8F%E5%AE%9E%E4%BE%8B/clip_image024.png" alt="img"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="item的数据只有最后一条"><a href="#item的数据只有最后一条" class="headerlink" title="item的数据只有最后一条"></a>item的数据只有最后一条</h3><p>出现这种情况一般存在是在需要进行遍历的时候，将item对象放在了for循环的外面，解决方法：直接放进去就可以了。</p><h3 id="item字段传递后混乱、错误"><a href="#item字段传递后混乱、错误" class="headerlink" title="item字段传递后混乱、错误"></a>item字段传递后混乱、错误</h3><p>有时候遇到这种情况，item传递几次之后，发现不同页面的数据被混乱的组合在了一起，这种情况一般出在item的传递过程中，解决方式可以像我那样，将所有要存放的数据全部放在最后一层里，但是这并不友好，因此，建议是使用深拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">def parse_base(self,response):</span><br><span class="line"></span><br><span class="line">  base_url = &#x27;https://www.base_url.com&#x27;</span><br><span class="line"></span><br><span class="line">  for result in result_list:</span><br><span class="line"></span><br><span class="line">​    item = ExampleItem()</span><br><span class="line"></span><br><span class="line">​    item[&#x27;name&#x27;] = result.css(&#x27;div a::text&#x27;).extract_first()</span><br><span class="line"></span><br><span class="line">​    item[&#x27;age&#x27;] = result.css(&#x27;div #id&#x27;).extract_first()</span><br><span class="line"></span><br><span class="line">​    yield scrapy.Request(url=base_url,meta=copy.deepcopy(&#123;&#x27;item&#x27;:item&#125;),callback=self.parse_detail) # 使用深拷贝将item存在meta中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">def parse_detail(self,response):</span><br><span class="line"></span><br><span class="line">  item = response.meta[&#x27;item&#x27;] # 取出之前传递的item</span><br><span class="line"></span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  do some thing</span><br><span class="line"></span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">  yield item</span><br></pre></td></tr></table></figure><h3 id="对一个页面要进行多种的解析"><a href="#对一个页面要进行多种的解析" class="headerlink" title="对一个页面要进行多种的解析"></a>对一个页面要进行多种的解析</h3><p>出现这种情况的原因是，scrapy默认的对同一个url，相同的body以及相同的请求视为一个请求，但是如果我们想要对同一页面有不同的请求时，就会发现默认情况下只能得到第一个parse的结果。解决方式：设置参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def start_requests(self):</span><br><span class="line"></span><br><span class="line">  base_url = &#x27;https://www.base_url.com&#x27;</span><br><span class="line"></span><br><span class="line">  yield scrapy.Request(url=base_url,dont_filter=&#x27;True&#x27;,callback=self.parse_one)</span><br><span class="line"></span><br><span class="line">  yield scrapy.Request(url=base_url,dont_filter=&#x27;True&#x27;,callback=self.parse_two)</span><br></pre></td></tr></table></figure><h3 id="Xpath中contains的使用"><a href="#Xpath中contains的使用" class="headerlink" title="Xpath中contains的使用"></a>Xpath中contains的使用</h3><p>这种情况出现在标签没有特定属性值但是文本中又包含了特定的汉字的时候，当然也可以包含特定的属性值来使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def parse(self,response):</span><br><span class="line"></span><br><span class="line">  item = BookItem()</span><br><span class="line"></span><br><span class="line">  item[&#x27;author&#x27;] = response.xpath(&#x27;//span[contains(.//text(),&quot;作者：&quot;)]//text()&#x27;).split(&#x27;作者：&#x27;)[-1] # 先用contains限定好特定的span标签，然后取出文本字符串并进行字符串切片得到需要的信息。下同</span><br><span class="line"></span><br><span class="line">  item[&#x27;book_name&#x27;] = response.xpath(&#x27;//span[contains(.//text(),&quot;书名：&quot;)]//text()&#x27;).split(&#x27;书名：&#x27;)[-1]</span><br><span class="line"></span><br><span class="line">  yield item</span><br><span class="line"></span><br><span class="line">### 提取不在</span><br></pre></td></tr></table></figure><h3 id="标签的文本内容"><a href="#标签的文本内容" class="headerlink" title="标签的文本内容"></a>标签的文本内容</h3><p>这种情况也会出现，加入文本在两个标签中间，但是不属于任何一个，此时可以用xpath或者正则来解决这个问题。</p><h3 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h3><p>当页面数据需要登陆进行抓取时，就需要模拟登陆了。常见的方式有：使用登陆后的cookie来抓取数据；发送表单数据进行登陆；使用自动化测试工具登陆，比如selenium配合chrome、firefox等，不过听说selenium不再更新，也可以使用chrome的无头模式。鉴于自动化测试的抓取效率比较低，而且我确实很久没使用过这个了。本次只讨论使用cookie和发送表单两种方式来模拟登陆。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;笔趣阁爬虫—scrapy小实例&quot;&gt;&lt;a href=&quot;#笔趣阁爬虫—scrapy小实例&quot; class=&quot;headerlink&quot; title=&quot;笔趣阁爬虫—scrapy小实例&quot;&gt;&lt;/a&gt;笔趣阁爬虫—scrapy小实例&lt;/h1&gt;&lt;h2 id=&quot;项目环境：&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>scrapy框架初步解析</title>
    <link href="http://rczmm.github.io/2021/07/21/scrapy%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://rczmm.github.io/2021/07/21/scrapy%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5%E8%A7%A3%E6%9E%90/</id>
    <published>2021-07-21T14:29:50.000Z</published>
    <updated>2021-07-21T14:52:34.665Z</updated>
    
    <content type="html"><![CDATA[<p>scrapy框架是一个常用的爬虫框架，其中内嵌了许多的内容，使得爬取网页的过程不再像原生那样复杂。</p><p>Scrapy的架构</p><p><img src="/2021/07/21/scrapy%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A5%E8%A7%A3%E6%9E%90/clip_image001.png" alt="架构图"></p><p>引擎：负责控制数据流在所有组件流动，并在相应动作是触发事件。可以理解为爬虫的大脑</p><p>调度器：从引擎接受请求（requests）并将它们加入爬虫队列，可以理解把等待爬取的网页排队的功能</p><p>下载器：负责获取页面并提供给引擎，相当于之前学的“获取网页”数据</p><p>爬虫器：负责解析网页（response），提取数据，或额外跟进一些url，相当于之前的解析网页的功能。</p><p>管道：负责处理被爬虫提取的数据（items），例如保存下来，相当于之前的“储存数据”功能</p><p>下载器中间件：引擎的下载器中间的一个部分，处理下载器传递给引擎的数据（response），一般不做处理</p><p>爬虫器中间件：引擎和爬虫器中间的一部分，处理爬虫器的输入（response）和输出（items，requests）</p><p>作为一个框架，上面列出来的各种组件还是很复杂的，一不小心就处于一个懵逼的状态了。</p><table><thead><tr><th>组件</th><th>对应爬虫三大流程</th><th>Scrapy项目是否需要修改</th></tr></thead><tbody><tr><td>引擎</td><td></td><td>无需修改</td></tr><tr><td>调度器</td><td></td><td>无需修改</td></tr><tr><td>下载器</td><td>获取网页（requests库）</td><td>无需修改</td></tr><tr><td>爬虫器</td><td>解析网页（beautifulsoup库）</td><td>需要</td></tr><tr><td>管道</td><td>储存数据</td><td>需要</td></tr><tr><td>下载器中间件</td><td>获取网页（个性化部分）</td><td>一般不用</td></tr><tr><td>爬虫器中间件</td><td>解析网页（个性化部分）</td><td>一般不用</td></tr></tbody></table><p>可以看出来，使用scrapy框架之后，我们要写的内容就变得少了很多，一般来说，只需要负责好爬虫器和管道就可以了。</p><p>?</p><p>到底数据是怎么在scrapy中流动的呐？</p><p>（1）   引擎：向爬虫器发送第一个要抓取的url</p><p>（2）   爬虫器：提供www…….给引擎</p><p>（3）   引擎：接收到网址，交给调度器排序入队</p><p>（4）   调度器：将它处理成请求（requests）给引擎</p><p>（5）   引擎：接收到request，并通过下载器中间件给下载器下载</p><p>（6）   下载器：根据request下载页面，返回回应（response）给引擎</p><p>（7）   引擎：接收到response，并通过爬虫器中间件给爬虫器处理</p><p>（8）   爬虫器：处理response，提取内容，返回item给引擎，如果有跟进的request也会提交给引擎</p><p>（9）   引擎：接收到item，交给管道，新的request交给调度器</p><p>（10） 管道：储存数据</p><p>从这里就可以很明显的看出来scrapy框架的优缺点。</p><p>写爬虫的人，就像古代练剑一样，从开始用的木剑，到绝世好剑，最后到一草一木，爬虫也是这样，从最开始的不用框架，到使用框架，最后再到不用框架。</p><p>最开始使用request和bs4的时候很方便，但是接触了scrapy之后，你就会发现，原来真正的只需要几行代码就可以实现一个爬虫，这时候你会觉得scrapy很好用，但是随着需求越来越奇怪，也就是说你需要特地的去定制化一些功能的时候，scrapy作为一种条条框框的框架已经是不能满足这些需求了，所以还是会回到原始的request和bs4上。</p><p>Scrapy的优势就是并发性比较强，在做大批量的数据爬虫的时候简单易用，此外，做一些长期的爬虫项目维护管理也比较容易。</p><p>相比之下，不使用框架的话，爬虫的定制化就比较高，身经百战的高手总是可以杀人无形之中，爬虫之中最关键的就是反爬虫，scrapy毕竟作为一个框架，写的太死了，固然他也有中间件可以用来使用，但是比起不用框架的各种扩展功能，scrapy功能还是不够强大。</p><p>scrapy的安装</p><p>在Windows下的scrapy安装非常简单，只需要pip install scrapy就可以。但是一般来说都不会这么简单。</p><p>Scrapy框架是一个Python爬虫的框架没错，但是他确是要基于Twisted的，所以我们可以直接选择先安装Twisted组件，再安装Scrapy框架程序可以成功安装。</p><p>组件下载完成后文件名为“Twisted-20.3.0-cp38-cp38-win_amd64.whl”。我们打开cmd命令，在dos窗口中直接输入“pip install D:\软件安装包\Twisted-20.3.0-cp38-cp38-win_amd64.whl”其中“D:\软件安装包\Twisted-20.3.0-cp38-cp38-win_amd64.whl”为Twisted安装文件在电脑上的存放路径</p><p>使用pip安装Scrapy框架程序。</p><p>在cmd命令的DOS窗口中输入“pip install scrapy”进行安装。</p><p>制作爬虫</p><p>制作Scrapy爬虫大致需要4步：<br> 新建项目（scrapy startproject xxx）:新建一个新的爬虫项目。<br> 明确目标（编写items.py）:明确你想要抓取的目标。<br> 制作爬虫（spiders/xxspider.py）:制作爬虫开始爬取网页。<br> 存储内容（pipelines.py）:设计管道存储爬取内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;scrapy框架是一个常用的爬虫框架，其中内嵌了许多的内容，使得爬取网页的过程不再像原生那样复杂。&lt;/p&gt;
&lt;p&gt;Scrapy的架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/21/scrapy%E6%A1%86%E6%9E%B6%E5%88%9D%E6%AD%A</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>迭代器、生成器与装饰器</title>
    <link href="http://rczmm.github.io/2021/07/21/%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://rczmm.github.io/2021/07/21/%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2021-07-21T14:18:16.000Z</published>
    <updated>2021-07-21T14:25:34.159Z</updated>
    
    <content type="html"><![CDATA[<p>迭代器、生成器与装饰器</p><p>迭代器</p><p>迭代几乎是python最强的功能之一，是访问集合元素的一种方式</p><p>for i in rang(1,101)</p><p>迭代器是一个可以记住遍历的位置的<strong>对象</strong></p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完，结束</p><p>迭代器<strong>只能前进，不能后退</strong>。</p><p>迭代器基本方法：iter（）和next（）</p><p>迭代器用在哪儿？（字符串、列表、元组等对象都可以创建迭代器）（序列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list=[1,2,3,4,5]</span><br><span class="line">it=iter(list)</span><br></pre></td></tr></table></figure><p>for语句遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list=[1,2,3,4,5]</span><br><span class="line">it =iter(list)</span><br><span class="line">for i in it:</span><br><span class="line">print(i,end=&#x27; &#x27;)</span><br></pre></td></tr></table></figure><p>next()函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">list=[1,2,3,4,5]</span><br><span class="line">it =iter(list)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">try:</span><br><span class="line">print(next(it))</span><br><span class="line">except StopIteration:</span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><p>创建一个迭代器</p><p>类有一个构造函数，python中，他会在对象初始化的时候执行</p><p>迭代器类里，iter()方法返回一个特殊的迭代器对象，这个迭代器对象实现了next（）并且通过StopIteration</p><p>异常的标识来判断迭代是否完成</p><p>next（）方法返回下一个迭代器的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        self.a=1</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        x = self.a</span><br><span class="line">        self.a+=1</span><br><span class="line">        return x</span><br><span class="line">myclass=MyNumbers()</span><br><span class="line">myiter=iter(myclass)</span><br><span class="line"></span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure><p>以上的代码把一个类当做了迭代器，我们不难发现，需要至少实现两个方法，iter和next。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        self.a=1</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.a &lt;= 3:</span><br><span class="line">            x = self.a</span><br><span class="line">            self.a+=1</span><br><span class="line">            return x</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration</span><br><span class="line">myclass=MyNumbers()</span><br><span class="line">myiter=iter(myclass)</span><br><span class="line"></span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure><p>以上代码，使用了stopiteration异常来限制了循环的次数（迭代的次数）</p><p>所有的技术都要根据使用场景来。</p><span id="more"></span><p>生成器</p><p>python中，使用了yield的函数被成为生成器</p><p>跟普通函数不同，生成器是一个返回迭代器的函数，只能用于迭代操作，简单理解，生成器就是一个迭代器</p><p>在调用生成器，运行的过程中，遇到yield函数会暂停并且保存当前所有的运行信息，返回yield的值</p><p>在下一次执行next方法时继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象</p><p>yield来实现斐波那契数列(从第三项开始，每一项等于前面两项之和的数列)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def fibonaqi(n):# 生成器函数</span><br><span class="line">    a,b,counter=0,1,0</span><br><span class="line">    while True:</span><br><span class="line">        if (counter &gt; n):</span><br><span class="line">            return</span><br><span class="line">        yield a</span><br><span class="line">        a,b=b,a+b</span><br><span class="line">        counter+=1</span><br><span class="line">f=fibonaqi(10) # f是一个迭代器，由生成器返回生成</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print(next(f),end=&#x27; &#x27;)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><p>装饰器</p><p>装饰器之前，先来理解一个概念（闭包）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def a():</span><br><span class="line">    s=&#x27;i am liupeng!&#x27;</span><br><span class="line"></span><br><span class="line">    # p是一个嵌套函数</span><br><span class="line">    def p():</span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line">    return p</span><br><span class="line"># 把a函数赋值给变量myclass的时候，这个就获得了一个闭包</span><br><span class="line"># s是一个局部变量，在a函数结束之后就不会存在了。</span><br><span class="line"># 但是现在我们使用了一个嵌套函数，把这个局部变量封闭在了嵌套函数中</span><br><span class="line"># 这样子就形成了一个闭包</span><br><span class="line">myclass=a()</span><br><span class="line">myclass()</span><br><span class="line"># 闭包其实就是一个引用了自有变量的函数</span><br><span class="line"># 函数保存了执行的上下文，可以脱离原本的作用域而存在。</span><br></pre></td></tr></table></figure><p>装饰器是python一个重要部分，他是一个函数（修改其他函数功能的函数）有助于让代码更短</p><p>父类与子类。</p><p>一切皆可对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def a(name=&#x27;liupeng&#x27;):</span><br><span class="line">    return &quot;hello  &quot; + name</span><br><span class="line"># print(a())</span><br><span class="line">b=a</span><br><span class="line"># 为什么我不用小括号呐？因为我并不是在调用函数，而是把这个函数放在变量里面</span><br><span class="line"># print(b())</span><br><span class="line">del a</span><br><span class="line"># print(a())</span><br><span class="line">print(b())</span><br></pre></td></tr></table></figure><p>函数的嵌套</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def a(name=&#x27;liupeng&#x27;):</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">    def b():</span><br><span class="line">        return &#x27;2&#x27;</span><br><span class="line">    def c():</span><br><span class="line">        return &quot;3&quot;</span><br><span class="line"></span><br><span class="line">    print(b())</span><br><span class="line">    print(c())</span><br><span class="line">    print(&quot;4&quot;)</span><br><span class="line"></span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>函数中返回函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def a(name=&#x27;liupeng&#x27;):</span><br><span class="line">    def b():</span><br><span class="line">        return 1</span><br><span class="line">    def c():</span><br><span class="line">        return 2</span><br><span class="line">    if True:</span><br><span class="line">        return b</span><br><span class="line">    else:</span><br><span class="line">        return c</span><br><span class="line">x=a()</span><br><span class="line">print(x)</span><br><span class="line">print(x())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># x=a() a函数会被执行，而由于判断条件时true，那么b会被返回，如果是flase，那么c会被返回</span><br><span class="line"># 我们还可以打印出a（）（）</span><br></pre></td></tr></table></figure><p>把函数作为参数传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def a():</span><br><span class="line">return 1</span><br><span class="line">def b(func):</span><br><span class="line">print(2)</span><br><span class="line">print(func())</span><br><span class="line">b(a)</span><br></pre></td></tr></table></figure><p>装饰器（最简单的装饰器）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def a(a_func):</span><br><span class="line">    def b():</span><br><span class="line">        print(1)</span><br><span class="line"></span><br><span class="line">        a_func()  # c（）</span><br><span class="line"></span><br><span class="line">        print(2)</span><br><span class="line">    return b</span><br><span class="line">def c():</span><br><span class="line">    print(3)</span><br><span class="line"># c()</span><br><span class="line">c=a(c)</span><br><span class="line">c()</span><br></pre></td></tr></table></figure><p>装饰器：封装一个函数，并且用不同的方式去修改它的行为，@是一个简短的方式来生成一个被装饰的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@a</span><br><span class="line">def c():</span><br><span class="line">print(3)</span><br><span class="line">c()</span><br><span class="line">c=a(c)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line">def a_name(f):</span><br><span class="line">    @wraps(f)</span><br><span class="line">    def b(*args,**kwargs):</span><br><span class="line">        if not can_run:</span><br><span class="line">            return &quot;函数不会运行&quot;</span><br><span class="line">        return f(*args,**kwargs)</span><br><span class="line">    return b</span><br><span class="line"></span><br><span class="line">@a_name</span><br><span class="line">def func():</span><br><span class="line">    return &quot;函数正在运行&quot;</span><br><span class="line"></span><br><span class="line"># can_run=True</span><br><span class="line"># print(func())</span><br><span class="line"></span><br><span class="line">can_run=False</span><br><span class="line">print(func())</span><br></pre></td></tr></table></figure><p>以上就是装饰器的一个简单的应用场景，@wraps 接受一个函数进行装饰，并且加入了函数的一些功能，函数名称、参数列表、注释文档等等，这可以让我们在装饰器里访问装饰之前的函数的属性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;迭代器、生成器与装饰器&lt;/p&gt;
&lt;p&gt;迭代器&lt;/p&gt;
&lt;p&gt;迭代几乎是python最强的功能之一，是访问集合元素的一种方式&lt;/p&gt;
&lt;p&gt;for i in rang(1,101)&lt;/p&gt;
&lt;p&gt;迭代器是一个可以记住遍历的位置的&lt;strong&gt;对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完，结束&lt;/p&gt;
&lt;p&gt;迭代器&lt;strong&gt;只能前进，不能后退&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;迭代器基本方法：iter（）和next（）&lt;/p&gt;
&lt;p&gt;迭代器用在哪儿？（字符串、列表、元组等对象都可以创建迭代器）（序列）&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;list=[1,2,3,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it=iter(list)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;for语句遍历：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;list=[1,2,3,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it =iter(list)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for i in it:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	print(i,end=&amp;#x27; &amp;#x27;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;next()函数&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list=[1,2,3,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it =iter(list)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while True:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		print(next(it))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	except StopIteration:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		sys.exit()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;创建一个迭代器&lt;/p&gt;
&lt;p&gt;类有一个构造函数，python中，他会在对象初始化的时候执行&lt;/p&gt;
&lt;p&gt;迭代器类里，iter()方法返回一个特殊的迭代器对象，这个迭代器对象实现了next（）并且通过StopIteration&lt;/p&gt;
&lt;p&gt;异常的标识来判断迭代是否完成&lt;/p&gt;
&lt;p&gt;next（）方法返回下一个迭代器的对象&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class MyNumbers:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __iter__(self):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.a=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __next__(self):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x = self.a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.a+=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myclass=MyNumbers()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myiter=iter(myclass)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以上的代码把一个类当做了迭代器，我们不难发现，需要至少实现两个方法，iter和next。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class MyNumbers:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __iter__(self):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.a=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __next__(self):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if self.a &amp;lt;= 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            x = self.a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.a+=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            raise StopIteration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myclass=MyNumbers()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myiter=iter(myclass)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(next(myiter))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以上代码，使用了stopiteration异常来限制了循环的次数（迭代的次数）&lt;/p&gt;
&lt;p&gt;所有的技术都要根据使用场景来。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>真正的看python（1）</title>
    <link href="http://rczmm.github.io/2021/07/20/%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%9C%8Bpython%EF%BC%881%EF%BC%89/"/>
    <id>http://rczmm.github.io/2021/07/20/%E7%9C%9F%E6%AD%A3%E7%9A%84%E7%9C%8Bpython%EF%BC%881%EF%BC%89/</id>
    <published>2021-07-20T15:23:54.000Z</published>
    <updated>2021-07-20T19:38:16.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="真正的看python（1）"><a href="#真正的看python（1）" class="headerlink" title="真正的看python（1）"></a>真正的看python（1）</h1><h2 id="1、python是一门解释性语言嘛？"><a href="#1、python是一门解释性语言嘛？" class="headerlink" title="1、python是一门解释性语言嘛？"></a>1、python是一门解释性语言嘛？</h2><p>是但不完全是，python其实是一门基于虚拟机的语言，首先他有三门主要的解释器，他利用这个解释器，来解释并且执行自己定义的语法来生成代码执行。解释性语言并不需要编译。</p><p>再说的清楚一点、计算机并不能直接理解我们的语言，他只能理解机器语言，也就是0和1，因此，我们需要进行翻译。</p><p>而翻译，有两种，一种就是解释、一种就是编译。</p><p>编译型语言、在我们的程序执行之前，会通过编译器编译为机器语言</p><p>，那么在运行的时候，就不需要翻译，直接执行就可以了，最典型的例子就是c。</p><p>解释型语言、没有提前编译的过程，在程序运行的时候，通过解释器对程序逐行做出解释，然后执行。</p><p>可以发现，从效率上来说，势必的，编译型语言的效率绝对是要比解释型语言要强的，但是现在的热门语言其实已经脱离了单纯的编译和解释的差别。</p><p>例如，java，java先通过编译器编译成字节码文件，然后运行时通过解释器解释成机器文件，可以说java是先编译再解释的语言。</p><p>python，其实和java一样，都是基于虚拟机的，同样也是先编译再解释的语言。</p><p>py文件，pyc文件，pycodeobject文件。</p><p>py文件不用说，就是我们写的，pyc我们也能在硬盘上看到。</p><p>pycodeobject其实是python编译器真正编译成的结果，只不过当程序运行时，这个文件被保存在内存中，运行完了后，解释器会把这个文件写到pyc文件中，当程序第二次运行时，首先会寻找pyc文件，然后对py和pyc的时间戳判断，是否修改过，没有的话，就直接载入pyc。</p><p>那么就很清晰了，pyc其实就是pyo的持久化存储方式。</p><h2 id="2、python的面向对象"><a href="#2、python的面向对象" class="headerlink" title="2、python的面向对象"></a>2、python的面向对象</h2><p>首先，要明白，面向对象是一种编程方式、基于的是类和对象的使用。</p><p>类是一个模板，封装了多个函数和变量。对象就是根据模板创建的实例。</p><p>面向对象有三大特性，封装、继承、多态。</p><p>来看看类。</p><span id="more"></span><p>类有成员，即字段、方法和属性。</p><p>java中static修饰了静态的变量和方法。而静态变量被储存在方法区里，实际上，static修饰的变量已经成为了类的成员。（没学过java的可以略过这一段）</p><p>在python里，字段分为两种类型，一种是在函数外定义的普通字段，这一类字段，只需要声明变量名和初始值就可以，同时这一类的字段属于类的成员，在实例化为对象的时候，是保存在内存中的、访问也是类型变量名的形式去访问，而另外一种，则是写在init初始化函数的变量，这一类的我们称之为静态字段，静态字段不同的是，这是保存在对象中的内容。</p><p>简明一点来说，普通字段定义在函数体外，同时属于对象。静态字段定义在init初始化函数体内，属于类。</p><p>那么在访问方式上的差别也就比较明显了，普通字段是通过对象访问的，静态字段则是由类去访问的。</p><p>再推导开去，静态字段在类中，那么在内存中，只保存一份，但是普通字段属于对象，那么就意味着每初始化一次对象、就会保存一份普通字段。</p><p>那么回到场景之中，如果说每个对象都有相同的字段时，那么就可以静态字段了。</p><p>方法，不存在属于类或者对象的差异，因为无论是类方法还是静态方法还是普通的方法，这三种方法在内存中都归属于类，区别仅仅是调用方式的差异罢了。</p><p>普通方法：由对象来调用，至少要有一个self参数，执行普通方法时，自动将调用方法的对象赋值个self。</p><p>类方法：由类来调用，至少一个cls参数，执行类方法是，自动将调用该方法的类赋值给cls。</p><p>静态方法：由类来调用，没有默认的参数</p><p>其实对于方法而言，都属于类，在内存当中只保存一份，只是在调用的时候，调用者不同，那么自动传入的参数也不同罢了。</p><p>属性，属性其实严格意义上说是一种特殊的普通方法。</p><p>定义时，使用装饰器定义，只有一个self参数，调用的时候，不用括号。</p><p>属性存在的意义是，访问属性时可以制造出和访问字段完全相同的假象，它由方法变种而来，如果没有属性，那么方法可以完全代替他。</p><p>那么属性的功能其实就很清楚了，内部进行一系列的逻辑计算，最红返回一个计算结果。</p><p>python的类是分为经典类和新式类的，其中新式类的属性比经典类的属性要丰富一些（两者的区别，就是是否继承了object，继承了就是新式类）</p><p>经典类中，具有一种装饰器。</p><p>新式类中，具有三种装饰器定义属性。</p><p>经典类中的属性只有一种访问方式，其对应被 <code>@property</code> 修饰的方法</p><p>新式类中的属性有三种访问方式，并分别对应了三个被<code>@property</code>、<code>@方法名.setter</code>、<code>@方法名.deleter</code>修饰的方法</p><p>由于新式类中具有三种访问方式，我们可以根据他们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p><p>静态字段方式，创建值为property对象的静态字段</p><p>当使用静态字段的方式创建属性时，经典类和新式类无区别</p><p>property的构造方法中有个四个参数</p><ul><li>第一个参数是方法名，调用 <code>对象.属性</code> 时自动触发执行方法</li><li>第二个参数是方法名，调用 <code>对象.属性 ＝ XXX</code> 时自动触发执行方法</li><li>第三个参数是方法名，调用 <code>del 对象.属性</code> 时自动触发执行方法</li><li>第四个参数是字符串，调用 <code>对象.属性.__doc__</code> ，此参数是该属性的描述信息</li></ul><p>由于静态字段方式创建属性具有三种访问方式，我们可以根据他们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p><p>所以，定义属性共有两种方式，分别是【装饰器】和【静态字段】，而【装饰器】方式针对经典类和新式类又有所不同。</p><p><strong>类成员的修饰符</strong></p><p>类的所有成员在上一步骤中已经做了详细的介绍，对于每一个类的成员而言都有两种形式：</p><ul><li>公有成员，在任何地方都能访问</li><li>私有成员，只有在类的内部才能方法</li></ul><p><strong>私有成员和公有成员的定义不同：</strong>私有成员命名时，前两个字符是下划线。（特殊成员除外，例如：<strong>init</strong>、<strong>call</strong>、<strong>dict</strong>等）</p><p><strong>私有成员和公有成员的访问限制不同：</strong></p><p><strong>静态字段</strong></p><ul><li>公有静态字段：类可以访问；类内部可以访问；派生类中可以访问</li><li>私有静态字段：仅类内部可以访问</li></ul><p><strong>普通字段</strong></p><ul><li>公有普通字段：对象可以访问；类内部可以访问；派生类中可以访问</li><li>私有普通字段：仅类内部可以访问；</li></ul><p>ps：如果想要强制访问私有字段，可以通过 【对象._类名__私有字段明 】访问（如：obj._C__foo），不建议强制访问私有成员。</p><p>方法、属性的访问于上述方式相似，即：私有成员只能在类内部使用</p><p><em>ps：非要访问私有属性的话，可以通过</em> <em><code>对象._类__属性名</code></em></p><p><strong>类的特殊成员</strong></p><p>上文介绍了Python的类成员以及成员修饰符，从而了解到类中有字段、方法和属性三大类成员，并且成员名前如果有两个下划线，则表示该成员是私有成员，私有成员只能由类内部调用。无论人或事物往往都有不按套路出牌的情况，Python的类成员也是如此，存在着一些具有特殊含义的成员，详情如下：</p><p><strong>1.</strong> <strong>doc</strong></p><p>表示类的描述信息</p><p><strong>2.</strong> <strong>module</strong> <strong>和</strong> <strong>class</strong></p><ul><li><strong>module</strong> 表示当前操作的对象在那个模块</li><li><strong>class</strong> 表示当前操作的对象的类是什么</li></ul><p><strong>3.</strong> <strong>init</strong></p><p>构造方法，通过类创建对象时，自动触发执行。</p><p><strong>4.</strong> <strong>del</strong></p><p>析构方法，当对象在内存中被释放时，自动触发执行。</p><p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p><p><strong>5.</strong> <strong>call</strong></p><p>对象后面加括号，触发执行。</p><p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p><p><strong>6.</strong> <strong>dict</strong></p><p>类或对象中的所有成员</p><p>上文中我们知道：类的普通字段属于对象；类中的静态字段和方法等属于类.</p><p><strong>7.</strong> <strong>str</strong></p><p>如果一个类中定义了<strong>str</strong>方法，那么在打印 对象 时，默认输出该方法的返回值。</p><p><strong>8、getitem、setitem、delitem</strong></p><p>用于索引操作，如字典。以上分别表示获取、设置、删除数据</p><p><strong>9、getslice、setslice、delslice</strong></p><p>该三个方法用于分片操作</p><p><strong>10.</strong> <strong>iter</strong></p><p>用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了 <strong>iter</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;真正的看python（1）&quot;&gt;&lt;a href=&quot;#真正的看python（1）&quot; class=&quot;headerlink&quot; title=&quot;真正的看python（1）&quot;&gt;&lt;/a&gt;真正的看python（1）&lt;/h1&gt;&lt;h2 id=&quot;1、python是一门解释性语言嘛？&quot;&gt;&lt;a href=&quot;#1、python是一门解释性语言嘛？&quot; class=&quot;headerlink&quot; title=&quot;1、python是一门解释性语言嘛？&quot;&gt;&lt;/a&gt;1、python是一门解释性语言嘛？&lt;/h2&gt;&lt;p&gt;是但不完全是，python其实是一门基于虚拟机的语言，首先他有三门主要的解释器，他利用这个解释器，来解释并且执行自己定义的语法来生成代码执行。解释性语言并不需要编译。&lt;/p&gt;
&lt;p&gt;再说的清楚一点、计算机并不能直接理解我们的语言，他只能理解机器语言，也就是0和1，因此，我们需要进行翻译。&lt;/p&gt;
&lt;p&gt;而翻译，有两种，一种就是解释、一种就是编译。&lt;/p&gt;
&lt;p&gt;编译型语言、在我们的程序执行之前，会通过编译器编译为机器语言&lt;/p&gt;
&lt;p&gt;，那么在运行的时候，就不需要翻译，直接执行就可以了，最典型的例子就是c。&lt;/p&gt;
&lt;p&gt;解释型语言、没有提前编译的过程，在程序运行的时候，通过解释器对程序逐行做出解释，然后执行。&lt;/p&gt;
&lt;p&gt;可以发现，从效率上来说，势必的，编译型语言的效率绝对是要比解释型语言要强的，但是现在的热门语言其实已经脱离了单纯的编译和解释的差别。&lt;/p&gt;
&lt;p&gt;例如，java，java先通过编译器编译成字节码文件，然后运行时通过解释器解释成机器文件，可以说java是先编译再解释的语言。&lt;/p&gt;
&lt;p&gt;python，其实和java一样，都是基于虚拟机的，同样也是先编译再解释的语言。&lt;/p&gt;
&lt;p&gt;py文件，pyc文件，pycodeobject文件。&lt;/p&gt;
&lt;p&gt;py文件不用说，就是我们写的，pyc我们也能在硬盘上看到。&lt;/p&gt;
&lt;p&gt;pycodeobject其实是python编译器真正编译成的结果，只不过当程序运行时，这个文件被保存在内存中，运行完了后，解释器会把这个文件写到pyc文件中，当程序第二次运行时，首先会寻找pyc文件，然后对py和pyc的时间戳判断，是否修改过，没有的话，就直接载入pyc。&lt;/p&gt;
&lt;p&gt;那么就很清晰了，pyc其实就是pyo的持久化存储方式。&lt;/p&gt;
&lt;h2 id=&quot;2、python的面向对象&quot;&gt;&lt;a href=&quot;#2、python的面向对象&quot; class=&quot;headerlink&quot; title=&quot;2、python的面向对象&quot;&gt;&lt;/a&gt;2、python的面向对象&lt;/h2&gt;&lt;p&gt;首先，要明白，面向对象是一种编程方式、基于的是类和对象的使用。&lt;/p&gt;
&lt;p&gt;类是一个模板，封装了多个函数和变量。对象就是根据模板创建的实例。&lt;/p&gt;
&lt;p&gt;面向对象有三大特性，封装、继承、多态。&lt;/p&gt;
&lt;p&gt;来看看类。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="http://rczmm.github.io/2021/07/20/%E5%BC%82%E5%B8%B8/"/>
    <id>http://rczmm.github.io/2021/07/20/%E5%BC%82%E5%B8%B8/</id>
    <published>2021-07-20T15:22:10.000Z</published>
    <updated>2021-07-20T15:22:45.274Z</updated>
    
    <content type="html"><![CDATA[<p>异常</p><p>程序在运行当中，不可避免的会产生一些错误。</p><p>​    使用了没有赋值的变量，使用了不存在的索引、使用了过深的递归、传入了无效的参数…</p><p>一旦出现异常，程序会立即停止。</p><p>处理异常</p><p>python是希望在出现异常的时候，程序不停，可以编写代码来对异常进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">代码块（可能出现异常的语句）</span><br><span class="line">except 异常类型 as 异常名（可以自定义）:</span><br><span class="line">代码块（程序出错了的处理方式）</span><br><span class="line">else:</span><br><span class="line">代码块（没出错要执行的语句）</span><br><span class="line">finally:</span><br><span class="line">代码块（一定会执行，无论是否出错的语句）</span><br></pre></td></tr></table></figure><p>try语句是必须的，else则不是，except和finally至少要有一股</p><p>raise语句 抛出异常</p><p>常见的异常对象</p><p>nameerror（你的变量名称为找到，函数名称，类名称。变量没有定义）</p><p>recursionerror（超过最大递归深度）</p><p>syntaxerror 语法错误</p><p>timeoueerror 超时</p><p>typeerror 类型错误（print（1+“sasda”））</p><p>valueerror   int（”12.2月”）</p><p>keyerror </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;异常&lt;/p&gt;
&lt;p&gt;程序在运行当中，不可避免的会产生一些错误。&lt;/p&gt;
&lt;p&gt;​    使用了没有赋值的变量，使用了不存在的索引、使用了过深的递归、传入了无效的参数…&lt;/p&gt;
&lt;p&gt;一旦出现异常，程序会立即停止。&lt;/p&gt;
&lt;p&gt;处理异常&lt;/p&gt;
&lt;p&gt;python是希望在出</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>类与对象</title>
    <link href="http://rczmm.github.io/2021/07/20/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://rczmm.github.io/2021/07/20/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-07-20T15:21:27.000Z</published>
    <updated>2021-07-20T15:21:58.278Z</updated>
    
    <content type="html"><![CDATA[<p>函数</p><p>python是一门面向对象的语言，万物皆是对象（一切其实皆函数（不准确，不正确））</p><p>函数也是一种对象（内存中专门用来储存数据的一块区域）</p><p>函数可以保存一些可执行的代码，并且，在需要的时候，这一部分代码可以重复的使用。</p><p>创建函数：</p><p>def 函数名（形参1，形参2…..）：</p><p>​    代码块</p><p>函数名的命名规范，（不能占用保留字符，可以包含字母、数字、下划线，但是不能用数字开头）</p><p>函数中保存的代码不会立即执行，而是要调用才会执行（注意函数的参数）</p><p>调用函数</p><p>函数名（参数）</p><p>函数可以没有参数，也可以有多个参数，调用时必须要符合定义的规范</p><p>参数</p><p>形参（就相当于在函数内部声明了一个变量），多个形参用逗号隔开</p><p>实参（实际参数）调用函数的时候，传递进来的参数，实参会赋值给形参</p><p>有几个形参就要几个实参</p><p>函数式的编程</p><p>在python中，函数式一等对象</p><p>一等对象，如下特点</p><p>1、对象是在运行时创建的</p><p>2、能赋值给变量或者作为数据结构中的元素</p><p>3、能作为参数转递</p><p>4、能作为返回值返回</p><p>高阶函数</p><p>第一、接受一个或者多个函数作为参数</p><p>第二、将函数作为返回值返回</p><p>第三、装饰器</p><p>类与对象</p><p>面向对象</p><p>所谓的面向对象、简单来说就是所有操作都可以通过对象来实现</p><p>面向过程、将程序拆解成一个个的步骤</p><p>大鹏上学记</p><p>​    1、妈妈起床</p><p>​    2、妈妈上厕所</p><p>​    3、妈妈洗漱</p><p>​    4、妈妈做早饭</p><p>​    5、妈妈叫大鹏</p><p>​    6、大鹏上厕所</p><p>​    7、大鹏洗漱</p><p>​    8、大鹏吃早饭</p><p>​    9、背上书包</p><p>​    10、上学校‘</p><p>编程思想（面向过程）：将一个功能拆分成许多的小步骤</p><p>只适用于一个功能，如果要实现另外一个功能，即使两个功能相差很小，但是依旧要重新写代码</p><p>复用性比较低，难于维护</p><p>面向对象：关注的不是过程，关注的是对象</p><p>大鹏上学记</p><p>​    1、大鹏妈妈叫大鹏上学</p><p>编程思想（面向对象），将所有的功能保存到一个对象里</p><p>比如，妈妈的功能保存到妈妈对象里，大鹏的功能保存到大鹏的对象里，要使用这个功能，直接来找对象。</p><p>（要值得一提的是，作为一个功能来讲，（中小功能），面向过程写起来比较酣畅淋漓，同时比较快）</p><p>简单归纳一下，面向对象的思想：1、找对象、2、搞对象（设计对象，做对象）、调用对象</p><p>类（class）</p><p>类和对象是什么关系</p><p>类就是对象的图纸！</p><p>对象是类的实例</p><p>类也是一个对象（一个用来创建对象的对象）</p><p>类：</p><p>生活中所有的事物都可以抽象出来</p><p>1、数据（属性） 变量</p><p>2、行为（方法） 函数</p><p>所有的这个类的实例都可以对象.属性来访问这个变量，对象.方法（）都可以来调用这个方法</p><p>定义一个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class 类名（）:</span><br><span class="line">公共的一些属性</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line"></span><br><span class="line">对象的初始化方法</span><br><span class="line">def __init__(self,...):</span><br><span class="line">...</span><br><span class="line">其他的方法</span><br><span class="line">def method():</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>p1=类名（）（创建了一个对象，根据类名的那个类）然后，初始化方法就会自动调用，其他方法需要手动调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数&lt;/p&gt;
&lt;p&gt;python是一门面向对象的语言，万物皆是对象（一切其实皆函数（不准确，不正确））&lt;/p&gt;
&lt;p&gt;函数也是一种对象（内存中专门用来储存数据的一块区域）&lt;/p&gt;
&lt;p&gt;函数可以保存一些可执行的代码，并且，在需要的时候，这一部分代码可以重复的使用。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>序列</title>
    <link href="http://rczmm.github.io/2021/07/20/%E5%BA%8F%E5%88%97/"/>
    <id>http://rczmm.github.io/2021/07/20/%E5%BA%8F%E5%88%97/</id>
    <published>2021-07-20T15:20:15.000Z</published>
    <updated>2021-07-20T15:20:38.557Z</updated>
    
    <content type="html"><![CDATA[<p>序列</p><p>1、列表 list</p><p>​    1、列表是python中的一个对象</p><p>​    2、之前所说的对象，他只能单一的保存数据</p><p>​    3、列表可以保存很多个<strong>有序</strong>的数据</p><p>​    4、列表是用来存储对象的对象</p><p>​    5、列表的使用（本身、里面数据）</p><p>2、序列</p><p>​    1、序列是python中最基本的数据结构</p><p>​    2、数据结构是计算机中数据储存的方式</p><p>​    3、序列用于保存一组有序的数据，所有数据在序列当中是唯一的。（索引）</p><p>​    4、序列中的数据会按照添加的顺序来分配索引（从0开始）</p><p>​    5、序列的分类：</p><p>​            可变序列：list</p><p>​            不可变序列：str、tuple</p><p>3、字典 dict</p><p>​    1、字典又叫映射（mapping）</p><p>​    2、列表存的性能很好，查的性能很差。</p><p>​    3、字典查的性能很好，在字典中，每一个元素都有一个唯一的名字，通过这个名字可以很快的找到指定的元素</p><p>​    4、字典有可以被称为键值对，唯一的名字，键，那个值叫做值</p><p>4、集合 set</p><pre><code> 1、集合和列表很像</code></pre><p>​     2、集合只能存不可变的对象</p><p>​     3、集合中的对象是无序的</p><p>​     4、集合中不能出现重复的元素</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;序列&lt;/p&gt;
&lt;p&gt;1、列表 list&lt;/p&gt;
&lt;p&gt;​    1、列表是python中的一个对象&lt;/p&gt;
&lt;p&gt;​    2、之前所说的对象，他只能单一的保存数据&lt;/p&gt;
&lt;p&gt;​    3、列表可以保存很多个&lt;strong&gt;有序&lt;/strong&gt;的数据&lt;/p&gt;
&lt;p&gt;​</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>安装和几个概念</title>
    <link href="http://rczmm.github.io/2021/07/20/%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    <id>http://rczmm.github.io/2021/07/20/%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5/</id>
    <published>2021-07-20T15:17:48.000Z</published>
    <updated>2021-07-21T14:25:02.687Z</updated>
    
    <content type="html"><![CDATA[<p>python的安装</p><p><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></p><p>python   2和3两个版本，这两个版本是并行，而且差距还有点大</p><p>idle python自带的一个开发工具（tab 自动补全）</p><p>交互界面去完成一些简单的测试</p><p>一般将python代码保存到一个py文件里，然后通过python指令来执行文件中的代码。</p><p> 几个概念</p><p>1、表达式</p><p>表达式就是类似于数学公式的东西</p><p>表达式一般仅仅用来计算，不会对程序有什么实质性影响，如果说你在交互模式直接输入表达式，那么解释器会自动的表达式的值输出。</p><p>2、语句</p><p>语句，一般需要他完成某种功能</p><p>print 打印一些信息</p><p>input  获取信息</p><p>a=1  为变量赋值</p><p>……</p><p>语句的执行一般来说都会对程序造成一定的影响</p><p>在交互模式中不一定会输出语句的结果</p><p>3、程序</p><p>程序是由一条一条的语句和一条条的表达式构成的</p><p>4、函数</p><p>函数也是一种语句，来完成特定的功能</p><p>函数：xx（）</p><p>函数的分类：</p><p>​    内置函数：</p><p>​        由解释器提供的函数：print（）</p><p>​    自定义函数：</p><p>​        由开发者自己创建的函数</p><p>函数有两个要素：参数（），括号中的内容就是参数</p><p>​        函数可以没有参数，也可以有很多个参数，多个参数用，隔开</p><p>​    返回值</p><p>​        返回值就是函数的返回结果，不是所有的函数都有返回值</p><span id="more"></span><p>5、字面量和变量</p><p>​    字面量就是一个一个的值，一个一个看得到的值，</p><p>​    1,2,3，asa，“dsd”</p><p>​    就是它表面上的值，在程序·中可以直接使用字面量</p><p>​    变量 变量可以用来保存字面量，而且保存的字面量是不一定的。</p><p>​    x=qwq</p><p>​    变量本身是没有任何意思的，他的意思根据字面量来表达</p><p>6、数据类型</p><p>​    数据类型就是变量的值的类型，也就是说可以为变量赋那些值，还可以说，变量可以等于那些东西</p><p>​    数值（整型（整数）、浮点型（浮点数）、布尔（就是是或者否，true or false 1或者0）、字符串、空值）</p><p>7、对象</p><p>python是一门面向对象的语言</p><p>一切都是对象（一切都是函数）</p><p>程序运行当中，所有的数据都要储存到内存当中然后运行，对象实际上就是一个在内存中用来存储数据的一块区域，他就是一个容器，用来存储数据。</p><p>对象的结构</p><p>id（标识）</p><p>用来确定对象的唯一性</p><p>id是由解析器生成的，cpython中，id就是对象的内存地址。</p><p>id（）函数可以查看id</p><p>对象一旦创建。他的id永远不能改变。</p><p>type（类型）</p><p>int float bool str</p><p>类型决定了对象的功能</p><p>type（）函数可以查看对象类型</p><p>python是一门强类型的语言，java也是，但是js，JavaScript他不是，对象一旦创建就是更改类型</p><p>value（值）</p><p>值就是对象里存储的数据</p><p>对于值有些对象是可以改变的</p><p>对象又分为两个大类，一个是可变的，一个是不可变的。</p><p>8、变量和对象</p><p>对象其实没有存储到变量中，在Python中，变量更加像是给对象取了一个名字（别名）</p><p>变量中存储的不是对象的值，而是对象的id（内存地址）</p><p>使用变量，实际上就是通过id来查找对象</p><p>变量中保存的对象，只有在再一次赋值的时候才会改变</p><p>变量与变量是独立的，修改一个变量不会影响到下一个变量</p><p>9、类型转换</p><p>一个类型的对象转换为其他对象（不是改变对象本身，而是根据对象的值来创建一个新对象）</p><p>10、运算符</p><p><strong>+</strong>  <strong>-</strong> ***** <strong>/</strong> </p><p>算术运算符 </p><p>= 赋值运算符</p><p>== &lt;= &gt;= ! 比较运算符（关系运算符）</p><p>条件运算符（三元运算符）</p><p>逻辑运算符 and or</p><p>11、基本语法</p><p>1、python严格区分大小写</p><p>2、每一行就是一条语句</p><p>3、一行语句不要过长</p><p>4、一条语句可以多行写，后面\（转义字符）结尾</p><p>5、严格缩进（在python里不要随便写缩进）</p><p>6、#这是单行注释，严格养成写注释的习惯，而且一般来说，#后面加一个空格</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;python的安装&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.python.org/downloads/&quot;&gt;https://www.python.org/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python   2和3两个版本，这两个版本是并行，而且差距还有点大&lt;/p&gt;
&lt;p&gt;idle python自带的一个开发工具（tab 自动补全）&lt;/p&gt;
&lt;p&gt;交互界面去完成一些简单的测试&lt;/p&gt;
&lt;p&gt;一般将python代码保存到一个py文件里，然后通过python指令来执行文件中的代码。&lt;/p&gt;
&lt;p&gt; 几个概念&lt;/p&gt;
&lt;p&gt;1、表达式&lt;/p&gt;
&lt;p&gt;表达式就是类似于数学公式的东西&lt;/p&gt;
&lt;p&gt;表达式一般仅仅用来计算，不会对程序有什么实质性影响，如果说你在交互模式直接输入表达式，那么解释器会自动的表达式的值输出。&lt;/p&gt;
&lt;p&gt;2、语句&lt;/p&gt;
&lt;p&gt;语句，一般需要他完成某种功能&lt;/p&gt;
&lt;p&gt;print 打印一些信息&lt;/p&gt;
&lt;p&gt;input  获取信息&lt;/p&gt;
&lt;p&gt;a=1  为变量赋值&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;语句的执行一般来说都会对程序造成一定的影响&lt;/p&gt;
&lt;p&gt;在交互模式中不一定会输出语句的结果&lt;/p&gt;
&lt;p&gt;3、程序&lt;/p&gt;
&lt;p&gt;程序是由一条一条的语句和一条条的表达式构成的&lt;/p&gt;
&lt;p&gt;4、函数&lt;/p&gt;
&lt;p&gt;函数也是一种语句，来完成特定的功能&lt;/p&gt;
&lt;p&gt;函数：xx（）&lt;/p&gt;
&lt;p&gt;函数的分类：&lt;/p&gt;
&lt;p&gt;​    内置函数：&lt;/p&gt;
&lt;p&gt;​        由解释器提供的函数：print（）&lt;/p&gt;
&lt;p&gt;​    自定义函数：&lt;/p&gt;
&lt;p&gt;​        由开发者自己创建的函数&lt;/p&gt;
&lt;p&gt;函数有两个要素：参数（），括号中的内容就是参数&lt;/p&gt;
&lt;p&gt;​        函数可以没有参数，也可以有很多个参数，多个参数用，隔开&lt;/p&gt;
&lt;p&gt;​    返回值&lt;/p&gt;
&lt;p&gt;​        返回值就是函数的返回结果，不是所有的函数都有返回值&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>入门部分</title>
    <link href="http://rczmm.github.io/2021/07/20/%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86/"/>
    <id>http://rczmm.github.io/2021/07/20/%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86/</id>
    <published>2021-07-20T14:02:36.000Z</published>
    <updated>2021-07-20T14:05:30.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机基础知识（电子计算机）"><a href="#计算机基础知识（电子计算机）" class="headerlink" title="计算机基础知识（电子计算机）"></a>计算机基础知识（电子计算机）</h2><h3 id="1、计算机是什么？"><a href="#1、计算机是什么？" class="headerlink" title="1、计算机是什么？"></a>1、计算机是什么？</h3><p>计算机就是一个用来计算的机器</p><p>目前来讲，计算机智能根据人类的指令来完成各种操作，人让他干嘛他就得干嘛</p><p>所以说，我们现在学习计算机，就是学习如何的去控制计算机</p><h3 id="2、计算机的组成"><a href="#2、计算机的组成" class="headerlink" title="2、计算机的组成"></a>2、计算机的组成</h3><p>硬件</p><p>键盘、鼠标、显示器、cpu（中央处理器）、主板（连接）、内存（运行内存、内存条）、硬盘（机械、固态…）…</p><p>看得见、摸得着的东西</p><p>软件</p><p><strong>系统</strong>软件（操作系统）</p><p>Windows、linux、macos</p><p>应用软件</p><p>办公软件（office、wps、xmind）、游戏、浏览器、聊天工具….</p><p>看得见、但是摸不着，软件起到的作用是负责控制计算机的硬件。</p><h3 id="3、计算机的使用方式"><a href="#3、计算机的使用方式" class="headerlink" title="3、计算机的使用方式"></a>3、计算机的使用方式</h3><p>必须要通过软件来完成对计算机的各种操作</p><p>但是、注意一点</p><p>一个软件并不是说，你下载了这个软件，你就可以使用它的全部功能。</p><p>用户需要的功能：接口（interface（接口） 交互界面）来操作计算机。</p><p>接口这个概念， c# java 这些编程语言当中，大多数是以一种方法集的形式，本质上说他是个类</p><p>web开发，写网站。写接口（例子：修改我的密码（第一个接口）、我想充值（也是一个接口）、注册（也是一个接口））</p><p>用户界面：文本交互界面（TUI） 和图形化交互界面（GUI）</p><p>TUI（Windows）</p><p>命令行（cmd，dos命令窗口、命令提示符、cmd窗口、shell、终端、terminal）</p><p>shell编程（命令行输入指令去操作系统）</p><p>终端</p><p>terminal 控制台</p><p>文本交互界面，指令去操作计算机</p><p>任何一个计算机操作系统都拥有命令行</p><h3 id="windows-命令行"><a href="#windows-命令行" class="headerlink" title="windows 命令行"></a>windows 命令行</h3><p>进入方式：1、底部搜索框 2、win键加r键，运行窗口，输入cmd</p><p>结构：</p><p>-版本以及版权的声明（一般没有什么用处）</p><p>Microsoft Windows [版本 10.0.18363.1316]<br>(c) 2019 Microsoft Corporation。保留所有权利。</p><p>-命令提示符</p><p>C:\Users***  **&gt;**（命令提示符、在&gt;后面可以直接输入指令）</p><p>C：</p><p>​    -当前所在的磁盘的根目录</p><p>​    -可以通过x：来切换盘符（x是表示你的盘符）</p><p>\Users***</p><p>​    -所在磁盘的路径、当前所在的文件夹</p><p>​    -cd切换目录</p><p>常见的dos命令</p><p>dir（查看当前路径下的所有文件包括文件夹）</p><p>cd（切换到指定的目录）. ..（正则表达式）</p><p>.表示的当前的目录</p><p>..表示的是上一级目录</p><p>md 创建一个目录</p><p>rd 删除一个目录</p><p>del 删除文件</p><p>cls 清屏</p><p>小技巧：</p><p>方向键上下键：会出现命令的历史记录</p><p>tab键：自动补全命令</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>path（路径）</p><p>Windows，path或许没有，可以手动添加</p><p>path不区分大小写pAth</p><p>修改完环境变量，必须重启命令行窗口</p><p>多个路径必须用;（英文的分号）隔开</p><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>十进制（满十进一）</p><p>0、1、2、3、4、5、6、7、8、9</p><p>千位、百位、个位</p><p>10^3  10^2    10^1</p><p>二进制（计算机底层使用的进制、满二进一）</p><p>01、001、01101</p><p>0000011010100   1      0        1</p><p>​                            2^2      2^1    2^0</p><p>计算机底层储存方式，二进制方式，内存中的每一个小格子，我们称之为一个bit（位）</p><p>一位（1 bit（其实就是一个1或者0））</p><p>bit是计算机中最小的单位</p><p>byte（字节）才是我们最小的可操作的单位</p><p>1 byte=8 bit</p><p>1024 byte =1 kb</p><p>……</p><p>八进制（一般不用）</p><p>十六进制</p><p>（不是给计算机底部用的，而是给我们（用户、开发者）看的）</p><p>一般来讲，查看二进制数据的时候，都不会用二进制来显示，而是用提供十六进制</p><h3 id="文本文件和字符集"><a href="#文本文件和字符集" class="headerlink" title="文本文件和字符集"></a>文本文件和字符集</h3><p>文本分成两种：纯文本（只能保存单一的文本内容、（字体、颜色、图片….）这些都不能保存） 富文本（可以保存文本之外的内容）</p><p>但是，在开发的时候，使用的全都是纯文本</p><p>纯文本在计算机底层转换成二进制保存</p><p>将字符转换二进制的过程、编码</p><p>二进制码转换成字符的过程、解码</p><p>编码与解码、所采用的规则，叫做字符集</p><p>常见：</p><p>ascll 美国人</p><p>iso 欧洲</p><p>ltain（mysql默认的编码方式）只认英文</p><p>gbk gb2312 中国</p><p>unicode 编码（万国码）utf-8 、utf-16、utf-32</p><h2 id="python入门"><a href="#python入门" class="headerlink" title="python入门"></a>python入门</h2><h3 id="python是什么？"><a href="#python是什么？" class="headerlink" title="python是什么？"></a>python是什么？</h3><p>计算机语言</p><p>机器语言(全是二进制，执行效率高、编写太麻烦)</p><p>符号语言（汇编语言）</p><p>（符号来代替二进制）</p><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>基本跟英语语法很相似，并且和硬件的关系没有那么紧密了，而且学习起来更容易。</p><p>c c++ c# java JavaScript（node.js）（本质上写服务器的时候还是用的服务器加客户端的结构，而且一般不用js写服务器，用js写中间件，因为他的并发处理）、python….</p><p>高级语言又分类：编译型语言（在代码执行前，转化为二进制（机器码），然后交给计算机执行）</p><p>源码——编译——机器码</p><p>c语言</p><p>执行速度很快，跨平台性很差</p><p>解释型语言（不对代码进行编译，而是一边执行一边编译）</p><p>源码–解释器–解释运行</p><p>执行速度会比较慢，但是跨平台性会非常好</p><p>js java python</p><p>python 使用广泛、可读性强、比较简洁，用更少的代码去完成自己的想法，不管是大程序还是小程序，都让结构变得清晰明了。</p><h3 id="python的用途"><a href="#python的用途" class="headerlink" title="python的用途"></a>python的用途</h3><p>web（facebook、豆瓣）</p><p>爬虫</p><p>科学计算</p><p>大数据（数据清洗）</p><p>云计算</p><p>人工智能</p><p>游戏</p><p>…</p><h3 id="python开发环境的搭建"><a href="#python开发环境的搭建" class="headerlink" title="python开发环境的搭建"></a>python开发环境的搭建</h3><p>python是有解释器的</p><p>cpython（官方）</p><p>用c语言（c语言直接作用在内存上）编写的python解释器</p><p>大型游戏（全部都是由c或者c#编写的，为什么？因为c能够直接作用在内存上）</p><p>pypy</p><p>用python语言编写的Python解释器</p><p>ironpython</p><p>.net编写</p><p>jpython</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机基础知识（电子计算机）&quot;&gt;&lt;a href=&quot;#计算机基础知识（电子计算机）&quot; class=&quot;headerlink&quot; title=&quot;计算机基础知识（电子计算机）&quot;&gt;&lt;/a&gt;计算机基础知识（电子计算机）&lt;/h2&gt;&lt;h3 id=&quot;1、计算机是什么？&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
</feed>
