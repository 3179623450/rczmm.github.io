<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小世界</title>
  
  <subtitle>永远在路上</subtitle>
  <link href="http://rczmm.github.io/atom.xml" rel="self"/>
  
  <link href="http://rczmm.github.io/"/>
  <updated>2021-09-21T14:52:42.732Z</updated>
  <id>http://rczmm.github.io/</id>
  
  <author>
    <name>rczmm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>numpy-dnc，rnn，lstm</title>
    <link href="http://rczmm.github.io/2021/09/21/numpy-dnc%EF%BC%8Crnn%EF%BC%8Clstm/"/>
    <id>http://rczmm.github.io/2021/09/21/numpy-dnc%EF%BC%8Crnn%EF%BC%8Clstm/</id>
    <published>2021-09-21T14:45:16.000Z</published>
    <updated>2021-09-21T14:52:42.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NumPy-中的微分神经计算"><a href="#NumPy-中的微分神经计算" class="headerlink" title="NumPy 中的微分神经计算"></a>NumPy 中的微分神经计算</h1><p>可微分神经计算 <a href="https://www.nature.com/article/nature20101">https://www.nature.com/article/nature20101</a> 的实现尽可能接近于本文的描述。任务：char-level 预测。报告还包括简单RNN(RNN-numpy.py)和LSTM(LSTM-numpy.py)。一些外部数据(ptb、wiki)需要单独下载。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dnc-debug.py</span><br></pre></td></tr></table></figure><p>这些版本已完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python rnn-numpy.py</span><br><span class="line">python lstm-numpy.py</span><br><span class="line">python dnc-numpy.py</span><br></pre></td></tr></table></figure><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><p>RNN代码基于A.Karpath(min-char-rnn.py)的原始工作</p><p>gist: <a href="https://gist.github.com/karpathy/d4dee566867f8291f086">https://gist.github.com/karpathy/d4dee566867f8291f086</a></p><p>文章: <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">http://karpathy.github.io/2015/05/21/rnn-effectiveness/</a></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>RNN版本仍然依赖numpy</li><li>添加批处理</li><li>将RNN修改为LSTM</li><li>包括梯度检测</li></ul><h3 id="DNC"><a href="#DNC" class="headerlink" title="DNC"></a>DNC</h3><p><strong>实施</strong></p><ul><li>LSTM控制器</li><li>2D存储器数组</li><li>内容可寻址的读/写</li></ul><p><strong>问题</strong></p><p>关键相似度的softmax会导致崩溃（除以0） - 如果遇到这种情况，需要重新启动</p><p><strong>将要做</strong></p><ul><li>动态内存分配/自由</li><li>更快的实现（使用PyTorch？）</li><li>保存模型</li><li>例子</li></ul><h3 id="示例输出："><a href="#示例输出：" class="headerlink" title="示例输出："></a>示例输出：</h3><p>时间，迭代，BPC（预测误差 - &gt;每个字符的位数，越低越好），处理速度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="number">4163.009</span> s, <span class="built_in">iter</span> <span class="number">104800</span>, <span class="number">1.2808</span> BPC, <span class="number">1488.38</span> char/s</span><br></pre></td></tr></table></figure><h3 id="模型中的样本（alice29-txt）："><a href="#模型中的样本（alice29-txt）：" class="headerlink" title="模型中的样本（alice29.txt）："></a>模型中的样本（alice29.txt）：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> e garden <span class="keyword">as</span> she very dunced.</span><br><span class="line">                  </span><br><span class="line">  Alice fighting be it.  The breats?</span><br><span class="line">              here on likegs voice withoup.</span><br><span class="line">                                                                               </span><br><span class="line">  `You minced more hal disheze, <span class="keyword">and</span> I done hippertyou-sage, who say it<span class="string">&#x27;s a look down whales that</span></span><br><span class="line"><span class="string">his meckling moruste!&#x27;</span> said Alice<span class="string">&#x27;s can younderen, in they puzzled to them!&#x27;</span></span><br><span class="line">     </span><br><span class="line">  `Of betinkling reple bade to, punthery pormoved the piose himble, of to he see foudhed</span><br><span class="line">just rounds, seef wance side pigs, it addeal sumprked.</span><br><span class="line">                                                                                    </span><br><span class="line">  `As <span class="keyword">or</span> the Gryphon,<span class="string">&#x27; Alice said,</span></span><br><span class="line"><span class="string">Fith didn&#x27;</span>t begun, <span class="keyword">and</span> she garden <span class="keyword">as</span> <span class="keyword">in</span> a who tew.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">  Hat hed think after as marman as much the pirly</span></span><br><span class="line"><span class="string">startares to dreaps</span></span><br><span class="line"><span class="string">was one poon it                                                                           </span></span><br><span class="line"><span class="string">out him were brived they                                                        </span></span><br><span class="line"><span class="string">proce?                                                                                    </span></span><br><span class="line"><span class="string">                                                                                 </span></span><br><span class="line"><span class="string">                                                                                          </span></span><br><span class="line"><span class="string">  CHAT, I fary,&#x27;</span> said the Hat,<span class="string">&#x27; said the Divery tionly to himpos.&#x27;</span>               </span><br><span class="line">                                                                                          </span><br><span class="line">  `Com, planere?<span class="string">&quot;&#x27;                                                               </span></span><br><span class="line"><span class="string">                                                                                          </span></span><br><span class="line"><span class="string">  `Ica--&#x27;                                                                        </span></span><br><span class="line"><span class="string">            Onlice IN&#x27;s tread!  Wonderieving again, `but her rist,&#x27; said Alice.           </span></span><br><span class="line"><span class="string">                                                                                 </span></span><br><span class="line"><span class="string">                                                                                          </span></span><br><span class="line"><span class="string">  She                                                                            </span></span><br><span class="line"><span class="string">sea do voice.                                                                             </span></span><br><span class="line"><span class="string">                                                                                 </span></span><br><span class="line"><span class="string">  `I&#x27;mm the Panthing alece of the when beaning must anquerrouted not reclow, sobs to      </span></span><br><span class="line"><span class="string">                                                                                 </span></span><br><span class="line"><span class="string">  `In of queer behind her houn&#x27;t seemed                                                   </span></span><br></pre></td></tr></table></figure><h3 id="检查反向传递的数值梯度（最右边的列应该具有值-lt-1e-4）"><a href="#检查反向传递的数值梯度（最右边的列应该具有值-lt-1e-4）" class="headerlink" title="检查反向传递的数值梯度（最右边的列应该具有值&lt;1e-4）;"></a>检查反向传递的数值梯度（最右边的列应该具有值&lt;1e-4）;</h3><p>中间列具有计算的分析和数值梯度范围（这些应该更多/更少）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">----</span><br><span class="line">GRAD CHECK</span><br><span class="line"></span><br><span class="line">Wxh:            n = [-<span class="number">1.828500e-02</span>, <span class="number">5.292866e-03</span>]       <span class="built_in">min</span> <span class="number">3.005175e-09</span>, <span class="built_in">max</span> <span class="number">3.505012e-07</span></span><br><span class="line">                a = [-<span class="number">1.828500e-02</span>, <span class="number">5.292865e-03</span>]       mean <span class="number">5.158434e-08</span> <span class="comment"># 10/4</span></span><br><span class="line">Whh:            n = [-<span class="number">3.614049e-01</span>, <span class="number">6.580141e-01</span>]       <span class="built_in">min</span> <span class="number">1.549311e-10</span>, <span class="built_in">max</span> <span class="number">4.349188e-08</span></span><br><span class="line">                a = [-<span class="number">3.614049e-01</span>, <span class="number">6.580141e-01</span>]       mean <span class="number">9.340821e-09</span> <span class="comment"># 10/10</span></span><br><span class="line">Why:            n = [-<span class="number">9.868277e-02</span>, <span class="number">7.518284e-02</span>]       <span class="built_in">min</span> <span class="number">2.378911e-09</span>, <span class="built_in">max</span> <span class="number">1.901067e-05</span></span><br><span class="line">                a = [-<span class="number">9.868276e-02</span>, <span class="number">7.518284e-02</span>]       mean <span class="number">1.978080e-06</span> <span class="comment"># 10/10</span></span><br><span class="line">Whr:            n = [-<span class="number">3.652128e-02</span>, <span class="number">1.372321e-01</span>]       <span class="built_in">min</span> <span class="number">5.520914e-09</span>, <span class="built_in">max</span> <span class="number">6.750276e-07</span></span><br><span class="line">                a = [-<span class="number">3.652128e-02</span>, <span class="number">1.372321e-01</span>]       mean <span class="number">1.299713e-07</span> <span class="comment"># 10/10</span></span><br><span class="line">Whv:            n = [-<span class="number">1.065475e+00</span>, <span class="number">4.634808e-01</span>]       <span class="built_in">min</span> <span class="number">6.701966e-11</span>, <span class="built_in">max</span> <span class="number">1.462031e-08</span></span><br><span class="line">                a = [-<span class="number">1.065475e+00</span>, <span class="number">4.634808e-01</span>]       mean <span class="number">4.161271e-09</span> <span class="comment"># 10/10</span></span><br><span class="line">Whw:            n = [-<span class="number">1.677826e-01</span>, <span class="number">1.803906e-01</span>]       <span class="built_in">min</span> <span class="number">5.559963e-10</span>, <span class="built_in">max</span> <span class="number">1.096433e-07</span></span><br><span class="line">                a = [-<span class="number">1.677826e-01</span>, <span class="number">1.803906e-01</span>]       mean <span class="number">2.434751e-08</span> <span class="comment"># 10/10</span></span><br><span class="line">Whe:            n = [-<span class="number">2.791997e-02</span>, <span class="number">1.487244e-02</span>]       <span class="built_in">min</span> <span class="number">3.806438e-08</span>, <span class="built_in">max</span> <span class="number">8.633199e-06</span></span><br><span class="line">                a = [-<span class="number">2.791997e-02</span>, <span class="number">1.487244e-02</span>]       mean <span class="number">1.085696e-06</span> <span class="comment"># 10/10</span></span><br><span class="line">Wrh:            n = [-<span class="number">7.319636e-02</span>, <span class="number">9.466716e-02</span>]       <span class="built_in">min</span> <span class="number">4.183225e-09</span>, <span class="built_in">max</span> <span class="number">1.369062e-07</span></span><br><span class="line">                a = [-<span class="number">7.319636e-02</span>, <span class="number">9.466716e-02</span>]       mean <span class="number">3.677372e-08</span> <span class="comment"># 10/10</span></span><br><span class="line">Wry:            n = [-<span class="number">1.191088e-01</span>, <span class="number">5.271329e-01</span>]       <span class="built_in">min</span> <span class="number">1.168224e-09</span>, <span class="built_in">max</span> <span class="number">1.568242e-04</span></span><br><span class="line">                a = [-<span class="number">1.191088e-01</span>, <span class="number">5.271329e-01</span>]       mean <span class="number">2.827306e-05</span> <span class="comment"># 10/10</span></span><br><span class="line">bh:             n = [-<span class="number">1.363950e+00</span>, <span class="number">9.144058e-01</span>]       <span class="built_in">min</span> <span class="number">2.473756e-10</span>, <span class="built_in">max</span> <span class="number">5.217119e-08</span></span><br><span class="line">                a = [-<span class="number">1.363950e+00</span>, <span class="number">9.144058e-01</span>]       mean <span class="number">7.066159e-09</span> <span class="comment"># 10/10</span></span><br><span class="line">by:             n = [-<span class="number">5.594528e-02</span>, <span class="number">5.814085e-01</span>]       <span class="built_in">min</span> <span class="number">1.604237e-09</span>, <span class="built_in">max</span> <span class="number">1.017124e-05</span></span><br><span class="line">                a = [-<span class="number">5.594528e-02</span>, <span class="number">5.814085e-01</span>]       mean <span class="number">1.026833e-06</span> <span class="comment"># 10/10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NumPy-中的微分神经计算&quot;&gt;&lt;a href=&quot;#NumPy-中的微分神经计算&quot; class=&quot;headerlink&quot; title=&quot;NumPy 中的微分神经计算&quot;&gt;&lt;/a&gt;NumPy 中的微分神经计算&lt;/h1&gt;&lt;p&gt;可微分神经计算 &lt;a href=&quot;https</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>numpy-k均值聚类</title>
    <link href="http://rczmm.github.io/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/"/>
    <id>http://rczmm.github.io/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/</id>
    <published>2021-09-21T14:44:58.000Z</published>
    <updated>2021-09-21T14:51:31.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NumPy-实现k均值聚类算法（k-means）"><a href="#NumPy-实现k均值聚类算法（k-means）" class="headerlink" title="NumPy 实现k均值聚类算法（k-means）"></a>NumPy 实现k均值聚类算法（k-means）</h1><p>机器学习算法与Python实践这个系列主要是参考《机器学习实战》这本书。因为自己想学习Python，然后也想对一些机器学习算法加深下了解，所以就想通过Python来实现几个比较常用的机器学习算法。恰好遇见这本同样定位的书籍，所以就参考这本书的过程来学习了。</p><p>机器学习中有两类的大问题，一个是分类，一个是聚类。分类是根据一些给定的已知类别标号的样本，训练某种学习机器，使它能够对未知类别的样本进行分类。这属于supervised learning（监督学习）。而聚类指事先并不知道任何样本的类别标号，希望通过某种算法来把一组未知类别的样本划分成若干类别，这在机器学习中被称作 unsupervised learning （无监督学习）。在本文中，我们关注其中一个比较简单的聚类算法：k-means算法。</p><h2 id="k-means算法简介"><a href="#k-means算法简介" class="headerlink" title="k-means算法简介"></a>k-means算法简介</h2><p>通常，人们根据样本间的某种距离或者相似性来定义聚类，即把相似的（或距离近的）样本聚为同一类，而把不相似的（或距离远的）样本归在其他类。</p><p>我们以一个二维的例子来说明下聚类的目的。如下图左所示，假设我们的n个样本点分布在图中所示的二维空间。从数据点的大致形状可以看出它们大致聚为三个cluster，其中两个紧凑一些，剩下那个松散一些。我们的目的是为这些数据分组，以便能区分出属于不同的簇的数据，如果按照分组给它们标上不同的颜色，就是像下图右边的图那样：</p><p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226190225921.png" alt="聚类对比图"></p><p>如果人可以看到像上图那样的数据分布，就可以轻松进行聚类。但我们怎么教会计算机按照我们的思维去做同样的事情呢？这里就介绍个集简单和经典于一身的k-means算法。</p><p>k-means算法是一种很常见的聚类算法，它的基本思想是：通过迭代寻找k个聚类的一种划分方案，使得用这k个聚类的均值来代表相应各类样本时所得的总体误差最小。</p><p>k-means算法的基础是最小误差平方和准则。其代价函数是：</p><p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226190316156.png" alt="代价函数"></p><p>上式中，μc(i)表示第i个聚类的均值。我们希望代价函数最小，直观的来说，各类内的样本越相似，其与该类均值间的误差平方越小，对所有类所得到的误差平方求和，即可验证分为k类时，各聚类是否是最优的。</p><p>上式的代价函数无法用解析的方法最小化，只能有迭代的方法。k-means算法是将样本聚类成 k个簇（cluster），其中k是用户给定的，其求解过程非常直观简单，具体算法描述如下：</p><ol><li>随机选取 k个聚类质心点</li><li>重复下面过程直到收敛<ul><li>对于每一个样例 i，计算其应该属于的类： <img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191250687.png" alt="计算其应该属于的类"></li><li>对于每一个类 j，重新计算该类的质心： <img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191306718.png" alt="重新计算质心"></li></ul></li></ol><p>下图展示了对n个样本点进行K-means聚类的效果，这里k取2。</p><p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191321406.png" alt="聚类效果"></p><p>其伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建k个点作为初始的质心点（随机选择）</span><br><span class="line">当任意一个点的簇分配结果发生改变时</span><br><span class="line">    对数据集中的每一个数据点</span><br><span class="line">        对每一个质心</span><br><span class="line">            计算质心与数据点的距离</span><br><span class="line">        将数据点分配到距离最近的簇</span><br><span class="line">    对每一个簇，计算簇中所有点的均值，并将均值作为质心</span><br></pre></td></tr></table></figure><h2 id="Numpy-实现"><a href="#Numpy-实现" class="headerlink" title="Numpy 实现"></a>Numpy 实现</h2><p>我使用的Python是2.7.5版本的。附加的库有Numpy和Matplotlib。具体的安装和配置见前面的博文。在代码中已经有了比较详细的注释了。不知道有没有错误的地方，如果有，还望大家指正（每次的运行结果都有可能不同）。里面我写了个可视化结果的函数，但只能在二维的数据上面使用。直接贴代码：</p><p>kmeans.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment"># kmeans: k-means cluster</span></span><br><span class="line"><span class="comment"># Author : zouxy</span></span><br><span class="line"><span class="comment"># Date   : 2013-12-25</span></span><br><span class="line"><span class="comment"># HomePage : http://blog.csdn.net/zouxy09</span></span><br><span class="line"><span class="comment"># Email  : zouxy09@qq.com</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate Euclidean distance</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclDistance</span>(<span class="params">vector1, vector2</span>):</span></span><br><span class="line"><span class="keyword">return</span> sqrt(<span class="built_in">sum</span>(power(vector2 - vector1, <span class="number">2</span>)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># init centroids with random samples</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCentroids</span>(<span class="params">dataSet, k</span>):</span></span><br><span class="line">numSamples, dim = dataSet.shape</span><br><span class="line">centroids = zeros((k, dim))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">index = <span class="built_in">int</span>(random.uniform(<span class="number">0</span>, numSamples))</span><br><span class="line">centroids[i, :] = dataSet[index, :]</span><br><span class="line"><span class="keyword">return</span> centroids</span><br><span class="line"> </span><br><span class="line"><span class="comment"># k-means cluster</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span>(<span class="params">dataSet, k</span>):</span></span><br><span class="line">numSamples = dataSet.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># first column stores which cluster this sample belongs to,</span></span><br><span class="line"><span class="comment"># second column stores the error between this sample and its centroid</span></span><br><span class="line">clusterAssment = mat(zeros((numSamples, <span class="number">2</span>)))</span><br><span class="line">clusterChanged = <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## step 1: init centroids</span></span><br><span class="line">centroids = initCentroids(dataSet, k)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> clusterChanged:</span><br><span class="line">clusterChanged = <span class="literal">False</span></span><br><span class="line"><span class="comment">## for each sample</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(numSamples):</span><br><span class="line">minDist  = <span class="number">100000.0</span></span><br><span class="line">minIndex = <span class="number">0</span></span><br><span class="line"><span class="comment">## for each centroid</span></span><br><span class="line"><span class="comment">## step 2: find the centroid who is closest</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">distance = euclDistance(centroids[j, :], dataSet[i, :])</span><br><span class="line"><span class="keyword">if</span> distance &lt; minDist:</span><br><span class="line">minDist  = distance</span><br><span class="line">minIndex = j</span><br><span class="line"></span><br><span class="line"><span class="comment">## step 3: update its cluster</span></span><br><span class="line"><span class="keyword">if</span> clusterAssment[i, <span class="number">0</span>] != minIndex:</span><br><span class="line">clusterChanged = <span class="literal">True</span></span><br><span class="line">clusterAssment[i, :] = minIndex, minDist**<span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## step 4: update centroids</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">pointsInCluster = dataSet[nonzero(clusterAssment[:, <span class="number">0</span>].A == j)[<span class="number">0</span>]]</span><br><span class="line">centroids[j, :] = mean(pointsInCluster, axis = <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Congratulations, cluster complete!&#x27;</span></span><br><span class="line"><span class="keyword">return</span> centroids, clusterAssment</span><br><span class="line"> </span><br><span class="line"><span class="comment"># show your cluster only available with 2-D data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showCluster</span>(<span class="params">dataSet, k, centroids, clusterAssment</span>):</span></span><br><span class="line">numSamples, dim = dataSet.shape</span><br><span class="line"><span class="keyword">if</span> dim != <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Sorry! I can not draw because the dimension of your data is not 2!&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">mark = [<span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;ob&#x27;</span>, <span class="string">&#x27;og&#x27;</span>, <span class="string">&#x27;ok&#x27;</span>, <span class="string">&#x27;^r&#x27;</span>, <span class="string">&#x27;+r&#x27;</span>, <span class="string">&#x27;sr&#x27;</span>, <span class="string">&#x27;dr&#x27;</span>, <span class="string">&#x27;&lt;r&#x27;</span>, <span class="string">&#x27;pr&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> k &gt; <span class="built_in">len</span>(mark):</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Sorry! Your k is too large! please contact Zouxy&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># draw all samples</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(numSamples):</span><br><span class="line">markIndex = <span class="built_in">int</span>(clusterAssment[i, <span class="number">0</span>])</span><br><span class="line">plt.plot(dataSet[i, <span class="number">0</span>], dataSet[i, <span class="number">1</span>], mark[markIndex])</span><br><span class="line"> </span><br><span class="line">mark = [<span class="string">&#x27;Dr&#x27;</span>, <span class="string">&#x27;Db&#x27;</span>, <span class="string">&#x27;Dg&#x27;</span>, <span class="string">&#x27;Dk&#x27;</span>, <span class="string">&#x27;^b&#x27;</span>, <span class="string">&#x27;+b&#x27;</span>, <span class="string">&#x27;sb&#x27;</span>, <span class="string">&#x27;db&#x27;</span>, <span class="string">&#x27;&lt;b&#x27;</span>, <span class="string">&#x27;pb&#x27;</span>]</span><br><span class="line"><span class="comment"># draw the centroids</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">plt.plot(centroids[i, <span class="number">0</span>], centroids[i, <span class="number">1</span>], mark[i], markersize = <span class="number">12</span>)</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试数据是二维的，共80个样本。有4个类。如下：</p><h3 id="testSet-txt："><a href="#testSet-txt：" class="headerlink" title="testSet.txt："></a>testSet.txt：</h3><p>测试结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.658985</span><span class="number">4.285136</span></span><br><span class="line">-<span class="number">3.453687</span><span class="number">3.424321</span></span><br><span class="line"><span class="number">4.838138</span>-<span class="number">1.151539</span></span><br><span class="line">-<span class="number">5.379713</span>-<span class="number">3.362104</span></span><br><span class="line"><span class="number">0.972564</span><span class="number">2.924086</span></span><br><span class="line">-<span class="number">3.567919</span><span class="number">1.531611</span></span><br><span class="line"><span class="number">0.450614</span>-<span class="number">3.302219</span></span><br><span class="line">-<span class="number">3.487105</span>-<span class="number">1.724432</span></span><br><span class="line"><span class="number">2.668759</span><span class="number">1.594842</span></span><br><span class="line">-<span class="number">3.156485</span><span class="number">3.191137</span></span><br><span class="line"><span class="number">3.165506</span>-<span class="number">3.999838</span></span><br><span class="line">-<span class="number">2.786837</span>-<span class="number">3.099354</span></span><br><span class="line"><span class="number">4.208187</span><span class="number">2.984927</span></span><br><span class="line">-<span class="number">2.123337</span><span class="number">2.943366</span></span><br><span class="line"><span class="number">0.704199</span>-<span class="number">0.479481</span></span><br><span class="line">-<span class="number">0.392370</span>-<span class="number">3.963704</span></span><br><span class="line"><span class="number">2.831667</span><span class="number">1.574018</span></span><br><span class="line">-<span class="number">0.790153</span><span class="number">3.343144</span></span><br><span class="line"><span class="number">2.943496</span>-<span class="number">3.357075</span></span><br><span class="line">-<span class="number">3.195883</span>-<span class="number">2.283926</span></span><br><span class="line"><span class="number">2.336445</span><span class="number">2.875106</span></span><br><span class="line">-<span class="number">1.786345</span><span class="number">2.554248</span></span><br><span class="line"><span class="number">2.190101</span>-<span class="number">1.906020</span></span><br><span class="line">-<span class="number">3.403367</span>-<span class="number">2.778288</span></span><br><span class="line"><span class="number">1.778124</span><span class="number">3.880832</span></span><br><span class="line">-<span class="number">1.688346</span><span class="number">2.230267</span></span><br><span class="line"><span class="number">2.592976</span>-<span class="number">2.054368</span></span><br><span class="line">-<span class="number">4.007257</span>-<span class="number">3.207066</span></span><br><span class="line"><span class="number">2.257734</span><span class="number">3.387564</span></span><br><span class="line">-<span class="number">2.679011</span><span class="number">0.785119</span></span><br><span class="line"><span class="number">0.939512</span>-<span class="number">4.023563</span></span><br><span class="line">-<span class="number">3.674424</span>-<span class="number">2.261084</span></span><br><span class="line"><span class="number">2.046259</span><span class="number">2.735279</span></span><br><span class="line">-<span class="number">3.189470</span><span class="number">1.780269</span></span><br><span class="line"><span class="number">4.372646</span>-<span class="number">0.822248</span></span><br><span class="line">-<span class="number">2.579316</span>-<span class="number">3.497576</span></span><br><span class="line"><span class="number">1.889034</span><span class="number">5.190400</span></span><br><span class="line">-<span class="number">0.798747</span><span class="number">2.185588</span></span><br><span class="line"><span class="number">2.836520</span>-<span class="number">2.658556</span></span><br><span class="line">-<span class="number">3.837877</span>-<span class="number">3.253815</span></span><br><span class="line"><span class="number">2.096701</span><span class="number">3.886007</span></span><br><span class="line">-<span class="number">2.709034</span><span class="number">2.923887</span></span><br><span class="line"><span class="number">3.367037</span>-<span class="number">3.184789</span></span><br><span class="line">-<span class="number">2.121479</span>-<span class="number">4.232586</span></span><br><span class="line"><span class="number">2.329546</span><span class="number">3.179764</span></span><br><span class="line">-<span class="number">3.284816</span><span class="number">3.273099</span></span><br><span class="line"><span class="number">3.091414</span>-<span class="number">3.815232</span></span><br><span class="line">-<span class="number">3.762093</span>-<span class="number">2.432191</span></span><br><span class="line"><span class="number">3.542056</span><span class="number">2.778832</span></span><br><span class="line">-<span class="number">1.736822</span><span class="number">4.241041</span></span><br><span class="line"><span class="number">2.127073</span>-<span class="number">2.983680</span></span><br><span class="line">-<span class="number">4.323818</span>-<span class="number">3.938116</span></span><br><span class="line"><span class="number">3.792121</span><span class="number">5.135768</span></span><br><span class="line">-<span class="number">4.786473</span><span class="number">3.358547</span></span><br><span class="line"><span class="number">2.624081</span>-<span class="number">3.260715</span></span><br><span class="line">-<span class="number">4.009299</span>-<span class="number">2.978115</span></span><br><span class="line"><span class="number">2.493525</span><span class="number">1.963710</span></span><br><span class="line">-<span class="number">2.513661</span><span class="number">2.642162</span></span><br><span class="line"><span class="number">1.864375</span>-<span class="number">3.176309</span></span><br><span class="line">-<span class="number">3.171184</span>-<span class="number">3.572452</span></span><br><span class="line"><span class="number">2.894220</span><span class="number">2.489128</span></span><br><span class="line">-<span class="number">2.562539</span><span class="number">2.884438</span></span><br><span class="line"><span class="number">3.491078</span>-<span class="number">3.947487</span></span><br><span class="line">-<span class="number">2.565729</span>-<span class="number">2.012114</span></span><br><span class="line"><span class="number">3.332948</span><span class="number">3.983102</span></span><br><span class="line">-<span class="number">1.616805</span><span class="number">3.573188</span></span><br><span class="line"><span class="number">2.280615</span>-<span class="number">2.559444</span></span><br><span class="line">-<span class="number">2.651229</span>-<span class="number">3.103198</span></span><br><span class="line"><span class="number">2.321395</span><span class="number">3.154987</span></span><br><span class="line">-<span class="number">1.685703</span><span class="number">2.939697</span></span><br><span class="line"><span class="number">3.031012</span>-<span class="number">3.620252</span></span><br><span class="line">-<span class="number">4.599622</span>-<span class="number">2.185829</span></span><br><span class="line"><span class="number">4.196223</span><span class="number">1.126677</span></span><br><span class="line">-<span class="number">2.133863</span><span class="number">3.093686</span></span><br><span class="line"><span class="number">4.668892</span>-<span class="number">2.562705</span></span><br><span class="line">-<span class="number">2.793241</span>-<span class="number">2.149706</span></span><br><span class="line"><span class="number">2.884105</span><span class="number">3.043438</span></span><br><span class="line">-<span class="number">2.967647</span><span class="number">2.848696</span></span><br><span class="line"><span class="number">4.479332</span>-<span class="number">1.764772</span></span><br><span class="line">-<span class="number">4.905566</span>-<span class="number">2.911070</span></span><br></pre></td></tr></table></figure><h3 id="test-kmeans-py"><a href="#test-kmeans-py" class="headerlink" title="test_kmeans.py"></a>test_kmeans.py</h3><p>测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment"># kmeans: k-means cluster</span></span><br><span class="line"><span class="comment"># Author : zouxy</span></span><br><span class="line"><span class="comment"># Date   : 2013-12-25</span></span><br><span class="line"><span class="comment"># HomePage : http://blog.csdn.net/zouxy09</span></span><br><span class="line"><span class="comment"># Email  : zouxy09@qq.com</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment">## step 1: load data</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;step 1: load data...&quot;</span></span><br><span class="line">dataSet = []</span><br><span class="line">fileIn = <span class="built_in">open</span>(<span class="string">&#x27;E:/Python/Machine Learning in Action/testSet.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileIn.readlines():</span><br><span class="line">lineArr = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">dataSet.append([<span class="built_in">float</span>(lineArr[<span class="number">0</span>]), <span class="built_in">float</span>(lineArr[<span class="number">1</span>])])</span><br><span class="line"> </span><br><span class="line"><span class="comment">## step 2: clustering...</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;step 2: clustering...&quot;</span></span><br><span class="line">dataSet = mat(dataSet)</span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">centroids, clusterAssment = kmeans(dataSet, k)</span><br><span class="line"> </span><br><span class="line"><span class="comment">## step 3: show the result</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;step 3: show the result...&quot;</span></span><br><span class="line">showCluster(dataSet, k, centroids, clusterAssment)</span><br></pre></td></tr></table></figure><p>运行的前后结果对比：</p><p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191526187.png" alt="结果对比"></p><p>不同的类用不同的颜色来表示，其中的大菱形是对应类的均值质心点。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>k-means算法比较简单，但也有几个比较大的缺点：</p><ul><li>（1）k值的选择是用户指定的，不同的k得到的结果会有挺大的不同，如下图所示，左边是k=3的结果，这个就太稀疏了，蓝色的那个簇其实是可以再划分成两个簇的。而右图是k=5的结果，可以看到红色菱形和蓝色菱形这两个簇应该是可以合并成一个簇的：</li></ul><p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191547703.png" alt="不同结果"></p><ul><li>（2）对k个初始质心的选择比较敏感，容易陷入局部最小值。例如，我们上面的算法运行的时候，有可能会得到不同的结果，如下面这两种情况。K-means也是收敛了，只是收敛到了局部最小值：</li></ul><p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191601093.png" alt="局部最优解"></p><ul><li>（3）存在局限性，如下面这种非球状的数据分布就搞不定了：</li></ul><p><img src="/2021/09/21/numpy-k%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB/20131226191615171.png" alt="非球状的数据分布"></p><ul><li>（4）数据库比较大的时候，收敛会比较慢。</li></ul><p>k-means老早就出现在江湖了。所以以上的这些不足也被世人的目光敏锐的捕捉到，并融入世人的智慧进行了某种程度上的改良。例如问题（1）对k的选择可以先用一些算法分析数据的分布，如重心和密度等，然后选择合适的k。而对问题（2），有人提出了另一个成为二分k均值（bisecting k-means）算法，它对初始的k个质心的选择就不太敏感，这个算法我们下一个博文再分析和实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NumPy-实现k均值聚类算法（k-means）&quot;&gt;&lt;a href=&quot;#NumPy-实现k均值聚类算法（k-means）&quot; class=&quot;headerlink&quot; title=&quot;NumPy 实现k均值聚类算法（k-means）&quot;&gt;&lt;/a&gt;NumPy 实现k均值聚类算</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>numpy数组编程</title>
    <link href="http://rczmm.github.io/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/"/>
    <id>http://rczmm.github.io/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/</id>
    <published>2021-09-21T14:44:46.000Z</published>
    <updated>2021-09-21T14:49:43.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-NumPy-进行数组编程"><a href="#使用-NumPy-进行数组编程" class="headerlink" title="使用 NumPy 进行数组编程"></a>使用 NumPy 进行数组编程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人们有时会说，与C++这种低级语言相比，Python以运行速度为代价改善了开发时间和效率。幸运的是，有一些方法可以在不牺牲易用性的情况下加速Python中的操作运行时。适用于快速数值运算的一个选项是NumPy，它当之无愧地将自己称为使用Python进行科学计算的基本软件包。</p><p>当然，很少有人将50微秒（百万分之五十秒）的东西归类为“慢”。然而，计算机可能会有所不同。运行50微秒（50微秒）的运行时属于微执行领域，可以松散地定义为运行时间在1微秒和1毫秒之间的运算。</p><p>为什么速度很重要？微观性能值得监控的原因是运行时的小差异会随着重复的函数调用而放大：增量50μs的开销，重复超过100万次函数调用，转换为50秒的增量运行时间。</p><p>在计算方面，实际上有三个概念为NumPy提供了强大的功能：</p><ul><li>矢量化</li><li>广播</li><li>索引</li></ul><p>在本教程中，你将逐步了解<strong>如何利用矢量化和广播</strong>，以便你可以充分使用NumPy。虽然你在这里将使用一些索引，但NumPy的完整索引原理图(它扩展了Python的<a href="https://www.numpy.org.cn/article/advanced/(https://docs.python.org/3/reference/expressions.html?highlight=slice#slicings)">切片语法</a>)是它们自己的工具。如果你想了解有关<a href="https://www.numpy.org.cn/reference/array_objects/indexing.html">NumPy索引</a>的更多信息，请喝点咖啡，然后前往NumPy文档中的索引部分。</p><h2 id="进入状态：介绍NumPy数组"><a href="#进入状态：介绍NumPy数组" class="headerlink" title="进入状态：介绍NumPy数组"></a>进入状态：介绍NumPy数组</h2><p>NumPy的基本对象是它的ndarray（或numpy.array），这是一个n维数组，它也以某种形式出现在面向数组的语言中，如Fortran 90、R和MATLAB，以及以前的 APL 和 J。</p><p>让我们从形成一个包含36个元素的三维数组开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">36</span>).reshape(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>],</span><br><span class="line">        [<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>],</span><br><span class="line">        [<span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>],</span><br><span class="line">        [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>],</span><br><span class="line">        [<span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]]])</span><br></pre></td></tr></table></figure><p>在二维中描绘高维数组可能会比较困难。考虑数组形状的一种直观方法是简单地“从左到右读取它”。arr 是一个3乘4乘3的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>在视觉上，arr可以被认为是三个4x3网格（或矩形棱镜）的容器，看起来像这样：</p><p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/arr3d.7442cd4e11c6.jpg" alt="NumPy三维数组"></p><p>更高维度的数组可能更难以用图像表达出来，但它们仍将遵循这种“数组内的数组”模式。</p><p>你在哪里可以看到超过两个维度的数据？</p><ul><li><a href="https://en.wikipedia.org/wiki/Panel_data">面板数据</a>可以用三维表示。跟踪个体群组（群体）随时间变化的数据可以被构造为（受访者，日期，属性）。 1979年<a href="https://www.nlsinfo.org/content/cohorts/nlsy79">全国青年纵向调查（iq调查）</a>对27岁以上的12,686名受访者进行了调查。假设每个人每年有大约500个直接询问或派生的数据点，这些数据将具有形状（12686,27,500），总共177,604,000个数据点。</li><li>用于多幅图像的彩色图像数据通常存储在四个维度中。每个图像是一个三维数组(高度、宽度、通道)，通道通常是红色、绿色和蓝色(RGB)值。然后，图像的集合就是(图像数、高度、宽度、通道)。1，000张256x256 RGB图像将具有形状(1000，256，256，3)。(扩展的表示是RGBA，其中A-alpha-表示不透明的级别。)。</li></ul><h2 id="什么是矢量化？"><a href="#什么是矢量化？" class="headerlink" title="什么是矢量化？"></a>什么是矢量化？</h2><p>矢量化是NumPy中的一种强大功能，可以将操作表达为在整个数组上而不是在各个元素上发生。以下是Wes McKinney的简明定义：</p><blockquote><p>这种用数组表达式替换显式循环的做法通常称为向量化。通常，矢量化数组操作通常比其纯Python等价物快一个或两个（或更多）数量级，在任何类型的数值计算中都具有最大的影响。</p></blockquote><p>在Python中循环数组或任何数据结构时，会涉及很多开销。 NumPy中的向量化操作将内部循环委托给高度优化的C和Fortran函数，从而实现更清晰，更快速的Python代码。</p><h3 id="计数-简单的如：1-2-3…"><a href="#计数-简单的如：1-2-3…" class="headerlink" title="计数: 简单的如：1, 2, 3…"></a>计数: 简单的如：1, 2, 3…</h3><p>作为示例，考虑一个True和False的一维向量，你要为其计算序列中“False to True”转换的数量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.random.seed(<span class="number">444</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.random.choice([<span class="literal">False</span>, <span class="literal">True</span>], size=<span class="number">100000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>, ...,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>])</span><br></pre></td></tr></table></figure><p>使用Python for循环，一种方法是成对地评估序列中每个元素的<a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing">真值</a>以及紧随其后的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">count_transitions</span>(<span class="params">x</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(x[:-<span class="number">1</span>], x[<span class="number">1</span>:]):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> j <span class="keyword">and</span> <span class="keyword">not</span> i:</span><br><span class="line"><span class="meta">... </span>            count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> count</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_transitions(x)</span><br><span class="line"><span class="number">24984</span></span><br></pre></td></tr></table></figure><p>在矢量化形式中，没有明确的for循环或直接引用各个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.count_nonzero(x[:-<span class="number">1</span>] &lt; x[<span class="number">1</span>:])</span><br><span class="line"><span class="number">24984</span></span><br></pre></td></tr></table></figure><p>这两个等效函数在性能方面有何比较？ 在这种特殊情况下，向量化的NumPy调用胜出约70倍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setup = <span class="string">&#x27;from __main__ import count_transitions, x; import numpy as np&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = timeit(<span class="string">&#x27;count_transitions(x)&#x27;</span>, setup=setup, number=num)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = timeit(<span class="string">&#x27;np.count_nonzero(x[:-1] &lt; x[1:])&#x27;</span>, setup=setup, number=num)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Speed difference: &#123;:0.1f&#125;x&#x27;</span>.<span class="built_in">format</span>(t1 / t2))</span><br><span class="line">Speed difference: <span class="number">71.0</span>x</span><br></pre></td></tr></table></figure><p><strong>技术细节</strong>: 另一个术语是<a href="https://blogs.msdn.microsoft.com/nativeconcurrency/2012/04/12/what-is-vectorization/">矢量处理器</a>，它与计算机的硬件有关。 当我在这里谈论矢量化时，我指的是用数组表达式替换显式for循环的概念，在这种情况下，可以使用低级语言在内部计算。</p><h3 id="买低，卖高"><a href="#买低，卖高" class="headerlink" title="买低，卖高"></a>买低，卖高</h3><p>这是另一个激发你胃口的例子。考虑以下经典技术面试问题：</p><blockquote><p>假定一只股票的历史价格是一个序列，假设你只允许进行一次购买和一次出售，那么可以获得的最大利润是多少？例如，假设价格=(20，18，14，17，20，21，15)，最大利润将是7，从14买到21卖。</p></blockquote><p>(对所有金融界人士说：不，卖空是不允许的。)</p><p>存在具有n平方<a href="https://www.numpy.org.cn/article/advanced/(https://en.wikipedia.org/wiki/Time_complexity)">时间复杂度</a>的解决方案，其包括采用两个价格的每个组合，其中第二价格“在第一个之后”并且确定最大差异。</p><p>然而，还有一个O(n)解决方案，它包括迭代序列一次，找出每个价格和运行最小值之间的差异。 它是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">profit</span>(<span class="params">prices</span>):</span></span><br><span class="line"><span class="meta">... </span>    max_px = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    min_px = prices[<span class="number">0</span>]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> px <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line"><span class="meta">... </span>        min_px = <span class="built_in">min</span>(min_px, px)</span><br><span class="line"><span class="meta">... </span>        max_px = <span class="built_in">max</span>(px - min_px, max_px)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> max_px</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = (<span class="number">20</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>profit(prices)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>这可以用NumPy实现吗？行!没问题。但首先，让我们构建一个准现实的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create mostly NaN array with a few &#x27;turning points&#x27; (local min/max).</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = np.full(<span class="number">100</span>, fill_value=np.nan)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices[[<span class="number">0</span>, <span class="number">25</span>, <span class="number">60</span>, -<span class="number">1</span>]] = [<span class="number">80.</span>, <span class="number">30.</span>, <span class="number">75.</span>, <span class="number">50.</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linearly interpolate the missing values and add some noise.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.arange(<span class="built_in">len</span>(prices))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>is_valid = ~np.isnan(prices)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = np.interp(x=x, xp=x[is_valid], fp=prices[is_valid])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices += np.random.randn(<span class="built_in">len</span>(prices)) * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>下面是matplotlib的示例。俗话说：买低(绿)，卖高(红)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Warning! This isn&#x27;t a fully correct solution, but it works for now.</span></span><br><span class="line"><span class="comment"># If the absolute min came after the absolute max, you&#x27;d have trouble.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mn = np.argmin(prices)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mx = mn + np.argmax(prices[mn:])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwargs = &#123;<span class="string">&#x27;markersize&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;linestyle&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fig, ax = plt.subplots()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.plot(prices)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_title(<span class="string">&#x27;Price History&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_xlabel(<span class="string">&#x27;Time&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_ylabel(<span class="string">&#x27;Price&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.plot(mn, prices[mn], color=<span class="string">&#x27;green&#x27;</span>, **kwargs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.plot(mx, prices[mx], color=<span class="string">&#x27;red&#x27;</span>, **kwargs)</span><br></pre></td></tr></table></figure><p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/prices.664958f44799.png" alt="以序列形式显示股票价格历史的图解"></p><p>NumPy实现是什么样的？ 虽然没有np.cummin() “直接”，但NumPy的<a href="https://www.numpy.org.cn/reference/ufuncs/index.html">通用函数（ufuncs）</a>都有一个accumulate()方法，它的名字暗示了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cummin = np.minimum.accumulate</span><br></pre></td></tr></table></figure><p>从纯Python示例扩展逻辑，你可以找到每个价格和运行最小值（元素方面）之间的差异，然后获取此序列的最大值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">profit_with_numpy</span>(<span class="params">prices</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Price minus cumulative minimum price, element-wise.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    prices = np.asarray(prices)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> np.<span class="built_in">max</span>(prices - cummin(prices))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>profit_with_numpy(prices)</span><br><span class="line"><span class="number">44.2487532293278</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.allclose(profit_with_numpy(prices), profit(prices))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这两个具有相同理论时间复杂度的操作如何在实际运行时进行比较？ 首先，让我们采取更长的序列。（此时不一定需要是股票价格的时间序列。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, size=<span class="number">100000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq</span><br><span class="line">array([ <span class="number">3</span>, <span class="number">23</span>,  <span class="number">8</span>, <span class="number">67</span>, <span class="number">52</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">72</span>, <span class="number">41</span>, <span class="number">10</span>, ..., <span class="number">46</span>,  <span class="number">8</span>, <span class="number">90</span>, <span class="number">95</span>, <span class="number">93</span>,</span><br><span class="line">       <span class="number">28</span>, <span class="number">24</span>, <span class="number">88</span>, <span class="number">24</span>, <span class="number">49</span>])</span><br></pre></td></tr></table></figure><p>现在，对于一个有点不公平的比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>setup = (<span class="string">&#x27;from __main__ import profit_with_numpy, profit, seq;&#x27;</span></span><br><span class="line"><span class="meta">... </span>         <span class="string">&#x27; import numpy as np&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">250</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pytime = timeit(<span class="string">&#x27;profit(seq)&#x27;</span>, setup=setup, number=num)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nptime = timeit(<span class="string">&#x27;profit_with_numpy(seq)&#x27;</span>, setup=setup, number=num)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;Speed difference: &#123;:0.1f&#125;x&#x27;</span>.<span class="built_in">format</span>(pytime / nptime))</span><br><span class="line">Speed difference: <span class="number">76.0</span>x</span><br></pre></td></tr></table></figure><p>在上面，将profit_with_numpy() 视为伪代码（不考虑NumPy的底层机制），实际上有三个遍历序列：</p><ul><li>cummin(prices) 具有O(n)时间复杂度</li><li>prices - cummin(prices) 是 O(n)的时间复杂度</li><li>max(…) 是O(n)的时间复杂度</li></ul><p>这就减少到O(n)，因为O(3n)只剩下O(n)-当n接近无穷大时，n “占主导地位”。</p><p>因此，这两个函数具有等价的最坏情况时间复杂度。(不过，顺便提一下，NumPy函数的空间复杂度要高得多。)。但这可能是最不重要的内容。这里我们有一个教训是：虽然理论上的时间复杂性是一个重要的考虑因素，运行时机制也可以发挥很大的作用。NumPy不仅可以委托给C，而且通过一些元素操作和线性代数，它还可以利用多线程中的计算。但是这里有很多因素在起作用，包括所使用的底层库(BLAS/LAPACK/Atlas)，而这些细节完全是另一篇文章的全部内容。</p><h2 id="Intermezzo：理解轴符号"><a href="#Intermezzo：理解轴符号" class="headerlink" title="Intermezzo：理解轴符号"></a>Intermezzo：理解轴符号</h2><p>在NumPy中，轴指向多维数组的单个维度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"><span class="meta">... </span>                [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">array([ <span class="number">6</span>, <span class="number">60</span>])</span><br></pre></td></tr></table></figure><p>围绕轴的术语和描述它们的方式可能有点不直观。在Pandas(在NumPy之上构建的库)的文档中，你可能经常看到如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axis : &#123;&#x27;index&#x27; (0), &#x27;columns&#x27; (1)&#125;</span><br></pre></td></tr></table></figure><p>根据这一描述，你可以争辩说，上面的结果应该是“反向的”。但是，关键是轴指向调用函数的轴。杰克·范德普拉斯很好地阐述了这一点：</p><blockquote><p>此处指定轴的方式可能会让来自其他语言的用户感到困惑。AXIS关键字指定将折叠的数组的维度，而不是将要返回的维度。因此，指定Axis=0意味着第一个轴将折叠：对于二维数组，这意味着每列中的值将被聚合。</p></blockquote><p>换句话说，如果将AXIS=0的数组相加，则会使用按列计算的方式折叠数组的行。</p><p>考虑到这一区别，让我们继续探讨广播的概念。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播是另一个重要的NumPy抽象。你已经看到了两个NumPy数组(大小相等)之间的操作是按元素操作的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">10.</span>, <span class="number">5.</span>, <span class="number">1.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a / b</span><br><span class="line">array([<span class="number">0.15</span>, <span class="number">0.5</span> , <span class="number">3.5</span> ])</span><br></pre></td></tr></table></figure><p>但是，大小不相等的数组呢？这就是广播的意义所在：</p><blockquote><p>术语广播描述了在算术运算期间NumPy如何处理具有不同形状的数组。受某些约束条件的限制，较小的数组会在较大的数组中“广播”，以便它们具有兼容的形状。广播提供了一种向量化数组操作的方法，因此循环是在C而不是Python中进行的。</p></blockquote><p>当使用两个以上的数组时，广播的实现方式可能会变得乏味。但是，如果只有两个数组，那么可以用两条简短的规则来描述它们的广播能力：</p><blockquote><p>在对两个数组进行操作时，NumPy按元素对它们的形状进行比较。它从尾随维度开始，然后继续前进。两个维度在下列情况下是兼容的：</p><ul><li>他们是平等的，或者</li><li>其中一个是1</li></ul></blockquote><p>非那样做不行。</p><p>让我们以一个例子为例，我们想要减去数组的每个列的平均值，元素的平均值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample = np.random.normal(loc=[<span class="number">2.</span>, <span class="number">20.</span>], scale=[<span class="number">1.</span>, <span class="number">3.5</span>],</span><br><span class="line"><span class="meta">... </span>                          size=(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample</span><br><span class="line">array([[ <span class="number">1.816</span> , <span class="number">23.703</span> ],</span><br><span class="line">       [ <span class="number">2.8395</span>, <span class="number">12.2607</span>],</span><br><span class="line">       [ <span class="number">3.5901</span>, <span class="number">24.2115</span>]])</span><br></pre></td></tr></table></figure><p>在统计术语中，样本由两个独立于两个总体的样本(列)组成，平均值分别为2和20。按列分列的方法应该近似于总体方法(尽管是粗略的，因为样本很小)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mu = sample.mean(axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mu</span><br><span class="line">array([ <span class="number">2.7486</span>, <span class="number">20.0584</span>])</span><br></pre></td></tr></table></figure><p>现在，减去列意义是很简单的，因为广播规则检查出来了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;sample:&#x27;</span>, sample.shape, <span class="string">&#x27;| means:&#x27;</span>, mu.shape)</span><br><span class="line">sample: (<span class="number">3</span>, <span class="number">2</span>) | means: (<span class="number">2</span>,)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample - mu</span><br><span class="line">array([[-<span class="number">0.9325</span>,  <span class="number">3.6446</span>],</span><br><span class="line">       [ <span class="number">0.091</span> , -<span class="number">7.7977</span>],</span><br><span class="line">       [ <span class="number">0.8416</span>,  <span class="number">4.1531</span>]])</span><br></pre></td></tr></table></figure><p>下面是一个减去列意义的示例，其中较小的数组被“拉伸”，以便从较大的数组的每一行中减去它：</p><p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/broadcasting.084a0e28dea8.jpg" alt="NumPy数组广播"></p><p><strong>技术细节</strong>：较小的数组或标量不是按字面意义上在内存中展开的：重复的是计算本身。</p><p>这扩展到<a href="https://en.wikipedia.org/wiki/Standard_score">标准化</a>每个列，使每个单元格相对于其各自的列具有z-score：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(sample - sample.mean(axis=<span class="number">0</span>)) / sample.std(axis=<span class="number">0</span>)</span><br><span class="line">array([[-<span class="number">1.2825</span>,  <span class="number">0.6605</span>],</span><br><span class="line">       [ <span class="number">0.1251</span>, -<span class="number">1.4132</span>],</span><br><span class="line">       [ <span class="number">1.1574</span>,  <span class="number">0.7527</span>]])</span><br></pre></td></tr></table></figure><p>但是，如果出于某种原因，要减去行最小值，该怎么办？你会遇到这样的麻烦：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample - sample.<span class="built_in">min</span>(axis=<span class="number">1</span>)</span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">3</span>,<span class="number">2</span>) (<span class="number">3</span>,)</span><br></pre></td></tr></table></figure><p>这里的问题是，较小的数组，在其目前的形式，不能“伸展”，以形状与样本兼容。实际上，你需要扩展它的维度，以满足上面的广播规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample.<span class="built_in">min</span>(axis=<span class="number">1</span>)[:, <span class="literal">None</span>]  <span class="comment"># 3 minimums across 3 rows</span></span><br><span class="line">array([[<span class="number">1.816</span> ],</span><br><span class="line">       [<span class="number">2.8395</span>],</span><br><span class="line">       [<span class="number">3.5901</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample - sample.<span class="built_in">min</span>(axis=<span class="number">1</span>)[:, <span class="literal">None</span>]</span><br><span class="line">array([[ <span class="number">0.</span>    , <span class="number">21.887</span> ],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">9.4212</span>],</span><br><span class="line">       [ <span class="number">0.</span>    , <span class="number">20.6214</span>]])</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: [:, None]是一种扩展数组维度的方法，用于创建长度为1的轴。<a href="https://www.numpy.org.cn/reference/array_objects/indexing.html#numpy.newaxis">np.newaxis</a>是None的别名。</p><p>还有一些更为复杂的案例。下面是任何形状的任意数量的数组可以一起广播的更严格的定义：</p><blockquote><p>如果以下规则产生有效结果，则一组数组被称为“可广播”到相同的形状，这意味着 <strong>以下之一为真</strong> 时：</p><ol><li>矩阵都具有完全相同的形状。</li><li>矩阵都具有相同数量的维度，每个维度的长度是公共长度或1。</li><li>具有太少尺寸的矩列可以使其形状前面具有长度为1的尺寸以满足属性＃2。 </li></ol></blockquote><p>这更容易一步一步走。假设你有以下四个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.sin(np.arange(<span class="number">10</span>)[:, <span class="literal">None</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.random.randn(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.full_like(a, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>在检查形状之前，NumPy首先将标量转换为具有一个元素的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrays = [np.atleast_1d(arr) <span class="keyword">for</span> arr <span class="keyword">in</span> (a, b, c, d)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> arr <span class="keyword">in</span> arrays:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arr.shape)</span><br><span class="line">...</span><br><span class="line">(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure><p>现在我们可以检查标准＃1。如果所有数组具有相同的形状，则它们的一组形状将缩减为一个元素，因为set() 构造函数有效地从其输入中删除重复项。这里显然没有达到这个标准：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">set</span>(arr.shape <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)) == <span class="number">1</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>标准＃2的第一部分也失败了，这意味着整个标准失败：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">set</span>((arr.ndim) <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)) == <span class="number">1</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>最后一个标准更复杂一些：</p><blockquote><p>具有太少尺寸的矩列可以使其形状前面具有长度为1的尺寸以满足属性＃2。</p></blockquote><p>为了对此进行编码，你可以首先确定最高维数组的维度，然后将其添加到每个形状元组，直到所有数组具有相同的维度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>maxdim = <span class="built_in">max</span>(arr.ndim <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)  <span class="comment"># Maximum dimensionality</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shapes = np.array([(<span class="number">1</span>,) * (maxdim - arr.ndim) + arr.shape</span><br><span class="line"><span class="meta">... </span>                   <span class="keyword">for</span> arr <span class="keyword">in</span> arrays])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shapes</span><br><span class="line">array([[<span class="number">10</span>,  <span class="number">1</span>],</span><br><span class="line">       [ <span class="number">1</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">10</span>,  <span class="number">1</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>最后，你需要测试每个维度的长度是否是公共长度，或是1。这样做的一个技巧是首先在“等于”的位置屏蔽“shape-tuples”数组。然后，你可以检查 peak-to-peak（np.ptp()）列方差是否都为零：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>masked = np.ma.masked_where(shapes == <span class="number">1</span>, shapes)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">all</span>(masked.ptp(axis=<span class="number">0</span>) == <span class="number">0</span>)  <span class="comment"># ptp: max - min</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这个逻辑封装在单个函数中，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">can_broadcast</span>(<span class="params">*arrays</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"><span class="meta">... </span>    arrays = [np.atleast_1d(arr) <span class="keyword">for</span> arr <span class="keyword">in</span> arrays]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(arr.shape <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)) == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>((arr.ndim) <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)) == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="meta">... </span>    maxdim = <span class="built_in">max</span>(arr.ndim <span class="keyword">for</span> arr <span class="keyword">in</span> arrays)</span><br><span class="line"><span class="meta">... </span>    shapes = np.array([(<span class="number">1</span>,) * (maxdim - arr.ndim) + arr.shape</span><br><span class="line"><span class="meta">... </span>                       <span class="keyword">for</span> arr <span class="keyword">in</span> arrays])</span><br><span class="line"><span class="meta">... </span>    masked = np.ma.masked_where(shapes == <span class="number">1</span>, shapes)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> np.<span class="built_in">all</span>(masked.ptp(axis=<span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>can_broadcast(a, b, c, d)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>幸运的是，你可以选择一个快捷方式并使用np.cast()来进行这种健全性检查，尽管它并不是为此目的而显式设计的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">can_broadcast</span>(<span class="params">*arrays</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        np.broadcast(*arrays)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>can_broadcast(a, b, c, d)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>对于那些有兴趣深入挖掘的人来说，<a href="https://github.com/numpy/numpy/blob/7dcee7a469ad1bbfef1cd8980dc18bf5869c5391/numpy/core/src/multiarray/iterators.c#L1274">PyArray_Broadcast</a>是封装广播规则的底层C函数。</p><h2 id="矩阵编程实际应用：示例"><a href="#矩阵编程实际应用：示例" class="headerlink" title="矩阵编程实际应用：示例"></a>矩阵编程实际应用：示例</h2><p>在以下3个示例中，你将使用矢量化和广播来处理一些实际应用程序。</p><h3 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h3><p>机器学习是一个可以经常利用矢量化和广播的领域。 假设你有三角形的顶点（每行是x，y坐标）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tri = np.array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line"><span class="meta">... </span>                [<span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line"><span class="meta">... </span>                [<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure><p>这个<a href="https://en.wikipedia.org/wiki/Centroid">“簇”</a>的质心是(x, y)坐标，它是每列的算术平均值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroid = tri.mean(axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroid</span><br><span class="line">array([<span class="number">2.</span>    , <span class="number">1.6667</span>])</span><br></pre></td></tr></table></figure><p>可视化这有助于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>trishape = plt.Polygon(tri, edgecolor=<span class="string">&#x27;r&#x27;</span>, alpha=<span class="number">0.2</span>, lw=<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_, ax = plt.subplots(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.add_patch(trishape)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_ylim([<span class="number">.5</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_xlim([<span class="number">.5</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(*centroid, color=<span class="string">&#x27;g&#x27;</span>, marker=<span class="string">&#x27;D&#x27;</span>, s=<span class="number">70</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(*tri.T, color=<span class="string">&#x27;b&#x27;</span>,  s=<span class="number">70</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/tri.521228ffdca0.png" alt="三角形的图像"></p><p>许多<a href="http://scikit-learn.org/stable/modules/clustering.html">聚类算法</a>利用点集合的欧几里德距离，或者指向原点，或者相对于它们的质心。</p><p>在笛卡尔坐标下，p点和q点之间的欧几里德距离是：</p><p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/euclid.ffdfd280d315.png" alt="点之间欧氏距离的计算公式"></p><p>因此，对于上面的三坐标集，每个点到原点(0, 0) 的欧几里德距离是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(tri**<span class="number">2</span>, axis=<span class="number">1</span>) ** <span class="number">0.5</span>  <span class="comment"># Or: np.sqrt(np.sum(np.square(tri), 1))</span></span><br><span class="line">array([<span class="number">1.4142</span>, <span class="number">3.1623</span>, <span class="number">3.6056</span>])</span><br></pre></td></tr></table></figure><p>你可能会认识到我们实际上只是在寻找附和欧几里德的规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.norm(tri, axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">1.4142</span>, <span class="number">3.1623</span>, <span class="number">3.6056</span>])</span><br></pre></td></tr></table></figure><p>你也可以找到相对于三角形质心的每个点的范数，而不是参考原点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.norm(tri - centroid, axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">1.2019</span>, <span class="number">1.2019</span>, <span class="number">1.3333</span>])</span><br></pre></td></tr></table></figure><p>最后，让我们更进一步：假设你有一个二维数组X和一个多个(x, y) “建议”质心的二维数组。诸如<a href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html">K-Means聚类的算法</a>)通过随机分配初始“建议”质心，然后将每个数据点重新分配到其最接近的质心来工作。从那里开始，计算新的质心，一旦重新生成的标签（质心的编码）在迭代之间不变，算法就会收敛于解。这个个迭代过程的一部分需要计算每个质心中每个点的欧几里德距离：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.repeat([[<span class="number">5</span>, <span class="number">5</span>], [<span class="number">10</span>, <span class="number">10</span>]], [<span class="number">5</span>, <span class="number">5</span>], axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = X + np.random.randn(*X.shape)  <span class="comment"># 2 distinct &quot;blobs&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroids = np.array([[<span class="number">5</span>, <span class="number">5</span>], [<span class="number">10</span>, <span class="number">10</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X</span><br><span class="line">array([[ <span class="number">3.3955</span>,  <span class="number">3.682</span> ],</span><br><span class="line">       [ <span class="number">5.9224</span>,  <span class="number">5.785</span> ],</span><br><span class="line">       [ <span class="number">5.9087</span>,  <span class="number">4.5986</span>],</span><br><span class="line">       [ <span class="number">6.5796</span>,  <span class="number">3.8713</span>],</span><br><span class="line">       [ <span class="number">3.8488</span>,  <span class="number">6.7029</span>],</span><br><span class="line">       [<span class="number">10.1698</span>,  <span class="number">9.2887</span>],</span><br><span class="line">       [<span class="number">10.1789</span>,  <span class="number">9.8801</span>],</span><br><span class="line">       [ <span class="number">7.8885</span>,  <span class="number">8.7014</span>],</span><br><span class="line">       [ <span class="number">8.6206</span>,  <span class="number">8.2016</span>],</span><br><span class="line">       [ <span class="number">8.851</span> , <span class="number">10.0091</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroids</span><br><span class="line">array([[ <span class="number">5</span>,  <span class="number">5</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure><p>换句话说，我们想回答这个问题，X中的每个点所属的质心是什么？ 为了计算X中每个点与质心中每个点之间的欧几里德距离，我们需要进行一些重构以在此处启用广播：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroids[:, <span class="literal">None</span>]</span><br><span class="line">array([[[ <span class="number">5</span>,  <span class="number">5</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">10</span>, <span class="number">10</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>centroids[:, <span class="literal">None</span>].shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这使我们能够使用一个数组<strong>行的组合乘积</strong>，从另一个数组中清清楚楚地减掉这些数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.norm(X - centroids[:, <span class="literal">None</span>], axis=<span class="number">2</span>).<span class="built_in">round</span>(<span class="number">2</span>)</span><br><span class="line">array([[<span class="number">2.08</span>, <span class="number">1.21</span>, <span class="number">0.99</span>, <span class="number">1.94</span>, <span class="number">2.06</span>, <span class="number">6.72</span>, <span class="number">7.12</span>, <span class="number">4.7</span> , <span class="number">4.83</span>, <span class="number">6.32</span>],</span><br><span class="line">       [<span class="number">9.14</span>, <span class="number">5.86</span>, <span class="number">6.78</span>, <span class="number">7.02</span>, <span class="number">6.98</span>, <span class="number">0.73</span>, <span class="number">0.22</span>, <span class="number">2.48</span>, <span class="number">2.27</span>, <span class="number">1.15</span>]])</span><br></pre></td></tr></table></figure><p>换句话说，X-质心[:, None]的形状是(2，10，2)，本质上表示两个堆叠的数组，每个数组的大小都为X。接下来，我们希望每个最近的质心的标签(索引号)，从上面的数组找出第0轴上的最小距离：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argmin(np.linalg.norm(X - centroids[:, <span class="literal">None</span>], axis=<span class="number">2</span>), axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>你可以将所有这些以函数形式组合在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">get_labels</span>(<span class="params">X, centroids</span>) -&gt; np.ndarray:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> np.argmin(np.linalg.norm(X - centroids[:, <span class="literal">None</span>], axis=<span class="number">2</span>),</span><br><span class="line"><span class="meta">... </span>                     axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>labels = get_labels(X, centroids)</span><br></pre></td></tr></table></figure><p>让我们来直观地检查一下，用一个颜色映射来绘制两个集群和它们指定的标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1, c2 = [<span class="string">&#x27;#bc13fe&#x27;</span>, <span class="string">&#x27;#be0119&#x27;</span>]  <span class="comment"># https://xkcd.com/color/rgb/</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>llim, ulim  = np.trunc([X.<span class="built_in">min</span>() * <span class="number">0.9</span>, X.<span class="built_in">max</span>() * <span class="number">1.1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_, ax = plt.subplots(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(*X.T, c=np.where(labels, c2, c1), alpha=<span class="number">0.4</span>, s=<span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(*centroids.T, c=[c1, c2], marker=<span class="string">&#x27;s&#x27;</span>, s=<span class="number">95</span>,</span><br><span class="line"><span class="meta">... </span>           edgecolor=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_ylim([llim, ulim])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_xlim([llim, ulim])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.set_title(<span class="string">&#x27;One K-Means Iteration: Predicted Classes&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/classes.cdaa3e38d62f.png" alt="预测类颜色映射"></p><h3 id="摊还（分期）表"><a href="#摊还（分期）表" class="headerlink" title="摊还（分期）表"></a>摊还（分期）表</h3><p>矢量化也适用于金融领域。</p><p>给定年利率，支付频率（每年的次数），初始贷款余额和贷款期限，你可以以矢量化方式创建包含月贷款余额和付款的摊还表。让我们先设置一些标量常量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>freq = <span class="number">12</span>     <span class="comment"># 12 months per year</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rate = <span class="number">.0675</span>  <span class="comment"># 6.75% annualized</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nper = <span class="number">30</span>     <span class="comment"># 30 years</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pv = <span class="number">200000</span>   <span class="comment"># Loan face value</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rate /= freq  <span class="comment"># Monthly basis</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nper *= freq  <span class="comment"># 360 months</span></span><br></pre></td></tr></table></figure><p>NumPy预装了一些<a href="https://www.numpy.org.cn/reference/routines/financial.html">财务函数</a>，与<a href="http://www.tvmcalcs.com/index.php/calculators/apps/excel_loan_amortization">Excel表兄弟</a>不同，它们能够以矢量的形式输出。</p><p>债务人（或承租人）每月支付一笔由本金和利息部分组成的固定金额。由于未偿还的贷款余额下降，总付款的利息部分随之下降。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>periods = np.arange(<span class="number">1</span>, nper + <span class="number">1</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>principal = np.ppmt(rate, periods, nper, pv)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>interest = np.ipmt(rate, periods, nper, pv)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pmt = principal + interest  <span class="comment"># Or: pmt = np.pmt(rate, nper, pv)</span></span><br></pre></td></tr></table></figure><p>接下来，你需要计算每月的余额，包括支付前和付款后的余额，可以定义为<a href="http://financeformulas.net/Remaining_Balance_Formula.html">原始余额的未来价值减去年金(支付流)的未来价值</a>，使用折扣因子d：</p><p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/fv.7346eb669ac7.png" alt="原始余额未来价值计算的财务公式图"></p><p>从功能上看，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">balance</span>(<span class="params">pv, rate, nper, pmt</span>) -&gt; np.ndarray:</span></span><br><span class="line"><span class="meta">... </span>    d = (<span class="number">1</span> + rate) ** nper  <span class="comment"># Discount factor</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> pv * d - pmt * (d - <span class="number">1</span>) / rate</span><br></pre></td></tr></table></figure><p>最后，你可以使用Pandas 的 <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html">DataFrame</a> 将其放到表格格式中。小心这里的标志。从债务人的角度看，PMT是一种流出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cols = [<span class="string">&#x27;beg_bal&#x27;</span>, <span class="string">&#x27;prin&#x27;</span>, <span class="string">&#x27;interest&#x27;</span>, <span class="string">&#x27;end_bal&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [balance(pv, rate, periods - <span class="number">1</span>, -pmt),</span><br><span class="line"><span class="meta">... </span>        principal,</span><br><span class="line"><span class="meta">... </span>        interest,</span><br><span class="line"><span class="meta">... </span>        balance(pv, rate, periods, -pmt)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = pd.DataFrame(data, columns=periods, index=cols).T</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table.index.name = <span class="string">&#x27;month&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> pd.option_context(<span class="string">&#x27;display.max_rows&#x27;</span>, <span class="number">6</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># Note: Using floats for $$ in production-level code = bad</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(table.<span class="built_in">round</span>(<span class="number">2</span>))</span><br><span class="line">...</span><br><span class="line">         beg_bal     prin  interest    end_bal</span><br><span class="line">month</span><br><span class="line"><span class="number">1</span>      <span class="number">200000.00</span>  -<span class="number">172.20</span>  -<span class="number">1125.00</span>  <span class="number">199827.80</span></span><br><span class="line"><span class="number">2</span>      <span class="number">199827.80</span>  -<span class="number">173.16</span>  -<span class="number">1124.03</span>  <span class="number">199654.64</span></span><br><span class="line"><span class="number">3</span>      <span class="number">199654.64</span>  -<span class="number">174.14</span>  -<span class="number">1123.06</span>  <span class="number">199480.50</span></span><br><span class="line"><span class="meta">... </span>         ...      ...       ...        ...</span><br><span class="line"><span class="number">358</span>      <span class="number">3848.22</span> -<span class="number">1275.55</span>    -<span class="number">21.65</span>    <span class="number">2572.67</span></span><br><span class="line"><span class="number">359</span>      <span class="number">2572.67</span> -<span class="number">1282.72</span>    -<span class="number">14.47</span>    <span class="number">1289.94</span></span><br><span class="line"><span class="number">360</span>      <span class="number">1289.94</span> -<span class="number">1289.94</span>     -<span class="number">7.26</span>      -<span class="number">0.00</span></span><br></pre></td></tr></table></figure><p>At the end of year 30, the loan is paid off:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>final_month = periods[-<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.allclose(table.loc[final_month, <span class="string">&#x27;end_bal&#x27;</span>], <span class="number">0</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 虽然使用浮点数代表资金对于脚本环境中的概念说明非常有用，但在生产环境中使用Python浮点数进行财务计算可能会导致计算在某些情况下损失一两分钱。</p><h3 id="图像特征提取"><a href="#图像特征提取" class="headerlink" title="图像特征提取"></a>图像特征提取</h3><p>在最后一个例子中，我们将处理1941年10月莱克星顿号航空母舰(CV-2)的<a href="https://www.history.navy.mil/our-collections/photography/numerical-list-of-images/nara-series/80-g/80-G-410000/80-G-416362.html">照片</a>，这艘船的残骸是2018年3月在澳大利亚海岸外发现的。首先，我们可以将图像映射到它的像素值的NumPy数组中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = (<span class="string">&#x27;https://www.history.navy.mil/bin/imageDownload?image=/&#x27;</span></span><br><span class="line"><span class="meta">... </span>       <span class="string">&#x27;content/dam/nhhc/our-collections/photography/images/&#x27;</span></span><br><span class="line"><span class="meta">... </span>       <span class="string">&#x27;80-G-410000/80-G-416362&amp;rendition=cq5dam.thumbnail.319.319.png&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img = io.imread(url, as_grey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fig, ax = plt.subplots()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.grid(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/lex.77b7efabdb0c.png" alt="列克星敦号航空母舰的图像"></p><p>为了简单起见，图像是以灰度加载的，结果是一个由64位浮点数组成的2d数组，而不是一个三维mxnx4rgba数组，更低的值表示暗点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.shape</span><br><span class="line">(<span class="number">254</span>, <span class="number">319</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.<span class="built_in">min</span>(), img.<span class="built_in">max</span>()</span><br><span class="line">(<span class="number">0.027450980392156862</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">0</span>, :<span class="number">10</span>]  <span class="comment"># First ten cells of the first row</span></span><br><span class="line">array([<span class="number">0.8078</span>, <span class="number">0.7961</span>, <span class="number">0.7804</span>, <span class="number">0.7882</span>, <span class="number">0.7961</span>, <span class="number">0.8078</span>, <span class="number">0.8039</span>, <span class="number">0.7922</span>,</span><br><span class="line">       <span class="number">0.7961</span>, <span class="number">0.7961</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[-<span class="number">1</span>, -<span class="number">10</span>:]  <span class="comment"># Last ten cells of the last row</span></span><br><span class="line">array([<span class="number">0.0784</span>, <span class="number">0.0784</span>, <span class="number">0.0706</span>, <span class="number">0.0706</span>, <span class="number">0.0745</span>, <span class="number">0.0706</span>, <span class="number">0.0745</span>, <span class="number">0.0784</span>,</span><br><span class="line">       <span class="number">0.0784</span>, <span class="number">0.0824</span>])</span><br></pre></td></tr></table></figure><p>在图像分析中，一种常用的中间步骤是贴片提取。顾名思义，这包括从较大的数组中提取较小的重叠子数组，并可用于有利于“去噪”或模糊图像的情况。</p><p>这一概念也扩展到其他领域。例如，你可以通过使用具有多个特性(变量)的时间序列的“滚动”窗口来做类似的事情。它甚至对构建<a href="https://bitstorm.org/gameoflife/">康威的“生命游戏”</a>很有用。(不过，与3x3内核的<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.convolve.html">卷积</a>是一种更直接的方法。)</p><p>在这里，我们将找到 img 中每个重叠的10x10修补的平均值。以一个微型示例为例，img左上角的第一个3x3修补程序矩阵将是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[:<span class="number">3</span>, :<span class="number">3</span>]</span><br><span class="line">array([[<span class="number">0.8078</span>, <span class="number">0.7961</span>, <span class="number">0.7804</span>],</span><br><span class="line">       [<span class="number">0.8039</span>, <span class="number">0.8157</span>, <span class="number">0.8078</span>],</span><br><span class="line">       [<span class="number">0.7882</span>, <span class="number">0.8</span>   , <span class="number">0.7961</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[:<span class="number">3</span>, :<span class="number">3</span>].mean()</span><br><span class="line"><span class="number">0.7995642701525054</span></span><br></pre></td></tr></table></figure><p>用于创建滑动修复方式的纯Python方法将涉及嵌套的for循环。你需要考虑最右边补丁的起始索引是在索引 n - 3 + 1，其中n是数组的宽度。换句话说，如果你从名为arr的10x10数组中提取3x3修复，那么最后一个修复将来自arr[7: 10, 7: 10]。 还要记住，Python的range()不包含其stop参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>size = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m, n = img.shape</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm, nn = m - size + <span class="number">1</span>, n - size + <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patch_means = np.empty((mm, nn))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mm):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line"><span class="meta">... </span>        patch_means[i, j] = img[i: i+size, j: j+size].mean()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fig, ax = plt.subplots()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.imshow(patch_means, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.grid(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%BC%96%E7%A8%8B/lexblur.0f886a01be97.png" alt="莱克星顿号航空母舰的模糊图像"></p><p>有了这个循环，你就会执行很多Python调用。</p><p>另一种可扩展到更大RGB或RGBA图像的替代方案是NumPy的stride_tricks。</p><p>一个有益的第一步是在给定修补大小和图像形状的情况下，可视化更高维度的修复矩阵。我们有一个2d数组img形状(254, 319)和一个(10, 10)2d 修复。这意味着我们的输出形状（在取每个“内部”* 10x10 *数组的平均值之前）将是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape = (img.shape[<span class="number">0</span>] - size + <span class="number">1</span>, img.shape[<span class="number">1</span>] - size + <span class="number">1</span>, size, size)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape</span><br><span class="line">(<span class="number">245</span>, <span class="number">310</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>你还需要指定新数组的<strong>步长</strong>。数组的步长是一个字节元组，用于在沿数组移动时跳转到每个维度。IMG中的每个像素都是64位(8字节)的浮点，这意味着总的图像大小为<em>254×319×8 = 648, 208</em>字节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.dtype</span><br><span class="line">dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.nbytes</span><br><span class="line"><span class="number">648208</span></span><br></pre></td></tr></table></figure><p>在内部，IMG作为一个连续的648，208字节块保存在内存中。因此，STEAMS是一种类似“元数据”的属性，它告诉我们需要向前跳转多少字节才能沿着每个轴移动到下一个位置。我们沿着行以8字节为单位移动，但需要遍历<em>8x319=2，552</em>字节才能将“向下”从一行移动到另一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.strides</span><br><span class="line">(<span class="number">2552</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>在我们的示例中，生成的修复程序的步调只会重复img的两次步调：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>strides = <span class="number">2</span> * img.strides</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strides</span><br><span class="line">(<span class="number">2552</span>, <span class="number">8</span>, <span class="number">2552</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>现在，让我们将这些部分与NumPy的<a href="https://www.numpy.org.cn/reference/routines/indexing.html#%E7%B1%BB%E4%BC%BC%E7%B4%A2%E5%BC%95%E7%9A%84%E6%93%8D%E4%BD%9C">stride_tricks</a>结合起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy.lib <span class="keyword">import</span> stride_tricks</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches = stride_tricks.as_strided(img, shape=shape, strides=strides)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches.shape</span><br><span class="line">(<span class="number">245</span>, <span class="number">310</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>Here’s the first <em>10x10</em> patch:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches[<span class="number">0</span>, <span class="number">0</span>].<span class="built_in">round</span>(<span class="number">2</span>)</span><br><span class="line">array([[<span class="number">0.81</span>, <span class="number">0.8</span> , <span class="number">0.78</span>, <span class="number">0.79</span>, <span class="number">0.8</span> , <span class="number">0.81</span>, <span class="number">0.8</span> , <span class="number">0.79</span>, <span class="number">0.8</span> , <span class="number">0.8</span> ],</span><br><span class="line">       [<span class="number">0.8</span> , <span class="number">0.82</span>, <span class="number">0.81</span>, <span class="number">0.79</span>, <span class="number">0.79</span>, <span class="number">0.79</span>, <span class="number">0.78</span>, <span class="number">0.81</span>, <span class="number">0.81</span>, <span class="number">0.8</span> ],</span><br><span class="line">       [<span class="number">0.79</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.79</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.82</span>, <span class="number">0.83</span>, <span class="number">0.79</span>, <span class="number">0.81</span>],</span><br><span class="line">       [<span class="number">0.8</span> , <span class="number">0.79</span>, <span class="number">0.81</span>, <span class="number">0.81</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.78</span>, <span class="number">0.76</span>, <span class="number">0.8</span> , <span class="number">0.79</span>],</span><br><span class="line">       [<span class="number">0.78</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.78</span>, <span class="number">0.8</span> , <span class="number">0.79</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.79</span>, <span class="number">0.79</span>],</span><br><span class="line">       [<span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.81</span>, <span class="number">0.79</span>],</span><br><span class="line">       [<span class="number">0.78</span>, <span class="number">0.77</span>, <span class="number">0.78</span>, <span class="number">0.76</span>, <span class="number">0.77</span>, <span class="number">0.8</span> , <span class="number">0.8</span> , <span class="number">0.77</span>, <span class="number">0.8</span> , <span class="number">0.8</span> ],</span><br><span class="line">       [<span class="number">0.79</span>, <span class="number">0.76</span>, <span class="number">0.77</span>, <span class="number">0.78</span>, <span class="number">0.77</span>, <span class="number">0.77</span>, <span class="number">0.79</span>, <span class="number">0.78</span>, <span class="number">0.77</span>, <span class="number">0.76</span>],</span><br><span class="line">       [<span class="number">0.78</span>, <span class="number">0.75</span>, <span class="number">0.76</span>, <span class="number">0.76</span>, <span class="number">0.73</span>, <span class="number">0.75</span>, <span class="number">0.78</span>, <span class="number">0.76</span>, <span class="number">0.77</span>, <span class="number">0.77</span>],</span><br><span class="line">       [<span class="number">0.78</span>, <span class="number">0.79</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.78</span>, <span class="number">0.77</span>, <span class="number">0.76</span>, <span class="number">0.77</span>, <span class="number">0.77</span>]])</span><br></pre></td></tr></table></figure><p>最后一步很棘手。 为了得到每个内部10x10数组的矢量化平均值，我们需要仔细考虑我们现在拥有的维数。结果应该折叠最后两个维度，以便我们留下一个245x310数组。</p><p>一种（次优）方式是首先重塑修复，将内部2d数组展平为长度为100的向量，然后计算最终轴上的均值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>veclen = size ** <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches.reshape(*patches.shape[:<span class="number">2</span>], veclen).mean(axis=-<span class="number">1</span>).shape</span><br><span class="line">(<span class="number">245</span>, <span class="number">310</span>)</span><br></pre></td></tr></table></figure><p>但是，你也可以将轴指定为元组，计算最后两个轴的平均值，这应该比重新整形更有效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>patches.mean(axis=(-<span class="number">1</span>, -<span class="number">2</span>)).shape</span><br><span class="line">(<span class="number">245</span>, <span class="number">310</span>)</span><br></pre></td></tr></table></figure><p>让我们通过比较与循环版本的相等性来确保检查。它确实如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>strided_means = patches.mean(axis=(-<span class="number">1</span>, -<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.allclose(patch_means, strided_means)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果大步幅的概念让你感到兴奋，请不要激动：Scikit-Learn已经在其feature_extraction模块中很好地<a href="http://scikit-learn.org/stable/modules/feature_extraction.html#image-feature-extraction">嵌入了整个过程</a>。</p><h2 id="临别赠言：不要过度优化"><a href="#临别赠言：不要过度优化" class="headerlink" title="临别赠言：不要过度优化"></a>临别赠言：不要过度优化</h2><p>在本文中，我们讨论了利用NumPy中的数组编程来优化运行时。在处理大型数据集时，注意微观性能非常重要。</p><p>但是，有一部分案例无法避免使用本机Python for循环。正如Donald Knuth<a href="http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf">所说</a>，“过早优化是所有邪恶的根源。”程序员可能错误地预测他们的代码中会出现瓶颈的地方，花费数小时试图完全矢量化操作，这将导致运行时相对不显着的改进。</p><p>在这里或那里都放上for循环也没有任何问题。通常，考虑在更高的抽象级别优化整个脚本的流程和结构，可能会更有效率。</p><h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><p>书籍：</p><ul><li>Travis Oliphant’s <a href="https://realpython.com/asins/151730007X/">Guide to NumPy, 2nd ed</a>. (特拉维斯是NumPy的主要创建者。)</li><li>Chapter 2 (“Introduction to NumPy”) of Jake VanderPlas’ <a href="https://realpython.com/asins/1491912057/">Python数据科学手册</a></li><li>Chapter 4 (“NumPy Basics”) and Chapter 12 (“Advanced NumPy”) of Wes McKinney’s <a href="https://realpython.com/asins/B075X4LT6K/">Python for Data Analysis 2nd ed</a>.</li><li>Chapter 2 (“The Mathematical Building Blocks of Neural Networks”) from François Chollet’s <a href="https://realpython.com/asins/1617294438/">Deep Learning with Python</a></li><li>Robert Johansson’s <a href="https://realpython.com/asins/1484205545/">Numerical Python</a></li><li>Ivan Idris: <a href="https://realpython.com/asins/1785281968/">Numpy Beginner’s Guide, 3rd ed</a>.</li></ul><p>其他资源:</p><ul><li>维基百科: <a href="https://en.wikipedia.org/wiki/Array_programming">数组编程</a></li><li>SciPy 课堂讲义: <a href="http://www.scipy-lectures.org/intro/numpy/index.html">Basic</a> and <a href="http://www.scipy-lectures.org/advanced/advanced_numpy/index.html">Advanced</a> NumPy</li><li>EricsBroadcastingDoc: <a href="http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc">NumPy中的数组广播</a></li><li>SciPy Cookbook: <a href="http://scipy-cookbook.readthedocs.io/items/ViewsVsCopies.html">NumPy中的视图与副本</a></li><li>Nicolas Rougier: <a href="http://www.labri.fr/perso/nrougier/from-python-to-numpy/">从Python到Numpy</a> and <a href="http://www.labri.fr/perso/nrougier/teaching/numpy.100/index.html">100 NumPy练习</a></li><li>TensorFlow 文档: <a href="https://www.tensorflow.org/performance/xla/broadcasting">广播语法</a></li><li>Theano 文档: <a href="http://deeplearning.net/software/theano/tutorial/broadcasting.html">广播</a></li><li>Eli Bendersky: <a href="https://eli.thegreenplace.net/2015/broadcasting-arrays-in-numpy/">用Numpy广播数组</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-NumPy-进行数组编程&quot;&gt;&lt;a href=&quot;#使用-NumPy-进行数组编程&quot; class=&quot;headerlink&quot; title=&quot;使用 NumPy 进行数组编程&quot;&gt;&lt;/a&gt;使用 NumPy 进行数组编程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>numpy神经网络</title>
    <link href="http://rczmm.github.io/2021/09/21/numpy%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://rczmm.github.io/2021/09/21/numpy%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2021-09-21T14:44:34.000Z</published>
    <updated>2021-09-21T14:46:11.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NumPy-与-神经网络"><a href="#NumPy-与-神经网络" class="headerlink" title="NumPy 与 神经网络"></a>NumPy 与 神经网络</h1><p>对我来说用于分类的神经网络是一种非常可怕的机器学习算法。学习神经网络算法时，会给人一种望而生畏的感觉，但当我最终妥协并陷入其中无法自拔的时候，才发现其实它并没有想象中的那么可怕。它们被称为神经网络，是因为它们松散地建立在人类大脑神经元以及神经元工作原理的基础上。但是，它们本质上是一组线性模型。关于这些算法的数学和结构有很多很好的文章来解释它们，所以这些部分我的这篇文章不会提及。相反，我将详细的用numpy库在python中编写一个一个的步骤，并非常清楚地解释它的。这篇文章的代码很大程度上基于<a href="https://s.click.taobao.com/t?e=m=2&s=XIetsYhTCu8cQipKwQzePOeEDrYVVa64K7Vc7tFgwiHjf2vlNIV67pZpQLiTO+hgmSMhGfkQJ77VdTmGfLKGc3msngnYL0uHYhNjQr6GXJQ0IVmWuK+Mt0g0aHp6CeiC6hqtRuAxoUJbnlHS8Kikd9qH4uMbv1iQxgxdTc00KD8=&pvid=10_183.14.30.247_9333_1539405668948">《集体智慧编程》</a>中提供的神经网络代码，只要输入数据格式正确，我就稍微调整它以使其可用于任何数据集。</p><p>首先，我们可以将每个神经元视为具有激活功能。此功能确定神经元是 <code>开</code> 还是 <code>关</code> - 是否激活。我们将使用sigmoid函数，在逻辑回归中，它应该是非常见的函数。与逻辑回归不同，我们在使用神经网络时也需要sigmoid函数的导数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"><span class="comment"># derivative of sigmoid</span></span><br><span class="line"><span class="comment"># sigmoid(y) * (1.0 - sigmoid(y))</span></span><br><span class="line"><span class="comment"># the way we use this y is already sigmoided</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dsigmoid</span>(<span class="params">y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> y * (<span class="number">1.0</span> - y)    </span><br></pre></td></tr></table></figure><p>就像逻辑回归一样，神经网络中的Sigmoid函数将生成输入的端点(激活)乘以它们的权重。例如，假设我们有两列(特征)的输入数据和一个隐藏节点(神经元)在我们的神经网络。每个特征都会乘以相应的权重值，然后相加，然后通过S形(就像逻辑回归一样)。以这个简单的例子，并把它变成一个神经网络，我们只是添加更多的隐藏单元。除了添加更多的隐藏单元外，我们还将每个输入特性的路径添加到每个隐藏单元，并将其乘以相应的权重。每个隐藏单元取其输入*权值之和，并通过S形传递，从而导致该单元的激活。</p><p>接下来，我们将设置数组来保存用于网络的数据，并初始化一些参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP_NeuralNetwork</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">input</span>, hidden, output</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param input: number of input neurons</span></span><br><span class="line"><span class="string">        :param hidden: number of hidden neurons</span></span><br><span class="line"><span class="string">        :param output: number of output neurons</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">input</span> = <span class="built_in">input</span> + <span class="number">1</span> <span class="comment"># add 1 for bias node</span></span><br><span class="line">        self.hidden = hidden</span><br><span class="line">        self.output = output</span><br><span class="line">        <span class="comment"># set up array of 1s for activations</span></span><br><span class="line">        self.ai = [<span class="number">1.0</span>] * self.<span class="built_in">input</span></span><br><span class="line">        self.ah = [<span class="number">1.0</span>] * self.hidden</span><br><span class="line">        self.ao = [<span class="number">1.0</span>] * self.output</span><br><span class="line">        <span class="comment"># create randomized weights</span></span><br><span class="line">        self.wi = np.random.randn(self.<span class="built_in">input</span>, self.hidden) </span><br><span class="line">        self.wo = np.random.randn(self.hidden, self.output) </span><br><span class="line">        <span class="comment"># create arrays of 0 for changes</span></span><br><span class="line">        self.ci = np.zeros((self.<span class="built_in">input</span>, self.hidden))</span><br><span class="line">        self.co = np.zeros((self.hidden, self.output))</span><br></pre></td></tr></table></figure><p>我们要用矩阵做所有这些计算，因为它们速度快，而且非常容易阅读。我们的类将接受三个输入：输入层的大小(特性)、隐藏层的大小(要调优的变量参数)和输出层的数量(可能的类的数量)。我们设置一个1数组作为单元激活的占位符，一个0数组作为层更改的占位符。需要注意的一件重要事情是，我们将所有的权重初始化为随机数。重要的是权值是随机的，否则我们将无法调整网络。如果所有的权重是一样的，那么所有隐藏的单位都是一样的，那你的神经网络算法就废了。</p><p>所以现在是时候做一些预测的运算操作了。我们要做的是通过随机权重将所有数据通过网络提供给用户，并生成一些(不那么准确的)预测。后来，每次做出预测时，我们都会计算出预测的错误程度，以及为了使预测更好(即误差)，我们需要改变权重的方向。我们会做很多…很多次，当权重被更新时，我们会创建一个前馈函数，这个函数可以被一次又一次地调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feedForward</span>(<span class="params">self, inputs</span>):</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(inputs) != self.<span class="built_in">input</span>-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Wrong number of inputs you silly goose!&#x27;</span>)</span><br><span class="line">    <span class="comment"># input activations</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">input</span> -<span class="number">1</span>): <span class="comment"># -1 is to avoid the bias</span></span><br><span class="line">        self.ai[i] = inputs[i]</span><br><span class="line">    <span class="comment"># hidden activations</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">input</span>):</span><br><span class="line">            <span class="built_in">sum</span> += self.ai[i] * self.wi[i][j]</span><br><span class="line">        self.ah[j] = sigmoid(<span class="built_in">sum</span>)</span><br><span class="line">    <span class="comment"># output activations</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.output):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">            <span class="built_in">sum</span> += self.ah[j] * self.wo[j][k]</span><br><span class="line">        self.ao[k] = sigmoid(<span class="built_in">sum</span>)</span><br><span class="line">    <span class="keyword">return</span> self.ao[:]</span><br></pre></td></tr></table></figure><p>输入激活只是输入功能。但是，对于另一层，激活变成了前一层激活的总和乘以它们的相应的权值，反馈到S形中去了。</p><p>在第一次运算之后，我们的预测的误差相当大的。所以我们将使用一个非常熟悉的概念，梯度下降。这是我感到兴奋的部分，因为我认为数学真的很聪明。与线性模型的梯度下降不同，我们需要对神经网络使用一点微积分。这就是为什么我们在开始的时候，为S函数的导数写了这个函数。</p><p>我们的反向传播算法首先计算我们预测的输出与真实输出的误差。然后我们在输出激活(预测值)上取S形的导数，以得到梯度的方向(斜率)，并将该值乘以误差。这就给了我们误差的大小，隐藏的权值需要改变哪个方向来修正它。然后我们进入到隐藏层，并根据前面计算的幅度和误差计算隐藏层权值的误差。</p><p>利用该误差和隐藏层激活的S形导数，我们计算了输入层的权重需要改变多少，以及在哪个方向上需要改变。</p><p>现在我们有了价值网络，我们想改变利率的多少，以及在什么方向上，我们真正做到了这一点。我们更新连接每一层的权重。我们通过将当前权重乘以学习速率常数以及相应的权重层的大小和方向来实现这一点。就像在线性模型中一样，我们使用学习速率常数在每一步中做一些小的改变，这样我们就有更好的机会为最小化成本函数的权值找到真正的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backPropagate</span>(<span class="params">self, targets, N</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param targets: y values</span></span><br><span class="line"><span class="string">    :param N: learning rate</span></span><br><span class="line"><span class="string">    :return: updated weights and current error</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(targets) != self.output:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Wrong number of targets you silly goose!&#x27;</span>)</span><br><span class="line">    <span class="comment"># calculate error terms for output</span></span><br><span class="line">    <span class="comment"># the delta tell you which direction to change the weights</span></span><br><span class="line">    output_deltas = [<span class="number">0.0</span>] * self.output</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.output):</span><br><span class="line">        error = -(targets[k] - self.ao[k])</span><br><span class="line">        output_deltas[k] = dsigmoid(self.ao[k]) * error</span><br><span class="line">    <span class="comment"># calculate error terms for hidden</span></span><br><span class="line">    <span class="comment"># delta tells you which direction to change the weights</span></span><br><span class="line">    hidden_deltas = [<span class="number">0.0</span>] * self.hidden</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">        error = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.output):</span><br><span class="line">            error += output_deltas[k] * self.wo[j][k]</span><br><span class="line">        hidden_deltas[j] = dsigmoid(self.ah[j]) * error</span><br><span class="line">    <span class="comment"># update the weights connecting hidden to output</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(self.output):</span><br><span class="line">            change = output_deltas[k] * self.ah[j]</span><br><span class="line">            self.wo[j][k] -= N * change + self.co[j][k]</span><br><span class="line">            self.co[j][k] = change</span><br><span class="line">    <span class="comment"># update the weights connecting input to hidden</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">input</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.hidden):</span><br><span class="line">            change = hidden_deltas[j] * self.ai[i]</span><br><span class="line">            self.wi[i][j] -= N * change + self.ci[i][j]</span><br><span class="line">            self.ci[i][j] = change</span><br><span class="line">    <span class="comment"># calculate error</span></span><br><span class="line">    error = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(targets)):</span><br><span class="line">        error += <span class="number">0.5</span> * (targets[k] - self.ao[k]) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> error</span><br></pre></td></tr></table></figure><p>好的，让我们把它们链接在一起，创建训练和预测功能。训练网络的步骤是非常直接和直观的。我们首先调用“<code>前馈</code>”函数，它给出我们初始化的随机权值的输出。然后，我们调用反向传播算法来调整和更新权值，以做出更好的预测。然后再调用前馈函数，但这一次它使用了更新后的权值，预测结果略好一些。我们将这个循环保持在一个预先确定的迭代数量中，在此期间，我们应该看到错误下降到接近0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">self, patterns, iterations = <span class="number">3000</span>, N = <span class="number">0.0002</span></span>):</span></span><br><span class="line">    <span class="comment"># N: learning rate</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">        error = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> patterns:</span><br><span class="line">            inputs = p[<span class="number">0</span>]</span><br><span class="line">            targets = p[<span class="number">1</span>]</span><br><span class="line">            self.feedForward(inputs)</span><br><span class="line">            error = self.backPropagate(targets, N)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;error %-.5f&#x27;</span> % error)</span><br></pre></td></tr></table></figure><p>最后，对于预测操作。我们只是简单地调用前馈函数，它将返回输出层的激活。记住，每一层的激活是前一层输出的线性组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    return list of predictions after training algorithm</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    predictions = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> X:</span><br><span class="line">        predictions.append(self.feedForward(p))</span><br><span class="line">    <span class="keyword">return</span> predictions</span><br></pre></td></tr></table></figure><p>基本上就是这样！你可以<a href="https://github.com/FlorianMuellerklein/Machine-Learning/blob/master/Old/BackPropagationNN.py">在这里</a>看到完整的代码。</p><p>我运行了这个代码的数字识别数据集提供的skLearning，它完成了一个97%的准确性。我要说那是相当成功的！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">          0       0.98      0.96      0.97        49</span><br><span class="line">          1       0.92      0.97      0.95        36</span><br><span class="line">          2       1.00      1.00      1.00        43</span><br><span class="line">          3       0.95      0.88      0.91        41</span><br><span class="line">          4       0.98      1.00      0.99        47</span><br><span class="line">          5       0.96      1.00      0.98        46</span><br><span class="line">          6       1.00      1.00      1.00        47</span><br><span class="line">          7       0.98      0.96      0.97        46</span><br><span class="line">          8       0.93      0.80      0.86        49</span><br><span class="line">          9       1.00      0.91      0.95        46</span><br><span class="line"></span><br><span class="line">avg / total       0.97      0.95      0.96       450</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NumPy-与-神经网络&quot;&gt;&lt;a href=&quot;#NumPy-与-神经网络&quot; class=&quot;headerlink&quot; title=&quot;NumPy 与 神经网络&quot;&gt;&lt;/a&gt;NumPy 与 神经网络&lt;/h1&gt;&lt;p&gt;对我来说用于分类的神经网络是一种非常可怕的机器学习算法。学习</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>numpy数据分析练习</title>
    <link href="http://rczmm.github.io/2021/09/21/numpy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%BB%83%E4%B9%A0/"/>
    <id>http://rczmm.github.io/2021/09/21/numpy%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%BB%83%E4%B9%A0/</id>
    <published>2021-09-21T14:34:17.000Z</published>
    <updated>2021-09-21T14:43:42.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NumPy-数据分析练习"><a href="#NumPy-数据分析练习" class="headerlink" title="NumPy 数据分析练习"></a>NumPy 数据分析练习</h1><p>Numpy练习的目标仅作为学习numpy的参考，并让你脱离基础性的NumPy使用。这些问题有4个级别的难度，其中L1是最容易的，L4是最难的。</p><h2 id="NumPy数据分析问答"><a href="#NumPy数据分析问答" class="headerlink" title="NumPy数据分析问答"></a>NumPy数据分析问答</h2><h3 id="1、导入numpy作为np，并查看版本"><a href="#1、导入numpy作为np，并查看版本" class="headerlink" title="1、导入numpy作为np，并查看版本"></a>1、导入numpy作为np，并查看版本</h3><p><strong>难度等级：</strong>L1 <strong>问题：</strong>将numpy导入为 <code>np</code> 并打印版本号。 <strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(np.__version__)</span><br><span class="line"><span class="comment"># &gt; 1.13.3</span></span><br></pre></td></tr></table></figure><p>你必须将numpy导入np，才能使本练习中的其余代码正常工作。</p><p>要安装numpy，建议安装anaconda，里面已经包含了numpy。</p><h3 id="2、如何创建一维数组？"><a href="#2、如何创建一维数组？" class="headerlink" title="2、如何创建一维数组？"></a>2、如何创建一维数组？</h3><p><strong>难度等级：</strong>L1 <strong>问题：</strong>创建从0到9的一维数字数组</p><p><strong>期望输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure><h3 id="3-如何创建一个布尔数组？"><a href="#3-如何创建一个布尔数组？" class="headerlink" title="3. 如何创建一个布尔数组？"></a>3. 如何创建一个布尔数组？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>创建一个numpy数组元素值全为True（真）的数组</p><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.full((<span class="number">3</span>, <span class="number">3</span>), <span class="literal">True</span>, dtype=<span class="built_in">bool</span>)</span><br><span class="line"><span class="comment"># &gt; array([[ True,  True,  True],</span></span><br><span class="line"><span class="comment"># &gt;        [ True,  True,  True],</span></span><br><span class="line"><span class="comment"># &gt;        [ True,  True,  True]], dtype=bool)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternate method:</span></span><br><span class="line">np.ones((<span class="number">3</span>,<span class="number">3</span>), dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure><h3 id="4-如何从一维数组中提取满足指定条件的元素？"><a href="#4-如何从一维数组中提取满足指定条件的元素？" class="headerlink" title="4. 如何从一维数组中提取满足指定条件的元素？"></a>4. 如何从一维数组中提取满足指定条件的元素？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>从 arr 中提取所有的奇数</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([1, 3, 5, 7, 9])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[arr % <span class="number">2</span> == <span class="number">1</span>]</span><br><span class="line"><span class="comment"># &gt; array([1, 3, 5, 7, 9])</span></span><br></pre></td></tr></table></figure><h3 id="5-如何用numpy数组中的另一个值替换满足条件的元素项？"><a href="#5-如何用numpy数组中的另一个值替换满足条件的元素项？" class="headerlink" title="5. 如何用numpy数组中的另一个值替换满足条件的元素项？"></a>5. 如何用numpy数组中的另一个值替换满足条件的元素项？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>将arr中的所有奇数替换为-1。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt;  array([ 0, -1,  2, -1,  4, -1,  6, -1,  8, -1])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[arr % <span class="number">2</span> == <span class="number">1</span>] = -<span class="number">1</span></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([ 0, -1,  2, -1,  4, -1,  6, -1,  8, -1])</span></span><br></pre></td></tr></table></figure><h3 id="6-如何在不影响原始数组的情况下替换满足条件的元素项？"><a href="#6-如何在不影响原始数组的情况下替换满足条件的元素项？" class="headerlink" title="6. 如何在不影响原始数组的情况下替换满足条件的元素项？"></a>6. 如何在不影响原始数组的情况下替换满足条件的元素项？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>将arr中的所有奇数替换为-1，而不改变arr。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out</span><br><span class="line"><span class="comment"># &gt;  array([ 0, -1,  2, -1,  4, -1,  6, -1,  8, -1])</span></span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt;  array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">out = np.where(arr % <span class="number">2</span> == <span class="number">1</span>, -<span class="number">1</span>, arr)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">out</span><br><span class="line"><span class="comment"># &gt; [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">array([ <span class="number">0</span>, -<span class="number">1</span>,  <span class="number">2</span>, -<span class="number">1</span>,  <span class="number">4</span>, -<span class="number">1</span>,  <span class="number">6</span>, -<span class="number">1</span>,  <span class="number">8</span>, -<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="7-如何改变数组的形状？"><a href="#7-如何改变数组的形状？" class="headerlink" title="7. 如何改变数组的形状？"></a>7. 如何改变数组的形状？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>将一维数组转换为2行的2维数组</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &gt; array([[0, 1, 2, 3, 4],</span><br><span class="line"># &gt;        [5, 6, 7, 8, 9]])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr.reshape(<span class="number">2</span>, -<span class="number">1</span>)  <span class="comment"># Setting to -1 automatically decides the number of cols</span></span><br><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9]])</span></span><br></pre></td></tr></table></figure><h3 id="8-如何垂直叠加两个数组？"><a href="#8-如何垂直叠加两个数组？" class="headerlink" title="8. 如何垂直叠加两个数组？"></a>8. 如何垂直叠加两个数组？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>垂直堆叠数组a和数组b</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9],</span></span><br><span class="line"><span class="comment"># &gt;        [1, 1, 1, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [1, 1, 1, 1, 1]])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Answers</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">np.concatenate([a, b], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">np.vstack([a, b])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3:</span></span><br><span class="line">np.r_[a, b]</span><br><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9],</span></span><br><span class="line"><span class="comment"># &gt;        [1, 1, 1, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [1, 1, 1, 1, 1]])</span></span><br></pre></td></tr></table></figure><h3 id="9-如何水平叠加两个数组？"><a href="#9-如何水平叠加两个数组？" class="headerlink" title="9. 如何水平叠加两个数组？"></a>9. 如何水平叠加两个数组？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>将数组a和数组b水平堆叠。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4, 1, 1, 1, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9, 1, 1, 1, 1, 1]])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Answers</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">np.concatenate([a, b], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">np.hstack([a, b])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3:</span></span><br><span class="line">np.c_[a, b]</span><br><span class="line"><span class="comment"># &gt; array([[0, 1, 2, 3, 4, 1, 1, 1, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 6, 7, 8, 9, 1, 1, 1, 1, 1]])</span></span><br></pre></td></tr></table></figure><h3 id="10-如何在无硬编码的情况下生成numpy中的自定义序列？"><a href="#10-如何在无硬编码的情况下生成numpy中的自定义序列？" class="headerlink" title="10. 如何在无硬编码的情况下生成numpy中的自定义序列？"></a>10. 如何在无硬编码的情况下生成numpy中的自定义序列？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>创建以下模式而不使用硬编码。只使用numpy函数和下面的输入数组a。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])`</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.r_[np.repeat(a, <span class="number">3</span>), np.tile(a, <span class="number">3</span>)]</span><br><span class="line"><span class="comment"># &gt; array([1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])</span></span><br></pre></td></tr></table></figure><h3 id="11-如何获取两个numpy数组之间的公共项？"><a href="#11-如何获取两个numpy数组之间的公共项？" class="headerlink" title="11. 如何获取两个numpy数组之间的公共项？"></a>11. 如何获取两个numpy数组之间的公共项？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>获取数组a和数组b之间的公共项。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = np.array([<span class="number">7</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">2</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = np.array([<span class="number">7</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line">np.intersect1d(a,b)</span><br><span class="line"><span class="comment"># &gt; array([2, 4])</span></span><br></pre></td></tr></table></figure><h3 id="12-如何从一个数组中删除存在于另一个数组中的项？"><a href="#12-如何从一个数组中删除存在于另一个数组中的项？" class="headerlink" title="12. 如何从一个数组中删除存在于另一个数组中的项？"></a>12. 如何从一个数组中删除存在于另一个数组中的项？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>从数组a中删除数组b中的所有项。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># From &#x27;a&#x27; remove all of &#x27;b&#x27;</span></span><br><span class="line">np.setdiff1d(a,b)</span><br><span class="line"><span class="comment"># &gt; array([1, 2, 3, 4])</span></span><br></pre></td></tr></table></figure><h3 id="13-如何得到两个数组元素匹配的位置？"><a href="#13-如何得到两个数组元素匹配的位置？" class="headerlink" title="13. 如何得到两个数组元素匹配的位置？"></a>13. 如何得到两个数组元素匹配的位置？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>获取a和b元素匹配的位置。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = np.array([<span class="number">7</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; (array([1, 3, 5, 7]),)</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">b = np.array([<span class="number">7</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">np.where(a == b)</span><br><span class="line"><span class="comment"># &gt; (array([1, 3, 5, 7]),)</span></span><br></pre></td></tr></table></figure><h3 id="14-如何从numpy数组中提取给定范围内的所有数字？"><a href="#14-如何从numpy数组中提取给定范围内的所有数字？" class="headerlink" title="14. 如何从numpy数组中提取给定范围内的所有数字？"></a>14. 如何从numpy数组中提取给定范围内的所有数字？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>获取5到10之间的所有项目。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">27</span>])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(array([<span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]),)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1</span></span><br><span class="line">index = np.where((a &gt;= <span class="number">5</span>) &amp; (a &lt;= <span class="number">10</span>))</span><br><span class="line">a[index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">index = np.where(np.logical_and(a&gt;=<span class="number">5</span>, a&lt;=<span class="number">10</span>))</span><br><span class="line">a[index]</span><br><span class="line"><span class="comment"># &gt; (array([6, 9, 10]),)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3: (thanks loganzk!)</span></span><br><span class="line">a[(a &gt;= <span class="number">5</span>) &amp; (a &lt;= <span class="number">10</span>)]</span><br></pre></td></tr></table></figure><h3 id="15-如何创建一个python函数来处理scalars并在numpy数组上工作？"><a href="#15-如何创建一个python函数来处理scalars并在numpy数组上工作？" class="headerlink" title="15. 如何创建一个python函数来处理scalars并在numpy数组上工作？"></a>15. 如何创建一个python函数来处理scalars并在numpy数组上工作？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>转换适用于两个标量的函数maxx，以处理两个数组。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxx</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get the maximum of two items&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">maxx(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># &gt; 5</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>])</span><br><span class="line">pair_max(a, b)</span><br><span class="line"><span class="comment"># &gt; array([ 6.,  7.,  9.,  8.,  9.,  7.,  5.])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxx</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get the maximum of two items&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">pair_max = np.vectorize(maxx, otypes=[<span class="built_in">float</span>])</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">pair_max(a, b)</span><br><span class="line"><span class="comment"># &gt; array([ 6.,  7.,  9.,  8.,  9.,  7.,  5.])</span></span><br></pre></td></tr></table></figure><h3 id="16-如何交换二维numpy数组中的两列？"><a href="#16-如何交换二维numpy数组中的两列？" class="headerlink" title="16. 如何交换二维numpy数组中的两列？"></a>16. 如何交换二维numpy数组中的两列？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>在数组arr中交换列1和2。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[:, [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="comment"># &gt; array([[1, 0, 2],</span></span><br><span class="line"><span class="comment"># &gt;        [4, 3, 5],</span></span><br><span class="line"><span class="comment"># &gt;        [7, 6, 8]])</span></span><br></pre></td></tr></table></figure><h3 id="17-如何交换二维numpy数组中的两行？"><a href="#17-如何交换二维numpy数组中的两行？" class="headerlink" title="17. 如何交换二维numpy数组中的两行？"></a>17. 如何交换二维numpy数组中的两行？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>交换数组arr中的第1和第2行：</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>], :]</span><br><span class="line"><span class="comment"># &gt; array([[3, 4, 5],</span></span><br><span class="line"><span class="comment"># &gt;        [0, 1, 2],</span></span><br><span class="line"><span class="comment"># &gt;        [6, 7, 8]])</span></span><br></pre></td></tr></table></figure><h3 id="18-如何反转二维数组的行？"><a href="#18-如何反转二维数组的行？" class="headerlink" title="18. 如何反转二维数组的行？"></a>18. 如何反转二维数组的行？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>反转二维数组arr的行。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[::-<span class="number">1</span>]</span><br><span class="line">array([[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h3 id="19-如何反转二维数组的列？"><a href="#19-如何反转二维数组的列？" class="headerlink" title="19. 如何反转二维数组的列？"></a>19. 如何反转二维数组的列？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>反转二维数组arr的列。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[:, ::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># &gt; array([[2, 1, 0],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 4, 3],</span></span><br><span class="line"><span class="comment"># &gt;        [8, 7, 6]])</span></span><br></pre></td></tr></table></figure><h3 id="20-如何创建包含5到10之间随机浮动的二维数组？"><a href="#20-如何创建包含5到10之间随机浮动的二维数组？" class="headerlink" title="20. 如何创建包含5到10之间随机浮动的二维数组？"></a>20. 如何创建包含5到10之间随机浮动的二维数组？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>创建一个形状为5x3的二维数组，以包含5到10之间的随机十进制数。</p><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution Method 1:</span></span><br><span class="line">rand_arr = np.random.randint(low=<span class="number">5</span>, high=<span class="number">10</span>, size=(<span class="number">5</span>,<span class="number">3</span>)) + np.random.random((<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># print(rand_arr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution Method 2:</span></span><br><span class="line">rand_arr = np.random.uniform(<span class="number">5</span>,<span class="number">10</span>, size=(<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(rand_arr)</span><br><span class="line"><span class="comment"># &gt; [[ 8.50061025  9.10531502  6.85867783]</span></span><br><span class="line"><span class="comment"># &gt;  [ 9.76262069  9.87717411  7.13466701]</span></span><br><span class="line"><span class="comment"># &gt;  [ 7.48966403  8.33409158  6.16808631]</span></span><br><span class="line"><span class="comment"># &gt;  [ 7.75010551  9.94535696  5.27373226]</span></span><br><span class="line"><span class="comment"># &gt;  [ 8.0850361   5.56165518  7.31244004]]</span></span><br></pre></td></tr></table></figure><h3 id="21-如何在numpy数组中只打印小数点后三位？"><a href="#21-如何在numpy数组中只打印小数点后三位？" class="headerlink" title="21. 如何在numpy数组中只打印小数点后三位？"></a>21. 如何在numpy数组中只打印小数点后三位？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>只打印或显示numpy数组rand_arr的小数点后3位。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand_arr = np.random.random((<span class="number">5</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">rand_arr = np.random.random((<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the random array</span></span><br><span class="line">rand_arr = np.random.random([<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Limit to 3 decimal places</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">3</span>)</span><br><span class="line">rand_arr[:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># &gt; array([[ 0.443,  0.109,  0.97 ],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.388,  0.447,  0.191],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.891,  0.474,  0.212],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.609,  0.518,  0.403]])</span></span><br></pre></td></tr></table></figure><h3 id="22-如何通过e式科学记数法（如1e10）来打印一个numpy数组？"><a href="#22-如何通过e式科学记数法（如1e10）来打印一个numpy数组？" class="headerlink" title="22. 如何通过e式科学记数法（如1e10）来打印一个numpy数组？"></a>22. 如何通过e式科学记数法（如1e10）来打印一个numpy数组？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>通过e式科学记数法来打印rand_arr（如1e10）</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create the random array</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">rand_arr = np.random.random([<span class="number">3</span>,<span class="number">3</span>])/<span class="number">1e3</span></span><br><span class="line">rand_arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; array([[  5.434049e-04,   2.783694e-04,   4.245176e-04],</span></span><br><span class="line"><span class="comment"># &gt;        [  8.447761e-04,   4.718856e-06,   1.215691e-04],</span></span><br><span class="line"><span class="comment"># &gt;        [  6.707491e-04,   8.258528e-04,   1.367066e-04]])</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([[ 0.000543,  0.000278,  0.000425],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.000845,  0.000005,  0.000122],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.000671,  0.000826,  0.000137]])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reset printoptions to default</span></span><br><span class="line">np.set_printoptions(suppress=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the random array</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">rand_arr = np.random.random([<span class="number">3</span>,<span class="number">3</span>])/<span class="number">1e3</span></span><br><span class="line">rand_arr</span><br><span class="line"><span class="comment"># &gt; array([[  5.434049e-04,   2.783694e-04,   4.245176e-04],</span></span><br><span class="line"><span class="comment"># &gt;        [  8.447761e-04,   4.718856e-06,   1.215691e-04],</span></span><br><span class="line"><span class="comment"># &gt;        [  6.707491e-04,   8.258528e-04,   1.367066e-04]])</span></span><br><span class="line">np.set_printoptions(suppress=<span class="literal">True</span>, precision=<span class="number">6</span>)  <span class="comment"># precision is optional</span></span><br><span class="line">rand_arr</span><br><span class="line"><span class="comment"># &gt; array([[ 0.000543,  0.000278,  0.000425],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.000845,  0.000005,  0.000122],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.000671,  0.000826,  0.000137]])</span></span><br></pre></td></tr></table></figure><h3 id="23-如何限制numpy数组输出中打印的项目数？"><a href="#23-如何限制numpy数组输出中打印的项目数？" class="headerlink" title="23. 如何限制numpy数组输出中打印的项目数？"></a>23. 如何限制numpy数组输出中打印的项目数？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>将numpy数组a中打印的项数限制为最多6个元素。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([ 0,  1,  2, ..., 12, 13, 14])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=<span class="number">6</span>)</span><br><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2, ..., 12, 13, 14])</span></span><br></pre></td></tr></table></figure><h3 id="24-如何打印完整的numpy数组而不截断"><a href="#24-如何打印完整的numpy数组而不截断" class="headerlink" title="24. 如何打印完整的numpy数组而不截断"></a>24. 如何打印完整的numpy数组而不截断</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>打印完整的numpy数组a而不截断。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=<span class="number">6</span>)</span><br><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2, ..., 12, 13, 14])</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.set_printoptions(threshold=<span class="number">6</span>)</span><br><span class="line">a = np.arange(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">np.set_printoptions(threshold=np.nan)</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure><h3 id="25-如何导入数字和文本的数据集保持文本在numpy数组中完好无损？"><a href="#25-如何导入数字和文本的数据集保持文本在numpy数组中完好无损？" class="headerlink" title="25. 如何导入数字和文本的数据集保持文本在numpy数组中完好无损？"></a>25. 如何导入数字和文本的数据集保持文本在numpy数组中完好无损？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>导入鸢尾属植物数据集，保持文本不变。</p><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Solution</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the first 3 rows</span></span><br><span class="line">iris[:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># &gt; array([[b&#x27;5.1&#x27;, b&#x27;3.5&#x27;, b&#x27;1.4&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.9&#x27;, b&#x27;3.0&#x27;, b&#x27;1.4&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.7&#x27;, b&#x27;3.2&#x27;, b&#x27;1.3&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;]], dtype=object)</span></span><br></pre></td></tr></table></figure><h3 id="26-如何从1维元组数组中提取特定列？"><a href="#26-如何从1维元组数组中提取特定列？" class="headerlink" title="26. 如何从1维元组数组中提取特定列？"></a>26. 如何从1维元组数组中提取特定列？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>从前面问题中导入的一维鸢尾属植物数据集中提取文本列的物种。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_1d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_1d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(iris_1d.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line">species = np.array([row[<span class="number">4</span>] <span class="keyword">for</span> row <span class="keyword">in</span> iris_1d])</span><br><span class="line">species[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># &gt; (150,)</span></span><br><span class="line"><span class="comment"># &gt; array([b&#x27;Iris-setosa&#x27;, b&#x27;Iris-setosa&#x27;, b&#x27;Iris-setosa&#x27;, b&#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        b&#x27;Iris-setosa&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;|S18&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="27-如何将1维元组数组转换为2维numpy数组？"><a href="#27-如何将1维元组数组转换为2维numpy数组？" class="headerlink" title="27. 如何将1维元组数组转换为2维numpy数组？"></a>27. 如何将1维元组数组转换为2维numpy数组？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>通过省略鸢尾属植物数据集种类的文本字段，将一维鸢尾属植物数据集转换为二维数组iris_2d。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_1d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_1d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line"><span class="comment"># Method 1: Convert each row to a list and get the first 4 items</span></span><br><span class="line">iris_2d = np.array([row.tolist()[:<span class="number">4</span>] <span class="keyword">for</span> row <span class="keyword">in</span> iris_1d])</span><br><span class="line">iris_2d[:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alt Method 2: Import only the first 4 columns from source url</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># &gt; array([[ 5.1,  3.5,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.9,  3. ,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.7,  3.2,  1.3,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.6,  3.1,  1.5,  0.2]])</span></span><br></pre></td></tr></table></figure><h3 id="28-如何计算numpy数组的均值，中位数，标准差？"><a href="#28-如何计算numpy数组的均值，中位数，标准差？" class="headerlink" title="28. 如何计算numpy数组的均值，中位数，标准差？"></a>28. 如何计算numpy数组的均值，中位数，标准差？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>求出鸢尾属植物萼片长度的平均值、中位数和标准差(第1列)</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">mu, med, sd = np.mean(sepallength), np.median(sepallength), np.std(sepallength)</span><br><span class="line"><span class="built_in">print</span>(mu, med, sd)</span><br><span class="line"><span class="comment"># &gt; 5.84333333333 5.8 0.825301291785</span></span><br></pre></td></tr></table></figure><h3 id="29-如何规范化数组，使数组的值正好介于0和1之间？"><a href="#29-如何规范化数组，使数组的值正好介于0和1之间？" class="headerlink" title="29. 如何规范化数组，使数组的值正好介于0和1之间？"></a>29. 如何规范化数组，使数组的值正好介于0和1之间？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>创建一种标准化形式的鸢尾属植物间隔长度，其值正好介于0和1之间，这样最小值为0，最大值为1。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">Smax, Smin = sepallength.<span class="built_in">max</span>(), sepallength.<span class="built_in">min</span>()</span><br><span class="line">S = (sepallength - Smin)/(Smax - Smin)</span><br><span class="line"><span class="comment"># or </span></span><br><span class="line">S = (sepallength - Smin)/sepallength.ptp()  <span class="comment"># Thanks, David Ojeda!</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"><span class="comment"># &gt; [ 0.222  0.167  0.111  0.083  0.194  0.306  0.083  0.194  0.028  0.167</span></span><br><span class="line"><span class="comment"># &gt;   0.306  0.139  0.139  0.     0.417  0.389  0.306  0.222  0.389  0.222</span></span><br><span class="line"><span class="comment"># &gt;   0.306  0.222  0.083  0.222  0.139  0.194  0.194  0.25   0.25   0.111</span></span><br><span class="line"><span class="comment"># &gt;   0.139  0.306  0.25   0.333  0.167  0.194  0.333  0.167  0.028  0.222</span></span><br><span class="line"><span class="comment"># &gt;   0.194  0.056  0.028  0.194  0.222  0.139  0.222  0.083  0.278  0.194</span></span><br><span class="line"><span class="comment"># &gt;   0.75   0.583  0.722  0.333  0.611  0.389  0.556  0.167  0.639  0.25</span></span><br><span class="line"><span class="comment"># &gt;   0.194  0.444  0.472  0.5    0.361  0.667  0.361  0.417  0.528  0.361</span></span><br><span class="line"><span class="comment"># &gt;   0.444  0.5    0.556  0.5    0.583  0.639  0.694  0.667  0.472  0.389</span></span><br><span class="line"><span class="comment"># &gt;   0.333  0.333  0.417  0.472  0.306  0.472  0.667  0.556  0.361  0.333</span></span><br><span class="line"><span class="comment"># &gt;   0.333  0.5    0.417  0.194  0.361  0.389  0.389  0.528  0.222  0.389</span></span><br><span class="line"><span class="comment"># &gt;   0.556  0.417  0.778  0.556  0.611  0.917  0.167  0.833  0.667  0.806</span></span><br><span class="line"><span class="comment"># &gt;   0.611  0.583  0.694  0.389  0.417  0.583  0.611  0.944  0.944  0.472</span></span><br><span class="line"><span class="comment"># &gt;   0.722  0.361  0.944  0.556  0.667  0.806  0.528  0.5    0.583  0.806</span></span><br><span class="line"><span class="comment"># &gt;   0.861  1.     0.583  0.556  0.5    0.944  0.556  0.583  0.472  0.722</span></span><br><span class="line"><span class="comment"># &gt;   0.667  0.722  0.417  0.694  0.667  0.667  0.556  0.611  0.528  0.444]</span></span><br></pre></td></tr></table></figure><h3 id="30-如何计算Softmax得分？"><a href="#30-如何计算Softmax得分？" class="headerlink" title="30. 如何计算Softmax得分？"></a>30. 如何计算Softmax得分？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>计算sepallength的softmax分数。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">sepallength = np.array([<span class="built_in">float</span>(row[<span class="number">0</span>]) <span class="keyword">for</span> row <span class="keyword">in</span> iris])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Compute softmax values for each sets of scores in x.</span></span><br><span class="line"><span class="string">    https://stackoverflow.com/questions/34968722/how-to-implement-the-softmax-function-in-python&quot;&quot;&quot;</span></span><br><span class="line">    e_x = np.exp(x - np.<span class="built_in">max</span>(x))</span><br><span class="line">    <span class="keyword">return</span> e_x / e_x.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(softmax(sepallength))</span><br><span class="line"><span class="comment"># &gt; [ 0.002  0.002  0.001  0.001  0.002  0.003  0.001  0.002  0.001  0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.003  0.002  0.002  0.001  0.004  0.004  0.003  0.002  0.004  0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.003  0.002  0.001  0.002  0.002  0.002  0.002  0.002  0.002  0.001</span></span><br><span class="line"><span class="comment"># &gt;   0.002  0.003  0.002  0.003  0.002  0.002  0.003  0.002  0.001  0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.002  0.001  0.001  0.002  0.002  0.002  0.002  0.001  0.003  0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.015  0.008  0.013  0.003  0.009  0.004  0.007  0.002  0.01   0.002</span></span><br><span class="line"><span class="comment"># &gt;   0.002  0.005  0.005  0.006  0.004  0.011  0.004  0.004  0.007  0.004</span></span><br><span class="line"><span class="comment"># &gt;   0.005  0.006  0.007  0.006  0.008  0.01   0.012  0.011  0.005  0.004</span></span><br><span class="line"><span class="comment"># &gt;   0.003  0.003  0.004  0.005  0.003  0.005  0.011  0.007  0.004  0.003</span></span><br><span class="line"><span class="comment"># &gt;   0.003  0.006  0.004  0.002  0.004  0.004  0.004  0.007  0.002  0.004</span></span><br><span class="line"><span class="comment"># &gt;   0.007  0.004  0.016  0.007  0.009  0.027  0.002  0.02   0.011  0.018</span></span><br><span class="line"><span class="comment"># &gt;   0.009  0.008  0.012  0.004  0.004  0.008  0.009  0.03   0.03   0.005</span></span><br><span class="line"><span class="comment"># &gt;   0.013  0.004  0.03   0.007  0.011  0.018  0.007  0.006  0.008  0.018</span></span><br><span class="line"><span class="comment"># &gt;   0.022  0.037  0.008  0.007  0.006  0.03   0.007  0.008  0.005  0.013</span></span><br><span class="line"><span class="comment"># &gt;   0.011  0.013  0.004  0.012  0.011  0.011  0.007  0.009  0.007  0.005]</span></span><br></pre></td></tr></table></figure><h3 id="31-如何找到numpy数组的百分位数？"><a href="#31-如何找到numpy数组的百分位数？" class="headerlink" title="31. 如何找到numpy数组的百分位数？"></a>31. 如何找到numpy数组的百分位数？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>找到鸢尾属植物数据集的第5和第95百分位数</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">sepallength = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">np.percentile(sepallength, q=[<span class="number">5</span>, <span class="number">95</span>])</span><br><span class="line"><span class="comment"># &gt; array([ 4.6  ,  7.255])</span></span><br></pre></td></tr></table></figure><h3 id="32-如何在数组中的随机位置插入值？"><a href="#32-如何在数组中的随机位置插入值？" class="headerlink" title="32. 如何在数组中的随机位置插入值？"></a>32. 如何在数组中的随机位置插入值？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>在iris_2d数据集中的20个随机位置插入np.nan值</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1</span></span><br><span class="line">i, j = np.where(iris_2d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># i, j contain the row numbers and column numbers of 600 elements of iris_x</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">iris_2d[np.random.choice((i), <span class="number">20</span>), np.random.choice((j), <span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print first 10 rows</span></span><br><span class="line"><span class="built_in">print</span>(iris_2d[:<span class="number">10</span>])</span><br><span class="line"><span class="comment"># &gt; [[b&#x27;5.1&#x27; b&#x27;3.5&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;3.0&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.7&#x27; b&#x27;3.2&#x27; b&#x27;1.3&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;5.0&#x27; b&#x27;3.6&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;5.4&#x27; b&#x27;3.9&#x27; b&#x27;1.7&#x27; b&#x27;0.4&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.4&#x27; b&#x27;1.4&#x27; b&#x27;0.3&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;5.0&#x27; b&#x27;3.4&#x27; b&#x27;1.5&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.4&#x27; nan b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]]</span></span><br></pre></td></tr></table></figure><h3 id="33-如何在numpy数组中找到缺失值的位置？"><a href="#33-如何在numpy数组中找到缺失值的位置？" class="headerlink" title="33. 如何在numpy数组中找到缺失值的位置？"></a>33. 如何在numpy数组中找到缺失值的位置？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>在iris_2d的sepallength中查找缺失值的数量和位置（第1列）</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of missing values: \n&quot;</span>, np.isnan(iris_2d[:, <span class="number">0</span>]).<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Position of missing values: \n&quot;</span>, np.where(np.isnan(iris_2d[:, <span class="number">0</span>])))</span><br><span class="line"><span class="comment"># &gt; Number of missing values: </span></span><br><span class="line"><span class="comment"># &gt;  5</span></span><br><span class="line"><span class="comment"># &gt; Position of missing values: </span></span><br><span class="line"><span class="comment"># &gt;  (array([ 39,  88,  99, 130, 147]),)</span></span><br></pre></td></tr></table></figure><h3 id="34-如何根据两个或多个条件过滤numpy数组？"><a href="#34-如何根据两个或多个条件过滤numpy数组？" class="headerlink" title="34. 如何根据两个或多个条件过滤numpy数组？"></a>34. 如何根据两个或多个条件过滤numpy数组？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>过滤具有petallength（第3列）&gt; 1.5 和 sepallength（第1列）&lt; 5.0 的iris_2d行</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">condition = (iris_2d[:, <span class="number">2</span>] &gt; <span class="number">1.5</span>) &amp; (iris_2d[:, <span class="number">0</span>] &lt; <span class="number">5.0</span>)</span><br><span class="line">iris_2d[condition]</span><br><span class="line"><span class="comment"># &gt; array([[ 4.8,  3.4,  1.6,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.8,  3.4,  1.9,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.7,  3.2,  1.6,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.8,  3.1,  1.6,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.9,  2.4,  3.3,  1. ],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.9,  2.5,  4.5,  1.7]])</span></span><br></pre></td></tr></table></figure><h3 id="35-如何从numpy数组中删除包含缺失值的行？"><a href="#35-如何从numpy数组中删除包含缺失值的行？" class="headerlink" title="35. 如何从numpy数组中删除包含缺失值的行？"></a>35. 如何从numpy数组中删除包含缺失值的行？</h3><p><strong>难度等级：</strong>L3:</p><p><strong>问题：</strong>选择没有任何nan值的iris_2d行。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># No direct numpy function for this.</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">any_nan_in_row = np.array([~np.<span class="built_in">any</span>(np.isnan(row)) <span class="keyword">for</span> row <span class="keyword">in</span> iris_2d])</span><br><span class="line">iris_2d[any_nan_in_row][:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2: (By Rong)</span></span><br><span class="line">iris_2d[np.<span class="built_in">sum</span>(np.isnan(iris_2d), axis = <span class="number">1</span>) == <span class="number">0</span>][:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># &gt; array([[ 4.9,  3. ,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.7,  3.2,  1.3,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.6,  3.1,  1.5,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 5. ,  3.6,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 5.4,  3.9,  1.7,  0.4]])</span></span><br></pre></td></tr></table></figure><h3 id="36-如何找到numpy数组的两列之间的相关性？"><a href="#36-如何找到numpy数组的两列之间的相关性？" class="headerlink" title="36. 如何找到numpy数组的两列之间的相关性？"></a>36. 如何找到numpy数组的两列之间的相关性？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>在iris_2d中找出SepalLength（第1列）和PetalLength（第3列）之间的相关性</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1</span></span><br><span class="line">np.corrcoef(iris[:, <span class="number">0</span>], iris[:, <span class="number">2</span>])[<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2</span></span><br><span class="line"><span class="keyword">from</span> scipy.stats.stats <span class="keyword">import</span> pearsonr  </span><br><span class="line">corr, p_value = pearsonr(iris[:, <span class="number">0</span>], iris[:, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(corr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Correlation coef indicates the degree of linear relationship between two numeric variables.</span></span><br><span class="line"><span class="comment"># It can range between -1 to +1.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The p-value roughly indicates the probability of an uncorrelated system producing </span></span><br><span class="line"><span class="comment"># datasets that have a correlation at least as extreme as the one computed.</span></span><br><span class="line"><span class="comment"># The lower the p-value (&lt;0.01), stronger is the significance of the relationship.</span></span><br><span class="line"><span class="comment"># It is not an indicator of the strength.</span></span><br><span class="line"><span class="comment"># &gt; 0.871754157305</span></span><br></pre></td></tr></table></figure><h3 id="37-如何查找给定数组是否具有任何空值？"><a href="#37-如何查找给定数组是否具有任何空值？" class="headerlink" title="37. 如何查找给定数组是否具有任何空值？"></a>37. 如何查找给定数组是否具有任何空值？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>找出iris_2d是否有任何缺失值。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">np.isnan(iris_2d).<span class="built_in">any</span>()</span><br><span class="line"><span class="comment"># &gt; False</span></span><br></pre></td></tr></table></figure><h3 id="38-如何在numpy数组中用0替换所有缺失值？"><a href="#38-如何在numpy数组中用0替换所有缺失值？" class="headerlink" title="38. 如何在numpy数组中用0替换所有缺失值？"></a>38. 如何在numpy数组中用0替换所有缺失值？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>在numpy数组中将所有出现的nan替换为0</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;float&#x27;</span>, usecols=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">iris_2d[np.random.randint(<span class="number">150</span>, size=<span class="number">20</span>), np.random.randint(<span class="number">4</span>, size=<span class="number">20</span>)] = np.nan</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">iris_2d[np.isnan(iris_2d)] = <span class="number">0</span></span><br><span class="line">iris_2d[:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># &gt; array([[ 5.1,  3.5,  1.4,  0. ],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.9,  3. ,  1.4,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.7,  3.2,  1.3,  0.2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 4.6,  3.1,  1.5,  0.2]])</span></span><br></pre></td></tr></table></figure><h3 id="39-如何在numpy数组中查找唯一值的计数？"><a href="#39-如何在numpy数组中查找唯一值的计数？" class="headerlink" title="39. 如何在numpy数组中查找唯一值的计数？"></a>39. 如何在numpy数组中查找唯一值的计数？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>找出鸢尾属植物物种中的独特值和独特值的数量</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import iris keeping the text column intact</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Extract the species column as an array</span></span><br><span class="line">species = np.array([row.tolist()[<span class="number">4</span>] <span class="keyword">for</span> row <span class="keyword">in</span> iris])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the unique values and the counts</span></span><br><span class="line">np.unique(species, return_counts=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># &gt; (array([b&#x27;Iris-setosa&#x27;, b&#x27;Iris-versicolor&#x27;, b&#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;        dtype=&#x27;|S15&#x27;), array([50, 50, 50]))</span></span><br></pre></td></tr></table></figure><h3 id="40-如何将数字转换为分类（文本）数组？"><a href="#40-如何将数字转换为分类（文本）数组？" class="headerlink" title="40. 如何将数字转换为分类（文本）数组？"></a>40. 如何将数字转换为分类（文本）数组？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>将iris_2d的花瓣长度（第3列）加入以形成文本数组，这样如果花瓣长度为：</p><ul><li>Less than 3 –&gt; ‘small’</li><li>3-5 –&gt; ‘medium’</li><li>‘&gt;=5 –&gt; ‘large’</li></ul><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bin petallength </span></span><br><span class="line">petal_length_bin = np.digitize(iris[:, <span class="number">2</span>].astype(<span class="string">&#x27;float&#x27;</span>), [<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Map it to respective category</span></span><br><span class="line">label_map = &#123;<span class="number">1</span>: <span class="string">&#x27;small&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;medium&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;large&#x27;</span>, <span class="number">4</span>: np.nan&#125;</span><br><span class="line">petal_length_cat = [label_map[x] <span class="keyword">for</span> x <span class="keyword">in</span> petal_length_bin]</span><br><span class="line"></span><br><span class="line"><span class="comment"># View</span></span><br><span class="line">petal_length_cat[:<span class="number">4</span>]</span><br><span class="line">&lt;<span class="comment"># &gt; [&#x27;small&#x27;, &#x27;small&#x27;, &#x27;small&#x27;, &#x27;small&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="41-如何从numpy数组的现有列创建新列？"><a href="#41-如何从numpy数组的现有列创建新列？" class="headerlink" title="41. 如何从numpy数组的现有列创建新列？"></a>41. 如何从numpy数组的现有列创建新列？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>在iris_2d中为卷创建一个新列，其中volume是<code>（pi x petallength x sepal_length ^ 2）/ 3</code></p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris_2d = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Compute volume</span></span><br><span class="line">sepallength = iris_2d[:, <span class="number">0</span>].astype(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line">petallength = iris_2d[:, <span class="number">2</span>].astype(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line">volume = (np.pi * petallength * (sepallength**<span class="number">2</span>))/<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Introduce new dimension to match iris_2d&#x27;s</span></span><br><span class="line">volume = volume[:, np.newaxis]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the new column</span></span><br><span class="line">out = np.hstack([iris_2d, volume])</span><br><span class="line"></span><br><span class="line"><span class="comment"># View</span></span><br><span class="line">out[:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># &gt; array([[b&#x27;5.1&#x27;, b&#x27;3.5&#x27;, b&#x27;1.4&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;, 38.13265162927291],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.9&#x27;, b&#x27;3.0&#x27;, b&#x27;1.4&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;, 35.200498485922445],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.7&#x27;, b&#x27;3.2&#x27;, b&#x27;1.3&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;, 30.0723720777127],</span></span><br><span class="line"><span class="comment"># &gt;        [b&#x27;4.6&#x27;, b&#x27;3.1&#x27;, b&#x27;1.5&#x27;, b&#x27;0.2&#x27;, b&#x27;Iris-setosa&#x27;, 33.238050274980004]], dtype=object)</span></span><br></pre></td></tr></table></figure><h3 id="42-如何在numpy中进行概率抽样？"><a href="#42-如何在numpy中进行概率抽样？" class="headerlink" title="42. 如何在numpy中进行概率抽样？"></a>42. 如何在numpy中进行概率抽样？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>随机抽鸢尾属植物的种类，使得刚毛的数量是云芝和维吉尼亚的两倍</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import iris keeping the text column intact</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import iris keeping the text column intact</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Get the species column</span></span><br><span class="line">species = iris[:, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Approach 1: Generate Probablistically</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.array([<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>])</span><br><span class="line">species_out = np.random.choice(a, <span class="number">150</span>, p=[<span class="number">0.5</span>, <span class="number">0.25</span>, <span class="number">0.25</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Approach 2: Probablistic Sampling (preferred)</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">probs = np.r_[np.linspace(<span class="number">0</span>, <span class="number">0.500</span>, num=<span class="number">50</span>), np.linspace(<span class="number">0.501</span>, <span class="number">.750</span>, num=<span class="number">50</span>), np.linspace(<span class="number">.751</span>, <span class="number">1.0</span>, num=<span class="number">50</span>)]</span><br><span class="line">index = np.searchsorted(probs, np.random.random(<span class="number">150</span>))</span><br><span class="line">species_out = species[index]</span><br><span class="line"><span class="built_in">print</span>(np.unique(species_out, return_counts=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; (array([b&#x27;Iris-setosa&#x27;, b&#x27;Iris-versicolor&#x27;, b&#x27;Iris-virginica&#x27;], dtype=object), array([77, 37, 36]))</span></span><br></pre></td></tr></table></figure><p>方法2是首选方法，因为它创建了一个索引变量，该变量可用于取样2维表格数据。</p><h3 id="43-如何在按另一个数组分组时获取数组的第二大值？"><a href="#43-如何在按另一个数组分组时获取数组的第二大值？" class="headerlink" title="43. 如何在按另一个数组分组时获取数组的第二大值？"></a>43. 如何在按另一个数组分组时获取数组的第二大值？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>第二长的物种setosa的价值是多少</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import iris keeping the text column intact</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Get the species and petal length columns</span></span><br><span class="line">petal_len_setosa = iris[iris[:, <span class="number">4</span>] == <span class="string">b&#x27;Iris-setosa&#x27;</span>, [<span class="number">2</span>]].astype(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the second last value</span></span><br><span class="line">np.unique(np.sort(petal_len_setosa))[-<span class="number">2</span>]</span><br><span class="line"><span class="comment"># &gt; 1.7</span></span><br></pre></td></tr></table></figure><h3 id="44-如何按列对2D数组进行排序"><a href="#44-如何按列对2D数组进行排序" class="headerlink" title="44. 如何按列对2D数组进行排序"></a>44. 如何按列对2D数组进行排序</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>根据sepallength列对虹膜数据集进行排序。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sort by column position 0: SepalLength</span></span><br><span class="line"><span class="built_in">print</span>(iris[iris[:,<span class="number">0</span>].argsort()][:<span class="number">20</span>])</span><br><span class="line"><span class="comment"># &gt; [[b&#x27;4.3&#x27; b&#x27;3.0&#x27; b&#x27;1.1&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.4&#x27; b&#x27;3.2&#x27; b&#x27;1.3&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.4&#x27; b&#x27;3.0&#x27; b&#x27;1.3&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.4&#x27; b&#x27;2.9&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.5&#x27; b&#x27;2.3&#x27; b&#x27;1.3&#x27; b&#x27;0.3&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.6&#x27; b&#x27;1.0&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.4&#x27; b&#x27;1.4&#x27; b&#x27;0.3&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.6&#x27; b&#x27;3.2&#x27; b&#x27;1.4&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.7&#x27; b&#x27;3.2&#x27; b&#x27;1.3&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.7&#x27; b&#x27;3.2&#x27; b&#x27;1.6&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.0&#x27; b&#x27;1.4&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.0&#x27; b&#x27;1.4&#x27; b&#x27;0.3&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.4&#x27; b&#x27;1.9&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.4&#x27; b&#x27;1.6&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.8&#x27; b&#x27;3.1&#x27; b&#x27;1.6&#x27; b&#x27;0.2&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;2.4&#x27; b&#x27;3.3&#x27; b&#x27;1.0&#x27; b&#x27;Iris-versicolor&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;2.5&#x27; b&#x27;4.5&#x27; b&#x27;1.7&#x27; b&#x27;Iris-virginica&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;4.9&#x27; b&#x27;3.1&#x27; b&#x27;1.5&#x27; b&#x27;0.1&#x27; b&#x27;Iris-setosa&#x27;]]</span></span><br></pre></td></tr></table></figure><h3 id="45-如何在numpy数组中找到最常见的值？"><a href="#45-如何在numpy数组中找到最常见的值？" class="headerlink" title="45. 如何在numpy数组中找到最常见的值？"></a>45. 如何在numpy数组中找到最常见的值？</h3><p><strong>难度等级：</strong>L1</p><p><strong>问题：</strong>在鸢尾属植物数据集中找到最常见的花瓣长度值（第3列）。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line">vals, counts = np.unique(iris[:, <span class="number">2</span>], return_counts=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(vals[np.argmax(counts)])</span><br><span class="line"><span class="comment"># &gt; b&#x27;1.5&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="46-如何找到第一次出现的值大于给定值的位置？"><a href="#46-如何找到第一次出现的值大于给定值的位置？" class="headerlink" title="46. 如何找到第一次出现的值大于给定值的位置？"></a>46. 如何找到第一次出现的值大于给定值的位置？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>在虹膜数据集的petalwidth第4列中查找第一次出现的值大于1.0的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution: (edit: changed argmax to argwhere. Thanks Rong!)</span></span><br><span class="line">np.argwhere(iris[:, <span class="number">3</span>].astype(<span class="built_in">float</span>) &gt; <span class="number">1.0</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># &gt; 50</span></span><br></pre></td></tr></table></figure><h3 id="47-如何将大于给定值的所有值替换为给定的截止值？"><a href="#47-如何将大于给定值的所有值替换为给定的截止值？" class="headerlink" title="47. 如何将大于给定值的所有值替换为给定的截止值？"></a>47. 如何将大于给定值的所有值替换为给定的截止值？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>从数组a中，替换所有大于30到30和小于10到10的值。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.uniform(<span class="number">1</span>,<span class="number">50</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.uniform(<span class="number">1</span>,<span class="number">50</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1: Using np.clip</span></span><br><span class="line">np.clip(a, a_min=<span class="number">10</span>, a_max=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2: Using np.where</span></span><br><span class="line"><span class="built_in">print</span>(np.where(a &lt; <span class="number">10</span>, <span class="number">10</span>, np.where(a &gt; <span class="number">30</span>, <span class="number">30</span>, a)))</span><br><span class="line"><span class="comment"># &gt; [ 27.63  14.64  21.8   30.    10.    10.    30.    30.    10.    29.18  30.</span></span><br><span class="line"><span class="comment"># &gt;   11.25  10.08  10.    11.77  30.    30.    10.    30.    14.43]</span></span><br></pre></td></tr></table></figure><h3 id="48-如何从numpy数组中获取最大n值的位置？"><a href="#48-如何从numpy数组中获取最大n值的位置？" class="headerlink" title="48. 如何从numpy数组中获取最大n值的位置？"></a>48. 如何从numpy数组中获取最大n值的位置？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>获取给定数组a中前5个最大值的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.uniform(<span class="number">1</span>,<span class="number">50</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.uniform(<span class="number">1</span>,<span class="number">50</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line"><span class="built_in">print</span>(a.argsort())</span><br><span class="line"><span class="comment"># &gt; [18 7 3 10 15]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2:</span></span><br><span class="line">np.argpartition(-a, <span class="number">5</span>)[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># &gt; [15 10  3  7 18]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Below methods will get you the values.</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">a[a.argsort()][-<span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">np.sort(a)[-<span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 3:</span></span><br><span class="line">np.partition(a, kth=-<span class="number">5</span>)[-<span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 4:</span></span><br><span class="line">a[np.argpartition(-a, <span class="number">5</span>)][:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="49-如何计算数组中所有可能值的行数？"><a href="#49-如何计算数组中所有可能值的行数？" class="headerlink" title="49. 如何计算数组中所有可能值的行数？"></a>49. 如何计算数组中所有可能值的行数？</h3><p><strong>难度等级：</strong>L4</p><p><strong>问题：</strong>按行计算唯一值的计数。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">11</span>,size=(<span class="number">6</span>, <span class="number">10</span>))</span><br><span class="line">arr</span><br><span class="line">&gt; array([[ <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">4</span>,  <span class="number">8</span>,  <span class="number">8</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">3</span>],</span><br><span class="line">&gt;        [ <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">1</span>, <span class="number">10</span>,  <span class="number">7</span>,  <span class="number">3</span>],</span><br><span class="line">&gt;        [ <span class="number">5</span>,  <span class="number">2</span>,  <span class="number">6</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">5</span>,  <span class="number">4</span>,  <span class="number">8</span>,  <span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">&gt;        [ <span class="number">8</span>,  <span class="number">8</span>,  <span class="number">1</span>,  <span class="number">3</span>, <span class="number">10</span>, <span class="number">10</span>,  <span class="number">4</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">&gt;        [ <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">3</span>,  <span class="number">1</span>,  <span class="number">9</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">2</span>],</span><br><span class="line">&gt;        [ <span class="number">9</span>,  <span class="number">2</span>,  <span class="number">6</span>,  <span class="number">5</span>,  <span class="number">3</span>,  <span class="number">9</span>,  <span class="number">4</span>,  <span class="number">6</span>,  <span class="number">1</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">&gt;  [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">&gt;  [<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">&gt;  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">&gt;  [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">&gt;  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>输出包含10列，表示从1到10的数字。这些值是各行中数字的计数。 例如，cell(0，2)的值为2，这意味着数字3在第一行中恰好出现了2次。</p><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">11</span>,size=(<span class="number">6</span>, <span class="number">10</span>))</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([[ 9,  9,  4,  8,  8,  1,  5,  3,  6,  3],</span></span><br><span class="line"><span class="comment"># &gt;        [ 3,  3,  2,  1,  9,  5,  1, 10,  7,  3],</span></span><br><span class="line"><span class="comment"># &gt;        [ 5,  2,  6,  4,  5,  5,  4,  8,  2,  2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 8,  8,  1,  3, 10, 10,  4,  3,  6,  9],</span></span><br><span class="line"><span class="comment"># &gt;        [ 2,  1,  8,  7,  3,  1,  9,  3,  6,  2],</span></span><br><span class="line"><span class="comment"># &gt;        [ 9,  2,  6,  5,  3,  9,  4,  6,  1, 10]])</span></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counts_of_all_values_rowwise</span>(<span class="params">arr2d</span>):</span></span><br><span class="line">    <span class="comment"># Unique values and its counts row wise</span></span><br><span class="line">    num_counts_array = [np.unique(row, return_counts=<span class="literal">True</span>) <span class="keyword">for</span> row <span class="keyword">in</span> arr2d]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Counts of all values row wise</span></span><br><span class="line">    <span class="keyword">return</span>([[<span class="built_in">int</span>(b[a==i]) <span class="keyword">if</span> i <span class="keyword">in</span> a <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> np.unique(arr2d)] <span class="keyword">for</span> a, b <span class="keyword">in</span> num_counts_array])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print</span></span><br><span class="line"><span class="built_in">print</span>(np.arange(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">counts_of_all_values_rowwise(arr)</span><br><span class="line"><span class="comment"># &gt; [ 1  2  3  4  5  6  7  8  9 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; [[1, 0, 2, 1, 1, 1, 0, 2, 2, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [2, 1, 3, 0, 1, 0, 1, 0, 1, 1],</span></span><br><span class="line"><span class="comment"># &gt;  [0, 3, 0, 2, 3, 1, 0, 1, 0, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [1, 0, 2, 1, 0, 1, 0, 2, 1, 2],</span></span><br><span class="line"><span class="comment"># &gt;  [2, 2, 2, 0, 0, 1, 1, 1, 1, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [1, 1, 1, 1, 1, 2, 0, 0, 2, 1]]</span></span><br><span class="line"><span class="comment"># Example 2:</span></span><br><span class="line">arr = np.array([np.array(<span class="built_in">list</span>(<span class="string">&#x27;bill clinton&#x27;</span>)), np.array(<span class="built_in">list</span>(<span class="string">&#x27;narendramodi&#x27;</span>)), np.array(<span class="built_in">list</span>(<span class="string">&#x27;jjayalalitha&#x27;</span>))])</span><br><span class="line"><span class="built_in">print</span>(np.unique(arr))</span><br><span class="line">counts_of_all_values_rowwise(arr)</span><br><span class="line"><span class="comment"># &gt; [&#x27; &#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;r&#x27; &#x27;t&#x27; &#x27;y&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; [[1, 0, 1, 1, 0, 0, 0, 2, 0, 3, 0, 2, 1, 0, 1, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [0, 2, 0, 0, 2, 1, 0, 1, 0, 0, 1, 2, 1, 2, 0, 0],</span></span><br><span class="line"><span class="comment"># &gt;  [0, 4, 0, 0, 0, 0, 1, 1, 2, 2, 0, 0, 0, 0, 1, 1]]</span></span><br></pre></td></tr></table></figure><h3 id="50-如何将数组转换为平面一维数组？"><a href="#50-如何将数组转换为平面一维数组？" class="headerlink" title="50. 如何将数组转换为平面一维数组？"></a>50. 如何将数组转换为平面一维数组？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>将array_of_arrays转换为扁平线性1d数组。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">arr1 = np.arange(<span class="number">3</span>)</span><br><span class="line">arr2 = np.arange(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">arr3 = np.arange(<span class="number">7</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">array_of_arrays = np.array([arr1, arr2, arr3])</span><br><span class="line">array_of_arrays</span><br><span class="line"><span class="comment"># &gt; array([array([0, 1, 2]), array([3, 4, 5, 6]), array([7, 8, 9])], dtype=object)</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># **给定：**</span></span><br><span class="line">arr1 = np.arange(<span class="number">3</span>)</span><br><span class="line">arr2 = np.arange(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">arr3 = np.arange(<span class="number">7</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">array_of_arrays = np.array([arr1, arr2, arr3])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array_of_arrays: &#x27;</span>, array_of_arrays)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1</span></span><br><span class="line">arr_2d = np.array([a <span class="keyword">for</span> arr <span class="keyword">in</span> array_of_arrays <span class="keyword">for</span> a <span class="keyword">in</span> arr])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2:</span></span><br><span class="line">arr_2d = np.concatenate(array_of_arrays)</span><br><span class="line"><span class="built_in">print</span>(arr_2d)</span><br><span class="line"><span class="comment"># &gt; array_of_arrays:  [array([0, 1, 2]) array([3, 4, 5, 6]) array([7, 8, 9])]</span></span><br><span class="line"><span class="comment"># &gt; [0 1 2 3 4 5 6 7 8 9]</span></span><br></pre></td></tr></table></figure><h3 id="51-如何在numpy中为数组生成单热编码？"><a href="#51-如何在numpy中为数组生成单热编码？" class="headerlink" title="51. 如何在numpy中为数组生成单热编码？"></a>51. 如何在numpy中为数组生成单热编码？</h3><p><strong>难度等级：</strong>L4</p><p><strong>问题：</strong>计算一次性编码(数组中每个唯一值的虚拟二进制变量)</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">101</span>) </span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">4</span>, size=<span class="number">6</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([2, 3, 2, 2, 2, 1])</span></span><br></pre></td></tr></table></figure><p><strong>期望输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([[ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  0.,  1.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 1.,  0.,  0.]])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">np.random.seed(<span class="number">101</span>) </span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">4</span>, size=<span class="number">6</span>)</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([2, 3, 2, 2, 2, 1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot_encodings</span>(<span class="params">arr</span>):</span></span><br><span class="line">    uniqs = np.unique(arr)</span><br><span class="line">    out = np.zeros((arr.shape[<span class="number">0</span>], uniqs.shape[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">for</span> i, k <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">        out[i, k-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">one_hot_encodings(arr)</span><br><span class="line"><span class="comment"># &gt; array([[ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  0.,  1.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 0.,  1.,  0.],</span></span><br><span class="line"><span class="comment"># &gt;        [ 1.,  0.,  0.]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:</span></span><br><span class="line">(arr[:, <span class="literal">None</span>] == np.unique(arr)).view(np.int8)</span><br></pre></td></tr></table></figure><h3 id="52-如何创建按分类变量分组的行号？"><a href="#52-如何创建按分类变量分组的行号？" class="headerlink" title="52. 如何创建按分类变量分组的行号？"></a>52. 如何创建按分类变量分组的行号？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>创建按分类变量分组的行号。使用以下来自鸢尾属植物物种的样本作为输入。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">species = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;str&#x27;</span>, usecols=<span class="number">4</span>)</span><br><span class="line">species_small = np.sort(np.random.choice(species, size=<span class="number">20</span>))</span><br><span class="line">species_small</span><br><span class="line"><span class="comment"># &gt; array([&#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;&lt;U15&#x27;)</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">species = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;str&#x27;</span>, usecols=<span class="number">4</span>)</span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">species_small = np.sort(np.random.choice(species, size=<span class="number">20</span>))</span><br><span class="line">species_small</span><br><span class="line"><span class="comment"># &gt; array([&#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-setosa&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;&lt;U15&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> val <span class="keyword">in</span> np.unique(species_small) <span class="keyword">for</span> i, grp <span class="keyword">in</span> <span class="built_in">enumerate</span>(species_small[species_small==val])])</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="53-如何根据给定的分类变量创建组id？-53-如何根据给定的分类变量创建组ID？"><a href="#53-如何根据给定的分类变量创建组id？-53-如何根据给定的分类变量创建组ID？" class="headerlink" title="53-如何根据给定的分类变量创建组id？)53. 如何根据给定的分类变量创建组ID？"></a>53-如何根据给定的分类变量创建组id？)53. 如何根据给定的分类变量创建组ID？</h3><p><strong>难度等级：</strong>L4</p><p><strong>问题：</strong>根据给定的分类变量创建组ID。使用以下来自鸢尾属植物物种的样本作为输入。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">species = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;str&#x27;</span>, usecols=<span class="number">4</span>)</span><br><span class="line">species_small = np.sort(np.random.choice(species, size=<span class="number">20</span>))</span><br><span class="line">species_small</span><br><span class="line"><span class="comment"># &gt; array([&#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;&lt;U15&#x27;)</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2]</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">species = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;str&#x27;</span>, usecols=<span class="number">4</span>)</span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">species_small = np.sort(np.random.choice(species, size=<span class="number">20</span>))</span><br><span class="line">species_small</span><br><span class="line"><span class="comment"># &gt; array([&#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;, &#x27;Iris-setosa&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-setosa&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;, &#x27;Iris-versicolor&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-versicolor&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;, &#x27;Iris-virginica&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;Iris-virginica&#x27;],</span></span><br><span class="line"><span class="comment"># &gt;       dtype=&#x27;&lt;U15&#x27;)</span></span><br><span class="line"><span class="comment"># Solution:</span></span><br><span class="line">output = [np.argwhere(np.unique(species_small) == s).tolist()[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">for</span> val <span class="keyword">in</span> np.unique(species_small) <span class="keyword">for</span> s <span class="keyword">in</span> species_small[species_small==val]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution: For Loop version</span></span><br><span class="line">output = []</span><br><span class="line">uniqs = np.unique(species_small)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> uniqs:  <span class="comment"># uniq values in group</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> species_small[species_small==val]:  <span class="comment"># each element in group</span></span><br><span class="line">        groupid = np.argwhere(uniqs == s).tolist()[<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># groupid</span></span><br><span class="line">        output.append(groupid)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"><span class="comment"># &gt; [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2]</span></span><br></pre></td></tr></table></figure><h3 id="54-如何使用numpy对数组中的项进行排名？-54-如何使用numpy对数组中的项进行排名？"><a href="#54-如何使用numpy对数组中的项进行排名？-54-如何使用numpy对数组中的项进行排名？" class="headerlink" title="54-如何使用numpy对数组中的项进行排名？)54. 如何使用numpy对数组中的项进行排名？"></a>54-如何使用numpy对数组中的项进行排名？)54. 如何使用numpy对数组中的项进行排名？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>为给定的数字数组a创建排名。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">a = np.random.randint(<span class="number">20</span>, size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># &gt; [ 9  4 15  0 17 16 17  8  9  0]</span></span><br></pre></td></tr></table></figure><p><strong>期望输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span> <span class="number">2</span> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span> <span class="number">7</span> <span class="number">9</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">a = np.random.randint(<span class="number">20</span>, size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Array: &#x27;</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="built_in">print</span>(a.argsort().argsort())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Array: &#x27;</span>, a)</span><br><span class="line"><span class="comment"># &gt; Array:  [ 9  4 15  0 17 16 17  8  9  0]</span></span><br><span class="line"><span class="comment"># &gt; [4 2 6 0 8 7 9 3 5 1]</span></span><br><span class="line"><span class="comment"># &gt; Array:  [ 9  4 15  0 17 16 17  8  9  0]</span></span><br></pre></td></tr></table></figure><h3 id="55-如何使用numpy对多维数组中的项进行排名？-55-如何使用numpy对多维数组中的项进行排名？"><a href="#55-如何使用numpy对多维数组中的项进行排名？-55-如何使用numpy对多维数组中的项进行排名？" class="headerlink" title="55-如何使用numpy对多维数组中的项进行排名？)55. 如何使用numpy对多维数组中的项进行排名？"></a>55-如何使用numpy对多维数组中的项进行排名？)55. 如何使用numpy对多维数组中的项进行排名？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>创建与给定数字数组a相同形状的排名数组。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">a = np.random.randint(<span class="number">20</span>, size=[<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># &gt; [[ 9  4 15  0 17]</span></span><br><span class="line"><span class="comment"># &gt;  [16 17  8  9  0]]</span></span><br></pre></td></tr></table></figure><p><strong>期望输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; [[4 2 6 0 8]</span></span><br><span class="line"><span class="comment"># &gt;  [7 9 3 5 1]]</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：**</span></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">a = np.random.randint(<span class="number">20</span>, size=[<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="built_in">print</span>(a.ravel().argsort().argsort().reshape(a.shape))</span><br><span class="line"><span class="comment"># &gt; [[ 9  4 15  0 17]</span></span><br><span class="line"><span class="comment"># &gt;  [16 17  8  9  0]]</span></span><br><span class="line"><span class="comment"># &gt; [[4 2 6 0 8]</span></span><br><span class="line"><span class="comment"># &gt;  [7 9 3 5 1]]</span></span><br></pre></td></tr></table></figure><h3 id="56-如何在二维numpy数组的每一行中找到最大值？-56-如何在二维numpy数组的每一行中找到最大值？"><a href="#56-如何在二维numpy数组的每一行中找到最大值？-56-如何在二维numpy数组的每一行中找到最大值？" class="headerlink" title="56-如何在二维numpy数组的每一行中找到最大值？)56. 如何在二维numpy数组的每一行中找到最大值？"></a>56-如何在二维numpy数组的每一行中找到最大值？)56. 如何在二维numpy数组的每一行中找到最大值？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>计算给定数组中每行的最大值。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">1</span>,<span class="number">10</span>, [<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([[9, 9, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [8, 8, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 3, 6],</span></span><br><span class="line"><span class="comment"># &gt;        [3, 3, 3],</span></span><br><span class="line"><span class="comment"># &gt;        [2, 1, 9]])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">1</span>,<span class="number">10</span>, [<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1</span></span><br><span class="line">np.amax(a, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2</span></span><br><span class="line">np.apply_along_axis(np.<span class="built_in">max</span>, arr=a, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># &gt; array([9, 8, 6, 3, 9])</span></span><br></pre></td></tr></table></figure><h3 id="57-如何计算二维numpy数组每行的最小值？-57-如何计算二维numpy数组每行的最小值？"><a href="#57-如何计算二维numpy数组每行的最小值？-57-如何计算二维numpy数组每行的最小值？" class="headerlink" title="57-如何计算二维numpy数组每行的最小值？)57. 如何计算二维numpy数组每行的最小值？"></a>57-如何计算二维numpy数组每行的最小值？)57. 如何计算二维numpy数组每行的最小值？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>为给定的二维numpy数组计算每行的最小值。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">1</span>,<span class="number">10</span>, [<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line">a</span><br><span class="line"><span class="comment"># &gt; array([[9, 9, 4],</span></span><br><span class="line"><span class="comment"># &gt;        [8, 8, 1],</span></span><br><span class="line"><span class="comment"># &gt;        [5, 3, 6],</span></span><br><span class="line"><span class="comment"># &gt;        [3, 3, 3],</span></span><br><span class="line"><span class="comment"># &gt;        [2, 1, 9]])</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">1</span>,<span class="number">10</span>, [<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">np.apply_along_axis(<span class="keyword">lambda</span> x: np.<span class="built_in">min</span>(x)/np.<span class="built_in">max</span>(x), arr=a, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># &gt; array([ 0.44444444,  0.125     ,  0.5       ,  1.        ,  0.11111111])</span></span><br></pre></td></tr></table></figure><h3 id="58-如何在numpy数组中找到重复的记录？-58-如何在numpy数组中找到重复的记录？"><a href="#58-如何在numpy数组中找到重复的记录？-58-如何在numpy数组中找到重复的记录？" class="headerlink" title="58-如何在numpy数组中找到重复的记录？)58. 如何在numpy数组中找到重复的记录？"></a>58-如何在numpy数组中找到重复的记录？)58. 如何在numpy数组中找到重复的记录？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>在给定的numpy数组中找到重复的条目(第二次出现以后)，并将它们标记为True。第一次出现应该是False的。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Array: &#x27;</span>, a)</span><br><span class="line"><span class="comment"># &gt; Array: [0 0 3 0 2 4 2 2 2 2]</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; [False  True False  True False False  True  True  True  True]</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">a = np.random.randint(<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Solution</span></span><br><span class="line"><span class="comment"># There is no direct function to do this as of 1.13.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an all True array</span></span><br><span class="line">out = np.full(a.shape[<span class="number">0</span>], <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find the index positions of unique elements</span></span><br><span class="line">unique_positions = np.unique(a, return_index=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mark those positions as False</span></span><br><span class="line">out[unique_positions] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="comment"># &gt; [False  True False  True False False  True  True  True  True]</span></span><br></pre></td></tr></table></figure><h3 id="59-如何找出数字的分组均值？-59-如何找出数字的分组均值？"><a href="#59-如何找出数字的分组均值？-59-如何找出数字的分组均值？" class="headerlink" title="59-如何找出数字的分组均值？)59. 如何找出数字的分组均值？"></a>59-如何找出数字的分组均值？)59. 如何找出数字的分组均值？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>在二维数字数组中查找按分类列分组的数值列的平均值</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>理想的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; [[b&#x27;Iris-setosa&#x27;, 3.418],</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;Iris-versicolor&#x27;, 2.770],</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;Iris-virginica&#x27;, 2.974]]</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">url = <span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&#x27;</span></span><br><span class="line">iris = np.genfromtxt(url, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">names = (<span class="string">&#x27;sepallength&#x27;</span>, <span class="string">&#x27;sepalwidth&#x27;</span>, <span class="string">&#x27;petallength&#x27;</span>, <span class="string">&#x27;petalwidth&#x27;</span>, <span class="string">&#x27;species&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># No direct way to implement this. Just a version of a workaround.</span></span><br><span class="line">numeric_column = iris[:, <span class="number">1</span>].astype(<span class="string">&#x27;float&#x27;</span>)  <span class="comment"># sepalwidth</span></span><br><span class="line">grouping_column = iris[:, <span class="number">4</span>]  <span class="comment"># species</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List comprehension version</span></span><br><span class="line">[[group_val, numeric_column[grouping_column==group_val].mean()] <span class="keyword">for</span> group_val <span class="keyword">in</span> np.unique(grouping_column)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># For Loop version</span></span><br><span class="line">output = []</span><br><span class="line"><span class="keyword">for</span> group_val <span class="keyword">in</span> np.unique(grouping_column):</span><br><span class="line">    output.append([group_val, numeric_column[grouping_column==group_val].mean()])</span><br><span class="line"></span><br><span class="line">output</span><br><span class="line"><span class="comment"># &gt; [[b&#x27;Iris-setosa&#x27;, 3.418],</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;Iris-versicolor&#x27;, 2.770],</span></span><br><span class="line"><span class="comment"># &gt;  [b&#x27;Iris-virginica&#x27;, 2.974]]</span></span><br></pre></td></tr></table></figure><h3 id="60-如何将PIL图像转换为numpy数组？"><a href="#60-如何将PIL图像转换为numpy数组？" class="headerlink" title="60. 如何将PIL图像转换为numpy数组？"></a>60. 如何将PIL图像转换为numpy数组？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>从以下URL导入图像并将其转换为numpy数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL = &#x27;https://upload.wikimedia.org/wikipedia/commons/8/8b/Denali_Mt_McKinley.jpg&#x27;</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> PIL, requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import image from URL</span></span><br><span class="line">URL = <span class="string">&#x27;https://upload.wikimedia.org/wikipedia/commons/8/8b/Denali_Mt_McKinley.jpg&#x27;</span></span><br><span class="line">response = requests.get(URL)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read it as Image</span></span><br><span class="line">I = Image.<span class="built_in">open</span>(BytesIO(response.content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optionally resize</span></span><br><span class="line">I = I.resize([<span class="number">150</span>,<span class="number">150</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert to numpy array</span></span><br><span class="line">arr = np.asarray(I)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optionaly Convert it back to an image and show</span></span><br><span class="line">im = PIL.Image.fromarray(np.uint8(arr))</span><br><span class="line">Image.Image.show(im)</span><br></pre></td></tr></table></figure><h3 id="61-如何删除numpy数组中所有缺少的值？"><a href="#61-如何删除numpy数组中所有缺少的值？" class="headerlink" title="61. 如何删除numpy数组中所有缺少的值？"></a>61. 如何删除numpy数组中所有缺少的值？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>从一维numpy数组中删除所有NaN值</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,np.nan,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,np.nan])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,np.nan,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,np.nan])</span><br><span class="line">a[~np.isnan(a)]</span><br><span class="line"><span class="comment"># &gt; array([ 1.,  2.,  3.,  5.,  6.,  7.])</span></span><br></pre></td></tr></table></figure><h3 id="62-如何计算两个数组之间的欧氏距离？"><a href="#62-如何计算两个数组之间的欧氏距离？" class="headerlink" title="62. 如何计算两个数组之间的欧氏距离？"></a>62. 如何计算两个数组之间的欧氏距离？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>计算两个数组a和数组b之间的欧氏距离。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">dist = np.linalg.norm(a-b)</span><br><span class="line">dist</span><br><span class="line"><span class="comment"># &gt; 6.7082039324993694</span></span><br></pre></td></tr></table></figure><h3 id="63-如何在一维数组中找到所有的局部极大值-或峰值-？"><a href="#63-如何在一维数组中找到所有的局部极大值-或峰值-？" class="headerlink" title="63. 如何在一维数组中找到所有的局部极大值(或峰值)？"></a>63. 如何在一维数组中找到所有的局部极大值(或峰值)？</h3><p><strong>难度等级：</strong>L4</p><p><strong>问题：</strong>找到一个一维数字数组a中的所有峰值。峰顶是两边被较小数值包围的点。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; array([2, 5])</span></span><br></pre></td></tr></table></figure><p>其中，2和5是峰值7和6的位置。</p><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">doublediff = np.diff(np.sign(np.diff(a)))</span><br><span class="line">peak_locations = np.where(doublediff == -<span class="number">2</span>)[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">peak_locations</span><br><span class="line"><span class="comment"># &gt; array([2, 5])</span></span><br></pre></td></tr></table></figure><h3 id="64-如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去？"><a href="#64-如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去？" class="headerlink" title="64. 如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去？"></a>64. 如何从二维数组中减去一维数组，其中一维数组的每一项从各自的行中减去？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>从2d数组a_2d中减去一维数组b_1D，使得b_1D的每一项从a_2d的相应行中减去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a_2d = np.array([[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]])</span><br><span class="line">b_1d = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; [[2 2 2]</span></span><br><span class="line"><span class="comment"># &gt;  [2 2 2]</span></span><br><span class="line"><span class="comment"># &gt;  [2 2 2]]</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">a_2d = np.array([[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]])</span><br><span class="line">b_1d = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="built_in">print</span>(a_2d - b_1d[:,<span class="literal">None</span>])</span><br><span class="line"><span class="comment"># &gt; [[2 2 2]</span></span><br><span class="line"><span class="comment"># &gt;  [2 2 2]</span></span><br><span class="line"><span class="comment"># &gt;  [2 2 2]]</span></span><br></pre></td></tr></table></figure><h3 id="65-如何查找数组中项的第n次重复索引？"><a href="#65-如何查找数组中项的第n次重复索引？" class="headerlink" title="65. 如何查找数组中项的第n次重复索引？"></a>65. 如何查找数组中项的第n次重复索引？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>找出x中数字1的第5次重复的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">n = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 1: List comprehension</span></span><br><span class="line">[i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(x) <span class="keyword">if</span> v == <span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 2: Numpy version</span></span><br><span class="line">np.where(x == <span class="number">1</span>)[<span class="number">0</span>][n-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># &gt; 8</span></span><br></pre></td></tr></table></figure><h3 id="66-如何将numpy的datetime-64对象转换为datetime的datetime对象？"><a href="#66-如何将numpy的datetime-64对象转换为datetime的datetime对象？" class="headerlink" title="66. 如何将numpy的datetime 64对象转换为datetime的datetime对象？"></a>66. 如何将numpy的datetime 64对象转换为datetime的datetime对象？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>将numpy的<code>datetime64</code>对象转换为datetime的datetime对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：** a numpy datetime64 object</span></span><br><span class="line">dt64 = np.datetime64(<span class="string">&#x27;2018-02-25 22:10:10&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **给定：** a numpy datetime64 object</span></span><br><span class="line">dt64 = np.datetime64(<span class="string">&#x27;2018-02-25 22:10:10&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">dt64.tolist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">dt64.astype(datetime)</span><br><span class="line"><span class="comment"># &gt; datetime.datetime(2018, 2, 25, 22, 10, 10)</span></span><br></pre></td></tr></table></figure><h3 id="67-如何计算numpy数组的移动平均值？"><a href="#67-如何计算numpy数组的移动平均值？" class="headerlink" title="67. 如何计算numpy数组的移动平均值？"></a>67. 如何计算numpy数组的移动平均值？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>对于给定的一维数组，计算窗口大小为3的移动平均值。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">Z = np.random.randint(<span class="number">10</span>, size=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Solution</span></span><br><span class="line"><span class="comment"># Source: https://stackoverflow.com/questions/14313510/how-to-calculate-moving-average-using-numpy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moving_average</span>(<span class="params">a, n=<span class="number">3</span></span>) :</span></span><br><span class="line">    ret = np.cumsum(a, dtype=<span class="built_in">float</span>)</span><br><span class="line">    ret[n:] = ret[n:] - ret[:-n]</span><br><span class="line">    <span class="keyword">return</span> ret[n - <span class="number">1</span>:] / n</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line">Z = np.random.randint(<span class="number">10</span>, size=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;array: &#x27;</span>, Z)</span><br><span class="line"><span class="comment"># Method 1</span></span><br><span class="line">moving_average(Z, n=<span class="number">3</span>).<span class="built_in">round</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2:  # Thanks AlanLRH!</span></span><br><span class="line"><span class="comment"># np.ones(3)/3 gives equal weights. Use np.ones(4)/4 for window size 4.</span></span><br><span class="line">np.convolve(Z, np.ones(<span class="number">3</span>)/<span class="number">3</span>, mode=<span class="string">&#x27;valid&#x27;</span>) . </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; array:  [8 8 3 7 7 0 4 2 5 2]</span></span><br><span class="line"><span class="comment"># &gt; moving average:  [ 6.33  6.    5.67  4.67  3.67  2.    3.67  3.  ]</span></span><br></pre></td></tr></table></figure><h3 id="68-如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列？"><a href="#68-如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列？" class="headerlink" title="68. 如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列？"></a>68. 如何在给定起始点、长度和步骤的情况下创建一个numpy数组序列？</h3><p><strong>难度等级：</strong>L2</p><p><strong>问题：</strong>创建长度为10的numpy数组，从5开始，在连续的数字之间的步长为3。</p><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">length = <span class="number">10</span></span><br><span class="line">start = <span class="number">5</span></span><br><span class="line">step = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seq</span>(<span class="params">start, length, step</span>):</span></span><br><span class="line">    end = start + (step*length)</span><br><span class="line">    <span class="keyword">return</span> np.arange(start, end, step)</span><br><span class="line"></span><br><span class="line">seq(start, length, step)</span><br><span class="line"><span class="comment"># &gt; array([ 5,  8, 11, 14, 17, 20, 23, 26, 29, 32])</span></span><br></pre></td></tr></table></figure><h3 id="69-如何填写不规则系列的numpy日期中的缺失日期？"><a href="#69-如何填写不规则系列的numpy日期中的缺失日期？" class="headerlink" title="69. 如何填写不规则系列的numpy日期中的缺失日期？"></a>69. 如何填写不规则系列的numpy日期中的缺失日期？</h3><p><strong>难度等级：</strong>L3</p><p><strong>问题：</strong>给定一系列不连续的日期序列。填写缺失的日期，使其成为连续的日期序列。</p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">dates = np.arange(np.datetime64(<span class="string">&#x27;2018-02-01&#x27;</span>), np.datetime64(<span class="string">&#x27;2018-02-25&#x27;</span>), <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dates)</span><br><span class="line"><span class="comment"># &gt; [&#x27;2018-02-01&#x27; &#x27;2018-02-03&#x27; &#x27;2018-02-05&#x27; &#x27;2018-02-07&#x27; &#x27;2018-02-09&#x27;</span></span><br><span class="line"><span class="comment"># &gt;  &#x27;2018-02-11&#x27; &#x27;2018-02-13&#x27; &#x27;2018-02-15&#x27; &#x27;2018-02-17&#x27; &#x27;2018-02-19&#x27;</span></span><br><span class="line"><span class="comment"># &gt;  &#x27;2018-02-21&#x27; &#x27;2018-02-23&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Input</span></span><br><span class="line">dates = np.arange(np.datetime64(<span class="string">&#x27;2018-02-01&#x27;</span>), np.datetime64(<span class="string">&#x27;2018-02-25&#x27;</span>), <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dates)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution ---------------</span></span><br><span class="line">filled_in = np.array([np.arange(date, (date+d)) <span class="keyword">for</span> date, d <span class="keyword">in</span> <span class="built_in">zip</span>(dates, np.diff(dates))]).reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the last day</span></span><br><span class="line">output = np.hstack([filled_in, dates[-<span class="number">1</span>]])</span><br><span class="line">output</span><br><span class="line"></span><br><span class="line"><span class="comment"># For loop version -------</span></span><br><span class="line">out = []</span><br><span class="line"><span class="keyword">for</span> date, d <span class="keyword">in</span> <span class="built_in">zip</span>(dates, np.diff(dates)):</span><br><span class="line">    out.append(np.arange(date, (date+d)))</span><br><span class="line"></span><br><span class="line">filled_in = np.array(out).reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the last day</span></span><br><span class="line">output = np.hstack([filled_in, dates[-<span class="number">1</span>]])</span><br><span class="line">output</span><br><span class="line"><span class="comment"># &gt; [&#x27;2018-02-01&#x27; &#x27;2018-02-03&#x27; &#x27;2018-02-05&#x27; &#x27;2018-02-07&#x27; &#x27;2018-02-09&#x27;</span></span><br><span class="line"><span class="comment"># &gt;  &#x27;2018-02-11&#x27; &#x27;2018-02-13&#x27; &#x27;2018-02-15&#x27; &#x27;2018-02-17&#x27; &#x27;2018-02-19&#x27;</span></span><br><span class="line"><span class="comment"># &gt;  &#x27;2018-02-21&#x27; &#x27;2018-02-23&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt; array([&#x27;2018-02-01&#x27;, &#x27;2018-02-02&#x27;, &#x27;2018-02-03&#x27;, &#x27;2018-02-04&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-05&#x27;, &#x27;2018-02-06&#x27;, &#x27;2018-02-07&#x27;, &#x27;2018-02-08&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-09&#x27;, &#x27;2018-02-10&#x27;, &#x27;2018-02-11&#x27;, &#x27;2018-02-12&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-13&#x27;, &#x27;2018-02-14&#x27;, &#x27;2018-02-15&#x27;, &#x27;2018-02-16&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-17&#x27;, &#x27;2018-02-18&#x27;, &#x27;2018-02-19&#x27;, &#x27;2018-02-20&#x27;,</span></span><br><span class="line"><span class="comment"># &gt;        &#x27;2018-02-21&#x27;, &#x27;2018-02-22&#x27;, &#x27;2018-02-23&#x27;], dtype=&#x27;datetime64[D]&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="70-如何从给定的一维数组创建步长？"><a href="#70-如何从给定的一维数组创建步长？" class="headerlink" title="70. 如何从给定的一维数组创建步长？"></a>70. 如何从给定的一维数组创建步长？</h3><p><strong>难度等级：</strong>L4</p><p><strong>问题：</strong>从给定的一维数组arr中，利用步进生成一个二维矩阵，窗口长度为4，步距为2，类似于 <code>[[0,1,2,3], [2,3,4,5], [4,5,6,7]..]</code></p><p><strong>给定：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>) </span><br><span class="line">arr</span><br><span class="line"><span class="comment"># &gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</span></span><br></pre></td></tr></table></figure><p><strong>期望的输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment"># &gt;  [ 2  3  4  5]</span></span><br><span class="line"><span class="comment"># &gt;  [ 4  5  6  7]</span></span><br><span class="line"><span class="comment"># &gt;  [ 6  7  8  9]</span></span><br><span class="line"><span class="comment"># &gt;  [ 8  9 10 11]</span></span><br><span class="line"><span class="comment"># &gt;  [10 11 12 13]]</span></span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_strides</span>(<span class="params">a, stride_len=<span class="number">5</span>, window_len=<span class="number">5</span></span>):</span></span><br><span class="line">    n_strides = ((a.size-window_len)//stride_len) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># return np.array([a[s:(s+window_len)] for s in np.arange(0, a.size, stride_len)[:n_strides]])</span></span><br><span class="line">    <span class="keyword">return</span> np.array([a[s:(s+window_len)] <span class="keyword">for</span> s <span class="keyword">in</span> np.arange(<span class="number">0</span>, n_strides*stride_len, stride_len)])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gen_strides(np.arange(<span class="number">15</span>), stride_len=<span class="number">2</span>, window_len=<span class="number">4</span>))</span><br><span class="line"><span class="comment"># &gt; [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment"># &gt;  [ 2  3  4  5]</span></span><br><span class="line"><span class="comment"># &gt;  [ 4  5  6  7]</span></span><br><span class="line"><span class="comment"># &gt;  [ 6  7  8  9]</span></span><br><span class="line"><span class="comment"># &gt;  [ 8  9 10 11]</span></span><br><span class="line"><span class="comment"># &gt;  [10 11 12 13]]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NumPy-数据分析练习&quot;&gt;&lt;a href=&quot;#NumPy-数据分析练习&quot; class=&quot;headerlink&quot; title=&quot;NumPy 数据分析练习&quot;&gt;&lt;/a&gt;NumPy 数据分析练习&lt;/h1&gt;&lt;p&gt;Numpy练习的目标仅作为学习numpy的参考，并让你脱离基</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>numpy中的矩阵和向量</title>
    <link href="http://rczmm.github.io/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/"/>
    <id>http://rczmm.github.io/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/</id>
    <published>2021-09-21T14:32:20.000Z</published>
    <updated>2021-09-21T14:33:45.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NumPy-中的矩阵和向量"><a href="#NumPy-中的矩阵和向量" class="headerlink" title="NumPy 中的矩阵和向量"></a>NumPy 中的矩阵和向量</h1><p>numpy的<code>ndarray</code>类用于表示矩阵和向量。 要在numpy中构造矩阵，我们在列表中列出矩阵的行， 并将该列表传递给numpy数组构造函数。</p><p>例如，构造与矩阵对应的numpy数组</p><p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA1.png" alt="矩阵1"></p><p>我们会这样做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>]])</span><br></pre></td></tr></table></figure><p>向量只是具有单列的数组。 例如，构建向量</p><p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA2.png" alt="矩阵2"></p><p>我们会这样做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = np.array([[<span class="number">2</span>],[<span class="number">1</span>],[<span class="number">3</span>]])</span><br></pre></td></tr></table></figure><p>更方便的方法是转置相应的行向量。 例如，为了使上面的矢量，我们可以改为转置行向量</p><p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA3.png" alt="矩阵3"></p><p>这个代码是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = np.transpose(np.array([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]))</span><br></pre></td></tr></table></figure><p>numpy重载数组索引和切片符号以访问矩阵的各个部分。 例如，要打印矩阵A中的右下方条目，我们会这样做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(A[<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>要切出A矩阵中的第二列，我们会这样做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col = A[:,<span class="number">1</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>第一个切片选择A中的所有行，而第二个切片仅选择每行中的中间条目。</p><p>要进行矩阵乘法或矩阵向量乘法，我们使用np.dot()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = np.dot(A,v)</span><br></pre></td></tr></table></figure><h2 id="用numpy求解方程组"><a href="#用numpy求解方程组" class="headerlink" title="用numpy求解方程组"></a>用numpy求解方程组</h2><p>线性代数中比较常见的问题之一是求解矩阵向量方程。 这是一个例子。 我们寻找解决方程的向量x</p><p><em>A</em> <strong>x</strong> = <strong>b</strong></p><p>当</p><p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA4.png" alt="矩阵4"></p><p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA5.png" alt="矩阵5"></p><p>我们首先构建A和b的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">2</span>,<span class="number">1</span>,-<span class="number">2</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]])</span><br><span class="line">b = np.transpose(np.array([[-<span class="number">3</span>,<span class="number">5</span>,-<span class="number">2</span>]]))</span><br></pre></td></tr></table></figure><p>为了解决这个系统</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = np.linalg.solve(A,b)</span><br></pre></td></tr></table></figure><h2 id="应用：多元线性回归"><a href="#应用：多元线性回归" class="headerlink" title="应用：多元线性回归"></a>应用：多元线性回归</h2><p>在多元回归问题中，我们寻找一种能够将输入数据点映射到结果值的函数。 每个数据点是<em>特征向量（x1，x2，…，xm）</em>，由两个或多个捕获输入的各种特征的数据值组成。为了表示所有输入数据以及输出值的向量，我们设置了输入矩阵X和输出向量 <strong>y</strong>：</p><p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA6.png" alt="矩阵6"></p><p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA7.png" alt="矩阵7"></p><p>在简单的最小二乘线性回归模型中，我们寻找向量<strong>β</strong>，使得乘积Xβ最接近结果向量 <strong>y</strong>。</p><p>一旦我们构建了<strong>β</strong>向量，我们就可以使用它将输入数据映射到预测结果。 给定表单中的输入向量</p><p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA8.png" alt="矩阵8"></p><p>我们可以计算预测结果值</p><p><img src="/2021/09/21/numpy%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F/numpyLA9.png" alt="矩阵9"></p><p>计算β向量的公式是</p><p><strong>β</strong> = (<em>X**T</em> <em>X</em>)-1 <em>X**T</em> <strong>y</strong></p><p>在我们的下一个示例程序中，我将使用numpy构造适当的矩阵和向量并求解<strong>β</strong>向量。一旦我们解决了<strong>β</strong>，我们将使用它来预测我们最初从输入数据集中遗漏的一些测试数据点。</p><p>假设我们在numpy中构造了输入矩阵X和结果向量<strong>y</strong>，下面的代码将计算<strong>β</strong>向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Xt = np.transpose(X)</span><br><span class="line">XtX = np.dot(Xt,X)</span><br><span class="line">Xty = np.dot(Xt,y)</span><br><span class="line">beta = np.linalg.solve(XtX,Xty)</span><br></pre></td></tr></table></figure><p>最后一行使用<code>np.linalg.solve</code>计算<strong>β</strong>，因为等式是：</p><p><strong>β</strong> = (<em>X**T</em> <em>X</em>)-1 <em>X**T</em> <strong>y</strong></p><p>在数学上等价于方程组：</p><p>(<em>X**T</em> <em>X</em>) <strong>β</strong> = <em>X**T</em> <strong>y</strong></p><p>我将用于此示例的数据集是Windsor房价数据集，其中包含有关安大略省温莎市区房屋销售的信息。 输入变量涵盖了可能对房价产生影响的一系列因素，例如批量大小，卧室数量以及各种设施的存在。<a href="http://www2.lawrence.edu/fast/GREGGJ/Python/numpy/Housing.csv">此处</a>提供具有完整数据集的CSV文件。我从<a href="https://vincentarelbundock.github.io/Rdatasets/datasets.html">这个网站</a>下载了数据集，该网站提供了大量涵盖大量主题的数据集。</p><p>这里现在是示例程序的源代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readData</span>():</span></span><br><span class="line">    X = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Housing.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        rdr = csv.reader(f)</span><br><span class="line">        <span class="comment"># Skip the header row</span></span><br><span class="line">        <span class="built_in">next</span>(rdr)</span><br><span class="line">        <span class="comment"># Read X and y</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> rdr:</span><br><span class="line">            xline = [<span class="number">1.0</span>]</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> line[:-<span class="number">1</span>]:</span><br><span class="line">                xline.append(<span class="built_in">float</span>(s))</span><br><span class="line">            X.append(xline)</span><br><span class="line">            y.append(<span class="built_in">float</span>(line[-<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> (X,y)</span><br><span class="line"></span><br><span class="line">X0,y0 = readData()</span><br><span class="line"><span class="comment"># Convert all but the last 10 rows of the raw data to numpy arrays</span></span><br><span class="line">d = <span class="built_in">len</span>(X0)-<span class="number">10</span></span><br><span class="line">X = np.array(X0[:d])</span><br><span class="line">y = np.transpose(np.array([y0[:d]]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute beta</span></span><br><span class="line">Xt = np.transpose(X)</span><br><span class="line">XtX = np.dot(Xt,X)</span><br><span class="line">Xty = np.dot(Xt,y)</span><br><span class="line">beta = np.linalg.solve(XtX,Xty)</span><br><span class="line"><span class="built_in">print</span>(beta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make predictions for the last 10 rows in the data set</span></span><br><span class="line"><span class="keyword">for</span> data,actual <span class="keyword">in</span> <span class="built_in">zip</span>(X0[d:],y0[d:]):</span><br><span class="line">    x = np.array([data])</span><br><span class="line">    prediction = np.dot(x,beta)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;prediction = &#x27;</span>+<span class="built_in">str</span>(prediction[<span class="number">0</span>,<span class="number">0</span>])+<span class="string">&#x27; actual = &#x27;</span>+<span class="built_in">str</span>(actual))</span><br></pre></td></tr></table></figure><p>原始数据集包含500多个条目 为了测试线性回归模型所做预测的准确性，我们使用除最后10个数据条目之外的所有数据条目来构建回归模型并计算<strong>β</strong>。一旦我们构建了<strong>β</strong>向量，我们就用它来预测最后10个输入值，然后将预测的房价与数据集中的实际房价进行比较。</p><p>以下是该计划产生的产出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[[ -<span class="number">4.14106096e+03</span>]</span><br><span class="line"> [  <span class="number">3.55197583e+00</span>]</span><br><span class="line"> [  <span class="number">1.66328263e+03</span>]</span><br><span class="line"> [  <span class="number">1.45465644e+04</span>]</span><br><span class="line"> [  <span class="number">6.77755381e+03</span>]</span><br><span class="line"> [  <span class="number">6.58750520e+03</span>]</span><br><span class="line"> [  <span class="number">4.44683380e+03</span>]</span><br><span class="line"> [  <span class="number">5.60834856e+03</span>]</span><br><span class="line"> [  <span class="number">1.27979572e+04</span>]</span><br><span class="line"> [  <span class="number">1.24091640e+04</span>]</span><br><span class="line"> [  <span class="number">4.19931185e+03</span>]</span><br><span class="line"> [  <span class="number">9.42215457e+03</span>]]</span><br><span class="line">prediction = <span class="number">97360.6550969</span> actual = <span class="number">82500.0</span></span><br><span class="line">prediction = <span class="number">71774.1659014</span> actual = <span class="number">83000.0</span></span><br><span class="line">prediction = <span class="number">92359.0891976</span> actual = <span class="number">84000.0</span></span><br><span class="line">prediction = <span class="number">77748.2742379</span> actual = <span class="number">85000.0</span></span><br><span class="line">prediction = <span class="number">91015.5903066</span> actual = <span class="number">85000.0</span></span><br><span class="line">prediction = <span class="number">97545.1179047</span> actual = <span class="number">91500.0</span></span><br><span class="line">prediction = <span class="number">97360.6550969</span> actual = <span class="number">94000.0</span></span><br><span class="line">prediction = <span class="number">106006.800756</span> actual = <span class="number">103000.0</span></span><br><span class="line">prediction = <span class="number">92451.6931269</span> actual = <span class="number">105000.0</span></span><br><span class="line">prediction = <span class="number">73458.2949381</span> actual = <span class="number">105000.0</span></span><br></pre></td></tr></table></figure><p>总体而言，预测并不是非常好，但是一些预测有点接近正确。从这些数据中做出更好的预测将成为机器学习冬季学期教程的主题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NumPy-中的矩阵和向量&quot;&gt;&lt;a href=&quot;#NumPy-中的矩阵和向量&quot; class=&quot;headerlink&quot; title=&quot;NumPy 中的矩阵和向量&quot;&gt;&lt;/a&gt;NumPy 中的矩阵和向量&lt;/h1&gt;&lt;p&gt;numpy的&lt;code&gt;ndarray&lt;/code&gt;</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>numpy数组的不同方式</title>
    <link href="http://rczmm.github.io/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F/"/>
    <id>http://rczmm.github.io/2021/09/21/numpy%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F/</id>
    <published>2021-09-21T14:30:02.000Z</published>
    <updated>2021-09-21T14:31:54.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建-Numpy-数组的不同方式"><a href="#创建-Numpy-数组的不同方式" class="headerlink" title="创建 Numpy 数组的不同方式"></a>创建 Numpy 数组的不同方式</h1><p>Numpy库的核心是数组对象或ndarray对象（n维数组）。你将使用Numpy数组执行逻辑，统计和傅里叶变换等运算。作为使用Numpy的一部分，你要做的第一件事就是创建Numpy数组。本指南的主要目的是帮助数据科学爱好者了解可用于创建Numpy数组的不同方式。</p><p>创建Numpy数组有三种不同的方法：</p><ol><li>使用Numpy内部功能函数</li><li>从列表等其他Python的结构进行转换</li><li>使用特殊的库函数</li></ol><h2 id="使用Numpy内部功能函数"><a href="#使用Numpy内部功能函数" class="headerlink" title="使用Numpy内部功能函数"></a>使用Numpy内部功能函数</h2><p>Numpy具有用于创建数组的内置函数。 我们将在本指南中介绍其中一些内容。</p><h3 id="创建一个一维的数组"><a href="#创建一个一维的数组" class="headerlink" title="创建一个一维的数组"></a>创建一个一维的数组</h3><p>首先，让我们创建一维数组或rank为1的数组。<code>arange</code>是一种广泛使用的函数，用于快速创建数组。将值20传递给<code>arange</code>函数会创建一个值范围为0到19的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.arange(<span class="number">20</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,</span><br><span class="line">       <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line">       <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>,</span><br><span class="line">       <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>])</span><br></pre></td></tr></table></figure><p>要验证此数组的维度，请使用shape属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.shape</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">20</span>,)</span><br></pre></td></tr></table></figure><p>由于逗号后面没有值，因此这是一维数组。 要访问此数组中的值，请指定非负索引。 与其他编程语言一样，索引从零开始。 因此，要访问数组中的第四个元素，请使用索引3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>Numpy的数组是可变的，这意味着你可以在初始化数组后更改数组中元素的值。 使用print函数查看数组的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">3</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(array)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span> <span class="number">100</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line">   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line">   <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line">   <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>与Python列表不同，Numpy数组的内容是同质的。 因此，如果你尝试将字符串值分配给数组中的元素，其数据类型为int，则会出现错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">3</span>] =<span class="string">&#x27;Numpy&#x27;</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: invalid literal <span class="keyword">for</span> <span class="built_in">int</span>() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">&#x27;Numpy&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="创建一个二维数组"><a href="#创建一个二维数组" class="headerlink" title="创建一个二维数组"></a>创建一个二维数组</h3><p>我们来谈谈创建一个二维数组。 如果只使用arange函数，它将输出一维数组。 要使其成为二维数组，请使用reshape函数链接其输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">       [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]])</span><br></pre></td></tr></table></figure><p>首先，将创建20个整数，然后将数组转换为具有4行和5列的二维数组。 我们来检查一下这个数组的维数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>由于我们得到两个值，这是一个二维数组。 要访问二维数组中的元素，需要为行和列指定索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">3</span>][<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure><h3 id="创建三维数组及更多维度"><a href="#创建三维数组及更多维度" class="headerlink" title="创建三维数组及更多维度"></a>创建三维数组及更多维度</h3><p>要创建三维数组，请为重塑形状函数指定3个参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = np.arange(<span class="number">27</span>).reshape(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">        [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>]]])</span><br></pre></td></tr></table></figure><p>需要注意的是：数组中元素的数量（27）必须是其尺寸（3 * 3 * 3）的乘积。 要交叉检查它是否是三维数组，可以使用shape属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.shape</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>此外，使用<code>arange</code>函数，你可以创建一个在定义的起始值和结束值之间具有特定序列的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>, <span class="number">35</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">34</span>])</span><br></pre></td></tr></table></figure><h3 id="使用其他Numpy函数"><a href="#使用其他Numpy函数" class="headerlink" title="使用其他Numpy函数"></a>使用其他Numpy函数</h3><p>除了arange函数之外，你还可以使用其他有用的函数（如 <code>zeros</code> 和 <code>ones</code>）来快速创建和填充数组。</p><p>使用<code>zeros</code>函数创建一个填充零的数组。函数的参数表示行数和列数（或其维数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.zeros((<span class="number">2</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><p>使用<code>ones</code>函数创建一个填充了1的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.ones((<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><p><code>empty</code>函数创建一个数组。它的初始内容是随机的，取决于内存的状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">0.65670626</span>, <span class="number">0.52097334</span>, <span class="number">0.99831087</span>],</span><br><span class="line">       [<span class="number">0.07280136</span>, <span class="number">0.4416958</span> , <span class="number">0.06185705</span>]])</span><br></pre></td></tr></table></figure><p><code>full</code>函数创建一个填充给定值的n * n数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure><p><code>eye</code>函数可以创建一个n * n矩阵，对角线为1s，其他为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.eye(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><p>函数<code>linspace</code>在指定的时间间隔内返回均匀间隔的数字。 例如，下面的函数返回0到10之间的四个等间距数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(<span class="number">0</span>, <span class="number">10</span>, num=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([ <span class="number">0.</span>, <span class="number">3.33333333</span>, <span class="number">6.66666667</span>, <span class="number">10.</span>])</span><br></pre></td></tr></table></figure><h2 id="从Python列表转换"><a href="#从Python列表转换" class="headerlink" title="从Python列表转换"></a>从Python列表转换</h2><p>除了使用Numpy函数之外，你还可以直接从Python列表创建数组。将Python列表传递给数组函数以创建Numpy数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">array</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>你还可以创建Python列表并传递其变量名以创建Numpy数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">list</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">array = np.array(<span class="built_in">list</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>你可以确认变量<code>array</code>和<code>list</code>分别是Python列表和Numpy数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><blockquote><p>list</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(array)</span><br></pre></td></tr></table></figure><blockquote><p>Numpy.ndarray</p></blockquote><p>要创建二维数组，请将一系列列表传递给数组函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = np.array([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)])</span><br><span class="line">array</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">array.shape</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(2, 3)</span><br></pre></td></tr></table></figure><h2 id="使用特殊的库函数"><a href="#使用特殊的库函数" class="headerlink" title="使用特殊的库函数"></a>使用特殊的库函数</h2><p>你还可以使用特殊库函数来创建数组。例如，要创建一个填充0到1之间随机值的数组，请使用<code>random</code>函数。这对于需要随机状态才能开始的问题特别有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.random((<span class="number">2</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">0.1632794</span> , <span class="number">0.34567049</span>],</span><br><span class="line">       [<span class="number">0.03463241</span>, <span class="number">0.70687903</span>]])</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>创建和填充Numpy数组是使用Numpy执行快速数值数组计算的第一步。使用不同的方式创建数组，你现在可以很好地执行基本的数组操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建-Numpy-数组的不同方式&quot;&gt;&lt;a href=&quot;#创建-Numpy-数组的不同方式&quot; class=&quot;headerlink&quot; title=&quot;创建 Numpy 数组的不同方式&quot;&gt;&lt;/a&gt;创建 Numpy 数组的不同方式&lt;/h1&gt;&lt;p&gt;Numpy库的核心是数组对象</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ssm框架（二）</title>
    <link href="http://rczmm.github.io/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://rczmm.github.io/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-09-21T13:45:12.000Z</published>
    <updated>2021-09-21T13:59:38.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssm框架（二）"><a href="#ssm框架（二）" class="headerlink" title="ssm框架（二）"></a>ssm框架（二）</h1><h2 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h2><p> 下面主要介绍三大框架的整合，至于环境的搭建以及项目的创建。这次整合我分了2个配置文件，分别是spring-mybatis.xml，包含spring和mybatis的配置文件，还有个是spring-mvc的配置文件，此外有2个资源文件：jdbc.propertis和log4j.properties。</p><h3 id="使用框架的版本："><a href="#使用框架的版本：" class="headerlink" title="使用框架的版本："></a>使用框架的版本：</h3><pre><code>   Spring 4.0.2 RELEASE   Spring MVC 4.0.2 RELEASE   MyBatis 3.2.6</code></pre><h3 id="Maven引入需要的JAR包"><a href="#Maven引入需要的JAR包" class="headerlink" title="Maven引入需要的JAR包"></a>Maven引入需要的JAR包</h3><p>​    在pom.xml中引入jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.javen.maven01&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven01&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;maven01 Maven Webapp&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;  </span><br><span class="line">        &lt;!-- spring版本号 --&gt;  </span><br><span class="line">        &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt;  </span><br><span class="line">        &lt;!-- mybatis版本号 --&gt;  </span><br><span class="line">        &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt;  </span><br><span class="line">        &lt;!-- log4j日志文件管理包版本 --&gt;  </span><br><span class="line">        &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;  </span><br><span class="line">        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;  </span><br><span class="line">    &lt;/properties&gt; </span><br><span class="line">    </span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">             &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt;  </span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt; --&gt;</span><br><span class="line">        </span><br><span class="line">         &lt;!-- spring核心包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- mybatis核心包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">         &lt;!-- mybatis/spring包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        </span><br><span class="line">         &lt;!-- 导入java ee jar 包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;javax&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;7.0&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        </span><br><span class="line">         &lt;!-- 导入Mysql数据库链接jar包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;5.1.36&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        </span><br><span class="line">        &lt;!-- JSTL标签类 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;jstl&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;jstl&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.2&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- 日志文件管理包 --&gt;  </span><br><span class="line">        &lt;!-- log start --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​          </span><br><span class="line"></span><br><span class="line">        &lt;!-- 格式化对象，方便输出日志 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.1.41&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">      </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- log end --&gt;  </span><br><span class="line">        &lt;!-- 映入JSON --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.9.13&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;!-- 上传组件包 --&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.3.1&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;commons-io&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;2.4&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;commons-codec&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;1.9&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">    </span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;maven01&lt;/finalName&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;9.2.8.v20150217&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;httpConnector&gt;</span><br><span class="line">                        &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">                    &lt;/httpConnector&gt;</span><br><span class="line">                    &lt;stopKey&gt;shutdown&lt;/stopKey&gt;</span><br><span class="line">                    &lt;stopPort&gt;9966&lt;/stopPort&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h3 id="整合SpringMVC"><a href="#整合SpringMVC" class="headerlink" title="整合SpringMVC"></a>整合SpringMVC</h3><h4 id="配置spring-mvc-xml"><a href="#配置spring-mvc-xml" class="headerlink" title="配置spring-mvc.xml"></a>配置spring-mvc.xml</h4><p>配置里面的注释也很详细，主要是自动扫描控制器，视图模式，注解的启动这三个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;  </span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;  </span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    </span><br><span class="line">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    </span><br><span class="line">                        http://www.springframework.org/schema/context    </span><br><span class="line">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd    </span><br><span class="line">                        http://www.springframework.org/schema/mvc    </span><br><span class="line">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;  </span><br><span class="line">    &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;  </span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.javen.controller&quot; /&gt;  </span><br><span class="line">    &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt;</span><br><span class="line">    &lt;mvc:annotation-driven/&gt;</span><br><span class="line">    &lt;!-- 静态资源处理  css js imgs --&gt;</span><br><span class="line">    &lt;mvc:resources location=&quot;/resources/**&quot; mapping=&quot;/resources&quot;/&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot;  </span><br><span class="line">        class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;supportedMediaTypes&quot;&gt;  </span><br><span class="line">            &lt;list&gt;  </span><br><span class="line">                &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;  </span><br><span class="line">            &lt;/list&gt;  </span><br><span class="line">        &lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">    &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt;  </span><br><span class="line">    &lt;bean  </span><br><span class="line">        class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;messageConverters&quot;&gt;  </span><br><span class="line">            &lt;list&gt;  </span><br><span class="line">                &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot; /&gt; &lt;!-- JSON转换器 --&gt;  </span><br><span class="line">            &lt;/list&gt;  </span><br><span class="line">        &lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;multipartResolver&quot;    </span><br><span class="line">        class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    </span><br><span class="line">        &lt;!-- 默认编码 --&gt;  </span><br><span class="line">        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt;    </span><br><span class="line">        &lt;!-- 文件大小最大值 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760000&quot; /&gt;    </span><br><span class="line">        &lt;!-- 内存中的最大值 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot; /&gt;    </span><br><span class="line">        &lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt;</span><br><span class="line">        &lt;property name=&quot;resolveLazily&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;   </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。   InternalResourceViewResolver 放在最后--&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;mediaTypes&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt;</span><br><span class="line">                &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;</span><br><span class="line">                &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;</span><br><span class="line">                &lt;entry key=&quot;htm&quot; value=&quot;text/htm&quot; /&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;defaultViews&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;!-- ModelAndView里的数据变成JSON --&gt;</span><br><span class="line">                &lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJacksonJsonView&quot; /&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt;  </span><br><span class="line">    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;  </span><br><span class="line">        &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt;  </span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;  </span><br></pre></td></tr></table></figure><h4 id="配置web-xml文件"><a href="#配置web-xml文件" class="headerlink" title="配置web.xml文件"></a>配置web.xml文件</h4><p> 配置的spring-mvc的Servlet就是为了完成SpringMVC+MAVEN的整合。</p><p>web.xml  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </span><br><span class="line">    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;  </span><br><span class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;  </span><br><span class="line">    version=&quot;3.0&quot;&gt;  </span><br><span class="line">    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  </span><br><span class="line">    &lt;!-- Spring和mybatis的配置文件 --&gt;  </span><br><span class="line">   &lt;!--  &lt;context-param&gt;  </span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class="line">        &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt;  </span><br><span class="line">    &lt;/context-param&gt;   --&gt;</span><br><span class="line">    &lt;!-- 编码过滤器 --&gt;  </span><br><span class="line">    &lt;filter&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  </span><br><span class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;  </span><br><span class="line">        &lt;init-param&gt;  </span><br><span class="line">            &lt;param-name&gt;encoding&lt;/param-name&gt;  </span><br><span class="line">            &lt;param-value&gt;UTF-8&lt;/param-value&gt;  </span><br><span class="line">        &lt;/init-param&gt;  </span><br><span class="line">    &lt;/filter&gt;  </span><br><span class="line">    &lt;filter-mapping&gt;  </span><br><span class="line">        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;  </span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/filter-mapping&gt;  </span><br><span class="line">    &lt;!-- Spring监听器 --&gt;  </span><br><span class="line">   &lt;!--  &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;   --&gt;</span><br><span class="line">    &lt;!-- 防止Spring内存溢出监听器 --&gt;  </span><br><span class="line">    &lt;!-- &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;  --&gt; </span><br><span class="line"></span><br><span class="line">    &lt;!-- Spring MVC servlet --&gt;  </span><br><span class="line">    &lt;servlet&gt;  </span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;  </span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  </span><br><span class="line">        &lt;init-param&gt;  </span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class="line">            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;  </span><br><span class="line">        &lt;/init-param&gt;  </span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  </span><br><span class="line">        &lt;async-supported&gt;true&lt;/async-supported&gt;  </span><br><span class="line">    &lt;/servlet&gt;  </span><br><span class="line">    &lt;servlet-mapping&gt;  </span><br><span class="line">        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;  </span><br><span class="line">        &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt;  </span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/servlet-mapping&gt;  </span><br><span class="line">    &lt;welcome-file-list&gt;  </span><br><span class="line">        &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt;  </span><br><span class="line">    &lt;/welcome-file-list&gt;  </span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;  </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="Log4j的配置"><a href="#Log4j的配置" class="headerlink" title="Log4j的配置"></a>Log4j的配置</h3><p>   为了方便调试，一般都会使用日志来输出信息，Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p><pre><code>  Log4j的配置很简单，而且也是通用的，下面给出一个基本的配置，换到其他项目中也无需做多大的调整，如果想做调整或者想了解Log4j的各种配置，参看我转载的一篇博文，很详细：http://blog.csdn.net/zhshulin/article/details/37937365</code></pre><p>下面给出配置文件目录：</p><p>log4j.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=INFO,Console,File  </span><br><span class="line">#定义日志输出目的地为控制台  </span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender  </span><br><span class="line">log4j.appender.Console.Target=System.out  </span><br><span class="line">#可以灵活地指定日志输出格式，下面一行是指定具体的格式  </span><br><span class="line">log4j.appender.Console.layout = org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n  </span><br><span class="line"></span><br><span class="line">#文件大小到达指定尺寸的时候产生一个新的文件  </span><br><span class="line">log4j.appender.File = org.apache.log4j.RollingFileAppender  </span><br><span class="line">#指定输出目录  </span><br><span class="line">log4j.appender.File.File = logs/ssm.log  </span><br><span class="line">#定义文件最大大小  </span><br><span class="line">log4j.appender.File.MaxFileSize = 10MB  </span><br><span class="line"></span><br><span class="line">输出所以日志，如果换成DEBUG表示输出DEBUG以上级别日志  </span><br><span class="line"></span><br><span class="line">log4j.appender.File.Threshold = ALL  </span><br><span class="line">log4j.appender.File.layout = org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c]%m%n  </span><br></pre></td></tr></table></figure><h3 id="使用Jetty测试"><a href="#使用Jetty测试" class="headerlink" title="使用Jetty测试"></a>使用Jetty测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.javen.model;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    private String userName;</span><br><span class="line">    </span><br><span class="line">    private String password;</span><br><span class="line">    </span><br><span class="line">    private Integer age;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName == null ? null : userName.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password == null ? null : password.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [id=&quot; + id + &quot;, userName=&quot; + userName + &quot;, password=&quot;</span><br><span class="line">                + password + &quot;, age=&quot; + age + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.javen.controller;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Controller;  </span><br><span class="line">import org.springframework.ui.Model;  </span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;  </span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import com.javen.model.User;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller  </span><br><span class="line">@RequestMapping(&quot;/user&quot;)  </span><br><span class="line">// /user/**</span><br><span class="line">public class UserController &#123;  </span><br><span class="line">    private static Logger log=LoggerFactory.getLogger(UserController.class);</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // /user/test?id=1</span><br><span class="line">    @RequestMapping(value=&quot;/test&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String test(HttpServletRequest request,Model model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(request.getParameter(&quot;id&quot;));  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user=null;</span><br><span class="line">        if (userId==1) &#123;</span><br><span class="line">             user = new User();  </span><br><span class="line">             user.setAge(11);</span><br><span class="line">             user.setId(1);</span><br><span class="line">             user.setPassword(&quot;123&quot;);</span><br><span class="line">             user.setUserName(&quot;javen&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.addAttribute(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;index&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>​                               </p><p>在浏览器中输入：<a href="http://localhost/user/test?id=1">http://localhost/user/test?id=1</a></p><p>到此 SpringMVC+Maven 整合完毕</p><h2 id="Spring与MyBatis的整合"><a href="#Spring与MyBatis的整合" class="headerlink" title="Spring与MyBatis的整合"></a>Spring与MyBatis的整合</h2><p>   取消3.2.2 web.xml中注释的代码 </p><h3 id="建立JDBC属性文件"><a href="#建立JDBC属性文件" class="headerlink" title="建立JDBC属性文件"></a>建立JDBC属性文件</h3><p>jdbc.properties（文件编码修改为utf-8）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/maven</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">#定义初始连接数  </span><br><span class="line">initialSize=0  </span><br><span class="line">#定义最大连接数  </span><br><span class="line">maxActive=20  </span><br><span class="line">#定义最大空闲  </span><br><span class="line">maxIdle=20  </span><br><span class="line">#定义最小空闲  </span><br><span class="line">minIdle=1  </span><br><span class="line">#定义最长等待时间  </span><br><span class="line">maxWait=60000 </span><br></pre></td></tr></table></figure><h4 id="建立spring-mybatis-xml配置文件"><a href="#建立spring-mybatis-xml配置文件" class="headerlink" title="建立spring-mybatis.xml配置文件"></a>建立spring-mybatis.xml配置文件</h4><p>​    这个文件就是用来完成spring和mybatis的整合的。这里面也没多少行配置，主要的就是自动扫描，自动注入，配置数据库。注释也很详细，大家看看就明白了。</p><p>spring-mybatis.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;  </span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;  </span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    </span><br><span class="line">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    </span><br><span class="line">                        http://www.springframework.org/schema/context    </span><br><span class="line">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd    </span><br><span class="line">                        http://www.springframework.org/schema/mvc    </span><br><span class="line">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;  </span><br><span class="line">    &lt;!-- 自动扫描 --&gt;  </span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.javen&quot; /&gt;  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入配置文件 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;propertyConfigurer&quot;  </span><br><span class="line">        class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.properties&quot; /&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;  </span><br><span class="line">        destroy-method=&quot;close&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;  </span><br><span class="line">        &lt;!-- 初始化连接大小 --&gt;  </span><br><span class="line">        &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">        &lt;!-- 连接池最大数量 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">        &lt;!-- 连接池最大空闲 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">        &lt;!-- 连接池最小空闲 --&gt;  </span><br><span class="line">        &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;minIdle&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">        &lt;!-- 获取连接最大等待时间 --&gt;  </span><br><span class="line">        &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;maxWait&#125;&quot;&gt;&lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;  </span><br><span class="line">    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  </span><br><span class="line">        &lt;!-- 自动扫描mapping.xml文件 --&gt;  </span><br><span class="line">        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/javen/mapping/*.xml&quot;&gt;&lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;  </span><br><span class="line">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;basePackage&quot; value=&quot;com.javen.dao&quot; /&gt;  </span><br><span class="line">        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;  </span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot;  </span><br><span class="line">        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  </span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  </span><br><span class="line">    &lt;/bean&gt;  </span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;  </span><br></pre></td></tr></table></figure><h3 id="JUnit测试"><a href="#JUnit测试" class="headerlink" title="JUnit测试"></a>JUnit测试</h3><p>  经过以上步骤，我们已经完成了Spring和mybatis的整合，这样我们就可以编写一段测试代码来试试是否成功了。</p><h2 id="创建测试用表"><a href="#创建测试用表" class="headerlink" title="创建测试用表"></a>创建测试用表</h2><p>既然我们需要测试，那么我们就需要建立在数据库中建立一个测试表，这个表建的很简单，SQL语句为：</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- Table structure for `user_t`</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS `user_t`;</span><br><span class="line">CREATE TABLE `user_t` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_name` varchar(40) NOT NULL,</span><br><span class="line">  `password` varchar(255) NOT NULL,</span><br><span class="line">  `age` int(4) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">-- Records of user_t</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">INSERT INTO `user_t` VALUES (&#x27;1&#x27;, &#x27;测试&#x27;, &#x27;345&#x27;, &#x27;24&#x27;);</span><br><span class="line">INSERT INTO `user_t` VALUES (&#x27;2&#x27;, &#x27;javen&#x27;, &#x27;123&#x27;, &#x27;10&#x27;);</span><br></pre></td></tr></table></figure><p>利用MyBatis Generator自动创建代码</p><p>参考博文：<a href="http://blog.csdn.net/zhshulin/article/details/23912615">http://blog.csdn.net/zhshulin/article/details/23912615</a></p><p> 这个可根据表自动创建实体类、MyBatis映射文件以及DAO接口，当然，我习惯将生成的接口名改为IUserDao，而不是直接用它生成的UserMapper。如果不想麻烦就可以不改。完成后将文件复制到工程中。如图：</p><p>​                                                                  </p><h2 id="建立Service接口和实现类"><a href="#建立Service接口和实现类" class="headerlink" title="建立Service接口和实现类"></a>建立Service接口和实现类</h2><p>​                                                                 </p><p>下面给出具体的内容：</p><p>IUserService.jave</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.javen.service;  </span><br><span class="line"></span><br><span class="line">import com.javen.model.User;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface IUserService &#123;  </span><br><span class="line">    public User getUserById(int userId);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">UserServiceImpl.java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.javen.service.impl;</span><br><span class="line">import javax.annotation.Resource;  </span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Service;  </span><br><span class="line">import com.javen.dao.IUserDao;</span><br><span class="line">import com.javen.model.User;</span><br><span class="line">import com.javen.service.IUserService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service(&quot;userService&quot;)  </span><br><span class="line">public class UserServiceImpl implements IUserService &#123;  </span><br><span class="line">    @Resource  </span><br><span class="line">    private IUserDao userDao;  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    public User getUserById(int userId) &#123;  </span><br><span class="line">        // TODO Auto-generated method stub  </span><br><span class="line">        return this.userDao.selectByPrimaryKey(userId);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="建立测试类"><a href="#建立测试类" class="headerlink" title="建立测试类"></a>建立测试类</h3><p> 测试类在src/test/java中建立，下面测试类中注释掉的部分是不使用Spring时，一般情况下的一种测试方法；如果使用了Spring那么就可以使用注解的方式来引入配置文件和类，然后再将service接口对象注入，就可以进行测试了。</p><blockquote><p>   如果测试成功，表示Spring和Mybatis已经整合成功了。输出信息使用的是Log4j打印到控制台。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.javen.testmybatis;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;  </span><br><span class="line"></span><br><span class="line">import org.apache.log4j.Logger;  </span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;  </span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;  </span><br><span class="line">import com.alibaba.fastjson.JSON;  </span><br><span class="line">import com.javen.model.User;</span><br><span class="line">import com.javen.service.IUserService;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)     //表示继承了SpringJUnit4ClassRunner类  </span><br><span class="line">@ContextConfiguration(locations = &#123;&quot;classpath:spring-mybatis.xml&quot;&#125;)  </span><br><span class="line"></span><br><span class="line">public class TestMyBatis &#123;  </span><br><span class="line">    private static Logger logger = Logger.getLogger(TestMyBatis.class);  </span><br><span class="line">//  private ApplicationContext ac = null;  </span><br><span class="line">    @Resource  </span><br><span class="line">    private IUserService userService = null;  </span><br><span class="line"></span><br><span class="line">//  @Before  </span><br><span class="line">//  public void before() &#123;  </span><br><span class="line">//      ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);  </span><br><span class="line">//      userService = (IUserService) ac.getBean(&quot;userService&quot;);  </span><br><span class="line">//  &#125;  </span><br><span class="line"></span><br><span class="line">    @Test  </span><br><span class="line">    public void test1() &#123;  </span><br><span class="line">        User user = userService.getUserById(1);  </span><br><span class="line">        // System.out.println(user.getUserName());  </span><br><span class="line">        // logger.info(&quot;值：&quot;+user.getUserName());  </span><br><span class="line">        logger.info(JSON.toJSONString(user));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>测试结果 </p><p> <img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/441423-20150830173453859-1226139271.png" alt="img"></p><h3 id="建立UserController类"><a href="#建立UserController类" class="headerlink" title="建立UserController类"></a>建立UserController类</h3><p>UserController.java  控制器   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">package com.javen.controller;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.io.FileUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.http.ResponseEntity;</span><br><span class="line">import org.springframework.stereotype.Controller;  </span><br><span class="line">import org.springframework.ui.Model;  </span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;  </span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import com.javen.model.User;</span><br><span class="line">import com.javen.service.IUserService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller  </span><br><span class="line">@RequestMapping(&quot;/user&quot;)  </span><br><span class="line">// /user/**</span><br><span class="line">public class UserController &#123;  </span><br><span class="line">    private static Logger log=LoggerFactory.getLogger(UserController.class);</span><br><span class="line">     @Resource  </span><br><span class="line">     private IUserService userService;     </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // /user/test?id=1</span><br><span class="line">    @RequestMapping(value=&quot;/test&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String test(HttpServletRequest request,Model model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(request.getParameter(&quot;id&quot;));  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user=null;</span><br><span class="line">        if (userId==1) &#123;</span><br><span class="line">             user = new User();  </span><br><span class="line">             user.setAge(11);</span><br><span class="line">             user.setId(1);</span><br><span class="line">             user.setPassword(&quot;123&quot;);</span><br><span class="line">             user.setUserName(&quot;javen&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.addAttribute(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;index&quot;;  </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    // /user/showUser?id=1</span><br><span class="line">    @RequestMapping(value=&quot;/showUser&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String toIndex(HttpServletRequest request,Model model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(request.getParameter(&quot;id&quot;));  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.addAttribute(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;showUser&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"> // /user/showUser2?id=1</span><br><span class="line">    @RequestMapping(value=&quot;/showUser2&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String toIndex2(@RequestParam(&quot;id&quot;) String id,Model model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(id);  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.addAttribute(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;showUser&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // /user/showUser3/&#123;id&#125;</span><br><span class="line">    @RequestMapping(value=&quot;/showUser3/&#123;id&#125;&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public String toIndex3(@PathVariable(&quot;id&quot;)String id,Map&lt;String, Object&gt; model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(id);  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.debug(user.toString());</span><br><span class="line">        model.put(&quot;user&quot;, user);  </span><br><span class="line">        return &quot;showUser&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"> // /user/&#123;id&#125;</span><br><span class="line">    @RequestMapping(value=&quot;/&#123;id&#125;&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public @ResponseBody User getUserInJson(@PathVariable String id,Map&lt;String, Object&gt; model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(id);  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.info(user.toString());</span><br><span class="line">        return user;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // /user/&#123;id&#125;</span><br><span class="line">    @RequestMapping(value=&quot;/jsontype/&#123;id&#125;&quot;,method=RequestMethod.GET)  </span><br><span class="line">    public ResponseEntity&lt;User&gt;  getUserInJson2(@PathVariable String id,Map&lt;String, Object&gt; model)&#123;  </span><br><span class="line">        int userId = Integer.parseInt(id);  </span><br><span class="line">        System.out.println(&quot;userId:&quot;+userId);</span><br><span class="line">        User user = this.userService.getUserById(userId);  </span><br><span class="line">        log.info(user.toString());</span><br><span class="line">        return new ResponseEntity&lt;User&gt;(user,HttpStatus.OK);  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    //文件上传、</span><br><span class="line">    @RequestMapping(value=&quot;/upload&quot;)</span><br><span class="line">    public String showUploadPage()&#123;</span><br><span class="line">        return &quot;user_admin/file&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value=&quot;/doUpload&quot;,method=RequestMethod.POST)</span><br><span class="line">    public String doUploadFile(@RequestParam(&quot;file&quot;)MultipartFile file) throws IOException&#123;</span><br><span class="line">        if (!file.isEmpty()) &#123;</span><br><span class="line">            log.info(&quot;Process file:&#123;&#125;&quot;,file.getOriginalFilename());</span><br><span class="line">        &#125;</span><br><span class="line">        FileUtils.copyInputStreamToFile(file.getInputStream(), new File(&quot;E:\\&quot;,System.currentTimeMillis()+file.getOriginalFilename()));</span><br><span class="line">        return &quot;succes&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="新建jsp页面"><a href="#新建jsp页面" class="headerlink" title="新建jsp页面"></a>新建jsp页面</h3><p>file.jsp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;</span><br><span class="line">    pageEncoding=&quot;utf-8&quot;%&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;上传文件&lt;/h1&gt;</span><br><span class="line">    &lt;form method=&quot;post&quot; action=&quot;/user/doUpload&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>index.jsp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">showUser.jsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;  </span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;  </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">  &lt;head&gt;  </span><br><span class="line">    &lt;title&gt;测试&lt;/title&gt;  </span><br><span class="line">  &lt;/head&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;body&gt;  </span><br><span class="line">    $&#123;user.userName&#125;  </span><br><span class="line">  &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;  </span><br></pre></td></tr></table></figure><p>至此，完成Spring+SpingMVC+mybatis这三大框架整合完成。</p><pre><code>参考博客：http://blog.csdn.net/gebitan505/article/details/44455235</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ssm框架（二）&quot;&gt;&lt;a href=&quot;#ssm框架（二）&quot; class=&quot;headerlink&quot; title=&quot;ssm框架（二）&quot;&gt;&lt;/a&gt;ssm框架（二）&lt;/h1&gt;&lt;h2 id=&quot;SSM整合&quot;&gt;&lt;a href=&quot;#SSM整合&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ssm框架（一）</title>
    <link href="http://rczmm.github.io/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://rczmm.github.io/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-09-21T13:21:44.000Z</published>
    <updated>2021-09-22T10:41:59.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssm框架原理（一）"><a href="#ssm框架原理（一）" class="headerlink" title="ssm框架原理（一）"></a>ssm框架原理（一）</h1><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>ssm框架实际上就是一个框架整合，包含了spring、spring mvc以及mybatis框架。是一种标准的mvc模式的体现，ssm框架将系统划分为表现层、控制层、服务层、以及DAO层。其中，我们使用spring mvc负责请求的转发和视图管理、spring实现业务对象管理、mybatis作为数据持久化引擎。（db）</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><h3 id="SpringMVC："><a href="#SpringMVC：" class="headerlink" title="SpringMVC："></a>SpringMVC：</h3><p>1.客户端发送请求到DispacherServlet（分发器）</p><p>2.由DispacherServlet控制器查询HanderMapping，找到处理请求的Controller</p><p>3.Controller调用业务逻辑处理后，返回ModelAndView</p><p>4.DispacherSerclet查询视图解析器，找到ModelAndView指定的视图</p><p>5.视图负责将结果显示到客户端<br><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/20151118190949363.png" alt="img"></p><h3 id="Spring："><a href="#Spring：" class="headerlink" title="Spring："></a>Spring：</h3><p>我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们Java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。</p><h3 id="Mybatis："><a href="#Mybatis：" class="headerlink" title="Mybatis："></a>Mybatis：</h3><p>mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。</p><h3 id="要完成一个功能："><a href="#要完成一个功能：" class="headerlink" title="要完成一个功能："></a>要完成一个功能：</h3><p>先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。<br>写Mapper.xml（Mybatis），其中定义你的功能，对应要对数据库进行的那些操作，比如 insert、selectAll、select ByKey、delete、update等。<br>写Mapper.java，将Mapper.xml中的操作按照id映射成Java函数。<br>写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。<br>写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。<br>写JSP页面调用，请求哪些参数，需要获取什么数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataBase ===&gt; Entity ===&gt; Mapper.xml ===&gt; Mapper.Java ===&gt; Service.java ===&gt; Controller.java ===&gt; Jsp.  </span><br></pre></td></tr></table></figure><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>拥有控制器，作用跟Struts类似，接收外部请求，解析参数传给服务层<br>Spring 容器属于协调上下文，管理对象间的依赖，提供事务机制<br>mybatis 属于orm持久层框架，将业务实体 与数据表联合 起来</p><p>Spring MVC  控制层，想当与 Struts的作用<br>Spring 控制反转和依赖注入  创建对象交由容器管理，达到了解耦的作用<br>mybatis 主要用来操作数据库（数据库的增删改查）</p><h3 id="IOC-控制反转"><a href="#IOC-控制反转" class="headerlink" title="IOC:控制反转"></a>IOC:控制反转</h3><p>是一种降低对象之间耦合关系的设计思想，面试的时候最好能说出来个例子，加深理解。例子：租房子，以前租房子需要一个房子一个房子找，费时费力，然后现在加入一个房屋中介，把你需要的房型告诉中介，就可以直接选到需要的房子，中介就相当于spring容器。</p><h3 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP:面向切面编程"></a>AOP:面向切面编程</h3><p>是面向对象开发的一种补充，它允许开发人员在不改变原来模型的基础上动态的修改模型以满足新的需求，如：动态的增加日志、安全或异常处理等。AOP使业务逻辑各部分间的耦合度降低，提高程序可重用性，提高开发效率。</p><h3 id="持久层：DAO层（mapper）"><a href="#持久层：DAO层（mapper）" class="headerlink" title="持久层：DAO层（mapper）"></a>持久层：DAO层（mapper）</h3><p>DAO层：DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，<br>DAO层的设计首先是设计DAO的接口，<br>然后在Spring的配置文件中定义此接口的实现类，<br>然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，<br>DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。</p><h3 id="业务层：Service层"><a href="#业务层：Service层" class="headerlink" title="业务层：Service层"></a>业务层：Service层</h3><p>Service层：Service层主要负责业务模块的逻辑应用设计。<br>首先设计接口，再设计其实现的类<br>接着再在Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。<br>Service层的业务实现，具体要调用到已定义的DAO层的接口，<br>封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。</p><h3 id="表现层：Controller层（Handler层）"><a href="#表现层：Controller层（Handler层）" class="headerlink" title="表现层：Controller层（Handler层）"></a>表现层：Controller层（Handler层）</h3><p>Controller层:Controller层负责具体的业务模块流程的控制，<br>在此层里面要调用Service层的接口来控制业务流程，<br>控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。</p><h3 id="View层"><a href="#View层" class="headerlink" title="View层"></a>View层</h3><p>View层 此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示.</p><h3 id="各层联系"><a href="#各层联系" class="headerlink" title="各层联系"></a>各层联系</h3><p>DAO层，Service层这两个层次都可以单独开发，互相的耦合度很低，完全可以独立进行，这样的一种模式在开发大项目的过程中尤其有优势<br>Controller，View层因为耦合度比较高，因而要结合在一起开发，但是也可以看作一个整体独立于前两个层进行开发。这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，一切显得非常清晰简单。</p><h3 id="Service逻辑层设计"><a href="#Service逻辑层设计" class="headerlink" title="Service逻辑层设计"></a>Service逻辑层设计</h3><p>Service层是建立在DAO层之上的，建立了DAO层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。</p><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>​        Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。</p><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>​        Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。</p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>​       MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。</p><h2 id="开发环境搭建以及创建Maven-Web项目"><a href="#开发环境搭建以及创建Maven-Web项目" class="headerlink" title="开发环境搭建以及创建Maven Web项目"></a>开发环境搭建以及创建Maven Web项目</h2><blockquote><p>Eclipse+Tomcat+MAVEN+SVN项目完整环境搭建</p></blockquote><h3 id="1-JDK的安装"><a href="#1-JDK的安装" class="headerlink" title="1.JDK的安装"></a>1.JDK的安装</h3><p>​    首先下载JDK，这个从sun公司官网可以下载，根据自己的系统选择64位还是32位，安装过程就是next一路到底。安装完成之后当然要配置环境变量了。</p><p>——————————————————————————————————————————————</p><blockquote><p>1.1新建变量名：JAVA_HOME  变量值：E:\Java\jdk1.6.0_43（这是我的jdk安装路径）</p><p>1.2编辑变量名：Path 在后面加上：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</p><p>1.3 新建变量名：CLASSPATH 变量值： .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</p></blockquote><p>（注意：在设置变量的末尾时不要加上“；”）</p><p>——————————————————————————————————————————————</p><p>设置完成之后我们当然需要测试，打开“运行”–&gt;输入“CMD”–&gt;在命令行上面输入：java，然后回车；输入javac，回车，输入java -version，回车，如果出现下列三个画面，那么JDK配置成功，否则就需要检查环境变量的配置。</p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/image-20210921213621372.png" alt="image-20210921213621372" style="zoom:50%;"><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/image-20210921213640935.png" alt="image-20210921213640935" style="zoom:50%;"><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/image-20210921213714443.png" alt="image-20210921213714443" style="zoom:50%;"><h3 id="2-Eclipse的安装"><a href="#2-Eclipse的安装" class="headerlink" title="2.Eclipse的安装"></a>2.Eclipse的安装</h3><p>   下载地址：<a href="http://www.eclipse.org/downloads/">http://www.eclipse.org/downloads/</a>  版本自行选择  </p><p>   完成之后我们启动Eclipse，设置好工作路径，也可以直接默认。我们打开window–&gt;preference输入jre，安装下图。</p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828185304219-909517504.png" alt="img"></p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828190251437-403272735.png" alt="img"></p><p> 此时我们可以随便建立一个JAVA项目，然后编写一个helloworld来测试一下是否正确。</p><h3 id="Tomcat8的安装"><a href="#Tomcat8的安装" class="headerlink" title="Tomcat8的安装"></a>Tomcat8的安装</h3><p>​    Tomcat使用的版本是8，大家可以到apache的官网上去下载，<a href="http://tomcat.apache.org/download-80.cgi">http://tomcat.apache.org</a>，下载直接解压就行。</p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828190448875-2048839166.png" alt="img"></p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828190629703-89662533.png" alt="img"></p><h3 id="Maven安装配置"><a href="#Maven安装配置" class="headerlink" title="Maven安装配置"></a>Maven安装配置</h3><h4 id="maven配置环境变量"><a href="#maven配置环境变量" class="headerlink" title="maven配置环境变量"></a>maven配置环境变量</h4><p> 下载maven，就是一个包：apache-maven-3.2.1，我用的版本是3.2.1，解压到一个路径，然后配置环境变量：</p><p>——————————————————————————————————————————————————</p><blockquote><p>   5.1 新建变量名：MAVEN_HOME  变量值：D:\server\apache-maven-3.2.1（这是我的MAVEN路径）</p><p>   编辑变量名：Path 在最前面加上：%MAVEN_HOME%\bin;（注意，最后要有个”;”作为分隔符）</p></blockquote><p>——————————————————————————————————————————————</p><p>完成之后，在命令行输入：mvn -version查看是否有以下内容，如果有表示配置成功。</p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150828190819234-882295285.png" alt="img"></p><h4 id="Maven数据仓库的配置"><a href="#Maven数据仓库的配置" class="headerlink" title="Maven数据仓库的配置"></a>Maven数据仓库的配置</h4><p>MAVEN中还有一个重要的配置就是数据仓库的路径配置，我们找到MAVEN的安装路径，进入conf–&gt;打开settings.xml，找到localRepository标签，此时是被注释掉的，我们解除注释，然后配置一个路径，例如：E:\Dev\Java\maven\repo，这样以后MAVEN管理下载的jar包都会在这个路径下。当然我们需要建这样一个目录结构，然后还要讲settings.xml复制一份到E:\Dev\Java\maven下，这个在与Eclipse集成时会用到。<strong>修改默认保存路径</strong></p><p><strong><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829203627344-2088280037.png" alt="img"></strong></p><h3 id="Eclipse中集成Maven"><a href="#Eclipse中集成Maven" class="headerlink" title="Eclipse中集成Maven"></a>Eclipse中集成Maven</h3><p>在preferences中进行配置，如图：</p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204010922-1975818603.png" alt="img"></p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204215719-809768030.png" alt="img"></p><p> 此时，点击File–&gt;new–&gt;other–&gt;输入maven–&gt;–&gt;Maven Project，如果可以看到这些，证明配置成功，已经可以建立Maven项目了。</p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204454765-1161572702.png" alt="img"><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204928656-1589383472.png" alt="img"></p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204944172-1087694389.png" alt="img"><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829204953047-22835249.png" alt="img"></p><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829205005375-1380967534.png" alt="img"></p><p>如果indexjsp 提示有错误需要在pom.xml中导入  javaee-api.jar</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="SVN安装"><a href="#SVN安装" class="headerlink" title="SVN安装"></a>SVN安装</h3><p><img src="/2021/09/21/ssm%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/441423-20150829205515859-847674917.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ssm框架原理（一）&quot;&gt;&lt;a href=&quot;#ssm框架原理（一）&quot; class=&quot;headerlink&quot; title=&quot;ssm框架原理（一）&quot;&gt;&lt;/a&gt;ssm框架原理（一）&lt;/h1&gt;&lt;h2 id=&quot;作用：&quot;&gt;&lt;a href=&quot;#作用：&quot; class=&quot;header</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>numpy教程</title>
    <link href="http://rczmm.github.io/2021/09/18/numpy%E6%95%99%E7%A8%8B/"/>
    <id>http://rczmm.github.io/2021/09/18/numpy%E6%95%99%E7%A8%8B/</id>
    <published>2021-09-18T01:30:36.000Z</published>
    <updated>2021-09-18T01:43:16.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python、Numpy-教程"><a href="#Python、Numpy-教程" class="headerlink" title="Python、Numpy 教程"></a>Python、Numpy 教程</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python是一种高级动态类型的多范式编程语言。Python代码通常被称为可运行的伪代码，因为它允许你在非常少的代码行中表达非常强大的想法，同时具有非常可读性。作为示例，这里是Python中经典快速排序算法的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(quicksort([<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># Prints &quot;[1, 1, 2, 3, 6, 8, 10]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Python-的版本"><a href="#Python-的版本" class="headerlink" title="Python 的版本"></a>Python 的版本</h3><p>目前有两种不同的受支持版本的Python，分别是2.7和3.9。有点令人困惑的是，Python 3.0引入了许多向后兼容的语言更改，因此为2.7编写的代码可能无法在3.9下运行，反之亦然。所以我们下面所有的示例的代码都使用Python 3.9来编程。</p><p>你可以通过运行 <code>python -version</code> 在命令行中查看Python的版本。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>与大多数语言一样，Python有许多基本类型，包括整数，浮点数，布尔值和字符串。这些数据类型的行为方式与其他编程语言相似。</p><p>**Numbers(数字类型)**：代表的是整数和浮点数，它原理与其他语言相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x)) <span class="comment"># Prints &quot;&lt;class &#x27;int&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x)       <span class="comment"># Prints &quot;3&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">1</span>)   <span class="comment"># Addition; prints &quot;4&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x - <span class="number">1</span>)   <span class="comment"># Subtraction; prints &quot;2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x * <span class="number">2</span>)   <span class="comment"># Multiplication; prints &quot;6&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x ** <span class="number">2</span>)  <span class="comment"># Exponentiation; prints &quot;9&quot;</span></span><br><span class="line">x += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># Prints &quot;4&quot;</span></span><br><span class="line">x *= <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># Prints &quot;8&quot;</span></span><br><span class="line">y = <span class="number">2.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(y)) <span class="comment"># Prints &quot;&lt;class &#x27;float&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(y, y + <span class="number">1</span>, y * <span class="number">2</span>, y ** <span class="number">2</span>) <span class="comment"># Prints &quot;2.5 3.5 5.0 6.25&quot;</span></span><br></pre></td></tr></table></figure><p>注意，与许多语言不同，Python没有一元增量(<code>x+</code>)或递减(<code>x-</code>)运算符。</p><p>Python还有用于复数的内置类型；你可以在<a href="https://docs.python.org/3.9/library/stdtypes.html#numeric-types-int-float-complex">这篇文档（python官网doc）</a>中找到所有的详细信息。</p><p><strong>Booleans(布尔类型)</strong>: Python实现了所有常用的布尔逻辑运算符，但它使用的是英文单词而不是符号 (<code>&amp;&amp;</code>, <code>||</code>, etc.)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="literal">True</span></span><br><span class="line">f = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t)) <span class="comment"># Prints &quot;&lt;class &#x27;bool&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">and</span> f) <span class="comment"># Logical AND; prints &quot;False&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">or</span> f)  <span class="comment"># Logical OR; prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> t)   <span class="comment"># Logical NOT; prints &quot;False&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t != f)  <span class="comment"># Logical XOR; prints &quot;True&quot;</span></span><br></pre></td></tr></table></figure><p>**Strings(字符串类型)**：Python对字符串有很好的支持：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello = <span class="string">&#x27;hello&#x27;</span>    <span class="comment"># String literals can use single quotes</span></span><br><span class="line">world = <span class="string">&quot;world&quot;</span>    <span class="comment"># or double quotes; it does not matter.</span></span><br><span class="line"><span class="built_in">print</span>(hello)       <span class="comment"># Prints &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(hello))  <span class="comment"># String length; prints &quot;5&quot;</span></span><br><span class="line">hw = hello + <span class="string">&#x27; &#x27;</span> + world  <span class="comment"># String concatenation</span></span><br><span class="line"><span class="built_in">print</span>(hw)  <span class="comment"># prints &quot;hello world&quot;</span></span><br><span class="line">hw12 = <span class="string">&#x27;%s %s %d&#x27;</span> % (hello, world, <span class="number">12</span>)  <span class="comment"># sprintf style string formatting</span></span><br><span class="line"><span class="built_in">print</span>(hw12)  <span class="comment"># prints &quot;hello world 12&quot;</span></span><br></pre></td></tr></table></figure><p>String对象有许多有用的方法；例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.capitalize())  <span class="comment"># Capitalize a string; prints &quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.upper())       <span class="comment"># Convert a string to uppercase; prints &quot;HELLO&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rjust(<span class="number">7</span>))      <span class="comment"># Right-justify a string, padding with spaces; prints &quot;  hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">7</span>))     <span class="comment"># Center a string, padding with spaces; prints &quot; hello &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;(ell)&#x27;</span>))  <span class="comment"># Replace all instances of one substring with another;</span></span><br><span class="line">                                <span class="comment"># prints &quot;he(ell)(ell)o&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;  world &#x27;</span>.strip())  <span class="comment"># Strip leading and trailing whitespace; prints &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>你可以在<a href="https://docs.python.org/3.9/library/stdtypes.html#string-methods">这篇文档（python官网doc）</a>中找到所有String方法的列表。</p><h3 id="容器-Containers"><a href="#容器-Containers" class="headerlink" title="容器(Containers)"></a>容器(Containers)</h3><p>Python包含几种内置的容器类型：列表、字典、集合和元组。</p><h4 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表(Lists)"></a>列表(Lists)</h4><p>列表其实就是Python中的数组，但是可以它可以动态的调整大小并且可以包含不同类型的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xs = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]    <span class="comment"># Create a list</span></span><br><span class="line"><span class="built_in">print</span>(xs, xs[<span class="number">2</span>])  <span class="comment"># Prints &quot;[3, 1, 2] 2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(xs[-<span class="number">1</span>])     <span class="comment"># Negative indices count from the end of the list; prints &quot;2&quot;</span></span><br><span class="line">xs[<span class="number">2</span>] = <span class="string">&#x27;foo&#x27;</span>     <span class="comment"># Lists can contain elements of different types</span></span><br><span class="line"><span class="built_in">print</span>(xs)         <span class="comment"># Prints &quot;[3, 1, &#x27;foo&#x27;]&quot;</span></span><br><span class="line">xs.append(<span class="string">&#x27;bar&#x27;</span>)  <span class="comment"># Add a new element to the end of the list</span></span><br><span class="line"><span class="built_in">print</span>(xs)         <span class="comment"># Prints &quot;[3, 1, &#x27;foo&#x27;, &#x27;bar&#x27;]&quot;</span></span><br><span class="line">x = xs.pop()      <span class="comment"># Remove and return the last element of the list</span></span><br><span class="line"><span class="built_in">print</span>(x, xs)      <span class="comment"># Prints &quot;bar [3, 1, &#x27;foo&#x27;]&quot;</span></span><br></pre></td></tr></table></figure><p>像往常一样，你可以在<a href="https://docs.python.org/3.9/tutorial/datastructures.html#more-on-lists">这篇文档</a>中找到有关列表的所有详细信息。</p><p><strong>切片(Slicing)</strong>: 除了一次访问一个列表元素之外，Python还提供了访问子列表的简明语法; 这被称为切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))     <span class="comment"># range is a built-in function that creates a list of integers</span></span><br><span class="line"><span class="built_in">print</span>(nums)               <span class="comment"># Prints &quot;[0, 1, 2, 3, 4]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:<span class="number">4</span>])          <span class="comment"># Get a slice from index 2 to 4 (exclusive); prints &quot;[2, 3]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:])           <span class="comment"># Get a slice from index 2 to the end; prints &quot;[2, 3, 4]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[:<span class="number">2</span>])           <span class="comment"># Get a slice from the start to index 2 (exclusive); prints &quot;[0, 1]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[:])            <span class="comment"># Get a slice of the whole list; prints &quot;[0, 1, 2, 3, 4]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[:-<span class="number">1</span>])          <span class="comment"># Slice indices can be negative; prints &quot;[0, 1, 2, 3]&quot;</span></span><br><span class="line">nums[<span class="number">2</span>:<span class="number">4</span>] = [<span class="number">8</span>, <span class="number">9</span>]        <span class="comment"># Assign a new sublist to a slice</span></span><br><span class="line"><span class="built_in">print</span>(nums)               <span class="comment"># Prints &quot;[0, 1, 8, 9, 4]&quot;</span></span><br></pre></td></tr></table></figure><p>我们将在numpy数组的上下文中再次看到切片。</p><p><strong>(循环)Loops</strong>: 你可以循环遍历列表的元素，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    <span class="built_in">print</span>(animal)</span><br><span class="line"><span class="comment"># Prints &quot;cat&quot;, &quot;dog&quot;, &quot;monkey&quot;, each on its own line.</span></span><br></pre></td></tr></table></figure><p>如果要访问循环体内每个元素的索引，请使用内置的 <code>enumerate</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line</span></span><br></pre></td></tr></table></figure><p><strong>列表推导式(List comprehensions)</strong>: 编程时，我们经常想要将一种数据转换为另一种数据。 举个简单的例子，思考以下计算平方数的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">    squares.append(x ** <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(squares)   <span class="comment"># Prints [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><p>你可以使用 <strong>列表推导式</strong> 使这段代码更简单:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums]</span><br><span class="line"><span class="built_in">print</span>(squares)   <span class="comment"># Prints [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><p>列表推导还可以包含条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">even_squares = [x ** 2 for x in nums if x % 2 == 0]</span><br><span class="line">print(even_squares)  # Prints &quot;[0, 4, 16]&quot;</span><br></pre></td></tr></table></figure><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典存储（键，值）对，类似于Java中的<code>Map</code>或Javascript中的对象。你可以像这样使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;cat&#x27;</span>: <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>: <span class="string">&#x27;furry&#x27;</span>&#125;  <span class="comment"># Create a new dictionary with some data</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;cat&#x27;</span>])       <span class="comment"># Get an entry from a dictionary; prints &quot;cute&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> d)     <span class="comment"># Check if a dictionary has a given key; prints &quot;True&quot;</span></span><br><span class="line">d[<span class="string">&#x27;fish&#x27;</span>] = <span class="string">&#x27;wet&#x27;</span>     <span class="comment"># Set an entry in a dictionary</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;fish&#x27;</span>])      <span class="comment"># Prints &quot;wet&quot;</span></span><br><span class="line"><span class="comment"># print(d[&#x27;monkey&#x27;])  # KeyError: &#x27;monkey&#x27; not a key of d</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;monkey&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># Get an element with a default; prints &quot;N/A&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;fish&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))    <span class="comment"># Get an element with a default; prints &quot;wet&quot;</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;fish&#x27;</span>]         <span class="comment"># Remove an element from a dictionary</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;fish&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>)) <span class="comment"># &quot;fish&quot; is no longer a key; prints &quot;N/A&quot;</span></span><br></pre></td></tr></table></figure><p>你可以在<a href="https://docs.python.org/3.9/library/stdtypes.html#dict">这篇文档</a>中找到有关字典的所有信息。</p><p><strong>(循环)Loops</strong>: 迭代词典中的键很容易：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;person&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spider&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> d:</span><br><span class="line">    legs = d[animal]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A %s has %d legs&#x27;</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span></span><br></pre></td></tr></table></figure><p>如果要访问键及其对应的值，请使用<code>items</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;person&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spider&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal, legs <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A %s has %d legs&#x27;</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span></span><br></pre></td></tr></table></figure><p><strong>字典推导式(Dictionary comprehensions)</strong>: 类似于列表推导式，可以让你轻松构建词典数据类型。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">even_num_to_square = &#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(even_num_to_square)  <span class="comment"># Prints &quot;&#123;0: 0, 2: 4, 4: 16&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h4><p>集合是不同元素的无序集合。举个简单的例子，请思考下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">animals = &#123;<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> animals)   <span class="comment"># Check if an element is in a set; prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fish&#x27;</span> <span class="keyword">in</span> animals)  <span class="comment"># prints &quot;False&quot;</span></span><br><span class="line">animals.add(<span class="string">&#x27;fish&#x27;</span>)       <span class="comment"># Add an element to a set</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fish&#x27;</span> <span class="keyword">in</span> animals)  <span class="comment"># Prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(animals))       <span class="comment"># Number of elements in a set; prints &quot;3&quot;</span></span><br><span class="line">animals.add(<span class="string">&#x27;cat&#x27;</span>)        <span class="comment"># Adding an element that is already in the set does nothing</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(animals))       <span class="comment"># Prints &quot;3&quot;</span></span><br><span class="line">animals.remove(<span class="string">&#x27;cat&#x27;</span>)     <span class="comment"># Remove an element from a set</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(animals))       <span class="comment"># Prints &quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>与往常一样，你想知道的关于集合的所有内容都可以在<a href="https://docs.python.org/3.9/library/stdtypes.html#set">这篇文档</a>中找到。</p><p><strong>循环(Loops)</strong>: 遍历集合的语法与遍历列表的语法相同；但是，由于集合是无序的，因此不能假设访问集合元素的顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = &#123;<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;</span></span><br></pre></td></tr></table></figure><p><strong>集合推导式(Set comprehensions)</strong>: 就像列表和字典一样，我们可以很容易地使用集合理解来构造集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">nums = &#123;<span class="built_in">int</span>(sqrt(x)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(nums)  <span class="comment"># Prints &quot;&#123;0, 1, 2, 3, 4, 5&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="元组-Tuples"><a href="#元组-Tuples" class="headerlink" title="元组(Tuples)"></a>元组(Tuples)</h4><p>元组是（不可变的）有序值列表。 元组在很多方面类似于列表; 其中一个最重要的区别是元组可以用作字典中的键和集合的元素，而列表则不能。 这是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;(x, x + <span class="number">1</span>): x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;  <span class="comment"># Create a dictionary with tuple keys</span></span><br><span class="line">t = (<span class="number">5</span>, <span class="number">6</span>)        <span class="comment"># Create a tuple</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t))    <span class="comment"># Prints &quot;&lt;class &#x27;tuple&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d[t])       <span class="comment"># Prints &quot;5&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d[(<span class="number">1</span>, <span class="number">2</span>)])  <span class="comment"># Prints &quot;1&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/3.9/tutorial/datastructures.html#tuples-and-sequences">这篇文档</a>包含有关元组的更多信息。</p><h3 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数(Functions)"></a>函数(Functions)</h3><p>Python函数使用<code>def</code>关键字定义。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;positive&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;negative&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;zero&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">    <span class="built_in">print</span>(sign(x))</span><br><span class="line"><span class="comment"># Prints &quot;negative&quot;, &quot;zero&quot;, &quot;positive&quot;</span></span><br></pre></td></tr></table></figure><p>我们经常定义函数来获取可选的关键字参数，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name, loud=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> loud:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;HELLO, %s!&#x27;</span> % name.upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line">hello(<span class="string">&#x27;Bob&#x27;</span>) <span class="comment"># Prints &quot;Hello, Bob&quot;</span></span><br><span class="line">hello(<span class="string">&#x27;Fred&#x27;</span>, loud=<span class="literal">True</span>)  <span class="comment"># Prints &quot;HELLO, FRED!&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/3.9/tutorial/controlflow.html#defining-functions">这篇文档</a>中有更多关于Python函数的信息。</p><h3 id="类-Classes"><a href="#类-Classes" class="headerlink" title="类(Classes)"></a>类(Classes)</h3><p>在Python中定义类的语法很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name  <span class="comment"># Create an instance variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instance method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">self, loud=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> loud:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;HELLO, %s!&#x27;</span> % self.name.upper())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">g = Greeter(<span class="string">&#x27;Fred&#x27;</span>)  <span class="comment"># Construct an instance of the Greeter class</span></span><br><span class="line">g.greet()            <span class="comment"># Call an instance method; prints &quot;Hello, Fred&quot;</span></span><br><span class="line">g.greet(loud=<span class="literal">True</span>)   <span class="comment"># Call an instance method; prints &quot;HELLO, FRED!&quot;</span></span><br></pre></td></tr></table></figure><p>你可以在<a href="https://docs.python.org/3.9/tutorial/classes.html">这篇文档</a>中阅读更多关于Python类的内容。</p><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>Numpy是Python中科学计算的核心库。它提供了一个高性能的多维数组对象，以及用于处理这些数组的工具。</p><h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h3><p>numpy数组是一个值网格，所有类型都相同，并由非负整数元组索引。 维数是数组的排名; 数组的形状是一个整数元组，给出了每个维度的数组大小。</p><p>我们可以从嵌套的Python列表初始化numpy数组，并使用方括号访问元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])   <span class="comment"># Create a rank 1 array</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))            <span class="comment"># Prints &quot;&lt;class &#x27;numpy.ndarray&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)            <span class="comment"># Prints &quot;(3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])   <span class="comment"># Prints &quot;1 2 3&quot;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                  <span class="comment"># Change an element of the array</span></span><br><span class="line"><span class="built_in">print</span>(a)                  <span class="comment"># Prints &quot;[5, 2, 3]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])    <span class="comment"># Create a rank 2 array</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)                     <span class="comment"># Prints &quot;(2, 3)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])   <span class="comment"># Prints &quot;1 2 4&quot;</span></span><br></pre></td></tr></table></figure><p>Numpy还提供了许多创建数组的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))   <span class="comment"># Create an array of all zeros</span></span><br><span class="line"><span class="built_in">print</span>(a)              <span class="comment"># Prints &quot;[[ 0.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  0.]]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))    <span class="comment"># Create an array of all ones</span></span><br><span class="line"><span class="built_in">print</span>(b)              <span class="comment"># Prints &quot;[[ 1.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># Create a constant array</span></span><br><span class="line"><span class="built_in">print</span>(c)               <span class="comment"># Prints &quot;[[ 7.  7.]</span></span><br><span class="line">                       <span class="comment">#          [ 7.  7.]]&quot;</span></span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)         <span class="comment"># Create a 2x2 identity matrix</span></span><br><span class="line"><span class="built_in">print</span>(d)              <span class="comment"># Prints &quot;[[ 1.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))  <span class="comment"># Create an array filled with random values</span></span><br><span class="line"><span class="built_in">print</span>(e)                     <span class="comment"># Might print &quot;[[ 0.91940167  0.08143941]</span></span><br><span class="line">                             <span class="comment">#               [ 0.68744134  0.87236687]]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h3><p>Numpy提供了几种索引数组的方法。</p><p><strong>切片(Slicing)</strong>: 与Python列表类似，可以对numpy数组进行切片。由于数组可能是多维的，因此必须为数组的每个维指定一个切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use slicing to pull out the subarray consisting of the first 2 rows</span></span><br><span class="line"><span class="comment"># and columns 1 and 2; b is the following array of shape (2, 2):</span></span><br><span class="line"><span class="comment"># [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># A slice of an array is a view into the same data, so modifying it</span></span><br><span class="line"><span class="comment"># will modify the original array.</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;2&quot;</span></span><br><span class="line">b[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">77</span>     <span class="comment"># b[0, 0] is the same piece of data as a[0, 1]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;77&quot;</span></span><br></pre></td></tr></table></figure><p>你还可以将整数索引与切片索引混合使用。 但是，这样做会产生比原始数组更低级别的数组。 请注意，这与MATLAB处理数组切片的方式完全不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two ways of accessing the data in the middle row of the array.</span></span><br><span class="line"><span class="comment"># Mixing integer indexing with slices yields an array of lower rank,</span></span><br><span class="line"><span class="comment"># while using only slices yields an array of the same rank as the</span></span><br><span class="line"><span class="comment"># original array:</span></span><br><span class="line">row_r1 = a[<span class="number">1</span>, :]    <span class="comment"># Rank 1 view of the second row of a</span></span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>, :]  <span class="comment"># Rank 2 view of the second row of a</span></span><br><span class="line"><span class="built_in">print</span>(row_r1, row_r1.shape)  <span class="comment"># Prints &quot;[5 6 7 8] (4,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(row_r2, row_r2.shape)  <span class="comment"># Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can make the same distinction when accessing columns of an array:</span></span><br><span class="line">col_r1 = a[:, <span class="number">1</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(col_r1, col_r1.shape)  <span class="comment"># Prints &quot;[ 2  6 10] (3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(col_r2, col_r2.shape)  <span class="comment"># Prints &quot;[[ 2]</span></span><br><span class="line">                             <span class="comment">#          [ 6]</span></span><br><span class="line">                             <span class="comment">#          [10]] (3, 1)&quot;</span></span><br></pre></td></tr></table></figure><p><strong>整数数组索引</strong>: 使用切片索引到numpy数组时，生成的数组视图将始终是原始数组的子数组。 相反，整数数组索引允许你使用另一个数组中的数据构造任意数组。 这是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># An example of integer array indexing.</span></span><br><span class="line"><span class="comment"># The returned array will have shape (3,) and</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The above example of integer array indexing is equivalent to this:</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When using integer array indexing, you can reuse the same</span></span><br><span class="line"><span class="comment"># element from the source array:</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalent to the previous integer array indexing example</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">1</span>], a[<span class="number">0</span>, <span class="number">1</span>]]))  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br></pre></td></tr></table></figure><p>整数数组索引的一个有用技巧是从矩阵的每一行中选择或改变一个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new array from which we will select elements</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[ 1,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5,  6],</span></span><br><span class="line">          <span class="comment">#                [ 7,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 11, 12]])&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array of indices</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select one element from each row of a using the indices in b</span></span><br><span class="line"><span class="built_in">print</span>(a[np.arange(<span class="number">4</span>), b])  <span class="comment"># Prints &quot;[ 1  6  7 11]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mutate one element from each row of a using the indices in b</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[11,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5, 16],</span></span><br><span class="line">          <span class="comment">#                [17,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 21, 12]])</span></span><br></pre></td></tr></table></figure><p><strong>布尔数组索引</strong>: 布尔数组索引允许你选择数组的任意元素。通常，这种类型的索引用于选择满足某些条件的数组元素。下面是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)   <span class="comment"># Find the elements of a that are bigger than 2;</span></span><br><span class="line">                     <span class="comment"># this returns a numpy array of Booleans of the same</span></span><br><span class="line">                     <span class="comment"># shape as a, where each slot of bool_idx tells</span></span><br><span class="line">                     <span class="comment"># whether that element of a is &gt; 2.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bool_idx)      <span class="comment"># Prints &quot;[[False False]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We use boolean array indexing to construct a rank 1 array</span></span><br><span class="line"><span class="comment"># consisting of the elements of a corresponding to the True values</span></span><br><span class="line"><span class="comment"># of bool_idx</span></span><br><span class="line"><span class="built_in">print</span>(a[bool_idx])  <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can do all of the above in a single concise statement:</span></span><br><span class="line"><span class="built_in">print</span>(a[a &gt; <span class="number">2</span>])     <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>每个numpy数组都是相同类型元素的网格。Numpy提供了一组可用于构造数组的大量数值数据类型。Numpy在创建数组时尝试猜测数据类型，但构造数组的函数通常还包含一个可选参数来显式指定数据类型。这是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)         <span class="comment"># Prints &quot;int64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)             <span class="comment"># Prints &quot;float64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)   <span class="comment"># Force a particular datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)                         <span class="comment"># Prints &quot;int64&quot;</span></span><br></pre></td></tr></table></figure><h3 id="数组中的数学"><a href="#数组中的数学" class="headerlink" title="数组中的数学"></a>数组中的数学</h3><p>基本数学函数在数组上以元素方式运行，既可以作为运算符重载，也可以作为numpy模块中的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise sum; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 6.0  8.0]</span></span><br><span class="line"><span class="comment">#  [10.0 12.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise difference; both produce the array</span></span><br><span class="line"><span class="comment"># [[-4.0 -4.0]</span></span><br><span class="line"><span class="comment">#  [-4.0 -4.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x - y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise product; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 5.0 12.0]</span></span><br><span class="line"><span class="comment">#  [21.0 32.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x * y)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise division; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 0.2         0.33333333]</span></span><br><span class="line"><span class="comment">#  [ 0.42857143  0.5       ]]</span></span><br><span class="line"><span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="built_in">print</span>(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise square root; produces the array</span></span><br><span class="line"><span class="comment"># [[ 1.          1.41421356]</span></span><br><span class="line"><span class="comment">#  [ 1.73205081  2.        ]]</span></span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br></pre></td></tr></table></figure><p>请注意，与MATLAB不同，<code>*</code>是元素乘法，而不是矩阵乘法。 我们使用<code>dot</code>函数来计算向量的内积，将向量乘以矩阵，并乘以矩阵。 <code>dot</code>既可以作为numpy模块中的函数，也可以作为数组对象的实例方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inner product of vectors; both produce 219</span></span><br><span class="line"><span class="built_in">print</span>(v.dot(w))</span><br><span class="line"><span class="built_in">print</span>(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / vector product; both produce the rank 1 array [29 67]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(v))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / matrix product; both produce the rank 2 array</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(y))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))</span><br></pre></td></tr></table></figure><p>Numpy为在数组上执行计算提供了许多有用的函数；其中最有用的函数之一是 <code>SUM</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x))  <span class="comment"># Compute sum of all elements; prints &quot;10&quot;</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>))  <span class="comment"># Compute sum of each column; prints &quot;[4 6]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>))  <span class="comment"># Compute sum of each row; prints &quot;[3 7]&quot;</span></span><br></pre></td></tr></table></figure><p>除了使用数组计算数学函数外，我们经常需要对数组中的数据进行整形或其他操作。这种操作的最简单的例子是转置一个矩阵；要转置一个矩阵，只需使用一个数组对象的<code>T</code>属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)    <span class="comment"># Prints &quot;[[1 2]</span></span><br><span class="line">            <span class="comment">#          [3 4]]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x.T)  <span class="comment"># Prints &quot;[[1 3]</span></span><br><span class="line">            <span class="comment">#          [2 4]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that taking the transpose of a rank 1 array does nothing:</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(v)    <span class="comment"># Prints &quot;[1 2 3]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(v.T)  <span class="comment"># Prints &quot;[1 2 3]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="广播-Broadcasting"><a href="#广播-Broadcasting" class="headerlink" title="广播(Broadcasting)"></a>广播(Broadcasting)</h3><p>广播是一种强大的机制，它允许numpy在执行算术运算时使用不同形状的数组。通常，我们有一个较小的数组和一个较大的数组，我们希望多次使用较小的数组来对较大的数组执行一些操作。</p><p>例如，假设我们要向矩阵的每一行添加一个常数向量。我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.empty_like(x)   <span class="comment"># Create an empty matrix with the same shape as x</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the vector v to each row of the matrix x with an explicit loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now y is the following</span></span><br><span class="line"><span class="comment"># [[ 2  2  4]</span></span><br><span class="line"><span class="comment">#  [ 5  5  7]</span></span><br><span class="line"><span class="comment">#  [ 8  8 10]</span></span><br><span class="line"><span class="comment">#  [11 11 13]]</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>这会凑效; 但是当矩阵 <code>x</code> 非常大时，在Python中计算显式循环可能会很慢。注意，向矩阵 <code>x</code> 的每一行添加向量 <code>v</code> 等同于通过垂直堆叠多个 <code>v</code> 副本来形成矩阵 <code>vv</code>，然后执行元素的求和<code>x</code> 和 <code>vv</code>。 我们可以像如下这样实现这种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">vv = np.tile(v, (<span class="number">4</span>, <span class="number">1</span>))   <span class="comment"># Stack 4 copies of v on top of each other</span></span><br><span class="line"><span class="built_in">print</span>(vv)                 <span class="comment"># Prints &quot;[[1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]]&quot;</span></span><br><span class="line">y = x + vv  <span class="comment"># Add x and vv elementwise</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># Prints &quot;[[ 2  2  4</span></span><br><span class="line">          <span class="comment">#          [ 5  5  7]</span></span><br><span class="line">          <span class="comment">#          [ 8  8 10]</span></span><br><span class="line">          <span class="comment">#          [11 11 13]]&quot;</span></span><br></pre></td></tr></table></figure><p>Numpy广播允许我们在不实际创建<code>v</code>的多个副本的情况下执行此计算。考虑这个需求，使用广播如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = x + v  <span class="comment"># Add v to each row of x using broadcasting</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># Prints &quot;[[ 2  2  4]</span></span><br><span class="line">          <span class="comment">#          [ 5  5  7]</span></span><br><span class="line">          <span class="comment">#          [ 8  8 10]</span></span><br><span class="line">          <span class="comment">#          [11 11 13]]&quot;</span></span><br></pre></td></tr></table></figure><p><code>y=x+v</code>行即使<code>x</code>具有形状<code>(4，3)</code>和<code>v</code>具有形状<code>(3,)</code>，但由于广播的关系，该行的工作方式就好像<code>v</code>实际上具有形状<code>(4，3)</code>，其中每一行都是<code>v</code>的副本，并且求和是按元素执行的。</p><p>将两个数组一起广播遵循以下规则：</p><ol><li>如果数组不具有相同的rank，则将较低等级数组的形状添加1，直到两个形状具有相同的长度。</li><li>如果两个数组在维度上具有相同的大小，或者如果其中一个数组在该维度中的大小为1，则称这两个数组在维度上是兼容的。</li><li>如果数组在所有维度上兼容，则可以一起广播。</li><li>广播之后，每个数组的行为就好像它的形状等于两个输入数组的形状的元素最大值。</li><li>在一个数组的大小为1且另一个数组的大小大于1的任何维度中，第一个数组的行为就像沿着该维度复制一样</li></ol><p>以下是广播的一些应用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute outer product of vectors</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># v has shape (3,)</span></span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])    <span class="comment"># w has shape (2,)</span></span><br><span class="line"><span class="comment"># To compute an outer product, we first reshape v to be a column</span></span><br><span class="line"><span class="comment"># vector of shape (3, 1); we can then broadcast it against w to yield</span></span><br><span class="line"><span class="comment"># an output of shape (3, 2), which is the outer product of v and w:</span></span><br><span class="line"><span class="comment"># [[ 4  5]</span></span><br><span class="line"><span class="comment">#  [ 8 10]</span></span><br><span class="line"><span class="comment">#  [12 15]]</span></span><br><span class="line"><span class="built_in">print</span>(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) * w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a vector to each row of a matrix</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span></span><br><span class="line"><span class="comment"># giving the following matrix:</span></span><br><span class="line"><span class="comment"># [[2 4 6]</span></span><br><span class="line"><span class="comment">#  [5 7 9]]</span></span><br><span class="line"><span class="built_in">print</span>(x + v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a vector to each column of a matrix</span></span><br><span class="line"><span class="comment"># x has shape (2, 3) and w has shape (2,).</span></span><br><span class="line"><span class="comment"># If we transpose x then it has shape (3, 2) and can be broadcast</span></span><br><span class="line"><span class="comment"># against w to yield a result of shape (3, 2); transposing this result</span></span><br><span class="line"><span class="comment"># yields the final result of shape (2, 3) which is the matrix x with</span></span><br><span class="line"><span class="comment"># the vector w added to each column. Gives the following matrix:</span></span><br><span class="line"><span class="comment"># [[ 5  6  7]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11]]</span></span><br><span class="line"><span class="built_in">print</span>((x.T + w).T)</span><br><span class="line"><span class="comment"># Another solution is to reshape w to be a column vector of shape (2, 1);</span></span><br><span class="line"><span class="comment"># we can then broadcast it directly against x to produce the same</span></span><br><span class="line"><span class="comment"># output.</span></span><br><span class="line"><span class="built_in">print</span>(x + np.reshape(w, (<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiply a matrix by a constant:</span></span><br><span class="line"><span class="comment"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span></span><br><span class="line"><span class="comment"># these can be broadcast together to shape (2, 3), producing the</span></span><br><span class="line"><span class="comment"># following array:</span></span><br><span class="line"><span class="comment"># [[ 2  4  6]</span></span><br><span class="line"><span class="comment">#  [ 8 10 12]]</span></span><br><span class="line"><span class="built_in">print</span>(x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>广播通常会使你的代码更简洁，效率更高，因此你应该尽可能地使用它。</p><h2 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h2><p>Numpy提供了一个高性能的多维数组和基本工具来计算和操作这些数组。 而<a href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>以此为基础，提供了大量在numpy数组上运行的函数，可用于不同类型的科学和工程应用程序。</p><p>熟悉SciPy的最佳方法是浏览<a href="https://docs.scipy.org/doc/scipy/reference/index.html">它的文档</a>。我们将重点介绍SciPy有关的对你有价值的部分内容。</p><h3 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h3><p>SciPy提供了一些处理图像的基本函数。例如，它具有将映像从磁盘读入numpy数组、将numpy数组作为映像写入磁盘以及调整映像大小的功能。下面是一个演示这些函数的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread, imsave, imresize</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read an JPEG image into a numpy array</span></span><br><span class="line">img = imread(<span class="string">&#x27;assets/cat.jpg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(img.dtype, img.shape)  <span class="comment"># Prints &quot;uint8 (400, 248, 3)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can tint the image by scaling each of the color channels</span></span><br><span class="line"><span class="comment"># by a different scalar constant. The image has shape (400, 248, 3);</span></span><br><span class="line"><span class="comment"># we multiply it by the array [1, 0.95, 0.9] of shape (3,);</span></span><br><span class="line"><span class="comment"># numpy broadcasting means that this leaves the red channel unchanged,</span></span><br><span class="line"><span class="comment"># and multiplies the green and blue channels by 0.95 and 0.9</span></span><br><span class="line"><span class="comment"># respectively.</span></span><br><span class="line">img_tinted = img * [<span class="number">1</span>, <span class="number">0.95</span>, <span class="number">0.9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize the tinted image to be 300 by 300 pixels.</span></span><br><span class="line">img_tinted = imresize(img_tinted, (<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the tinted image back to disk</span></span><br><span class="line">imsave(<span class="string">&#x27;assets/cat_tinted.jpg&#x27;</span>, img_tinted)</span><br></pre></td></tr></table></figure><p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/cat.jpg" alt="猫咪"> <img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/cat_tinted.jpg" alt="猫咪"></p><p>左：原始图像。右：着色和调整大小的图像。</p><h3 id="MATLAB-文件"><a href="#MATLAB-文件" class="headerlink" title="MATLAB 文件"></a>MATLAB 文件</h3><p>函数 <code>scipy.io.loadmat</code> 和 <code>scipy.io.savemat</code> 允许你读取和写入MATLAB文件。你可以在<a href="https://docs.scipy.org/doc/scipy/reference/io.html">这篇文档</a>中学习相关操作。</p><h3 id="点之间的距离"><a href="#点之间的距离" class="headerlink" title="点之间的距离"></a>点之间的距离</h3><p>SciPy定义了一些用于计算点集之间距离的有用函数。</p><p>函数<code>scipy.spatial.distance.pdist</code>计算给定集合中所有点对之间的距离：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist, squareform</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following array where each row is a point in 2D space:</span></span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [1 0]</span></span><br><span class="line"><span class="comment">#  [2 0]]</span></span><br><span class="line">x = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the Euclidean distance between all rows of x.</span></span><br><span class="line"><span class="comment"># d[i, j] is the Euclidean distance between x[i, :] and x[j, :],</span></span><br><span class="line"><span class="comment"># and d is the following array:</span></span><br><span class="line"><span class="comment"># [[ 0.          1.41421356  2.23606798]</span></span><br><span class="line"><span class="comment">#  [ 1.41421356  0.          1.        ]</span></span><br><span class="line"><span class="comment">#  [ 2.23606798  1.          0.        ]]</span></span><br><span class="line">d = squareform(pdist(x, <span class="string">&#x27;euclidean&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p><a href="https://matplotlib.org/">Matplotlib</a>是一个绘图库。本节简要介绍 <code>matplotlib.pyplot</code> 模块，该模块提供了类似于MATLAB的绘图系统。</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>matplotlib中最重要的功能是<code>plot</code>，它允许你绘制2D数据的图像。这是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the x and y coordinates for points on a sine curve</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the points using matplotlib</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()  <span class="comment"># You must call plt.show() to make graphics appear.</span></span><br></pre></td></tr></table></figure><p>运行此代码会生成以下图表：</p><p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/sine.png" alt="sine"></p><p>通过一些额外的工作，我们可以轻松地一次绘制多条线，并添加标题，图例和轴标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the x and y coordinates for points on sine and cosine curves</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the points using matplotlib</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x axis label&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y axis label&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Sine and Cosine&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Sine&#x27;</span>, <span class="string">&#x27;Cosine&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/sine_cosine.png" alt="sine_cosine"></p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>你可以使用<code>subplot</code>函数在同一个图中绘制不同的东西。 这是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the x and y coordinates for points on sine and cosine curves</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">3</span> * np.pi, <span class="number">0.1</span>)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a subplot grid that has height 2 and width 1,</span></span><br><span class="line"><span class="comment"># and set the first such subplot as active.</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make the first plot</span></span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.title(<span class="string">&#x27;Sine&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the second subplot as active, and make the second plot.</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.title(<span class="string">&#x27;Cosine&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the figure.</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/sine_cosine_subplot.png" alt="sine_cosine_subplot"></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>你可以使用 <code>imshow</code> 函数来显示一张图片。 这是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imread, imresize</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = imread(<span class="string">&#x27;assets/cat.jpg&#x27;</span>)</span><br><span class="line">img_tinted = img * [<span class="number">1</span>, <span class="number">0.95</span>, <span class="number">0.9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the original image</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the tinted image</span></span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A slight gotcha with imshow is that it might give strange results</span></span><br><span class="line"><span class="comment"># if presented with data that is not uint8. To work around this, we</span></span><br><span class="line"><span class="comment"># explicitly cast the image to uint8 before displaying it.</span></span><br><span class="line">plt.imshow(np.uint8(img_tinted))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/09/18/numpy%E6%95%99%E7%A8%8B/cat_tinted_imshow.png" alt="cat_tinted_imshow"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python、Numpy-教程&quot;&gt;&lt;a href=&quot;#Python、Numpy-教程&quot; class=&quot;headerlink&quot; title=&quot;Python、Numpy 教程&quot;&gt;&lt;/a&gt;Python、Numpy 教程&lt;/h1&gt;&lt;h2 id=&quot;Python&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>numpy基础入门</title>
    <link href="http://rczmm.github.io/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://rczmm.github.io/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-17T06:18:44.000Z</published>
    <updated>2021-09-17T10:39:37.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NumPy-简单入门教程"><a href="#NumPy-简单入门教程" class="headerlink" title="NumPy 简单入门教程"></a>NumPy 简单入门教程</h1><p>NumPy是Python中的一个运算速度非常快的一个数学库，它非常重视数组。它允许你在Python中进行向量和矩阵计算，并且由于许多底层函数实际上是用C编写的，因此你可以体验在原生Python中永远无法体验到的速度。</p><p>NumPy绝对是科学Python成功的关键之一，如果你想要进入Python中的数据科学/机器学习，你就要必须学习它。在我看来，NumPy的API设计得很好，所以我们要开始使用它并不困难。</p><h2 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h2><h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h3><p>NumPy围绕这些称为数组的事物展开。实际上它被称之为 <code>ndarrays</code>，你不知道没事儿。使用NumPy提供的这些数组，我们就可以以闪电般的速度执行各种有用的操作，如矢量和矩阵、线性代数等数学运算！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1D Array</span></span><br><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = np.array((<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">c = np.arange(<span class="number">5</span>)</span><br><span class="line">d = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># &gt;&gt;&gt;[ 0.          1.57079633  3.14159265  4.71238898  6.28318531]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>]) <span class="comment"># &gt;&gt;&gt;3</span></span><br></pre></td></tr></table></figure><p>上面的代码显示了创建数组的4种不同方法。最基本的方法是将序列传递给NumPy的array()函数; 你可以传递任何序列（类数组），而不仅仅是常见的列表（list）数据类型。</p><p>请注意，当我们打印具有不同长度数字的数组时，它会自动将它们填充出来。这对于查看矩阵很有用。对数组进行索引就像列表或任何其他Python序列一样。 你也可以对它们进行切片，我不打算在这里切片一维数组。</p><p>上面的数组示例是如何使用NumPy表示向量的，接下来我们将看看如何使用多维数组表示矩阵和更多的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MD Array,</span></span><br><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">4</span>]) <span class="comment"># &gt;&gt;&gt;25</span></span><br></pre></td></tr></table></figure><p>为了创建一个2D（二维）数组，我们传递一个列表的列表（或者是一个序列的序列）给array()函数。如果我们想要一个3D（三维）数组，我们就要传递一个列表的列表的列表，如果是一个4D（四维）数组，那就是列表的列表的列表的列表，以此类推。</p><p>请注意2D（二维）数组（在我们的朋友空格键的帮助下）是如何按行和列排列的。要索引2D（二维）数组，我们只需引用行数和列数即可。</p><h3 id="它背后的一些数学知识"><a href="#它背后的一些数学知识" class="headerlink" title="它背后的一些数学知识"></a>它背后的一些数学知识</h3><p>要正确理解这一点，我们应该真正了解一下矢量和矩阵是什么。</p><p>矢量是具有方向和幅度的量。它们通常用于表示速度，加速度和动量等事物。向量可以用多种方式编写，尽管对我们最有用的是它们被写为n元组的形式，如（1,4,6,9）。这就是我们在NumPy中表示他们的方式。</p><p>矩阵类似于矢量，除了它由行和列组成; 很像一个网格。可以通过给出它所在的行和列来引用矩阵中的值。在NumPy中，我们通过传递一系列序列来制作数组，就像我们之前所做的那样。</p><p><img src="/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/numpy_maths1-1.jpg" alt="简单线性代数图示"></p><h3 id="多维数组切片"><a href="#多维数组切片" class="headerlink" title="多维数组切片"></a>多维数组切片</h3><p>切片多维数组比1D数组复杂一点，并且在使用NumPy时你也会经常需要使用到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>:<span class="number">4</span>]) <span class="comment"># &gt;&gt;&gt;[12 13 14]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">4</span>, <span class="number">0</span>]) <span class="comment"># &gt;&gt;&gt;[16 21 26]</span></span><br><span class="line"><span class="built_in">print</span>(a[::<span class="number">2</span>,::<span class="number">2</span>]) <span class="comment"># &gt;&gt;&gt;[[11 13 15]</span></span><br><span class="line">                  <span class="comment">#     [21 23 25]</span></span><br><span class="line">                  <span class="comment">#     [31 33 35]]</span></span><br><span class="line"><span class="built_in">print</span>(a[:, <span class="number">1</span>]) <span class="comment"># &gt;&gt;&gt;[12 17 22 27 32]</span></span><br></pre></td></tr></table></figure><p>如你所见，通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于2D数组，我们的第一片定义了行的切片，第二片定义了列的切片。</p><p>注意，只需输入数字就可以指定行或列。上面的第一个示例从数组中选择第0列。</p><p>下面的图表说明了给定的示例切片是如何进行工作的。</p><p><img src="/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/numpy_2D_slicing_diagram-1.jpg" alt="numpy数组切片工作原理"></p><h3 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h3><p>在使用 NumPy 时，你会想知道数组的某些信息。很幸运，在这个包里边包含了很多便捷的方法，可以给你想要的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &gt;&gt;&gt;&lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a.dtype) <span class="comment"># &gt;&gt;&gt;int64</span></span><br><span class="line"><span class="built_in">print</span>(a.size) <span class="comment"># &gt;&gt;&gt;25</span></span><br><span class="line"><span class="built_in">print</span>(a.shape) <span class="comment"># &gt;&gt;&gt;(5, 5)</span></span><br><span class="line"><span class="built_in">print</span>(a.itemsize) <span class="comment"># &gt;&gt;&gt;8</span></span><br><span class="line"><span class="built_in">print</span>(a.ndim) <span class="comment"># &gt;&gt;&gt;2</span></span><br><span class="line"><span class="built_in">print</span>(a.nbytes) <span class="comment"># &gt;&gt;&gt;200</span></span><br></pre></td></tr></table></figure><p>正如你在上面的代码中看到的，NumPy数组实际上被称为ndarray。我不知道为什么他妈的它叫ndarray，如果有人知道请留言！我猜它代表n维数组。</p><p>数组的形状是它有多少行和列，上面的数组有5行和5列，所以它的形状是(5，5)。</p><p><code>itemsize</code>属性是每个项占用的字节数。这个数组的数据类型是int 64，一个int 64中有64位，一个字节中有8位，除以64除以8，你就可以得到它占用了多少字节，在本例中是8。</p><p><code>ndim</code> 属性是数组的维数。这个有2个。例如，向量只有1。</p><p><code>nbytes</code> 属性是数组中的所有数据消耗掉的字节数。你应该注意到，这并不计算数组的开销，因此数组占用的实际空间将稍微大一点。</p><h2 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h2><h3 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h3><p>只是能够从数组中创建和检索元素和属性不能满足你的需求，你有时也需要对它们进行数学运算。 你完全可以使用四则运算符 +、- 、/ 来完成运算操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Basic Operators</span></span><br><span class="line">a = np.arange(<span class="number">25</span>)</span><br><span class="line">a = a.reshape((<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">b = np.array([<span class="number">10</span>, <span class="number">62</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">56</span>, <span class="number">79</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">45</span>,</span><br><span class="line">              <span class="number">4</span>, <span class="number">92</span>, <span class="number">5</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">6</span>, <span class="number">53</span>, <span class="number">24</span>,</span><br><span class="line">              <span class="number">56</span>, <span class="number">3</span>, <span class="number">56</span>, <span class="number">44</span>, <span class="number">78</span>])</span><br><span class="line">b = b.reshape((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="built_in">print</span>(a - b)</span><br><span class="line"><span class="built_in">print</span>(a * b)</span><br><span class="line"><span class="built_in">print</span>(a / b)</span><br><span class="line"><span class="built_in">print</span>(a ** <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a &lt; b) <span class="built_in">print</span>(a &gt; b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.dot(b))</span><br></pre></td></tr></table></figure><p>除了 dot() 之外，这些操作符都是对数组进行逐元素运算。比如 (a, b, c) + (d, e, f) 的结果就是 (a+d, b+e, c+f)。它将分别对每一个元素进行配对，然后对它们进行运算。它返回的结果是一个数组。注意，当使用逻辑运算符比如 “&lt;” 和 “&gt;” 的时候，返回的将是一个布尔型数组，这点有一个很好的用处，后边我们会提到。</p><p>dot() 函数计算两个数组的点积。它返回的是一个标量（只有大小没有方向的一个值）而不是数组。</p><h3 id="它背后的一些数学知识-1"><a href="#它背后的一些数学知识-1" class="headerlink" title="它背后的一些数学知识"></a>它背后的一些数学知识</h3><p>dot()函数称为点积。理解这一点的最好方法是看下图，下图将表示它是如何进行计算的。</p><p><img src="/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/numpy_maths2-1.jpg" alt="点积运算原理"></p><h3 id="数组特殊运算符"><a href="#数组特殊运算符" class="headerlink" title="数组特殊运算符"></a>数组特殊运算符</h3><p>NumPy还提供了一些别的用于处理数组的好用的运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>()) <span class="comment"># &gt;&gt;&gt;45</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>()) <span class="comment"># &gt;&gt;&gt;0</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>()) <span class="comment"># &gt;&gt;&gt;9</span></span><br><span class="line"><span class="built_in">print</span>(a.cumsum()) <span class="comment"># &gt;&gt;&gt;[ 0  1  3  6 10 15 21 28 36 45]</span></span><br></pre></td></tr></table></figure><p>sum()、min()和max()函数的作用非常明显。将所有元素相加，找出最小和最大元素。</p><p>然而，cumsum()函数就不那么明显了。它将像sum()这样的每个元素相加，但是它首先将第一个元素和第二个元素相加，并将计算结果存储在一个列表中，然后将该结果添加到第三个元素中，然后再将该结果存储在一个列表中。这将对数组中的所有元素执行此操作，并返回作为列表的数组之和的运行总数。</p><h2 id="索引进阶"><a href="#索引进阶" class="headerlink" title="索引进阶"></a>索引进阶</h2><h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><p><code>花式索引</code> 是获取数组中我们想要的特定元素的有效方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fancy indexing</span></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">indices = [<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>]</span><br><span class="line">b = a[indices]</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &gt;&gt;&gt;[ 0 10 20 30 40 50 60 70 80 90]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;[10 50 90]</span></span><br></pre></td></tr></table></figure><p>正如你在上面的示例中所看到的，我们使用我们想要检索的特定索引序列对数组进行索引。这反过来返回我们索引的元素的列表。</p><h3 id="布尔屏蔽"><a href="#布尔屏蔽" class="headerlink" title="布尔屏蔽"></a>布尔屏蔽</h3><p>布尔屏蔽是一个有用的功能，它允许我们根据我们指定的条件检索数组中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Boolean masking</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">b = np.sin(a)</span><br><span class="line">plt.plot(a,b)</span><br><span class="line">mask = b &gt;= <span class="number">0</span></span><br><span class="line">plt.plot(a[mask], b[mask], <span class="string">&#x27;bo&#x27;</span>)</span><br><span class="line">mask = (b &gt;= <span class="number">0</span>) &amp; (a &lt;= np.pi / <span class="number">2</span>)</span><br><span class="line">plt.plot(a[mask], b[mask], <span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>上面的示例显示了如何进行布尔屏蔽。你所要做的就是将数组传递给涉及数组的条件，它将为你提供一个值的数组，为该条件返回true。</p><p>该示例生成以下图：</p><p><img src="/2021/09/17/numpy%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/numpy_masking-1.png" alt="布尔掩码结果图"></p><p>我们利用这些条件来选择图上的不同点。蓝色点(在图中还包括绿点，但绿点掩盖了蓝色点)，显示值大于0的所有点。绿色点表示值大于0且小于一半π的所有点。</p><h3 id="缺省索引"><a href="#缺省索引" class="headerlink" title="缺省索引"></a>缺省索引</h3><p>不完全索引是从多维数组的第一个维度获取索引或切片的一种方便方法。例如，如果数组a=[1，2，3，4，5]，[6，7，8，9，10]，那么[3]将在数组的第一个维度中给出索引为3的元素，这里是值4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Incomplete Indexing</span></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">b = a[:<span class="number">5</span>]</span><br><span class="line">c = a[a &gt;= <span class="number">50</span>]</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;[ 0 10 20 30 40]</span></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># &gt;&gt;&gt;[50 60 70 80 90]</span></span><br></pre></td></tr></table></figure><h3 id="Where-函数"><a href="#Where-函数" class="headerlink" title="Where 函数"></a>Where 函数</h3><p>where() 函数是另外一个根据条件返回数组中的值的有效方法。只需要把条件传递给它，它就会返回一个使得条件为真的元素的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Where</span></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">b = np.where(a &lt; <span class="number">50</span>) </span><br><span class="line">c = np.where(a &gt;= <span class="number">50</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;(array([0, 1, 2, 3, 4]),)</span></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># &gt;&gt;&gt;[5 6 7 8 9]</span></span><br></pre></td></tr></table></figure><p>这就是NumPy，没那么难吧？当然，这篇文章只涵盖了入门的基础知识，在NumPy中你还可以做许多其他好玩的事情，当你已经熟悉了NumPy的基础知识，你就可以开始自由的探索NumPy的世界了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NumPy-简单入门教程&quot;&gt;&lt;a href=&quot;#NumPy-简单入门教程&quot; class=&quot;headerlink&quot; title=&quot;NumPy 简单入门教程&quot;&gt;&lt;/a&gt;NumPy 简单入门教程&lt;/h1&gt;&lt;p&gt;NumPy是Python中的一个运算速度非常快的一个数学库，</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>alta数据治理</title>
    <link href="http://rczmm.github.io/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/"/>
    <id>http://rczmm.github.io/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/</id>
    <published>2021-09-15T01:20:37.000Z</published>
    <updated>2021-09-26T05:45:31.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Apache-Atlas-进行数据治理"><a href="#使用-Apache-Atlas-进行数据治理" class="headerlink" title="使用 Apache Atlas 进行数据治理"></a>使用 Apache Atlas 进行数据治理</h1><h2 id="数据治理"><a href="#数据治理" class="headerlink" title="数据治理"></a>数据治理</h2><p>数据治理意义重大，传统的数据治理采用文档的形式进行管理，已经无法满足大数据下的数据治理需要。而适合于Hadoop大数据生态体系的数据治理就非常的重要了。</p><blockquote><p>大数据下的数据治理作为很多企业的一个巨大的难题，能找到的数据的解决方案并不多，但是好在近几年，很多公司已经进行了尝试并开源了出来，本文将详细分析这些数据发现平台，在国外已经有了十几种的实现方案。<br>数据发现平台可以解决的问题<br>为什么需要一个数据发现平台？<br>在数据治理过程中，经常会遇到这些问题：</p><p>数据都存在哪？</p><p>该如何使用这些数据？</p><p>数据是做什么的？</p><p>数据是如何创建的？</p><p>数据是如何更新的？</p></blockquote><p><strong>数据发现平台的目的就是为了解决上面的问题，帮助更好的查找，理解和使用数据。</strong></p><blockquote><p>Facebook的Nemo就使用了全文检索技术，这样可以快速的搜索到目标数据。</p><p>es（搜索引擎）</p></blockquote><h3 id="各平台对比"><a href="#各平台对比" class="headerlink" title="各平台对比"></a>各平台对比</h3><p><img src="/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/image-20210915093419300.png" alt="image-20210915093419300"></p><p>开源的有五家：Amundsen Datahub Metacat Marquez Atlas</p><p>有文档的有三家：Amundsen Datahub Atlas</p><p>搜索功能较强 ：Amundsen</p><p>有数据血统功能：Datahub Atlas</p><p>考虑到项目的周期，实施性等情况，还是建议大家从Atlas入门，打开数据治理的探索之路。</p><h2 id="alta"><a href="#alta" class="headerlink" title="alta"></a>alta</h2><blockquote><p>面对海量且持续增加的各式各样的数据对象，你是否有信心知道哪些数据从哪里来以及它如何随时间而变化？采用Hadoop必须考虑数据管理的实际情况，元数据与数据治理成为企业级数据湖的重要部分。</p><p>为寻求数据治理的开源解决方案，Hortonworks 公司联合其他厂商与用户于2015年发起数据治理倡议，包括数据分类、集中策略引擎、数据血缘、安全和生命周期管理等方面。Apache Atlas 项目就是这个倡议的结果，社区伙伴持续的为该项目提供新的功能和特性。该项目用于管理共享元数据、数据分级、审计、安全性以及数据保护等方面，努力与Apache Ranger整合，用于数据权限控制策略。</p></blockquote><p>Atlas 是一个可扩展和可扩展的核心基础治理服务集 - 使企业能够有效地和高效地满足 Hadoop 中的合规性要求，并允许与整个企业数据生态系统的集成。</p><p><img src="/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/1253350-20180509182903076-1452084256.jpg" alt="alta数据治理"></p><p>Atlas 的组件可以分为以下主要类别：</p><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p>此类别包含实现 Atlas 功能核心的组件，包括：</p><p>Type System：Atlas 允许用户为他们想要管理的元数据对象定义一个模型。该模型由称为 “类型” 的定义组成。”类型” 的 实例被称为 “实体” 表示被管理的实际元数据对象。类型系统是一个组件，允许用户定义和管理类型和实体。由 Atlas 管理的所有元数据对象（例如Hive表）都使用类型进行建模，并表示为实体。要在 Atlas 中存储新类型的元数据，需要了解类型系统组件的概念。</p><p>需要注意的一个关键点是，Atlas 中建模的通用性质允许数据管理员和集成者定义技术元数据和业务元数据。也可以使用 Atlas 的特征来定义两者之间的丰富关系。</p><p>Ingest / Export：Ingest 组件允许将元数据添加到 Atlas。类似地，Export 组件暴露由 Atlas 检测到的元数据更改，以作为事件引发，消费者可以使用这些更改事件来实时响应元数据更改。</p><p>Graph Engine ：在内部，Atlas 通过使用图形模型管理元数据对象。以实现元数据对象之间的巨大灵活性和丰富的关系。图形引擎是负责在类型系统的类型和实体之间进行转换的组件，以及基础图形模型。除了管理图形对象之外，图形引擎还为元数据对象创建适当的索引，以便有效地搜索它们。</p><p>Titan：目前，Atlas 使用 Titan 图数据库来存储元数据对象。 Titan 使用两个存储：默认情况下元数据存储配置为 HBase ，索引存储配置为 Solr。也可以通过构建相应的配置文件将元数据存储作为 BerkeleyDB 和 Index 存储使用为 ElasticSearch。元数据存储用于存储元数据对象本身，并且索引存储用于存储元数据属性的索引，其允许高效搜索。</p><h2 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h2><p>用户可以使用两种方法管理 Atlas 中的元数据：</p><p>API：Atlas 的所有功能通过 REST API 提供给最终用户，允许创建，更新和删除类型和实体。它也是查询和发现通过 Atlas 管理的类型和实体的主要方法。</p><p>Messaging：除了 API 之外，用户还可以选择使用基于 Kafka 的消息接口与 Atlas 集成。这对于将元数据对象传输到 Atlas 以及从 Atlas 使用可以构建应用程序的元数据更改事件都非常有用。如果希望使用与 Atlas 更松散耦合的集成，这可以允许更好的可扩展性，可靠性等，消息传递接口是特别有用的。Atlas 使用 Apache Kafka 作为通知服务器用于钩子和元数据通知事件的下游消费者之间的通信。事件由钩子和 Atlas 写到不同的 Kafka 主题。</p><h3 id="元数据源"><a href="#元数据源" class="headerlink" title="元数据源"></a>元数据源</h3><p>Atlas 支持与许多元数据源的集成。将来还会添加更多集成。目前，Atlas 支持从以下来源获取和管理元数据：</p><p><a href="http://atlas.apache.org/StormAtlasHook.html">HiveSqoopFalconStorm</a></p><p>与其它元数据源集成意味着两件事：有一些元数据模型，Atlas 定义本机来表示这些组件的对象。 Atlas 提供了从这些组件中通过实时或批处理模式获取元数据对象的组件。</p><h2 id="Apps"><a href="#Apps" class="headerlink" title="Apps"></a>Apps</h2><p>由 Atlas 管理的元数据各种应用程序使用，满足许多治理用例。</p><p>Atlas Admin UI：该组件是一个基于 Web 的应用程序，允许数据管理员和科学家发现和注释元数据。这里最重要的是搜索界面和 SQL 样的查询语言，可以用来查询由 Atlas 管理的元数据类型和对象。管理 UI 使用 Atlas 的 REST API 来构建其功能。</p><p>Tag Based Policies：Apache Ranger 是针对 Hadoop 生态系统的高级安全管理解决方案，与各种 Hadoop 组件具有广泛的集成。通过与 Atlas 集成，Ranger 允许安全管理员定义元数据驱动的安全策略，以实现有效的治理。 Ranger 是由 Atlas 通知的元数据更改事件的消费者。</p><p>Business Taxonomy：从元数据源获取到 Atlas 的元数据对象主要是一种技术形式的元数据。为了增强可发现性和治理能力，Atlas 提供了一个业务分类界面，允许用户首先定义一组代表其业务域的业务术语，并将其与 Atlas 管理的元数据实体相关联。业务分类法是一种 Web 应用程序，目前是 Atlas Admin UI 的一部分，并且使用 REST API 与 Atlas 集成。</p><h2 id="Type-System"><a href="#Type-System" class="headerlink" title="Type System"></a>Type System</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Atlas 允许用户为他们想要管理的元数据对象定义一个模型。该模型由称为 “类型” 的定义组成。被称为 “实体” 的 “类型” 实例表示被管理的实际元数据对象。类型系统是一个组件，允许用户定义和管理类型和实体。由 Atlas 管理的所有元数据对象（例如Hive表）都使用类型进行建模，并表示为实体。要在Atlas中存储新类型的元数据，需要了解类型系统组件的概念。</p><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Atlas中的 “类型” 定义了如何存储和访问特定类型的元数据对象。类型表示了所定义元数据对象的一个或多个属性集合。具有开发背景的用户可以将 “类型” 理解成面向对象的编程语言的 “类” 定义的或关系数据库的 “表模式”。</p><p>与 Atlas 本地定义的类型的示例是 Hive 表。 Hive 表用这些属性定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name: hive_table</span><br><span class="line"> MetaType: Class</span><br><span class="line"> SuperTypes: DataSet</span><br><span class="line"> Attributes:</span><br><span class="line">     name: String (name of the table)</span><br><span class="line">     db: Database object of type hive_db</span><br><span class="line">     owner: String</span><br><span class="line">     createTime: Date</span><br><span class="line">     lastAccessTime: Date</span><br><span class="line">     comment: String</span><br><span class="line">     retention: int</span><br><span class="line">     sd: Storage Description object of type hive_storagedesc</span><br><span class="line">     partitionKeys: Array of objects of type hive_column</span><br><span class="line">     aliases: Array of strings</span><br><span class="line">     columns: Array of objects of type hive_column</span><br><span class="line">     parameters: Map of String keys to String values</span><br><span class="line">     viewOriginalText: String</span><br><span class="line">     viewExpandedText: String</span><br><span class="line">     tableType: String</span><br><span class="line">     temporary: Boolean</span><br></pre></td></tr></table></figure><p>从上面的例子可以注意到以下几点：</p><ul><li>Atlas中的类型由 “name” 唯一标识，</li><li>类型具有元类型。元类型表示 Atlas 中此模型的类型。 Atlas 有以下几种类型：<ul><li>基本元类型： Int，String，Boolean等。</li><li>枚举元类型</li><li>集合元类型：例如Array，Map</li><li>复合元类型：Class，Struct，Trait</li></ul></li><li>类型可以从称为 “supertype” 的父类型 “extend” - 凭借这一点，它将包含在 “supertype” 中定义的属性。这允许模型在一组相关类型等之间定义公共属性。这再次类似于面向对象语言如何定义类的超类的概念。 Atlas 中的类型也可以从多个超类型扩展。<ul><li>在该示例中，每个 hive 表从预定义的超类型（称为 “DataSet”）扩展。稍后将提供关于此预定义类型的更多细节。</li></ul></li><li>具有 “Class”，”Struct” 或 “Trait” 的元类型的类型可以具有属性集合。每个属性都有一个名称（例如 “name”）和一些其他关联的属性。可以使用表达式 type_name.attribute_name 来引用属性。还要注意，属性本身是使用 Atlas 元类型定义的。<ul><li>在这个例子中，hive_table.name 是一个字符串，hive_table.aliases 是一个字符串数组，hive_table.db 引用一个类型的实例称为 hive_db 等等。</li></ul></li><li>在属性中键入引用（如hive_table.db）。使用这样的属性，我们可以在 Atlas 中定义的两种类型之间的任意关系，从而构建丰富的模型。注意，也可以收集一个引用列表作为属性类型（例如 hive_table.cols，它表示从 hive_table 到 hive_column 类型的引用列表）</li></ul><h3 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h3><p>Atlas中的 “实体” 是类 “类型” 的特定值或实例，因此表示真实世界中的特定元数据对象。 回顾我们的面向对象编程语言的类比，”实例” 是某个 “类” 的 “对象”。</p><p>实体的示例将是特定的 Hive 表。 说 “Hive” 在 “默认” 数据库中有一个名为 “customers” 的表。 此表将是类型为 hive_table 的 Atlas 中的 “实体”。 通过作为类类型的实例，它将具有作为 Hive 表 “类型” 的一部分的每个属性的值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id: &quot;9ba387dd-fa76-429c-b791-ffc338d3c91f&quot;</span><br><span class="line"> typeName: “hive_table”</span><br><span class="line"> values:</span><br><span class="line">     name: &quot;customers&quot;</span><br><span class="line">     db: &quot;b42c6cfc-c1e7-42fd-a9e6-890e0adf33bc&quot;</span><br><span class="line">     owner: &quot;admin&quot;</span><br><span class="line">     createTime: &quot;2016-06-20T06:13:28.000Z&quot;</span><br><span class="line">     lastAccessTime: &quot;2016-06-20T06:13:28.000Z&quot;</span><br><span class="line">     comment: null</span><br><span class="line">     retention: 0</span><br><span class="line">     sd: &quot;ff58025f-6854-4195-9f75-3a3058dd8dcf&quot;</span><br><span class="line">     partitionKeys: null</span><br><span class="line">     aliases: null</span><br><span class="line">     columns: [&quot;65e2204f-6a23-4130-934a-9679af6a211f&quot;, &quot;d726de70-faca-46fb-9c99-cf04f6b579a6&quot;, ...]</span><br><span class="line">     parameters: &#123;&quot;transient_lastDdlTime&quot;: &quot;1466403208&quot;&#125;</span><br><span class="line">     viewOriginalText: null</span><br><span class="line">     viewExpandedText: null</span><br><span class="line">     tableType: &quot;MANAGED_TABLE&quot;</span><br><span class="line">     temporary: false</span><br></pre></td></tr></table></figure><p>从上面的例子可以注意到以下几点：</p><ul><li>作为 Class Type 实例的每个实体都由唯一标识符 GUID 标识。此 GUID 由 Atlas 服务器在定义对象时生成，并在实体的整个生命周期内保持不变。在任何时间点，可以使用其 GUID 来访问该特定实体。<ul><li>在本示例中，默认数据库中的 “customers” 表由GUID “9ba387dd-fa76-429c-b791-ffc338d3c91f” 唯一标识</li></ul></li><li>实体具有给定类型，并且类型的名称与实体定义一起提供。<ul><li>在这个例子中，”customers” 表是一个 “hive_table”。</li></ul></li><li>此实体的值是所有属性名称及其在 hive_table 类型定义中定义的属性的值的映射。</li><li>属性值将根据属性的元类型。<ul><li>基本元类型：整数，字符串，布尔值。例如。 ‘name’=’customers’，’Temporary’=’false’</li><li>集合元类型：包含元类型的值的数组或映射。例如。 parameters = {“transient_lastDdlTime”：”1466403208”}</li><li>复合元类型：对于类，值将是与该特定实体具有关系的实体。例如。hive 表 “customers” 存在于称为 “default” 的数据库中。</li></ul></li></ul><p>表和数据库之间的关系通过 “db” 属性捕获。因此，”db” 属性的值将是一个唯一标识 hive_db 实体的 GUID，称为 “default”对于实体的这个想法，我们现在可以看到 Class 和 Struct 元类型之间的区别。类和结构体都组成其他类型的属性。但是，类类型的实体具有 Id 属性（具有GUID值）并且可以从其他实体引用（如 hive_db 实体从 hive_table 实体引用）。 Struct 类型的实例没有自己的身份，Struct 类型的值是在实体本身内嵌入的属性的集合。</p><h3 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h3><p>我们已经看到属性在复合元类型（如 Class 和 Struct）中定义。 但是我们简单地将属性称为具有名称和元类型值。 然而， Atlas 中的属性还有一些属性，定义了与类型系统相关的更多概念。</p><p>属性具有以下属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name: string,</span><br><span class="line">  dataTypeName: string,</span><br><span class="line">  isComposite: boolean,</span><br><span class="line">  isIndexable: boolean,</span><br><span class="line">  isUnique: boolean,</span><br><span class="line">  multiplicity: enum,</span><br><span class="line">  reverseAttributeName: string</span><br></pre></td></tr></table></figure><p>以上属性具有以下含义：</p><ul><li>name - 属性的名称</li><li>dataTypeName - 属性的元类型名称（本机，集合或复合）</li><li>isComposite - 是否复合<ul><li>此标志指示建模的一个方面。如果一个属性被定义为复合，它意味着它不能有一个生命周期与它所包含的实体无关。这个概念的一个很好的例子是构成 hive 表一部分的一组列。由于列在 hive 表之外没有意义，它们被定义为组合属性。</li><li>必须在 Atlas 中创建复合属性及其所包含的实体。即，必须与 hive 表一起创建 hive 列。</li></ul></li><li>isIndexable - 是否索引<ul><li>此标志指示此属性是否应该索引，以便可以使用属性值作为谓词来执行查找，并且可以有效地执行查找。</li></ul></li><li>isUnique - 是否唯一<ul><li>此标志再次与索引相关。如果指定为唯一，这意味着为 Titan 中的此属性创建一个特殊索引，允许基于等式的查找。</li><li>具有此标志的真实值的任何属性都被视为主键，以将此实体与其他实体区分开。因此，应注意确保此属性在现实世界中模拟独特的属性。<ul><li>例如，考虑 hive_table 的 name 属性。孤立地，名称不是 hive_table 的唯一属性，因为具有相同名称的表可以存在于多个数据库中。如果 Atlas 在多个集群中存储 hive 表的元数据，即使一对（数据库名称，表名称）也不是唯一的。只有集群位置，数据库名称和表名称可以在物理世界中被视为唯一。</li></ul></li></ul></li><li>multiplicity - 指示此属性是（必需的／可选的／还是可以是多值）的。如果实体的属性值的定义与类型定义中的多重性声明不匹配，则这将是一个约束违反，并且实体添加将失败。因此，该字段可以用于定义元数据信息上的一些约束。</li></ul><p>使用上面的内容，让我们扩展下面的 hive 表的属性之一的属性定义。让我们看看称为 “db” 的属性，它表示 hive 表所属的数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db:</span><br><span class="line">    &quot;dataTypeName&quot;: &quot;hive_db&quot;,</span><br><span class="line">    &quot;isComposite&quot;: false,</span><br><span class="line">    &quot;isIndexable&quot;: true,</span><br><span class="line">    &quot;isUnique&quot;: false,</span><br><span class="line">    &quot;multiplicity&quot;: &quot;required&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;db&quot;,</span><br><span class="line">    &quot;reverseAttributeName&quot;: null</span><br></pre></td></tr></table></figure><p>注意多重性的 “multiplicity” = “required” 约束。 如果没有 db 引用，则不能发送表实体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">columns:</span><br><span class="line">    &quot;dataTypeName&quot;: &quot;array&lt;hive_column&gt;&quot;,</span><br><span class="line">    &quot;isComposite&quot;: true,</span><br><span class="line">    &quot;isIndexable&quot;: true,</span><br><span class="line">    “isUnique&quot;: false,</span><br><span class="line">    &quot;multiplicity&quot;: &quot;optional&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;columns&quot;,</span><br><span class="line">    &quot;reverseAttributeName&quot;: null</span><br></pre></td></tr></table></figure><p>请注意列的 “isComposite” = true 值。通过这样做，我们指示定义的列实体应该始终绑定到它们定义的表实体。</p><p>从这个描述和示例中，您将能够意识到属性定义可以用于影响 Atlas 系统要执行的特定建模行为（约束，索引等）。</p><h3 id="系统特定类型及其意义"><a href="#系统特定类型及其意义" class="headerlink" title="系统特定类型及其意义"></a>系统特定类型及其意义</h3><p>Atlas 提供了一些预定义的系统类型。我们在前面的章节中看到了一个例子（DataSet）。在本节中，我们将看到所有这些类型并了解它们的意义。</p><p>Referenceable：此类型表示可使用名为 qualifiedName 的唯一属性搜索的所有实体。</p><p>Asset：此类型包含名称，说明和所有者等属性。名称是必需属性（multiplicity = required），其他是可选的。可引用和资源的目的是为定型器提供在定义和查询其自身类型的实体时强制一致性的方法。拥有这些固定的属性集允许应用程序和用户界面基于约定基于默认情况下他们可以期望的属性的假设。</p><p>Infrastructure：此类型扩展了可引用和资产，通常可用于基础设施元数据对象（如群集，主机等）的常用超类型。</p><p>DataSet：此类型扩展了可引用和资产。在概念上，它可以用于表示存储数据的类型。在 Atlas 中，hive表，Sqoop RDBMS表等都是从 DataSet 扩展的类型。扩展 DataSet 的类型可以期望具有模式，它们将具有定义该数据集的属性的属性。例如， hive_table 中的 columns 属性。另外，扩展 DataSet 的实体类型的实体参与数据转换，这种转换可以由 Atlas 通过 lineage（或 provenance）生成图形。</p><p>Process：此类型扩展了可引用和资产。在概念上，它可以用于表示任何数据变换操作。例如，将原始数据的 hive 表转换为存储某个聚合的另一个 hive 表的 ETL 过程可以是扩展过程类型的特定类型。流程类型有两个特定的属性，输入和输出。输入和输出都是 DataSet 实体的数组。因此，Process 类型的实例可以使用这些输入和输出来捕获 DataSet 的 lineage 如何演变。</p><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>Atlas 支持以下 2 种方式搜索元数据:</p><ul><li>Search using DSL</li><li>Full-text search</li></ul><p><a href="http://atlas.apache.org/Bridge-Hive.html">Hive Atlas Bridge</a></p><h3 id="Hive-Model"><a href="#Hive-Model" class="headerlink" title="Hive Model"></a>Hive Model</h3><p>默认 hive 建模在 org.apache.atlas.hive.model.HiveDataModelGenerator 中可用。 它定义以下类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive_db(ClassType) - super types [Referenceable] - attributes [name, clusterName, description, locationUri, parameters, ownerName, ownerType]</span><br><span class="line">hive_storagedesc(ClassType) - super types [Referenceable] - attributes [cols, location, inputFormat, outputFormat, compressed, numBuckets, serdeInfo, bucketCols, sortCols, parameters, storedAsSubDirectories]</span><br><span class="line">hive_column(ClassType) - super types [Referenceable] - attributes [name, type, comment, table]</span><br><span class="line">hive_table(ClassType) - super types [DataSet] - attributes [name, db, owner, createTime, lastAccessTime, comment, retention, sd, partitionKeys, columns, aliases, parameters, viewOriginalText, viewExpandedText, tableType, temporary]</span><br><span class="line">hive_process(ClassType) - super types [Process] - attributes [name, startTime, endTime, userName, operationType, queryText, queryPlan, queryId]</span><br><span class="line">hive_principal_type(EnumType) - values [USER, ROLE, GROUP]</span><br><span class="line">hive_order(StructType) - attributes [col, order]</span><br><span class="line">hive_serde(StructType) - attributes [name, serializationLib, parameters]</span><br></pre></td></tr></table></figure><p>使用唯一的限定名称创建和去重复实体。它们提供命名空间，也可以用于 query／lineage。请注意，dbName，tableName 和 columnName 应为小写。 clusterName 解释如下。</p><ul><li>hive_db - attribute qualifiedName - <dbName>@<clusterName></clusterName></dbName></li><li>hive_table - attribute qualifiedName - <dbName>.<tableName>@<clusterName></clusterName></tableName></dbName></li><li>hive_column - attribute qualifiedName - <dbName>.<tableName>.<columnName>@<clusterName></clusterName></columnName></tableName></dbName></li><li>hive_process - attribute name - <queryString> - 小写的修剪查询字符串</queryString></li></ul><h3 id="导入-Hive-Metadata"><a href="#导入-Hive-Metadata" class="headerlink" title="导入 Hive Metadata"></a>导入 Hive Metadata</h3><p>org.apache.atlas.hive.bridge.HiveMetaStoreBridge 使用 org.apache.atlas.hive.model.HiveDataModelGenerator 中定义的模型将 Hive 元数据导入 Atlas。 import-hive.sh 命令可以用来方便这一点。脚本需要 Hadoop 和 Hive 类路径 jar。 对于 Hadoop jar，请确保环境变量 HADOOP_CLASSPATH 已设置。另一种方法是将 HADOOP_HOME 设置为指向 Hadoop 安装的根目录同样，对于 Hive jar，将 HIVE_HOME 设置为 Hive 安装的根目录将环境变量 HIVE_CONF_DIR 设置为 Hive 配置目录复制 ${atlas-conf}/atlas-application.properties 到 hive conf 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: &lt;atlas package&gt;/hook-bin/import-hive.sh</span><br></pre></td></tr></table></figure><p>日志位于 ${atlas package}/logs/import-hive.log</p><p>如果要在 kerberized 集群中导入元数据，则需要运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;atlas package&gt;/hook-bin/import-hive.sh -Dsun.security.jgss.debug=true -Djavax.security.auth.useSubjectCredsOnly=false -Djava.security.krb5.conf=[krb5.conf location] -Djava.security.auth.login.config=[jaas.conf location]</span><br></pre></td></tr></table></figure><ul><li>krb5.conf is typically found at /etc/krb5.conf</li><li>for details about jaas.conf and a suggested location see the <a href="http://atlas.apache.org/Security.html">atlas security documentation</a></li></ul><h3 id="Hive-Hook"><a href="#Hive-Hook" class="headerlink" title="Hive Hook"></a>Hive Hook</h3><p>Hive 在使用 hive hook 的 hive 命令执行上支持侦听器。 这用于在 Atlas 中使用 org.apache.atlas.hive.model.HiveDataModelGenerator 中定义的模型添加/更新/删除实体。 hive hook 将请求提交给线程池执行器，以避免阻塞命令执行。 线程将实体作为消息提交给通知服务器，并且服务器读取这些消息并注册实体。 按照 hive 设置中的这些说明为 Atlas 添加 hive hook ：</p><ul><li>Set-up atlas hook in hive-site.xml of your hive configuration:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.exec.post.hooks&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.atlas.hive.hook.HiveHook&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;atlas.cluster.name&lt;/name&gt;</span><br><span class="line">&lt;value&gt;primary&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><ul><li>Add ‘export HIVE_AUX_JARS_PATH=<atlas package>/hook/hive’ in hive-env.sh of your hive configuration</atlas></li><li>Copy <atlas-conf>/atlas-application.properties to the hive conf directory.</atlas-conf></li></ul><p>在<atlas-conf> /atlas-application.properties中的以下属性控制线程池和通知详细信息：</atlas-conf></p><ul><li>atlas.hook.hive.synchronous - boolean，true来同步运行钩子。 默认false。 建议设置为false，以避免 hive 查询完成中的延迟。</li><li>atlas.hook.hive.numRetries - 通知失败的重试次数。 默认值 3</li><li>atlas.hook.hive.minThreads - 核心线程数。 默认值 5</li><li>atlas.hook.hive.maxThreads - 最大线程数。 默认值 5</li><li>atlas.hook.hive.keepAliveTime - 保持活动时间以毫秒为单位。 默认 10</li><li>atlas.hook.hive.queueSize - 线程池的队列大小。 默认 10000</li></ul><p>参考 <a href="http://atlas.apache.org/Configuration.html">Configuration</a> 通知相关配置</p><h3 id="Column-Level-Lineage"><a href="#Column-Level-Lineage" class="headerlink" title="Column Level Lineage"></a>Column Level Lineage</h3><p>从 atlas-0.8-incubating 版本开始，在 Atlas 中捕获列 lineage</p><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><ul><li>ColumnLineageProcess 类型是 Process 的子类</li><li>这将输出列与一组输入列或输入表相关联</li><li>Lineage 还捕获 Dependency 的类型：当前的值是 SIMPLE，EXPRESSION，SCRIPT<ul><li>SIMPLE依赖： 意味着输出列具有与输入相同的值</li><li>EXPRESSION依赖： 意味着输出列被输入列上的运行时中的一些表达式（例如Hive SQL表达式）转换。</li><li>SCRIPT依赖： 表示输出列由用户提供的脚本转换。</li></ul></li><li>在 EXPRESSION 依赖的情况下，表达式属性包含字符串形式的表达式</li><li>由于 Process 链接输入和输出 DataSet，我们使 Column 成为 DataSet 的子类</li></ul><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p>对于下面的简单 CTAS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t2 as select id, name from T1</span><br></pre></td></tr></table></figure><p>lineage 为</p><p><img src="/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/1253350-20180509182917037-667288476.jpg" alt="img"></p><h4 id="Extracting-Lineage-from-Hive-commands"><a href="#Extracting-Lineage-from-Hive-commands" class="headerlink" title="Extracting Lineage from Hive commands"></a>Extracting Lineage from Hive commands</h4><ul><li>HiveHook 将 HookContext 中的 LineageInfo 映射到 Column lineage 实例</li><li>Hive 中的 LineageInfo 为最终的 FileSinkOperator 提供 Column lineage ，将它们链接到 Hive 查询中的输入列</li></ul><h4 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h4><p>在将 <a href="https://issues.apache.org/jira/browse/HIVE-13112">HIVE-13112</a> 的补丁应用于 Hive 源之后，列级别 lineage 与 Hive 版本1.2.1配合使用</p><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><ul><li>由于数据库名，表名和列名在 hive 中不区分大小写，因此实体中的对应名称为小写。 因此，任何搜索 API 都应该在查询实体名称时使用小写</li><li>以下 hive 操作由 hive hook 当前捕获<ul><li>create database</li><li>create table/view, create table as select</li><li>load, import, export</li><li>DMLs (insert)</li><li>alter database</li><li>alter table (skewed table information, stored as, protection is not supported)</li><li>alter view</li></ul></li></ul><h2 id="Sqoop-Atlas-Bridge"><a href="#Sqoop-Atlas-Bridge" class="headerlink" title="Sqoop Atlas Bridge"></a>Sqoop Atlas Bridge</h2><h3 id="Sqoop-Model"><a href="#Sqoop-Model" class="headerlink" title="Sqoop Model"></a>Sqoop Model</h3><p>默认的 Sqoop 建模在 org.apache.atlas.sqoop.model.SqoopDataModelGenerator 中可用。 它定义以下类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqoop_operation_type(EnumType) - values [IMPORT, EXPORT, EVAL]</span><br><span class="line">  sqoop_dbstore_usage(EnumType) - values [TABLE, QUERY, PROCEDURE, OTHER]</span><br><span class="line">  sqoop_process(ClassType) - super types [Process] - attributes [name, operation, dbStore, hiveTable, commandlineOpts, startTime, endTime, userName]</span><br><span class="line">  sqoop_dbdatastore(ClassType) - super types [DataSet] - attributes [name, dbStoreType, storeUse, storeUri, source, description, ownerName]</span><br></pre></td></tr></table></figure><p>使用唯一的限定名称创建和去重复实体。 它们提供命名空间，也可以用于查询：sqoop_process - attribute name - sqoop-dbStoreType-storeUri-endTime sqoop_dbdatastore - attribute name - dbStoreType-connectorUrl-source</p><h3 id="Sqoop-Hook"><a href="#Sqoop-Hook" class="headerlink" title="Sqoop Hook"></a>Sqoop Hook</h3><p>Sqoop 添加了一个 SqoopJobDataPublisher，在完成导入作业后将数据发布到 Atlas。 现在 sqoopHook 只支持hiveImport。 这用于使用 org.apache.atlas.sqoop.model.SqoopDataModelGenerator 中定义的模型在 Atlas 中添加实体。 按照 sqoop 设置中的以下说明在 ${sqoop-conf}/sqoop-site.xml 中为 Atlas 添加 sqoop 钩子：</p><ul><li>Sqoop Job publisher class. Currently only one publishing class is supported</li></ul><p>sqoop.job.data.publish.class org.apache.atlas.sqoop.hook.SqoopHook</p><ul><li>Atlas cluster name</li></ul><p>atlas.cluster.name</p><ul><li>复制 ${atlas-conf}/atlas-application.properties 到 sqoop 的配置文件夹 ${sqoop-conf}/</li><li>Link ${atlas-home}/hook/sqoop/*.jar in sqoop libRefer <a href="http://atlas.apache.org/Configuration.html">Configuration</a> for notification related configurations</li></ul><h3 id="Limitations-1"><a href="#Limitations-1" class="headerlink" title="Limitations"></a>Limitations</h3><ul><li>目前 sqoop hook 只支持 hiveImport 这一种 sqoop 操作</li></ul><h2 id="Falcon-Atlas-Bridge"><a href="#Falcon-Atlas-Bridge" class="headerlink" title="Falcon Atlas Bridge"></a>Falcon Atlas Bridge</h2><h3 id="Falcon-Model"><a href="#Falcon-Model" class="headerlink" title="Falcon Model"></a>Falcon Model</h3><p>默认的falcon建模在 org.apache.atlas.falcon.model.FalconDataModelGenerator. 它可以定义以下类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">falcon_cluster(ClassType) - super types [Infrastructure] - attributes [timestamp, colo, owner, tags]</span><br><span class="line">falcon_feed(ClassType) - super types [DataSet] - attributes [timestamp, stored-in, owner, groups, tags]</span><br><span class="line">falcon_feed_creation(ClassType) - super types [Process] - attributes [timestamp, stored-in, owner]</span><br><span class="line">falcon_feed_replication(ClassType) - super types [Process] - attributes [timestamp, owner]</span><br><span class="line">falcon_process(ClassType) - super types [Process] - attributes [timestamp, runs-on, owner, tags, pipelines, workflow-properties]</span><br></pre></td></tr></table></figure><p>为 falcon 进程定义的每个集群创建一个 falcon_process 实体。</p><p>使用唯一的 qualifiedName 属性创建和去重复实体。 它们提供命名空间，也可以用于查询/沿袭。 唯一的属性是：</p><ul><li>falcon_process - <process name>@<cluster name></cluster></process></li><li>falcon_cluster - <cluster name></cluster></li><li>falcon_feed - <feed name>@<cluster name></cluster></feed></li><li>falcon_feed_creation - <feed name></feed></li><li>falcon_feed_replication - <feed name></feed></li></ul><h3 id="Falcon-Hook"><a href="#Falcon-Hook" class="headerlink" title="Falcon Hook"></a>Falcon Hook</h3><p>Falcon 支持在 falcon 实体提交上的侦听器。 这用于在 Atlas 中使用 org.apache.atlas.falcon.model.FalconDataModelGenerator 中定义的模型添加实体。 hook 将请求提交给线程池执行器，以避免阻塞命令执行。 线程将实体作为消息提交给通知服务器，并且服务器读取这些消息并注册实体。</p><ul><li>Add ‘org.apache.atlas.falcon.service.AtlasService’ to application.services in ${falcon-conf}/startup.properties</li><li>Link falcon hook jars in falcon classpath - ‘ln -s atlas−home/hook/falcon/∗{falcon-home}/server/webapp/falcon/WEB-INF/lib/‘</li><li>In ${falcon_conf}/falcon-env.sh, set an environment variable as follows:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FALCON_SERVER_OPTS=&quot;&lt;atlas_home&gt;/hook/falcon/*:$FALCON_SERVER_OPTS&quot;</span><br></pre></td></tr></table></figure><p>The following properties in ${atlas-conf}/atlas-application.properties control the thread pool and notification details:</p><ul><li>atlas.hook.falcon.synchronous - boolean, true to run the hook synchronously. default false</li><li>atlas.hook.falcon.numRetries - number of retries for notification failure. default 3</li><li>atlas.hook.falcon.minThreads - core number of threads. default 5</li><li>atlas.hook.falcon.maxThreads - maximum number of threads. default 5</li><li>atlas.hook.falcon.keepAliveTime - keep alive time in msecs. default 10</li><li>atlas.hook.falcon.queueSize - queue size for the threadpool. default 10000</li></ul><p>Refer <a href="http://atlas.apache.org/Configuration.html">Configuration</a> for notification related configurations</p><h3 id="Limitations-2"><a href="#Limitations-2" class="headerlink" title="Limitations"></a>Limitations</h3><ul><li>在 falcon 集群实体中，使用的集群名称应该跨诸如 hive，falcon，sqoop 等组件是统一的。如果与 ambari 一起使用，则应该使用 ambari 集群名称用于集群实体</li></ul><h2 id="Storm-Atlas-Bridge"><a href="#Storm-Atlas-Bridge" class="headerlink" title="Storm Atlas Bridge"></a>Storm Atlas Bridge</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Apache Storm 是一个分布式实时计算系统。 Storm 使得容易可靠地处理无界的数据流，为实时处理 Hadoop 对批处理所做的工作。 该过程实质上是节点的 DAG，其被称为 topology。</p><p>Apache Atlas 是一个元数据存储库，支持端到端数据沿袭，搜索和关联业务分类。</p><p>这种集成的目的是推动操作 topology 元数据以及基础数据源，目标，推导过程和任何可用的业务上下文，以便 Atlas 可以捕获此 topology 的 lineage。</p><p>在此过程中有2个部分详述如下：</p><ul><li>Data model to represent the concepts in Storm</li><li>Storm Atlas Hook to update metadata in Atlas</li></ul><h3 id="Storm-Data-Model"><a href="#Storm-Data-Model" class="headerlink" title="Storm Data Model"></a>Storm Data Model</h3><p>数据模型在 Atlas 中表示为 Types。 它包含 topology 图中各种节点的描述，例如 spouts 和 bolts 以及相应的生产者和消费者类型。</p><p>在Atlas中添加以下类型。</p><ul><li>storm_topology - 表示粗粒度拓扑。storm_topology 来自于 Atlas 过程类型，因此可用于通知 Atlas 关于 lineage。</li><li>添加以下数据集 - kafka_topic，jms_topic，hbase_table，hdfs_data_set。 这些都来自Atlas Dataset类型，因此形成谱系图的端点。</li><li>storm_spout - 具有输出的数据生产者，通常为Kafka，JMS</li><li>storm_bolt - 具有输入和输出的数据使用者，通常为Hive，HBase，HDFS等。</li></ul><p>Storm Atlas hook自动注册依赖模型，如Hive数据模型，如果它发现这些是不为Atlas服务器所知。</p><p>每个类型的数据模型在类定义org.apache.atlas.storm.model.StormDataModel中描述。</p><h3 id="Storm-Atlas-Hook"><a href="#Storm-Atlas-Hook" class="headerlink" title="Storm Atlas Hook"></a>Storm Atlas Hook</h3><p>当在 Storm 中成功注册新 topology 时，通知 Atlas。 Storm 在 Storm 客户端提供了一个钩子，backtype.storm.ISubmitterHook，用于提交一个 Storm topology。</p><p>Storm Atlas hook 拦截 hook 后执行，并从 topology 中提取元数据，并使用定义的类型更新 Atlas。 Atlas 在org.apache.atlas.storm.hook.StormAtlasHook 中实现了 Storm 客户端 hook 接口。</p><h3 id="Limitations-3"><a href="#Limitations-3" class="headerlink" title="Limitations"></a>Limitations</h3><p>以下内容适用于集成的第一个版本。</p><ul><li>只有新的 topology 提交已注册到 Atlas，任何生命周期变化都不会反映在 Atlas 中。</li><li>当为要捕获的元数据提交 Storm topology 时，Atlas 服务器需要在线。</li><li>hook 目前不支持捕获自定义 spouts 和 bolts 的 lineage。</li></ul><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>Storm Atlas Hook 需要在客户端手动安装在 Storm 在：$ATLAS_PACKAGE/hook/storm</p><p>Storm Atlas Hook 需要复制到 $STORM_HOME/extlib。 使用 storm 安装路径替换 STORM_HOME。</p><p>在将安装了 atlas hook 到 Storm 后重新启动所有守护进程。</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><h4 id="Storm-Configuration"><a href="#Storm-Configuration" class="headerlink" title="Storm Configuration"></a>Storm Configuration</h4><p>Storm Atlas Hook 需要在 Storm 客户端 $STORM_HOME/conf/storm.yaml 进行配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm.topology.submission.notifier.plugin.class: &quot;org.apache.atlas.storm.hook.StormAtlasHook&quot;</span><br></pre></td></tr></table></figure><p>还设置一个 “集群名称”，将用作在 Atlas 中注册的对象的命名空间。 此名称将用于命名 Storm topology，spouts 和 bolts。</p><p>其他对象（如 Dataset）应该理想地用生成它们的组件的集群名称来标识。 例如， Hive 表和数据库应该使用在 Hive 中设置的集群名称来标识。 如果 Hive 配置在客户端上提交的 Storm topology jar 中可用，并且在那里定义了集群名称，Storm Atlas hook 将选择此选项。 对于 HBase 数据集，这种情况类似。 如果此配置不可用，将使用在 Storm 配置中设置的集群名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atlas.cluster.name: &quot;cluster_name&quot;</span><br></pre></td></tr></table></figure><p>在 $STORM_HOME/conf/storm_env.ini 中, 设置以下环境变量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STORM_JAR_JVM_OPTS:&quot;-Datlas.conf=$ATLAS_HOME/conf/&quot;</span><br></pre></td></tr></table></figure><p>将 ATLAS_HOME 指向 ATLAS 的安装目录.</p><p>你也可以通过程序对 Storm 进行如下配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Config stormConf = new Config();</span><br><span class="line">  ...</span><br><span class="line">  stormConf.put(Config.STORM_TOPOLOGY_SUBMISSION_NOTIFIER_PLUGIN,</span><br><span class="line">  org.apache.atlas.storm.hook.StormAtlasHook.class.getName());</span><br></pre></td></tr></table></figure><h2 id="容错和高可用"><a href="#容错和高可用" class="headerlink" title="容错和高可用"></a>容错和高可用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Apache Atlas 使用各种系统并与其交互，为数据管理员提供元数据管理和数据 lineage。 通过适当地选择和配置这些依赖关系，可以使用 Atlas 实现高度的服务可用性。 本文档介绍了 Atlas 的高可用性支持状态，包括其功能和当前限制，以及实现此级别高可用性所需的配置。</p><h3 id="Atlas-Web-Service"><a href="#Atlas-Web-Service" class="headerlink" title="Atlas Web Service"></a>Atlas Web Service</h3><p>目前，Atlas Web 服务有一个限制，它一次只能有一个活动实例。在早期版本的 Atlas 中，可以配置和保持备份实例。但是，需要手动故障转移才能使此备份实例处于活动状态。</p><p>从这个版本开始，Atlas 将支持带有自动故障转移的 主动/被动 配置中的 Atlas Web 服务的多个实例。这意味着用户可以在不同的物理主机上同时部署和启动 Atlas Web 服务的多个实例。其中一个实例将被自动选择为 “活动” 实例来为用户请求提供服务。其他人将自动被视为 “被动”。如果 “活动” 实例由于故意停止或由于意外故障而变得不可用，则其他实例之一将自动选为 “活动” 实例，并开始为用户请求提供服务。</p><p>“活动” 实例是能够正确响应用户请求的唯一实例。它可以创建，删除，修改或响应元数据对象上的查询。 “被动” 实例将接受用户请求，但会使用 HTTP 重定向将其重定向到当前已知的 “活动” 实例。具体来说，被动实例本身不会响应对元数据对象的任何查询。但是，所有实例（包括主动和被动）都将响应返回有关该实例的信息的管理请求。</p><p>当配置为高可用性模式时，用户可以获得以下操作优势：</p><ul><li>在维护间隔期间不间断服务：如果需要停用 Atlas Web 服务的活动实例进行维护，则另一个实例将自动变为活动状态并可以为请求提供服务。</li><li>在意外故障事件中的不间断服务：如果由于软件或硬件错误，Atlas Web 服务的活动实例失败，另一个实例将自动变为活动状态并可以为请求提供服务。</li></ul><p>在以下小节中，我们将介绍为 Atlas Web 服务设置高可用性所需的步骤。 我们还描述了如何设计部署和客户端以利用此功能。 最后，我们描述一些底层实现的细节。</p><h4 id="Setting-up-the-High-Availability-feature-in-Atlas"><a href="#Setting-up-the-High-Availability-feature-in-Atlas" class="headerlink" title="Setting up the High Availability feature in Atlas"></a>Setting up the High Availability feature in Atlas</h4><p>设置高可用性功能必须满足以下先决条件。</p><ul><li>确保在一组计算机上安装 Apache Zookeeper（建议至少使用3台服务器进行生产）。</li><li>选择 2 个或更多物理机以在其上运行 Atlas Web Service 实例。这些机器定义了我们称为 Atlas 的 “服务器集合”。</li></ul><p>要在 Atlas 中设置高可用性，必须在 atlas-application.properties 文件中定义一些配置选项。虽然配置项的完整列表在配置页中定义，但本节列出了几个主要选项。</p><ul><li><p>高可用性是 Atlas 的可选功能。因此，必须通过将配置选项 atlas.server.ha.enabled 设置为 true 来启用。</p></li><li><p>接下来，定义标识符列表，为您为 Atlas Web Service 实例选择的每个物理机器分配一个标识符。这些标识符可以是简单的字符串，如id1，id2等。它们应该是唯一的，不应包含逗号。</p></li><li><p>将这些标识符的逗号分隔列表定义为选项 atlas.server.ids 的值。</p></li><li><p>对于每个物理机，请列出IP地址/主机名和端口作为配置 atlas.server.address.id 的值，其中 id 指的是此物理机的标识符字符串。</p><ul><li><p>例如，如果您选择了 2 台主机名为 和 的计算机，则可以如下定义配置选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atlas.server.ids=id1,id2</span><br><span class="line">atlas.server.address.id1=host1.company.com:21000</span><br><span class="line">atlas.server.address.id2=host2.company.com:21000</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义使用的 Zookeeper 为 Atlas 提供高可用性功能</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atlas.server.ha.zookeeper.connect=zk1.company.com:2181,zk2.company.com:2181,zk3.company.com:2181</span><br></pre></td></tr></table></figure><ul><li>您可以查看为高可用性功能定义的其他配置选项，并根据需要在 atlas-application.properties 文件中进行设置。</li><li>对于生产环境，Atlas 所依赖的组件也必须在高可用性模式下设置。 这将在以下部分中详细描述。 按照这些说明设置和配置它们。</li><li>在选定的物理机器上安装 Atlas 软件。</li><li>将使用上述步骤创建的 atlas-application.properties 文件复制到所有计算机的配置目录。</li><li>启动相关组件。</li><li>启动 Atlas Web 服务的每个实例。</li></ul><p>要验证高可用性是否正常工作，请在安装了 Atlas Web Service 的每个实例上运行以下脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ATLAS_HOME/bin/atlas_admin.py -status</span><br></pre></td></tr></table></figure><p>此脚本可以打印以下值之一作为响应：</p><ul><li>ACTIVE：此实例处于活动状态，可以响应用户请求。</li><li>PASSIVE：此实例为 PASSIVE。它会将它收到的任何用户请求重定向到当前活动实例。</li><li>BECOMING_ACTIVE：如果服务器正在转换为 ACTIVE 实例，则将打印此消息。在此状态下，服务器无法处理任何元数据用户请求。</li><li>BECOMING_PASSIVE：如果服务器正在转换为 PASSIVE 实例，则将打印此消息。在此状态下，服务器无法处理任何元数据用户请求。</li></ul><p>在正常操作情况下，只有其中一个实例应该打印 ACTIVE 值作为对脚本的响应，而其他实例将打印 PASSIVE。</p><h4 id="配置客户端以使用高可用性功能"><a href="#配置客户端以使用高可用性功能" class="headerlink" title="配置客户端以使用高可用性功能"></a>配置客户端以使用高可用性功能</h4><p>Atlas Web 服务可以通过两种方式访问：</p><ul><li>使用 Atlas Web UI：这是一个基于浏览器的客户端，可用于查询存储在Atlas中的元数据。</li><li>使用 Atlas REST API：由于 Atlas 公开了一个 RESTful API，因此可以使用任何标准的 REST 客户端，包括其他应用程序中的库。事实上，Atlas 附带了一个名为 AtlasClient 的客户端，可以用作创建 REST 客户端访问的示例。</li></ul><p>为了利用客户端中的高可用性功能，可以有两个选项。</p><h4 id="使用中间代理"><a href="#使用中间代理" class="headerlink" title="使用中间代理"></a>使用中间代理</h4><p>启用高可用性访问 Atlas 的最简单的解决方案是安装和配置一些中间代理，其具有基于状态透明地切换服务的能力。一个这样的代理解决方案是 HAProxy。</p><p>下面是一个可以使用的 HAProxy 配置示例。注意，这只是为了说明，而不是作为推荐的生产配置。为此，请参阅 HAProxy文档以获取相应的说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frontend atlas_fe</span><br><span class="line">  bind *:41000</span><br><span class="line">  default_backend atlas_be</span><br><span class="line"></span><br><span class="line">backend atlas_be</span><br><span class="line">  mode http</span><br><span class="line">  option httpchk get /api/atlas/admin/status</span><br><span class="line">  http-check expect string ACTIVE</span><br><span class="line">  balance roundrobin</span><br><span class="line">  server host1_21000 host1:21000 check</span><br><span class="line">  server host2_21000 host2:21000 check backup</span><br><span class="line"></span><br><span class="line">listen atlas</span><br><span class="line">  bind localhost:42000</span><br></pre></td></tr></table></figure><p>以上配置绑定 HAProxy 侦听端口 41000 传入客户端连接。然后根据 HTTP 状态检查将连接路由到主机 host1 或 host2 中的任一个。状态检查是使用 REST URL / api / atlas / admin / status 上的 HTTP GET 完成的，只有当 HTTP 响应包含字符串ACTIVE 时，才认为成功。</p><h4 id="使用活动实例的自动检测"><a href="#使用活动实例的自动检测" class="headerlink" title="使用活动实例的自动检测"></a>使用活动实例的自动检测</h4><p>如果不想设置和管理单独的代理，则使用高可用性功能的另一个选项是构建能够检测状态和重试操作的客户端应用程序。在这样的设置中，可以使用形成集合的所有 Atlas Web 服务实例的 URL 启动客户端应用程序。然后，客户端应调用其中每一个上的 REST URL / api / atlas / admin / status，以确定哪个是活动实例。来自 Active 实例的响应将具有 {Status：ACTIVE}的形式。此外，当客户端在操作过程中遇到任何异常时，它应该再次确定哪些剩余的URL是活动的并重试该操作。</p><p>Atlas 附带的 AtlasClient 类可以用作一个示例客户端库，它实现了使用集合并选择正确的Active服务器实例的逻辑。</p><p>Atlas 中的实用程序（如quick_start.py和import-hive.sh）可以配置为使用多个服务器URL运行。当在此模式下启动时，AtlasClient 自动选择并使用当前活动实例。如果在之间设置了代理，则可以在运行 quick_start.py 或 import-hive.sh 时使用其地址。</p><h4 id="实现-Atlas-高可用"><a href="#实现-Atlas-高可用" class="headerlink" title="实现 Atlas 高可用"></a>实现 Atlas 高可用</h4><p>Atlas 高可用性工作在主 JIRA <a href="https://issues.apache.org/jira/browse/ATLAS-510">ATLAS-510</a> 下进行跟踪。根据其提交的 JIRA 具有关于高可用性功能如何实现的详细信息。在高级别可以调出以下几点：</p><ul><li>活动实例的自动选择以及到新的活动实例的自动故障转移通过领导者选择算法发生。</li><li>对于领导选举，我们使用 Apache Curator 的 Leader Latch Recipe。</li><li>Active 实例是唯一一个在后端存储中初始化，修改或读取状态以保持它们一致的实例。</li><li>此外，当实例被选为活动时，它会刷新后端存储中的任何缓存信息以获取最新信息。</li><li>servlet 过滤器确保只有活动的实例服务用户请求。如果被动实例接收到这些请求，它会自动将它们重定向到当前活动实例。</li></ul><h4 id="Metadata-Store"><a href="#Metadata-Store" class="headerlink" title="Metadata Store"></a>Metadata Store</h4><p>如上所述，Atlas 使用 Titan 来存储它管理的元数据。默认情况下，Atlas 使用独立的 HBase 实例作为 Titan 的后备存储。为了为元数据存储提供 HA，我们建议将 Atlas 配置为使用分布式 HBase 作为 Titan 的后备存储。这意味着您可以从 HBase 提供的 HA 保证中受益。为了将 Atlas 配置为在 HA 模式下使用 HBase，请执行以下操作：</p><ul><li>选择在HA模式中设置的现有 HBase 集群以在 Atlas（OR）中配置在 <a href="http://hbase.apache.org/book.html#quickstart_fully_distributed">HA模式</a> 下设置新的 HBase 集群。<ul><li>如果为 Atlas 设置 HBase，请按照 <a href="http://atlas.apache.org/InstallationSteps.html">Installation Steps</a> 中列出的用于设置 HBase 的说明进行操作。</li></ul></li><li>我们建议在使用 Zookeeper 协调的不同物理主机上的集群中使用多个 HBase 主机（至少2个），以提供 HBase的 冗余和高可用性。<ul><li>有关在 atlas.properties 中配置的选项的 <a href="http://atlas.apache.org/Configuration.html">Configuration page</a> ，请参考配置页面，以便使用 HBase 设置 Atlas。</li></ul></li></ul><h3 id="Index-Store"><a href="#Index-Store" class="headerlink" title="Index Store"></a>Index Store</h3><p>如上所述，Atlas 通过 Titan 索引元数据以支持全文搜索查询。 为了为索引存储提供 HA，我们建议将 Atlas 配置为使用 Solr作为 Titan 的后备索引存储。 为了将 Atlas 配置为在 HA 模式下使用 Solr，请执行以下操作：</p><ul><li>在 HA 模式下选择现有的 SolrCloud 群集设置以在 Atlas（OR）中配置设置新的 SolrCloud 群集。<ul><li>确保 Solr 在至少 2 个物理主机上启动以实现冗余，并且每个主机运行 Solr 节点。</li><li>我们建议将冗余数设置为至少 2。</li></ul></li><li>创建 Atlas 所需的 SolrCloud 集合，如安装步骤中所述</li><li>请参阅配置页面以了解在 atlas.properties 中配置的选项，以使用 Solr 设置 Atlas。</li></ul><h3 id="Notification-Server"><a href="#Notification-Server" class="headerlink" title="Notification Server"></a>Notification Server</h3><p>来自 Hook 的元数据通知事件通过写入到名为 ATLAS_HOOK 的 Kafka topic 发送到 Atlas 。类似地，从 Atlas 到其他集成组件（如Ranger）的事件写入名为 ATLAS_ENTITIES 的 Kafka topic。由于 Kafka 会保留这些消息，即使消费者在发送事件时失败，事件也不会丢失。此外，我们建议 Kafka 也设置容错，以便它具有更高的可用性保证。为了配置 Atlas 在 HA 模式下使用 Kafka，请执行以下操作：</p><ul><li><p>选择在 HA 模式中设置的现有 Kafka 集群以在 Atlas（OR）中配置设置新的 Kafka 集群。</p></li><li><p>我们建议在不同物理主机上的群集中有多个 Kafka 代理，它们使用 Zookeeper 协调，以提供 Kafka 的冗余和高可用性。</p><ul><li>设置至少 2 个物理主机以实现冗余，每个托管一个 Kafka 代理。</li></ul></li><li><p>为 Atlas 使用设置 Kafka 主题：</p><ul><li>ATLAS 主题的分区数应设置为1（numPartitions）</li><li>确定 Kafka 主题的副本数量：将此值设置为至少 2 以进行冗余。</li><li>运行以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper &lt;list of zookeeper host:port entries&gt; --topic ATLAS_HOOK --replication-factor &lt;numReplicas&gt; --partitions 1</span><br><span class="line">$KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper &lt;list of zookeeper host:port entries&gt; --topic ATLAS_ENTITIES --replication-factor &lt;numReplicas&gt; --partitions 1</span><br><span class="line">Here KAFKA_HOME points to the Kafka installation directory.</span><br></pre></td></tr></table></figure><ul><li>在 atlas-application.properties 中进行如下配置:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atlas.notification.embedded=false</span><br><span class="line">atlas.kafka.zookeeper.connect=&lt;comma separated list of servers forming Zookeeper quorum used by Kafka&gt;</span><br><span class="line">atlas.kafka.bootstrap.servers=&lt;comma separated list of Kafka broker endpoints in host:port form&gt; - Give at least 2 for redundancy.</span><br></pre></td></tr></table></figure></li></ul><h3 id="Known-Issues"><a href="#Known-Issues" class="headerlink" title="Known Issues"></a>Known Issues</h3><ul><li>如果托管 Atlas ‘titan’ HTable 的 HBase region servers 停机，Atlas 将无法在 HBase 恢复联机之前从 HBase 存储或检索元数据。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-Apache-Atlas-进行数据治理&quot;&gt;&lt;a href=&quot;#使用-Apache-Atlas-进行数据治理&quot; class=&quot;headerlink&quot; title=&quot;使用 Apache Atlas 进行数据治理&quot;&gt;&lt;/a&gt;使用 Apache Atlas 进行数据</summary>
      
    
    
    
    <category term="hadoop" scheme="http://rczmm.github.io/categories/hadoop/"/>
    
    
    <category term="-hadoop -转载" scheme="http://rczmm.github.io/tags/hadoop-%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>js对象高级</title>
    <link href="http://rczmm.github.io/2021/09/12/js%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <id>http://rczmm.github.io/2021/09/12/js%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</id>
    <published>2021-09-12T02:21:04.000Z</published>
    <updated>2021-09-12T02:21:44.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><ul><li><p>Object构造函数模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.name = &#x27;Tom&#x27;</span><br><span class="line">obj.setName = function(name)&#123;this.name=name&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象字面量模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name : &#x27;Tom&#x27;,</span><br><span class="line">  setName : function(name)&#123;this.name = name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Person(&#x27;tom&#x27;, 12);</span><br></pre></td></tr></table></figure></li><li><p>构造函数+原型的组合模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">new Person(&#x27;tom&#x27;, 12);</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><ul><li><p>原型链继承 : 得到方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line">function Child()&#123;&#125;</span><br><span class="line">Child.prototype = new Parent(); // 子类型的原型指向父类型实例</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line">var child = new Child(); //有test()</span><br></pre></td></tr></table></figure></li><li><p>借用构造函数 : 得到属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">var child = new Child(&#x27;a&#x27;, &#x27;b&#x27;);  //child.xxx为&#x27;a&#x27;, 但child没有test()</span><br></pre></td></tr></table></figure></li><li><p>组合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent(); //得到test()</span><br><span class="line">var child = new Child(); //child.xxx为&#x27;a&#x27;, 也有test()</span><br></pre></td></tr></table></figure></li><li><p>new一个对象背后做了些什么?</p><ul><li>创建一个空对象</li><li>给对象设置__proto__, 值为构造函数对象的prototype属性值   this.<strong>proto</strong> = Fn.prototype</li><li>执行构造函数体(给对象添加属性/方法)</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象的创建模式&quot;&gt;&lt;a href=&quot;#对象的创建模式&quot; class=&quot;headerlink&quot; title=&quot;对象的创建模式&quot;&gt;&lt;/a&gt;对象的创建模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Object构造函数模式&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    <category term="html" scheme="http://rczmm.github.io/categories/html/"/>
    
    
    <category term="html" scheme="http://rczmm.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>js函数高级</title>
    <link href="http://rczmm.github.io/2021/09/12/js%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/"/>
    <id>http://rczmm.github.io/2021/09/12/js%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/</id>
    <published>2021-09-12T02:20:15.000Z</published>
    <updated>2021-09-12T02:20:50.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><ul><li>所有函数都有一个特别的属性:<ul><li><code>prototype</code> : 显式原型属性</li></ul></li><li>所有实例对象都有一个特别的属性:<ul><li><code>__proto__</code> : 隐式原型属性</li></ul></li><li>显式原型与隐式原型的关系<ul><li>函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象</li><li>实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li><li>原型对象即为当前实例对象的父对象</li></ul></li><li>原型链<ul><li>所有的实例对象都有__proto__属性, 它指向的就是原型对象</li><li>这样通过__proto__属性就形成了一个链的结构—-&gt;原型链</li><li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li><li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</li></ul></li></ul><h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><ul><li>变量提升与函数提升<ul><li>变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)</li><li>函数提升: 在函数定义语句之前, 就执行该函数</li><li>先有变量提升, 再有函数提升</li></ul></li><li>理解<ul><li>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性</li><li>执行上下文栈: 用来管理产生的多个执行上下文</li></ul></li><li>分类:<ul><li>全局: window</li><li>函数: 对程序员来说是透明的</li></ul></li><li>生命周期<ul><li>全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡</li><li>函数 : 调用函数时产生, 函数执行完时死亡</li></ul></li><li>包含哪些属性:<ul><li>全局 : <ul><li>用var定义的全局变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt;window</li></ul></li><li>函数<ul><li>用var定义的局部变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt; 调用函数的对象, 如果没有指定就是window </li><li>形参变量   ===&gt;对应实参值</li><li>arguments ===&gt;实参列表的伪数组</li></ul></li></ul></li><li>执行上下文创建和初始化的过程<ul><li>全局:<ul><li>在全局代码执行前最先创建一个全局执行上下文(window)</li><li>收集一些全局变量, 并初始化</li><li>将这些变量设置为window的属性</li></ul></li><li>函数:<ul><li>在调用函数时, 在执行函数体之前先创建一个函数执行上下文</li><li>收集一些局部变量, 并初始化</li><li>将这些变量设置为执行上下文的属性</li></ul></li></ul></li></ul><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><ul><li>理解:<ul><li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li><li>作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量</li></ul></li><li>分类:<ul><li>全局</li><li>函数</li><li>js没有块作用域(在ES6之前)</li></ul></li><li>作用<ul><li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li><li>作用域链: 查找变量</li></ul></li><li>区别作用域与执行上下文<ul><li>作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了</li><li>执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失</li><li>联系: 执行上下文环境是在对应的作用域中的</li></ul></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li><p>理解:</p><ul><li>当嵌套的内部函数引用了外部函数的变量时就产生了闭包</li><li>通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性</li></ul></li><li><p>作用:</p><ul><li>延长局部变量的生命周期</li><li>让函数外部能操作内部的局部变量</li></ul></li><li><p>写一个闭包程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  function fn2() &#123;</span><br><span class="line">    a++;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  return fn2;</span><br><span class="line">&#125;</span><br><span class="line">var f = fn1();</span><br><span class="line">f();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></li><li><p>闭包应用:</p><ul><li>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为</li><li>循环遍历加监听</li><li>JS框架(jQuery)大量使用了闭包</li></ul></li><li><p>缺点:</p><ul><li>变量占用内存的时间可能会过长</li><li>可能导致内存泄露</li><li>解决:<ul><li>及时释放 : f = null; //让内部函数对象成为垃圾对象</li></ul></li></ul></li></ul><h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><ol><li>内存溢出</li></ol><ul><li>一种程序运行出现的错误</li><li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li></ul><ol start="2"><li>内存泄露</li></ol><ul><li>占用的内存没有及时释放</li><li>内存泄露积累多了就容易导致内存溢出</li><li>常见的内存泄露:<ul><li>意外的全局变量</li><li>没有及时清理的计时器或回调函数</li><li>闭包</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原型与原型链&quot;&gt;&lt;a href=&quot;#原型与原型链&quot; class=&quot;headerlink&quot; title=&quot;原型与原型链&quot;&gt;&lt;/a&gt;原型与原型链&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;所有函数都有一个特别的属性:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt; : </summary>
      
    
    
    
    <category term="html" scheme="http://rczmm.github.io/categories/html/"/>
    
    
    <category term="html" scheme="http://rczmm.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>js基础总结深入</title>
    <link href="http://rczmm.github.io/2021/09/12/js%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E6%B7%B1%E5%85%A5/"/>
    <id>http://rczmm.github.io/2021/09/12/js%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E6%B7%B1%E5%85%A5/</id>
    <published>2021-09-12T02:20:15.000Z</published>
    <updated>2021-09-12T02:41:56.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型的分类和判断"><a href="#数据类型的分类和判断" class="headerlink" title="数据类型的分类和判断"></a>数据类型的分类和判断</h2><ul><li>基本(值)类型<ul><li>Number —– 任意数值 ——– typeof</li><li>String —– 任意字符串 —— typeof</li><li>Boolean —- true/false —– typeof</li><li>undefined — undefined —– typeof/===</li><li>null ——– null ———- ===</li></ul></li><li>对象(引用)类型<ul><li>Object —– typeof/instanceof</li><li>Array —— instanceof</li><li>Function —- typeof</li></ul></li></ul><h2 id="数据-变量-内存的理解"><a href="#数据-变量-内存的理解" class="headerlink" title="数据,变量, 内存的理解"></a>数据,变量, 内存的理解</h2><ul><li>什么是数据?<ul><li>在内存中可读的, 可传递的保存了特定信息的’东东’</li><li>一切皆数据, 函数也是数据</li><li>在内存中的所有操作的目标: 数据</li></ul></li><li>什么是变量?<ul><li>在程序运行过程中它的值是允许改变的量</li><li>一个变量对应一块小内存, 它的值保存在此内存中  </li></ul></li><li>什么是内存?<ul><li>内存条通电后产生的存储空间(临时的)</li><li>一块内存包含2个方面的数据<ul><li>内部存储的数据</li><li>地址值数据</li></ul></li><li>内存空间的分类<ul><li>栈空间: 全局变量和局部变量</li><li>堆空间: 对象 </li></ul></li></ul></li><li>内存,数据, 变量三者之间的关系<ul><li>内存是容器, 用来存储不同数据</li><li>变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  </li></ul></li></ul><h2 id="对象的理解和使用"><a href="#对象的理解和使用" class="headerlink" title="对象的理解和使用"></a>对象的理解和使用</h2><ul><li><p>什么是对象?</p><ul><li>多个数据(属性)的集合</li><li>用来保存多个数据(属性)的容器</li></ul></li><li><p>属性组成:</p><ul><li>属性名 : 字符串(标识)</li><li>属性值 : 任意类型</li></ul></li><li><p>属性的分类:</p><ul><li>一般 : 属性值不是function  描述对象的状态</li><li>方法 : 属性值为function的属性  描述对象的行为</li></ul></li><li><p>特别的对象</p><ul><li>数组: 属性名是0,1,2,3之类的索引</li><li>函数: 可以执行的</li></ul></li><li><p>如何操作内部属性(方法)</p><ul><li><p>.属性名</p></li><li><p>[‘属性名’]: 属性名有特殊字符/属性名是一个变量</p></li></ul></li></ul><h2 id="函数的理解和使用"><a href="#函数的理解和使用" class="headerlink" title="函数的理解和使用"></a>函数的理解和使用</h2><ul><li><p>什么是函数?</p><ul><li>用来实现特定功能的, n条语句的封装体</li><li>只有函数类型的数据是可以执行的, 其它的都不可以</li></ul></li><li><p>为什么要用函数?</p><ul><li>提高复用性</li><li>便于阅读交流</li></ul></li><li><p>函数也是对象</p><ul><li>instanceof Object===true</li><li>函数有属性: prototype</li><li>函数有方法: call()/apply()</li><li>可以添加新的属性/方法</li></ul></li><li><p>函数的3种不同角色</p><ul><li>一般函数 : 直接调用</li><li>构造函数 : 通过new调用</li><li>对象 : 通过.调用内部的属性/方法</li></ul></li><li><p>函数中的this</p><ul><li>显式指定谁: obj.xxx()</li><li>通过call/apply指定谁调用: xxx.call(obj)</li><li>不指定谁调用: xxx()  : window</li><li>回调函数: 看背后是通过谁来调用的: window/其它</li></ul></li><li><p>匿名函数自调用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(w, obj)&#123;</span><br><span class="line">  //实现代码</span><br><span class="line">&#125;)(window, obj)</span><br></pre></td></tr></table></figure><ul><li>专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式                          </li></ul></li><li><p>回调函数的理解</p><ul><li>什么函数才是回调函数?<ul><li>你定义的</li><li>你没有调用</li><li>但它最终执行了(在一定条件下或某个时刻)</li></ul></li><li>常用的回调函数<ul><li>dom事件回调函数</li><li>定时器回调函数</li><li>ajax请求回调函数</li><li>生命周期回调函数</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据类型的分类和判断&quot;&gt;&lt;a href=&quot;#数据类型的分类和判断&quot; class=&quot;headerlink&quot; title=&quot;数据类型的分类和判断&quot;&gt;&lt;/a&gt;数据类型的分类和判断&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基本(值)类型&lt;ul&gt;
&lt;li&gt;Number —– 任意数值 —</summary>
      
    
    
    
    <category term="html" scheme="http://rczmm.github.io/categories/html/"/>
    
    
    <category term="html" scheme="http://rczmm.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>html学习笔记01</title>
    <link href="http://rczmm.github.io/2021/09/10/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <id>http://rczmm.github.io/2021/09/10/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</id>
    <published>2021-09-10T01:13:27.000Z</published>
    <updated>2021-09-11T03:54:24.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、html"><a href="#1、html" class="headerlink" title="1、html"></a>1、html</h2><p>html作为一门超文本标记语言，包括一系列的标签，它通过这些标签将网络文档结构统一化，通过浏览器进行解析与阅读。</p><p>html文本是由html（htm）为后缀的由html命令组成的描述性文本，通过对标签的使用，可以描述文字，图形，动画，声音，表格，链接等等。</p><h2 id="2、position"><a href="#2、position" class="headerlink" title="2、position"></a>2、position</h2><p>dom position属性。</p><p>position属性把元素放置到一个静态的、相对的、绝对的、固定的的位置中去。</p><p>要理解这个属性，首先应该明白什么是流？</p><p>所谓的文档流，指的其实就是元素排版布局过程中，元素会自动从左到右，从上往下的流式排列。并最终窗体自上而下分成一行行，并在每行中按从左至右的排放元素。</p><p>顺便说一下，除了设置position的属性值为absolute与fixed之外，float对象也会<strong>打乱这个队列</strong>，这些都会暂时脱离流的存在，clear之后才会回到流之中（单指float）。</p><p>（float：right显然会打乱文档流，但是float：left也有这样的效果：其实是因为子元素设置了float属性，然而父元素没有设置（或者保持了默认的static），则子元素会从父元素中溢出，（最明显的表现就是，父元素不会随着子元素的扩大而扩大），因为当元素设置了float这个属性之后，其他没有设置float属性的盒子或者是标签会无视这个属性，也就是其他没有设置浮动的元素会和他进行叠加，这就可以当作脱离了文档流。但是要注意一点的就是，与position：absolute不同的是，其他盒子内的元素依然会为了float元素让出位置，因此不会出现互相叠加的情况。这种情况下消除浮动就可以解决）</p><p>其中，默认得到html流属性其实就是static，默认布局，这种布局，是没有定位的，而且不会继承父元素的属性，w3c的文档里提到，忽略top、bottom、left、right或者z-index声明，他是存在于流里面的。除此之外还有relative，相对布局，假如父元素采用了这种布局，那么子元素就是相对于父元素的绝对定位，一般会配合到top、right、bottom、left来使用，这种布局其实也是存在于流里面的。但是fixed浮动布局，是相对于浏览器窗口的绝对布局（上下滚动页面），一般同样配合上下左右来使用，这个布局是脱离了流的存在的。（！！ie不兼容这种模式！！）</p><p>absolute布局，绝对布局，相对于页面的绝对布局（上下滚动），同样配合四方使用，脱离了流的存在，最后一种我用的比较少，inherit布局，w3c的文档规定他是继承了父元素position的值。</p><p><strong>如果我们想在页面上固定元素，毫无疑问，选择absolute，他是以页面左上角为（0，0），根据tblr来布局的，与fixed不同，f是当前窗口布局，也是左上角为（0，0），但是会根据滚动条一起滚动，相对于当前窗口的位置不变。relative是相对位置，指的是子节点和父节点的关系，当一个子节点在父节点中的时候，默认的position就是relative，在子节点包含在父节点中，这个时候就算我们设置的子节点是absolute，也会成为relative，也就是相对于父节点的左上角排版。</strong></p><p><strong>总结：在html中，永远没有绝对，只有相对。所有元素都是document的子元素。</strong></p><h2 id="3、相对路径与绝对路径"><a href="#3、相对路径与绝对路径" class="headerlink" title="3、相对路径与绝对路径"></a>3、相对路径与绝对路径</h2><p><strong>参照物不同</strong>，导致的差别。</p><p>在计算机中，这是一个避免不了问题，无论是path环境变量还是classpath类加载路径都是源自于这两个路径的差别。他们的差别也很简单，绝对路径以磁盘为参照物，而相对路径则以当前路径为参照。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、html&quot;&gt;&lt;a href=&quot;#1、html&quot; class=&quot;headerlink&quot; title=&quot;1、html&quot;&gt;&lt;/a&gt;1、html&lt;/h2&gt;&lt;p&gt;html作为一门超文本标记语言，包括一系列的标签，它通过这些标签将网络文档结构统一化，通过浏览器进行解析与阅</summary>
      
    
    
    
    <category term="html" scheme="http://rczmm.github.io/categories/html/"/>
    
    
    <category term="html" scheme="http://rczmm.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>numpy</title>
    <link href="http://rczmm.github.io/2021/09/09/numpy/"/>
    <id>http://rczmm.github.io/2021/09/09/numpy/</id>
    <published>2021-09-09T01:26:33.000Z</published>
    <updated>2021-09-17T01:42:30.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="numpy（基础篇）"><a href="#numpy（基础篇）" class="headerlink" title="numpy（基础篇）"></a>numpy（基础篇）</h1><p>numpy是一个python的扩展程序库，支持大量的维度数组和矩阵运算，除此之外还为数组计算提供了大量的科学库，运行速度很快，包含了一个强大的多维数组对象ndarray，广播功能函数，整合了c与c++语言的工具，还有线性代数、随机数生成等功能。</p><h2 id="numpy是什么？"><a href="#numpy是什么？" class="headerlink" title="numpy是什么？"></a>numpy是什么？</h2><p>NumPy是使用Python进行科学计算的基础软件包。除其他外，它包括：</p><ul><li>功能强大的N维数组对象。</li><li>精密广播功能函数。</li><li>集成 C/C+和Fortran 代码的工具。</li><li>强大的线性代数、傅立叶变换和随机数功能。</li></ul><h2 id="numpy两大利器"><a href="#numpy两大利器" class="headerlink" title="numpy两大利器"></a>numpy两大利器</h2><h3 id="利器之一：Ndarray"><a href="#利器之一：Ndarray" class="headerlink" title="利器之一：Ndarray"></a>利器之一：Ndarray</h3><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。ndarray 对象是用于存放同类型元素的多维数组。ndarray 中的每个元素在内存中都有相同存储大小的区域。</p><h3 id="利器之二：切片和索引"><a href="#利器之二：切片和索引" class="headerlink" title="利器之二：切片和索引"></a>利器之二：切片和索引</h3><p>ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。</p><span id="more"></span><h2 id="numpy的主要应用"><a href="#numpy的主要应用" class="headerlink" title="numpy的主要应用"></a>numpy的主要应用</h2><p>NumPy是一个功能强大的Python库，主要用于对多维数组执行计算。NumPy这个词来源于两个单词– <code>Numerical</code>和<code>Python</code>。NumPy提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算。这类数值计算广泛用于以下任务：</p><ul><li><strong>机器学习模型</strong>：在编写机器学习算法时，需要对矩阵进行各种数值计算。例如矩阵乘法、换位、加法等。NumPy提供了一个非常好的库，用于简单(在编写代码方面)和快速(在速度方面)计算。NumPy数组用于存储训练数据和机器学习模型的参数。</li><li><strong>图像处理和计算机图形学</strong>：计算机中的图像表示为多维数字数组。NumPy成为同样情况下最自然的选择。实际上，NumPy提供了一些优秀的库函数来快速处理图像。例如，镜像图像、按特定角度旋转图像等。</li><li><strong>数学任务</strong>：NumPy对于执行各种数学任务非常有用，如数值积分、微分、内插、外推等。因此，当涉及到数学任务时，它形成了一种基于Python的MATLAB的快速替代。</li></ul><h2 id="numpy安装"><a href="#numpy安装" class="headerlink" title="numpy安装"></a>numpy安装</h2><p>值得一提的是，python官网提供的发行版并没有包含numpy库，我们需要单独的下载，其中最简单的就是通过pip安装，安装成功后，可以使用numpy中生成对角矩阵的eye方法来检测是否安装成功。</p><p>在你的计算机上安装NumPy的最快也是最简单的方法是在shell上使用以下命令：<code>pip install numpy</code>。</p><p>这将在你的计算机上安装最新/最稳定的NumPy版本。通过PIP安装是安装任何Python软件包的最简单方法。</p><h2 id="NumPy-Ndarray-对象"><a href="#NumPy-Ndarray-对象" class="headerlink" title="NumPy Ndarray 对象"></a>NumPy Ndarray 对象</h2><p>NumPy提供的最重要的数据结构是一个称为NumPy数组(Ndarray)的强大对象。NumPy数组是通常的Python数组的扩展。NumPy数组配备了大量的函数和运算符，可以帮助我们快速编写上面讨论过的各种类型计算的高性能代码。</p><p>这是numpy中一个重要的特性，他是同一类数据类型的集合，以0为下标开始索引。</p><p>这是一个存放同类对象的多维数组，其中每个元素都有相同的区域储存，ndarray内部由一个指向数据的指针，数据类型，一个描述数组形状的数组，一个跨度元组组成。</p><p><img src="/2021/09/09/numpy/image-20210909093335315.png" alt="mdarray对象内部结构">值得一提的是，跨度可以是负数，这样数组在内存之中就会产生向前移动的效果。</p><p>创建这个对象只需要调用array函数。            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th>object</th><th>数组或者嵌套的数列（也是对象中的基本元素）</th></tr></thead><tbody><tr><td>dtype</td><td>数组中元素的数据类型</td></tr><tr><td>copy</td><td>数组中元素是否可复制</td></tr><tr><td>order</td><td>数组中元素的样式，C为行方向，F为列方向，A为任意方向（默认）</td></tr><tr><td>subok</td><td>返回一个与基本类型一样的数组</td></tr><tr><td>ndmin</td><td>指定生成数组的最小维度</td></tr></tbody></table><p>让我们看看如何快速定义一维NumPy数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">my_array = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) </span><br><span class="line"><span class="built_in">print</span>(my_array)</span><br></pre></td></tr></table></figure><p>在上面的简单示例中，我们首先使用import numpy作为np导入NumPy库。然后，我们创建了一个包含5个整数的简单NumPy数组，然后我们将其打印出来。继续在自己的机器上试一试。在看 “NumPy安装” 部分下面的步骤的时候，请确保已在计算机中安装了NumPy.</p><p>现在让我们看看我们可以用这个特定的NumPy数组能做些什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> my_array.shape</span><br></pre></td></tr></table></figure><p>它会打印我们创建的数组的形状：<code>(5, )</code>。意思就是 my_array 是一个包含5个元素的数组。</p><p>我们也可以打印各个元素。就像普通的Python数组一样，NumPy数组的起始索引编号为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> my_array[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> my_array[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>上述命令将分别在终端上打印1和2。我们还可以修改NumPy数组的元素。例如，假设我们编写以下2个命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_array[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> my_array</span><br></pre></td></tr></table></figure><p>我们将在屏幕上看到：<code>[-1,2,3,4,5]</code>。</p><p>现在假设，我们要创建一个长度为5的NumPy数组，但所有元素都为0，我们可以这样做吗？是的。NumPy提供了一种简单的方法来做同样的事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_new_array = np.zeros((<span class="number">5</span>)) </span><br><span class="line"><span class="built_in">print</span> my_new_array</span><br></pre></td></tr></table></figure><p>我们将看到输出了 <code>[0., 0., 0., 0., 0.]</code>。与 <code>np.zeros</code> 类似，我们也有 <code>np.ones</code>。  如果我们想创建一个随机值数组怎么办？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_random_array = np.random.random((<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span> my_random_array</span><br></pre></td></tr></table></figure><p>我们得到的输出看起来像 [0.22051844 0.35278286 0.11342404 0.79671772 0.62263151] 这样的数据。你获得的输出可能会有所不同，因为我们使用的是随机函数，它为每个元素分配0到1之间的随机值。</p><p>现在让我们看看如何使用NumPy创建二维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_2d_array = np.zeros((<span class="number">2</span>, <span class="number">3</span>)) <span class="built_in">print</span> my_2d_array</span><br></pre></td></tr></table></figure><p>这将在屏幕上打印以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0. 0. 0.]</span><br><span class="line"></span><br><span class="line">[0. 0. 0.]]</span><br></pre></td></tr></table></figure><p>猜猜以下代码的输出结果如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_2d_array_new = np.ones((<span class="number">2</span>, <span class="number">4</span>)) <span class="built_in">print</span> my_2d_array_new</span><br></pre></td></tr></table></figure><p>这里是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1. 1. 1. 1.]</span><br><span class="line"></span><br><span class="line">[1. 1. 1. 1.]]</span><br></pre></td></tr></table></figure><p>基本上，当你使用函数<code>np.zeros()</code>或<code>np.ones()</code>时，你可以指定讨论数组大小的元组。在上面的两个例子中，我们使用以下元组，(2, 3) 和(2, 4) 分别表示2行，3列和4列。像上面那样的多维数组可以用 <code>my_array[i][j]</code> 符号来索引，其中i表示行号，j表示列号。i和j都从0开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_array = np.array([[<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span> my_array[<span class="number">0</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>上面的代码片段的输出是5，因为它是索引0行和索引1列中的元素。</p><p>你还可以按如下方式打印my_array的形状：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> my_array.shape</span><br></pre></td></tr></table></figure><p>输出为(2, 2)，表示数组中有2行2列。</p><p>NumPy提供了一种提取多维数组的行/列的强大方法。例如，考虑我们上面定义的<code>my_array</code>的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">4</span> <span class="number">5</span>] [<span class="number">6</span> <span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>假设，我们想从中提取第二列（索引1）的所有元素。在这里，我们肉眼可以看出，第二列由两个元素组成：<code>5</code> 和 <code>1</code>。为此，我们可以执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_array_column_2 = my_array[:, <span class="number">1</span>] </span><br><span class="line"><span class="built_in">print</span> my_array_column_2</span><br></pre></td></tr></table></figure><p>注意，我们使用了冒号(<code>:</code>)而不是行号，而对于列号，我们使用了值<code>1</code>，最终输出是：<code>[5, 1]</code>。</p><p>我们可以类似地从多维NumPy数组中提取一行。现在，让我们看看NumPy在多个数组上执行计算时提供的强大功能。</p><h2 id="NumPy中的数组操作"><a href="#NumPy中的数组操作" class="headerlink" title="NumPy中的数组操作"></a>NumPy中的数组操作</h2><p>使用NumPy，你可以轻松地在数组上执行数学运算。例如，你可以添加NumPy数组，你可以减去它们，你可以将它们相乘，甚至可以将它们分开。 以下是一些例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]) </span><br><span class="line">b = np.array([[<span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>]]) </span><br><span class="line"><span class="built_in">sum</span> = a + b </span><br><span class="line">difference = a - b </span><br><span class="line">product = a * b </span><br><span class="line">quotient = a / b </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Sum = \n&quot;</span>, <span class="built_in">sum</span> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Difference = \n&quot;</span>, difference </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Product = \n&quot;</span>, product </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Quotient = \n&quot;</span>, quotient </span><br><span class="line"></span><br><span class="line"><span class="comment"># The output will be as follows: </span></span><br><span class="line"></span><br><span class="line">Sum = [[ <span class="number">6.</span> <span class="number">8.</span>] [<span class="number">10.</span> <span class="number">12.</span>]]</span><br><span class="line">Difference = [[-<span class="number">4.</span> -<span class="number">4.</span>] [-<span class="number">4.</span> -<span class="number">4.</span>]]</span><br><span class="line">Product = [[ <span class="number">5.</span> <span class="number">12.</span>] [<span class="number">21.</span> <span class="number">32.</span>]]</span><br><span class="line">Quotient = [[<span class="number">0.2</span> <span class="number">0.33333333</span>] [<span class="number">0.42857143</span> <span class="number">0.5</span> ]]</span><br></pre></td></tr></table></figure><p>如你所见，乘法运算符执行逐元素乘法而不是矩阵乘法。 要执行矩阵乘法，你可以执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix_product = a.dot(b) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Matrix Product = &quot;</span>, matrix_product</span><br></pre></td></tr></table></figure><p>输出将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[19. 22.]</span><br><span class="line"></span><br><span class="line">[43. 50.]]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;numpy（基础篇）&quot;&gt;&lt;a href=&quot;#numpy（基础篇）&quot; class=&quot;headerlink&quot; title=&quot;numpy（基础篇）&quot;&gt;&lt;/a&gt;numpy（基础篇）&lt;/h1&gt;&lt;p&gt;numpy是一个python的扩展程序库，支持大量的维度数组和矩阵运算，除此之外还为数组计算提供了大量的科学库，运行速度很快，包含了一个强大的多维数组对象ndarray，广播功能函数，整合了c与c++语言的工具，还有线性代数、随机数生成等功能。&lt;/p&gt;
&lt;h2 id=&quot;numpy是什么？&quot;&gt;&lt;a href=&quot;#numpy是什么？&quot; class=&quot;headerlink&quot; title=&quot;numpy是什么？&quot;&gt;&lt;/a&gt;numpy是什么？&lt;/h2&gt;&lt;p&gt;NumPy是使用Python进行科学计算的基础软件包。除其他外，它包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能强大的N维数组对象。&lt;/li&gt;
&lt;li&gt;精密广播功能函数。&lt;/li&gt;
&lt;li&gt;集成 C/C+和Fortran 代码的工具。&lt;/li&gt;
&lt;li&gt;强大的线性代数、傅立叶变换和随机数功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;numpy两大利器&quot;&gt;&lt;a href=&quot;#numpy两大利器&quot; class=&quot;headerlink&quot; title=&quot;numpy两大利器&quot;&gt;&lt;/a&gt;numpy两大利器&lt;/h2&gt;&lt;h3 id=&quot;利器之一：Ndarray&quot;&gt;&lt;a href=&quot;#利器之一：Ndarray&quot; class=&quot;headerlink&quot; title=&quot;利器之一：Ndarray&quot;&gt;&lt;/a&gt;利器之一：Ndarray&lt;/h3&gt;&lt;p&gt;NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。ndarray 对象是用于存放同类型元素的多维数组。ndarray 中的每个元素在内存中都有相同存储大小的区域。&lt;/p&gt;
&lt;h3 id=&quot;利器之二：切片和索引&quot;&gt;&lt;a href=&quot;#利器之二：切片和索引&quot; class=&quot;headerlink&quot; title=&quot;利器之二：切片和索引&quot;&gt;&lt;/a&gt;利器之二：切片和索引&lt;/h3&gt;&lt;p&gt;ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>进程基础概念</title>
    <link href="http://rczmm.github.io/2021/09/01/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://rczmm.github.io/2021/09/01/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-09-01T07:27:13.000Z</published>
    <updated>2021-09-01T07:42:13.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>一般地，现代程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和io设备。处理器看上去就像在不间断的一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象就是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的的概念之一。</p><p>进程是操作系统对一个正在运行的程序的一种抽象，在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而<strong>并发运行</strong>，则是说一个进程的指令和另外一个进程的指令其实是交错着在执行的。</p><p>在大多数系统中，需要运行的进程数是可以多于可以运行他们的cpu个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序，这是通过处理器在进程之间切换来实现的，操作系统实现这种交错执行的机制成为<strong>上下文切换</strong>。</p><p>操作系统保持跟踪进程运行所需的所有状态信息，这种状态，也就是上下文，包括许多信息，比如pc（寄存器，处理器核心（大小为一个字的储存设备））和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单核处理器都只能执行一个进程的代码，当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。</p><p>一个进程到另一个进程的转换是由操作系统内核负责管理的，内核不是一个独立的进程，他是操作系统用来管理全部进程所用的代码和数据结构的集合。他是操作系统代码常驻主存的部分，当app需要操作系统的某些操作时，例如最简单的读写文件，内核就会执行一条特殊的系统调用指令，将控制权传递给内核，然后内核执行被请求的操作并返回app。</p><p>现在进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作，以后会揭示这项工作的基本原理，以及app是如何创建和控制他们的进程的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;p&gt;一般地，现代程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和io设备。处</summary>
      
    
    
    
    <category term="操作系统" scheme="http://rczmm.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://rczmm.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>信息就是位加上下文</title>
    <link href="http://rczmm.github.io/2021/08/16/%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://rczmm.github.io/2021/08/16/%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2021-08-16T15:32:43.000Z</published>
    <updated>2021-08-16T16:23:56.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机系统是由硬件和系统软件组成的，他们共同的来运行应用程序。</p><p>我们通过一个简单的c程序输出hello程序的生命周期来开始分析：从它被程序员创建开始，到在系统上运行，输出简单的信息，然后终止。</p><h1 id="信息就是位加上下文"><a href="#信息就是位加上下文" class="headerlink" title="信息就是位加上下文"></a>信息就是位加上下文</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;计算机系统是由硬件和系统软件组成的，他们共同的来运行应用程序。&lt;/p&gt;
&lt;p&gt;我们通过一个简单的c程序输出hello程序的生命周期来开始分析</summary>
      
    
    
    
    <category term="操作系统" scheme="http://rczmm.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://rczmm.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>io编程</title>
    <link href="http://rczmm.github.io/2021/08/12/io%E7%BC%96%E7%A8%8B/"/>
    <id>http://rczmm.github.io/2021/08/12/io%E7%BC%96%E7%A8%8B/</id>
    <published>2021-08-12T08:58:23.000Z</published>
    <updated>2021-08-16T15:31:48.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="io编程"><a href="#io编程" class="headerlink" title="io编程"></a>io编程</h1><p>io（input|output，输入|输出）可以实现数据的读取和写入的操作。Java针对io提供了一给工具包。</p><h2 id="file文件操作"><a href="#file文件操作" class="headerlink" title="file文件操作"></a>file文件操作</h2><p>file类是一个与文件本身操作有关的类，创建、删除、重命名、取得文件大小、修改日期等常见的系统文件操作。</p><h3 id="file类的基本使用"><a href="#file类的基本使用" class="headerlink" title="file类的基本使用"></a>file类的基本使用</h3><p>如果要使用file类则必须提供完整的文件操作路径，对于文件路径的设置可以通过file类的构造方法来完成。</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>public File(String pathname)</td><td>构造</td><td>给定一个操作文件的完整路径</td></tr><tr><td>public File(String parent, String child)</td><td>构造</td><td>规定操作文件的完整路径和子文件名称</td></tr><tr><td>public boolean createNewFile() throws IOException</td><td>普通</td><td>创建文件</td></tr><tr><td>public boolean delete()</td><td>普通</td><td>删除文件</td></tr><tr><td>public boolean exists()</td><td>普通</td><td>判断文件路径是否存在</td></tr></tbody></table><h3 id="file类操作深入"><a href="#file类操作深入" class="headerlink" title="file类操作深入"></a>file类操作深入</h3><p>路径分割符：public static final String separator</p><p>文件路径定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;E:&quot;+File.separator+&quot;demo.txt&quot;</span><br></pre></td></tr></table></figure><p>file父路径操作方法</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>public File getParentFile()</td><td>普通</td><td>获取父路径</td></tr><tr><td>public boolean mkdirs()</td><td>普通</td><td>创建指定目录</td></tr></tbody></table><h3 id="获取文件元信息"><a href="#获取文件元信息" class="headerlink" title="获取文件元信息"></a>获取文件元信息</h3><p><img src="/2021/08/12/io%E7%BC%96%E7%A8%8B/image-20210812171347514.png" alt="image-20210812171347514"></p><h2 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h2><p><img src="/2021/08/12/io%E7%BC%96%E7%A8%8B/image-20210812171601095.png" alt="image-20210812171601095"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;io编程&quot;&gt;&lt;a href=&quot;#io编程&quot; class=&quot;headerlink&quot; title=&quot;io编程&quot;&gt;&lt;/a&gt;io编程&lt;/h1&gt;&lt;p&gt;io（input|output，输入|输出）可以实现数据的读取和写入的操作。Java针对io提供了一给工具包。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
</feed>
