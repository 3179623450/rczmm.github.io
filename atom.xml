<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小世界</title>
  
  <subtitle>永远在路上</subtitle>
  <link href="http://rczmm.github.io/atom.xml" rel="self"/>
  
  <link href="http://rczmm.github.io/"/>
  <updated>2021-09-15T01:35:48.979Z</updated>
  <id>http://rczmm.github.io/</id>
  
  <author>
    <name>rczmm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>alta数据治理</title>
    <link href="http://rczmm.github.io/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/"/>
    <id>http://rczmm.github.io/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/</id>
    <published>2021-09-15T01:20:37.000Z</published>
    <updated>2021-09-15T01:35:48.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Apache-Atlas-进行数据治理"><a href="#使用-Apache-Atlas-进行数据治理" class="headerlink" title="使用 Apache Atlas 进行数据治理"></a>使用 Apache Atlas 进行数据治理</h1><h2 id="数据治理"><a href="#数据治理" class="headerlink" title="数据治理"></a>数据治理</h2><p>数据治理意义重大，传统的数据治理采用文档的形式进行管理，已经无法满足大数据下的数据治理需要。而适合于Hadoop大数据生态体系的数据治理就非常的重要了。</p><blockquote><p>大数据下的数据治理作为很多企业的一个巨大的难题，能找到的数据的解决方案并不多，但是好在近几年，很多公司已经进行了尝试并开源了出来，本文将详细分析这些数据发现平台，在国外已经有了十几种的实现方案。<br>数据发现平台可以解决的问题<br>为什么需要一个数据发现平台？<br>在数据治理过程中，经常会遇到这些问题：</p><p>数据都存在哪？</p><p>该如何使用这些数据？</p><p>数据是做什么的？</p><p>数据是如何创建的？</p><p>数据是如何更新的？</p></blockquote><p><strong>数据发现平台的目的就是为了解决上面的问题，帮助更好的查找，理解和使用数据。</strong></p><blockquote><p>Facebook的Nemo就使用了全文检索技术，这样可以快速的搜索到目标数据。</p><p>es（搜索引擎）</p></blockquote><h3 id="各平台对比"><a href="#各平台对比" class="headerlink" title="各平台对比"></a>各平台对比</h3><p><img src="/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/image-20210915093419300.png" alt="image-20210915093419300"></p><p>开源的有五家：Amundsen Datahub Metacat Marquez Atlas</p><p>有文档的有三家：Amundsen Datahub Atlas</p><p>搜索功能较强 ：Amundsen</p><p>有数据血统功能：Datahub Atlas</p><p>考虑到项目的周期，实施性等情况，还是建议大家从Atlas入门，打开数据治理的探索之路。</p><h2 id="alta"><a href="#alta" class="headerlink" title="alta"></a>alta</h2><blockquote><p>面对海量且持续增加的各式各样的数据对象，你是否有信心知道哪些数据从哪里来以及它如何随时间而变化？采用Hadoop必须考虑数据管理的实际情况，元数据与数据治理成为企业级数据湖的重要部分。</p><p>为寻求数据治理的开源解决方案，Hortonworks 公司联合其他厂商与用户于2015年发起数据治理倡议，包括数据分类、集中策略引擎、数据血缘、安全和生命周期管理等方面。Apache Atlas 项目就是这个倡议的结果，社区伙伴持续的为该项目提供新的功能和特性。该项目用于管理共享元数据、数据分级、审计、安全性以及数据保护等方面，努力与Apache Ranger整合，用于数据权限控制策略。</p></blockquote><p>Atlas 是一个可扩展和可扩展的核心基础治理服务集 - 使企业能够有效地和高效地满足 Hadoop 中的合规性要求，并允许与整个企业数据生态系统的集成。</p><p><img src="/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/1253350-20180509182903076-1452084256.jpg" alt="alta数据治理"></p><p>Atlas 的组件可以分为以下主要类别：</p><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><p>此类别包含实现 Atlas 功能核心的组件，包括：</p><p>Type System：Atlas 允许用户为他们想要管理的元数据对象定义一个模型。该模型由称为 “类型” 的定义组成。”类型” 的 实例被称为 “实体” 表示被管理的实际元数据对象。类型系统是一个组件，允许用户定义和管理类型和实体。由 Atlas 管理的所有元数据对象（例如Hive表）都使用类型进行建模，并表示为实体。要在 Atlas 中存储新类型的元数据，需要了解类型系统组件的概念。</p><p>需要注意的一个关键点是，Atlas 中建模的通用性质允许数据管理员和集成者定义技术元数据和业务元数据。也可以使用 Atlas 的特征来定义两者之间的丰富关系。</p><p>Ingest / Export：Ingest 组件允许将元数据添加到 Atlas。类似地，Export 组件暴露由 Atlas 检测到的元数据更改，以作为事件引发，消费者可以使用这些更改事件来实时响应元数据更改。</p><p>Graph Engine ：在内部，Atlas 通过使用图形模型管理元数据对象。以实现元数据对象之间的巨大灵活性和丰富的关系。图形引擎是负责在类型系统的类型和实体之间进行转换的组件，以及基础图形模型。除了管理图形对象之外，图形引擎还为元数据对象创建适当的索引，以便有效地搜索它们。</p><p>Titan：目前，Atlas 使用 Titan 图数据库来存储元数据对象。 Titan 使用两个存储：默认情况下元数据存储配置为 HBase ，索引存储配置为 Solr。也可以通过构建相应的配置文件将元数据存储作为 BerkeleyDB 和 Index 存储使用为 ElasticSearch。元数据存储用于存储元数据对象本身，并且索引存储用于存储元数据属性的索引，其允许高效搜索。</p><h2 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h2><p>用户可以使用两种方法管理 Atlas 中的元数据：</p><p>API：Atlas 的所有功能通过 REST API 提供给最终用户，允许创建，更新和删除类型和实体。它也是查询和发现通过 Atlas 管理的类型和实体的主要方法。</p><p>Messaging：除了 API 之外，用户还可以选择使用基于 Kafka 的消息接口与 Atlas 集成。这对于将元数据对象传输到 Atlas 以及从 Atlas 使用可以构建应用程序的元数据更改事件都非常有用。如果希望使用与 Atlas 更松散耦合的集成，这可以允许更好的可扩展性，可靠性等，消息传递接口是特别有用的。Atlas 使用 Apache Kafka 作为通知服务器用于钩子和元数据通知事件的下游消费者之间的通信。事件由钩子和 Atlas 写到不同的 Kafka 主题。</p><h3 id="元数据源"><a href="#元数据源" class="headerlink" title="元数据源"></a>元数据源</h3><p>Atlas 支持与许多元数据源的集成。将来还会添加更多集成。目前，Atlas 支持从以下来源获取和管理元数据：</p><p><a href="http://atlas.apache.org/StormAtlasHook.html">HiveSqoopFalconStorm</a></p><p>与其它元数据源集成意味着两件事：有一些元数据模型，Atlas 定义本机来表示这些组件的对象。 Atlas 提供了从这些组件中通过实时或批处理模式获取元数据对象的组件。</p><h2 id="Apps"><a href="#Apps" class="headerlink" title="Apps"></a>Apps</h2><p>由 Atlas 管理的元数据各种应用程序使用，满足许多治理用例。</p><p>Atlas Admin UI：该组件是一个基于 Web 的应用程序，允许数据管理员和科学家发现和注释元数据。这里最重要的是搜索界面和 SQL 样的查询语言，可以用来查询由 Atlas 管理的元数据类型和对象。管理 UI 使用 Atlas 的 REST API 来构建其功能。</p><p>Tag Based Policies：Apache Ranger 是针对 Hadoop 生态系统的高级安全管理解决方案，与各种 Hadoop 组件具有广泛的集成。通过与 Atlas 集成，Ranger 允许安全管理员定义元数据驱动的安全策略，以实现有效的治理。 Ranger 是由 Atlas 通知的元数据更改事件的消费者。</p><p>Business Taxonomy：从元数据源获取到 Atlas 的元数据对象主要是一种技术形式的元数据。为了增强可发现性和治理能力，Atlas 提供了一个业务分类界面，允许用户首先定义一组代表其业务域的业务术语，并将其与 Atlas 管理的元数据实体相关联。业务分类法是一种 Web 应用程序，目前是 Atlas Admin UI 的一部分，并且使用 REST API 与 Atlas 集成。</p><h2 id="Type-System"><a href="#Type-System" class="headerlink" title="Type System"></a>Type System</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Atlas 允许用户为他们想要管理的元数据对象定义一个模型。该模型由称为 “类型” 的定义组成。被称为 “实体” 的 “类型” 实例表示被管理的实际元数据对象。类型系统是一个组件，允许用户定义和管理类型和实体。由 Atlas 管理的所有元数据对象（例如Hive表）都使用类型进行建模，并表示为实体。要在Atlas中存储新类型的元数据，需要了解类型系统组件的概念。</p><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Atlas中的 “类型” 定义了如何存储和访问特定类型的元数据对象。类型表示了所定义元数据对象的一个或多个属性集合。具有开发背景的用户可以将 “类型” 理解成面向对象的编程语言的 “类” 定义的或关系数据库的 “表模式”。</p><p>与 Atlas 本地定义的类型的示例是 Hive 表。 Hive 表用这些属性定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name: hive_table</span><br><span class="line"> MetaType: Class</span><br><span class="line"> SuperTypes: DataSet</span><br><span class="line"> Attributes:</span><br><span class="line">     name: String (name of the table)</span><br><span class="line">     db: Database object of type hive_db</span><br><span class="line">     owner: String</span><br><span class="line">     createTime: Date</span><br><span class="line">     lastAccessTime: Date</span><br><span class="line">     comment: String</span><br><span class="line">     retention: int</span><br><span class="line">     sd: Storage Description object of type hive_storagedesc</span><br><span class="line">     partitionKeys: Array of objects of type hive_column</span><br><span class="line">     aliases: Array of strings</span><br><span class="line">     columns: Array of objects of type hive_column</span><br><span class="line">     parameters: Map of String keys to String values</span><br><span class="line">     viewOriginalText: String</span><br><span class="line">     viewExpandedText: String</span><br><span class="line">     tableType: String</span><br><span class="line">     temporary: Boolean</span><br></pre></td></tr></table></figure><p>从上面的例子可以注意到以下几点：</p><ul><li>Atlas中的类型由 “name” 唯一标识，</li><li>类型具有元类型。元类型表示 Atlas 中此模型的类型。 Atlas 有以下几种类型：<ul><li>基本元类型： Int，String，Boolean等。</li><li>枚举元类型</li><li>集合元类型：例如Array，Map</li><li>复合元类型：Class，Struct，Trait</li></ul></li><li>类型可以从称为 “supertype” 的父类型 “extend” - 凭借这一点，它将包含在 “supertype” 中定义的属性。这允许模型在一组相关类型等之间定义公共属性。这再次类似于面向对象语言如何定义类的超类的概念。 Atlas 中的类型也可以从多个超类型扩展。<ul><li>在该示例中，每个 hive 表从预定义的超类型（称为 “DataSet”）扩展。稍后将提供关于此预定义类型的更多细节。</li></ul></li><li>具有 “Class”，”Struct” 或 “Trait” 的元类型的类型可以具有属性集合。每个属性都有一个名称（例如 “name”）和一些其他关联的属性。可以使用表达式 type_name.attribute_name 来引用属性。还要注意，属性本身是使用 Atlas 元类型定义的。<ul><li>在这个例子中，hive_table.name 是一个字符串，hive_table.aliases 是一个字符串数组，hive_table.db 引用一个类型的实例称为 hive_db 等等。</li></ul></li><li>在属性中键入引用（如hive_table.db）。使用这样的属性，我们可以在 Atlas 中定义的两种类型之间的任意关系，从而构建丰富的模型。注意，也可以收集一个引用列表作为属性类型（例如 hive_table.cols，它表示从 hive_table 到 hive_column 类型的引用列表）</li></ul><h3 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h3><p>Atlas中的 “实体” 是类 “类型” 的特定值或实例，因此表示真实世界中的特定元数据对象。 回顾我们的面向对象编程语言的类比，”实例” 是某个 “类” 的 “对象”。</p><p>实体的示例将是特定的 Hive 表。 说 “Hive” 在 “默认” 数据库中有一个名为 “customers” 的表。 此表将是类型为 hive_table 的 Atlas 中的 “实体”。 通过作为类类型的实例，它将具有作为 Hive 表 “类型” 的一部分的每个属性的值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id: &quot;9ba387dd-fa76-429c-b791-ffc338d3c91f&quot;</span><br><span class="line"> typeName: “hive_table”</span><br><span class="line"> values:</span><br><span class="line">     name: &quot;customers&quot;</span><br><span class="line">     db: &quot;b42c6cfc-c1e7-42fd-a9e6-890e0adf33bc&quot;</span><br><span class="line">     owner: &quot;admin&quot;</span><br><span class="line">     createTime: &quot;2016-06-20T06:13:28.000Z&quot;</span><br><span class="line">     lastAccessTime: &quot;2016-06-20T06:13:28.000Z&quot;</span><br><span class="line">     comment: null</span><br><span class="line">     retention: 0</span><br><span class="line">     sd: &quot;ff58025f-6854-4195-9f75-3a3058dd8dcf&quot;</span><br><span class="line">     partitionKeys: null</span><br><span class="line">     aliases: null</span><br><span class="line">     columns: [&quot;65e2204f-6a23-4130-934a-9679af6a211f&quot;, &quot;d726de70-faca-46fb-9c99-cf04f6b579a6&quot;, ...]</span><br><span class="line">     parameters: &#123;&quot;transient_lastDdlTime&quot;: &quot;1466403208&quot;&#125;</span><br><span class="line">     viewOriginalText: null</span><br><span class="line">     viewExpandedText: null</span><br><span class="line">     tableType: &quot;MANAGED_TABLE&quot;</span><br><span class="line">     temporary: false</span><br></pre></td></tr></table></figure><p>从上面的例子可以注意到以下几点：</p><ul><li>作为 Class Type 实例的每个实体都由唯一标识符 GUID 标识。此 GUID 由 Atlas 服务器在定义对象时生成，并在实体的整个生命周期内保持不变。在任何时间点，可以使用其 GUID 来访问该特定实体。<ul><li>在本示例中，默认数据库中的 “customers” 表由GUID “9ba387dd-fa76-429c-b791-ffc338d3c91f” 唯一标识</li></ul></li><li>实体具有给定类型，并且类型的名称与实体定义一起提供。<ul><li>在这个例子中，”customers” 表是一个 “hive_table”。</li></ul></li><li>此实体的值是所有属性名称及其在 hive_table 类型定义中定义的属性的值的映射。</li><li>属性值将根据属性的元类型。<ul><li>基本元类型：整数，字符串，布尔值。例如。 ‘name’=’customers’，’Temporary’=’false’</li><li>集合元类型：包含元类型的值的数组或映射。例如。 parameters = {“transient_lastDdlTime”：”1466403208”}</li><li>复合元类型：对于类，值将是与该特定实体具有关系的实体。例如。hive 表 “customers” 存在于称为 “default” 的数据库中。</li></ul></li></ul><p>表和数据库之间的关系通过 “db” 属性捕获。因此，”db” 属性的值将是一个唯一标识 hive_db 实体的 GUID，称为 “default”对于实体的这个想法，我们现在可以看到 Class 和 Struct 元类型之间的区别。类和结构体都组成其他类型的属性。但是，类类型的实体具有 Id 属性（具有GUID值）并且可以从其他实体引用（如 hive_db 实体从 hive_table 实体引用）。 Struct 类型的实例没有自己的身份，Struct 类型的值是在实体本身内嵌入的属性的集合。</p><h3 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h3><p>我们已经看到属性在复合元类型（如 Class 和 Struct）中定义。 但是我们简单地将属性称为具有名称和元类型值。 然而， Atlas 中的属性还有一些属性，定义了与类型系统相关的更多概念。</p><p>属性具有以下属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name: string,</span><br><span class="line">  dataTypeName: string,</span><br><span class="line">  isComposite: boolean,</span><br><span class="line">  isIndexable: boolean,</span><br><span class="line">  isUnique: boolean,</span><br><span class="line">  multiplicity: enum,</span><br><span class="line">  reverseAttributeName: string</span><br></pre></td></tr></table></figure><p>以上属性具有以下含义：</p><ul><li>name - 属性的名称</li><li>dataTypeName - 属性的元类型名称（本机，集合或复合）</li><li>isComposite - 是否复合<ul><li>此标志指示建模的一个方面。如果一个属性被定义为复合，它意味着它不能有一个生命周期与它所包含的实体无关。这个概念的一个很好的例子是构成 hive 表一部分的一组列。由于列在 hive 表之外没有意义，它们被定义为组合属性。</li><li>必须在 Atlas 中创建复合属性及其所包含的实体。即，必须与 hive 表一起创建 hive 列。</li></ul></li><li>isIndexable - 是否索引<ul><li>此标志指示此属性是否应该索引，以便可以使用属性值作为谓词来执行查找，并且可以有效地执行查找。</li></ul></li><li>isUnique - 是否唯一<ul><li>此标志再次与索引相关。如果指定为唯一，这意味着为 Titan 中的此属性创建一个特殊索引，允许基于等式的查找。</li><li>具有此标志的真实值的任何属性都被视为主键，以将此实体与其他实体区分开。因此，应注意确保此属性在现实世界中模拟独特的属性。<ul><li>例如，考虑 hive_table 的 name 属性。孤立地，名称不是 hive_table 的唯一属性，因为具有相同名称的表可以存在于多个数据库中。如果 Atlas 在多个集群中存储 hive 表的元数据，即使一对（数据库名称，表名称）也不是唯一的。只有集群位置，数据库名称和表名称可以在物理世界中被视为唯一。</li></ul></li></ul></li><li>multiplicity - 指示此属性是（必需的／可选的／还是可以是多值）的。如果实体的属性值的定义与类型定义中的多重性声明不匹配，则这将是一个约束违反，并且实体添加将失败。因此，该字段可以用于定义元数据信息上的一些约束。</li></ul><p>使用上面的内容，让我们扩展下面的 hive 表的属性之一的属性定义。让我们看看称为 “db” 的属性，它表示 hive 表所属的数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db:</span><br><span class="line">    &quot;dataTypeName&quot;: &quot;hive_db&quot;,</span><br><span class="line">    &quot;isComposite&quot;: false,</span><br><span class="line">    &quot;isIndexable&quot;: true,</span><br><span class="line">    &quot;isUnique&quot;: false,</span><br><span class="line">    &quot;multiplicity&quot;: &quot;required&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;db&quot;,</span><br><span class="line">    &quot;reverseAttributeName&quot;: null</span><br></pre></td></tr></table></figure><p>注意多重性的 “multiplicity” = “required” 约束。 如果没有 db 引用，则不能发送表实体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">columns:</span><br><span class="line">    &quot;dataTypeName&quot;: &quot;array&lt;hive_column&gt;&quot;,</span><br><span class="line">    &quot;isComposite&quot;: true,</span><br><span class="line">    &quot;isIndexable&quot;: true,</span><br><span class="line">    “isUnique&quot;: false,</span><br><span class="line">    &quot;multiplicity&quot;: &quot;optional&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;columns&quot;,</span><br><span class="line">    &quot;reverseAttributeName&quot;: null</span><br></pre></td></tr></table></figure><p>请注意列的 “isComposite” = true 值。通过这样做，我们指示定义的列实体应该始终绑定到它们定义的表实体。</p><p>从这个描述和示例中，您将能够意识到属性定义可以用于影响 Atlas 系统要执行的特定建模行为（约束，索引等）。</p><h3 id="系统特定类型及其意义"><a href="#系统特定类型及其意义" class="headerlink" title="系统特定类型及其意义"></a>系统特定类型及其意义</h3><p>Atlas 提供了一些预定义的系统类型。我们在前面的章节中看到了一个例子（DataSet）。在本节中，我们将看到所有这些类型并了解它们的意义。</p><p>Referenceable：此类型表示可使用名为 qualifiedName 的唯一属性搜索的所有实体。</p><p>Asset：此类型包含名称，说明和所有者等属性。名称是必需属性（multiplicity = required），其他是可选的。可引用和资源的目的是为定型器提供在定义和查询其自身类型的实体时强制一致性的方法。拥有这些固定的属性集允许应用程序和用户界面基于约定基于默认情况下他们可以期望的属性的假设。</p><p>Infrastructure：此类型扩展了可引用和资产，通常可用于基础设施元数据对象（如群集，主机等）的常用超类型。</p><p>DataSet：此类型扩展了可引用和资产。在概念上，它可以用于表示存储数据的类型。在 Atlas 中，hive表，Sqoop RDBMS表等都是从 DataSet 扩展的类型。扩展 DataSet 的类型可以期望具有模式，它们将具有定义该数据集的属性的属性。例如， hive_table 中的 columns 属性。另外，扩展 DataSet 的实体类型的实体参与数据转换，这种转换可以由 Atlas 通过 lineage（或 provenance）生成图形。</p><p>Process：此类型扩展了可引用和资产。在概念上，它可以用于表示任何数据变换操作。例如，将原始数据的 hive 表转换为存储某个聚合的另一个 hive 表的 ETL 过程可以是扩展过程类型的特定类型。流程类型有两个特定的属性，输入和输出。输入和输出都是 DataSet 实体的数组。因此，Process 类型的实例可以使用这些输入和输出来捕获 DataSet 的 lineage 如何演变。</p><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>Atlas 支持以下 2 种方式搜索元数据:</p><ul><li>Search using DSL</li><li>Full-text search</li></ul><p><a href="http://atlas.apache.org/Bridge-Hive.html">Hive Atlas Bridge</a></p><h3 id="Hive-Model"><a href="#Hive-Model" class="headerlink" title="Hive Model"></a>Hive Model</h3><p>默认 hive 建模在 org.apache.atlas.hive.model.HiveDataModelGenerator 中可用。 它定义以下类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive_db(ClassType) - super types [Referenceable] - attributes [name, clusterName, description, locationUri, parameters, ownerName, ownerType]</span><br><span class="line">hive_storagedesc(ClassType) - super types [Referenceable] - attributes [cols, location, inputFormat, outputFormat, compressed, numBuckets, serdeInfo, bucketCols, sortCols, parameters, storedAsSubDirectories]</span><br><span class="line">hive_column(ClassType) - super types [Referenceable] - attributes [name, type, comment, table]</span><br><span class="line">hive_table(ClassType) - super types [DataSet] - attributes [name, db, owner, createTime, lastAccessTime, comment, retention, sd, partitionKeys, columns, aliases, parameters, viewOriginalText, viewExpandedText, tableType, temporary]</span><br><span class="line">hive_process(ClassType) - super types [Process] - attributes [name, startTime, endTime, userName, operationType, queryText, queryPlan, queryId]</span><br><span class="line">hive_principal_type(EnumType) - values [USER, ROLE, GROUP]</span><br><span class="line">hive_order(StructType) - attributes [col, order]</span><br><span class="line">hive_serde(StructType) - attributes [name, serializationLib, parameters]</span><br></pre></td></tr></table></figure><p>使用唯一的限定名称创建和去重复实体。它们提供命名空间，也可以用于 query／lineage。请注意，dbName，tableName 和 columnName 应为小写。 clusterName 解释如下。</p><ul><li>hive_db - attribute qualifiedName - <dbName>@<clusterName></clusterName></dbName></li><li>hive_table - attribute qualifiedName - <dbName>.<tableName>@<clusterName></clusterName></tableName></dbName></li><li>hive_column - attribute qualifiedName - <dbName>.<tableName>.<columnName>@<clusterName></clusterName></columnName></tableName></dbName></li><li>hive_process - attribute name - <queryString> - 小写的修剪查询字符串</queryString></li></ul><h3 id="导入-Hive-Metadata"><a href="#导入-Hive-Metadata" class="headerlink" title="导入 Hive Metadata"></a>导入 Hive Metadata</h3><p>org.apache.atlas.hive.bridge.HiveMetaStoreBridge 使用 org.apache.atlas.hive.model.HiveDataModelGenerator 中定义的模型将 Hive 元数据导入 Atlas。 import-hive.sh 命令可以用来方便这一点。脚本需要 Hadoop 和 Hive 类路径 jar。 对于 Hadoop jar，请确保环境变量 HADOOP_CLASSPATH 已设置。另一种方法是将 HADOOP_HOME 设置为指向 Hadoop 安装的根目录同样，对于 Hive jar，将 HIVE_HOME 设置为 Hive 安装的根目录将环境变量 HIVE_CONF_DIR 设置为 Hive 配置目录复制 ${atlas-conf}/atlas-application.properties 到 hive conf 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: &lt;atlas package&gt;/hook-bin/import-hive.sh</span><br></pre></td></tr></table></figure><p>日志位于 ${atlas package}/logs/import-hive.log</p><p>如果要在 kerberized 集群中导入元数据，则需要运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;atlas package&gt;/hook-bin/import-hive.sh -Dsun.security.jgss.debug=true -Djavax.security.auth.useSubjectCredsOnly=false -Djava.security.krb5.conf=[krb5.conf location] -Djava.security.auth.login.config=[jaas.conf location]</span><br></pre></td></tr></table></figure><ul><li>krb5.conf is typically found at /etc/krb5.conf</li><li>for details about jaas.conf and a suggested location see the <a href="http://atlas.apache.org/Security.html">atlas security documentation</a></li></ul><h3 id="Hive-Hook"><a href="#Hive-Hook" class="headerlink" title="Hive Hook"></a>Hive Hook</h3><p>Hive 在使用 hive hook 的 hive 命令执行上支持侦听器。 这用于在 Atlas 中使用 org.apache.atlas.hive.model.HiveDataModelGenerator 中定义的模型添加/更新/删除实体。 hive hook 将请求提交给线程池执行器，以避免阻塞命令执行。 线程将实体作为消息提交给通知服务器，并且服务器读取这些消息并注册实体。 按照 hive 设置中的这些说明为 Atlas 添加 hive hook ：</p><ul><li>Set-up atlas hook in hive-site.xml of your hive configuration:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hive.exec.post.hooks&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.atlas.hive.hook.HiveHook&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;atlas.cluster.name&lt;/name&gt;</span><br><span class="line">&lt;value&gt;primary&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><ul><li>Add ‘export HIVE_AUX_JARS_PATH=<atlas package>/hook/hive’ in hive-env.sh of your hive configuration</atlas></li><li>Copy <atlas-conf>/atlas-application.properties to the hive conf directory.</atlas-conf></li></ul><p>在<atlas-conf> /atlas-application.properties中的以下属性控制线程池和通知详细信息：</atlas-conf></p><ul><li>atlas.hook.hive.synchronous - boolean，true来同步运行钩子。 默认false。 建议设置为false，以避免 hive 查询完成中的延迟。</li><li>atlas.hook.hive.numRetries - 通知失败的重试次数。 默认值 3</li><li>atlas.hook.hive.minThreads - 核心线程数。 默认值 5</li><li>atlas.hook.hive.maxThreads - 最大线程数。 默认值 5</li><li>atlas.hook.hive.keepAliveTime - 保持活动时间以毫秒为单位。 默认 10</li><li>atlas.hook.hive.queueSize - 线程池的队列大小。 默认 10000</li></ul><p>参考 <a href="http://atlas.apache.org/Configuration.html">Configuration</a> 通知相关配置</p><h3 id="Column-Level-Lineage"><a href="#Column-Level-Lineage" class="headerlink" title="Column Level Lineage"></a>Column Level Lineage</h3><p>从 atlas-0.8-incubating 版本开始，在 Atlas 中捕获列 lineage</p><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><ul><li>ColumnLineageProcess 类型是 Process 的子类</li><li>这将输出列与一组输入列或输入表相关联</li><li>Lineage 还捕获 Dependency 的类型：当前的值是 SIMPLE，EXPRESSION，SCRIPT<ul><li>SIMPLE依赖： 意味着输出列具有与输入相同的值</li><li>EXPRESSION依赖： 意味着输出列被输入列上的运行时中的一些表达式（例如Hive SQL表达式）转换。</li><li>SCRIPT依赖： 表示输出列由用户提供的脚本转换。</li></ul></li><li>在 EXPRESSION 依赖的情况下，表达式属性包含字符串形式的表达式</li><li>由于 Process 链接输入和输出 DataSet，我们使 Column 成为 DataSet 的子类</li></ul><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p>对于下面的简单 CTAS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t2 as select id, name from T1</span><br></pre></td></tr></table></figure><p>lineage 为</p><p><img src="/2021/09/15/alta%E6%95%B0%E6%8D%AE%E6%B2%BB%E7%90%86/1253350-20180509182917037-667288476.jpg" alt="img"></p><h4 id="Extracting-Lineage-from-Hive-commands"><a href="#Extracting-Lineage-from-Hive-commands" class="headerlink" title="Extracting Lineage from Hive commands"></a>Extracting Lineage from Hive commands</h4><ul><li>HiveHook 将 HookContext 中的 LineageInfo 映射到 Column lineage 实例</li><li>Hive 中的 LineageInfo 为最终的 FileSinkOperator 提供 Column lineage ，将它们链接到 Hive 查询中的输入列</li></ul><h4 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h4><p>在将 <a href="https://issues.apache.org/jira/browse/HIVE-13112">HIVE-13112</a> 的补丁应用于 Hive 源之后，列级别 lineage 与 Hive 版本1.2.1配合使用</p><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><ul><li>由于数据库名，表名和列名在 hive 中不区分大小写，因此实体中的对应名称为小写。 因此，任何搜索 API 都应该在查询实体名称时使用小写</li><li>以下 hive 操作由 hive hook 当前捕获<ul><li>create database</li><li>create table/view, create table as select</li><li>load, import, export</li><li>DMLs (insert)</li><li>alter database</li><li>alter table (skewed table information, stored as, protection is not supported)</li><li>alter view</li></ul></li></ul><h2 id="Sqoop-Atlas-Bridge"><a href="#Sqoop-Atlas-Bridge" class="headerlink" title="Sqoop Atlas Bridge"></a>Sqoop Atlas Bridge</h2><h3 id="Sqoop-Model"><a href="#Sqoop-Model" class="headerlink" title="Sqoop Model"></a>Sqoop Model</h3><p>默认的 Sqoop 建模在 org.apache.atlas.sqoop.model.SqoopDataModelGenerator 中可用。 它定义以下类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqoop_operation_type(EnumType) - values [IMPORT, EXPORT, EVAL]</span><br><span class="line">  sqoop_dbstore_usage(EnumType) - values [TABLE, QUERY, PROCEDURE, OTHER]</span><br><span class="line">  sqoop_process(ClassType) - super types [Process] - attributes [name, operation, dbStore, hiveTable, commandlineOpts, startTime, endTime, userName]</span><br><span class="line">  sqoop_dbdatastore(ClassType) - super types [DataSet] - attributes [name, dbStoreType, storeUse, storeUri, source, description, ownerName]</span><br></pre></td></tr></table></figure><p>使用唯一的限定名称创建和去重复实体。 它们提供命名空间，也可以用于查询：sqoop_process - attribute name - sqoop-dbStoreType-storeUri-endTime sqoop_dbdatastore - attribute name - dbStoreType-connectorUrl-source</p><h3 id="Sqoop-Hook"><a href="#Sqoop-Hook" class="headerlink" title="Sqoop Hook"></a>Sqoop Hook</h3><p>Sqoop 添加了一个 SqoopJobDataPublisher，在完成导入作业后将数据发布到 Atlas。 现在 sqoopHook 只支持hiveImport。 这用于使用 org.apache.atlas.sqoop.model.SqoopDataModelGenerator 中定义的模型在 Atlas 中添加实体。 按照 sqoop 设置中的以下说明在 ${sqoop-conf}/sqoop-site.xml 中为 Atlas 添加 sqoop 钩子：</p><ul><li>Sqoop Job publisher class. Currently only one publishing class is supported</li></ul><p>sqoop.job.data.publish.class org.apache.atlas.sqoop.hook.SqoopHook</p><ul><li>Atlas cluster name</li></ul><p>atlas.cluster.name</p><ul><li>复制 ${atlas-conf}/atlas-application.properties 到 sqoop 的配置文件夹 ${sqoop-conf}/</li><li>Link ${atlas-home}/hook/sqoop/*.jar in sqoop libRefer <a href="http://atlas.apache.org/Configuration.html">Configuration</a> for notification related configurations</li></ul><h3 id="Limitations-1"><a href="#Limitations-1" class="headerlink" title="Limitations"></a>Limitations</h3><ul><li>目前 sqoop hook 只支持 hiveImport 这一种 sqoop 操作</li></ul><h2 id="Falcon-Atlas-Bridge"><a href="#Falcon-Atlas-Bridge" class="headerlink" title="Falcon Atlas Bridge"></a>Falcon Atlas Bridge</h2><h3 id="Falcon-Model"><a href="#Falcon-Model" class="headerlink" title="Falcon Model"></a>Falcon Model</h3><p>默认的falcon建模在 org.apache.atlas.falcon.model.FalconDataModelGenerator. 它可以定义以下类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">falcon_cluster(ClassType) - super types [Infrastructure] - attributes [timestamp, colo, owner, tags]</span><br><span class="line">falcon_feed(ClassType) - super types [DataSet] - attributes [timestamp, stored-in, owner, groups, tags]</span><br><span class="line">falcon_feed_creation(ClassType) - super types [Process] - attributes [timestamp, stored-in, owner]</span><br><span class="line">falcon_feed_replication(ClassType) - super types [Process] - attributes [timestamp, owner]</span><br><span class="line">falcon_process(ClassType) - super types [Process] - attributes [timestamp, runs-on, owner, tags, pipelines, workflow-properties]</span><br></pre></td></tr></table></figure><p>为 falcon 进程定义的每个集群创建一个 falcon_process 实体。</p><p>使用唯一的 qualifiedName 属性创建和去重复实体。 它们提供命名空间，也可以用于查询/沿袭。 唯一的属性是：</p><ul><li>falcon_process - <process name>@<cluster name></cluster></process></li><li>falcon_cluster - <cluster name></cluster></li><li>falcon_feed - <feed name>@<cluster name></cluster></feed></li><li>falcon_feed_creation - <feed name></feed></li><li>falcon_feed_replication - <feed name></feed></li></ul><h3 id="Falcon-Hook"><a href="#Falcon-Hook" class="headerlink" title="Falcon Hook"></a>Falcon Hook</h3><p>Falcon 支持在 falcon 实体提交上的侦听器。 这用于在 Atlas 中使用 org.apache.atlas.falcon.model.FalconDataModelGenerator 中定义的模型添加实体。 hook 将请求提交给线程池执行器，以避免阻塞命令执行。 线程将实体作为消息提交给通知服务器，并且服务器读取这些消息并注册实体。</p><ul><li>Add ‘org.apache.atlas.falcon.service.AtlasService’ to application.services in ${falcon-conf}/startup.properties</li><li>Link falcon hook jars in falcon classpath - ‘ln -s atlas−home/hook/falcon/∗{falcon-home}/server/webapp/falcon/WEB-INF/lib/‘</li><li>In ${falcon_conf}/falcon-env.sh, set an environment variable as follows:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FALCON_SERVER_OPTS=&quot;&lt;atlas_home&gt;/hook/falcon/*:$FALCON_SERVER_OPTS&quot;</span><br></pre></td></tr></table></figure><p>The following properties in ${atlas-conf}/atlas-application.properties control the thread pool and notification details:</p><ul><li>atlas.hook.falcon.synchronous - boolean, true to run the hook synchronously. default false</li><li>atlas.hook.falcon.numRetries - number of retries for notification failure. default 3</li><li>atlas.hook.falcon.minThreads - core number of threads. default 5</li><li>atlas.hook.falcon.maxThreads - maximum number of threads. default 5</li><li>atlas.hook.falcon.keepAliveTime - keep alive time in msecs. default 10</li><li>atlas.hook.falcon.queueSize - queue size for the threadpool. default 10000</li></ul><p>Refer <a href="http://atlas.apache.org/Configuration.html">Configuration</a> for notification related configurations</p><h3 id="Limitations-2"><a href="#Limitations-2" class="headerlink" title="Limitations"></a>Limitations</h3><ul><li>在 falcon 集群实体中，使用的集群名称应该跨诸如 hive，falcon，sqoop 等组件是统一的。如果与 ambari 一起使用，则应该使用 ambari 集群名称用于集群实体</li></ul><h2 id="Storm-Atlas-Bridge"><a href="#Storm-Atlas-Bridge" class="headerlink" title="Storm Atlas Bridge"></a>Storm Atlas Bridge</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Apache Storm 是一个分布式实时计算系统。 Storm 使得容易可靠地处理无界的数据流，为实时处理 Hadoop 对批处理所做的工作。 该过程实质上是节点的 DAG，其被称为 topology。</p><p>Apache Atlas 是一个元数据存储库，支持端到端数据沿袭，搜索和关联业务分类。</p><p>这种集成的目的是推动操作 topology 元数据以及基础数据源，目标，推导过程和任何可用的业务上下文，以便 Atlas 可以捕获此 topology 的 lineage。</p><p>在此过程中有2个部分详述如下：</p><ul><li>Data model to represent the concepts in Storm</li><li>Storm Atlas Hook to update metadata in Atlas</li></ul><h3 id="Storm-Data-Model"><a href="#Storm-Data-Model" class="headerlink" title="Storm Data Model"></a>Storm Data Model</h3><p>数据模型在 Atlas 中表示为 Types。 它包含 topology 图中各种节点的描述，例如 spouts 和 bolts 以及相应的生产者和消费者类型。</p><p>在Atlas中添加以下类型。</p><ul><li>storm_topology - 表示粗粒度拓扑。storm_topology 来自于 Atlas 过程类型，因此可用于通知 Atlas 关于 lineage。</li><li>添加以下数据集 - kafka_topic，jms_topic，hbase_table，hdfs_data_set。 这些都来自Atlas Dataset类型，因此形成谱系图的端点。</li><li>storm_spout - 具有输出的数据生产者，通常为Kafka，JMS</li><li>storm_bolt - 具有输入和输出的数据使用者，通常为Hive，HBase，HDFS等。</li></ul><p>Storm Atlas hook自动注册依赖模型，如Hive数据模型，如果它发现这些是不为Atlas服务器所知。</p><p>每个类型的数据模型在类定义org.apache.atlas.storm.model.StormDataModel中描述。</p><h3 id="Storm-Atlas-Hook"><a href="#Storm-Atlas-Hook" class="headerlink" title="Storm Atlas Hook"></a>Storm Atlas Hook</h3><p>当在 Storm 中成功注册新 topology 时，通知 Atlas。 Storm 在 Storm 客户端提供了一个钩子，backtype.storm.ISubmitterHook，用于提交一个 Storm topology。</p><p>Storm Atlas hook 拦截 hook 后执行，并从 topology 中提取元数据，并使用定义的类型更新 Atlas。 Atlas 在org.apache.atlas.storm.hook.StormAtlasHook 中实现了 Storm 客户端 hook 接口。</p><h3 id="Limitations-3"><a href="#Limitations-3" class="headerlink" title="Limitations"></a>Limitations</h3><p>以下内容适用于集成的第一个版本。</p><ul><li>只有新的 topology 提交已注册到 Atlas，任何生命周期变化都不会反映在 Atlas 中。</li><li>当为要捕获的元数据提交 Storm topology 时，Atlas 服务器需要在线。</li><li>hook 目前不支持捕获自定义 spouts 和 bolts 的 lineage。</li></ul><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>Storm Atlas Hook 需要在客户端手动安装在 Storm 在：$ATLAS_PACKAGE/hook/storm</p><p>Storm Atlas Hook 需要复制到 $STORM_HOME/extlib。 使用 storm 安装路径替换 STORM_HOME。</p><p>在将安装了 atlas hook 到 Storm 后重新启动所有守护进程。</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><h4 id="Storm-Configuration"><a href="#Storm-Configuration" class="headerlink" title="Storm Configuration"></a>Storm Configuration</h4><p>Storm Atlas Hook 需要在 Storm 客户端 $STORM_HOME/conf/storm.yaml 进行配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm.topology.submission.notifier.plugin.class: &quot;org.apache.atlas.storm.hook.StormAtlasHook&quot;</span><br></pre></td></tr></table></figure><p>还设置一个 “集群名称”，将用作在 Atlas 中注册的对象的命名空间。 此名称将用于命名 Storm topology，spouts 和 bolts。</p><p>其他对象（如 Dataset）应该理想地用生成它们的组件的集群名称来标识。 例如， Hive 表和数据库应该使用在 Hive 中设置的集群名称来标识。 如果 Hive 配置在客户端上提交的 Storm topology jar 中可用，并且在那里定义了集群名称，Storm Atlas hook 将选择此选项。 对于 HBase 数据集，这种情况类似。 如果此配置不可用，将使用在 Storm 配置中设置的集群名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atlas.cluster.name: &quot;cluster_name&quot;</span><br></pre></td></tr></table></figure><p>在 $STORM_HOME/conf/storm_env.ini 中, 设置以下环境变量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STORM_JAR_JVM_OPTS:&quot;-Datlas.conf=$ATLAS_HOME/conf/&quot;</span><br></pre></td></tr></table></figure><p>将 ATLAS_HOME 指向 ATLAS 的安装目录.</p><p>你也可以通过程序对 Storm 进行如下配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Config stormConf = new Config();</span><br><span class="line">  ...</span><br><span class="line">  stormConf.put(Config.STORM_TOPOLOGY_SUBMISSION_NOTIFIER_PLUGIN,</span><br><span class="line">  org.apache.atlas.storm.hook.StormAtlasHook.class.getName());</span><br></pre></td></tr></table></figure><h2 id="容错和高可用"><a href="#容错和高可用" class="headerlink" title="容错和高可用"></a>容错和高可用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Apache Atlas 使用各种系统并与其交互，为数据管理员提供元数据管理和数据 lineage。 通过适当地选择和配置这些依赖关系，可以使用 Atlas 实现高度的服务可用性。 本文档介绍了 Atlas 的高可用性支持状态，包括其功能和当前限制，以及实现此级别高可用性所需的配置。</p><h3 id="Atlas-Web-Service"><a href="#Atlas-Web-Service" class="headerlink" title="Atlas Web Service"></a>Atlas Web Service</h3><p>目前，Atlas Web 服务有一个限制，它一次只能有一个活动实例。在早期版本的 Atlas 中，可以配置和保持备份实例。但是，需要手动故障转移才能使此备份实例处于活动状态。</p><p>从这个版本开始，Atlas 将支持带有自动故障转移的 主动/被动 配置中的 Atlas Web 服务的多个实例。这意味着用户可以在不同的物理主机上同时部署和启动 Atlas Web 服务的多个实例。其中一个实例将被自动选择为 “活动” 实例来为用户请求提供服务。其他人将自动被视为 “被动”。如果 “活动” 实例由于故意停止或由于意外故障而变得不可用，则其他实例之一将自动选为 “活动” 实例，并开始为用户请求提供服务。</p><p>“活动” 实例是能够正确响应用户请求的唯一实例。它可以创建，删除，修改或响应元数据对象上的查询。 “被动” 实例将接受用户请求，但会使用 HTTP 重定向将其重定向到当前已知的 “活动” 实例。具体来说，被动实例本身不会响应对元数据对象的任何查询。但是，所有实例（包括主动和被动）都将响应返回有关该实例的信息的管理请求。</p><p>当配置为高可用性模式时，用户可以获得以下操作优势：</p><ul><li>在维护间隔期间不间断服务：如果需要停用 Atlas Web 服务的活动实例进行维护，则另一个实例将自动变为活动状态并可以为请求提供服务。</li><li>在意外故障事件中的不间断服务：如果由于软件或硬件错误，Atlas Web 服务的活动实例失败，另一个实例将自动变为活动状态并可以为请求提供服务。</li></ul><p>在以下小节中，我们将介绍为 Atlas Web 服务设置高可用性所需的步骤。 我们还描述了如何设计部署和客户端以利用此功能。 最后，我们描述一些底层实现的细节。</p><h4 id="Setting-up-the-High-Availability-feature-in-Atlas"><a href="#Setting-up-the-High-Availability-feature-in-Atlas" class="headerlink" title="Setting up the High Availability feature in Atlas"></a>Setting up the High Availability feature in Atlas</h4><p>设置高可用性功能必须满足以下先决条件。</p><ul><li>确保在一组计算机上安装 Apache Zookeeper（建议至少使用3台服务器进行生产）。</li><li>选择 2 个或更多物理机以在其上运行 Atlas Web Service 实例。这些机器定义了我们称为 Atlas 的 “服务器集合”。</li></ul><p>要在 Atlas 中设置高可用性，必须在 atlas-application.properties 文件中定义一些配置选项。虽然配置项的完整列表在配置页中定义，但本节列出了几个主要选项。</p><ul><li><p>高可用性是 Atlas 的可选功能。因此，必须通过将配置选项 atlas.server.ha.enabled 设置为 true 来启用。</p></li><li><p>接下来，定义标识符列表，为您为 Atlas Web Service 实例选择的每个物理机器分配一个标识符。这些标识符可以是简单的字符串，如id1，id2等。它们应该是唯一的，不应包含逗号。</p></li><li><p>将这些标识符的逗号分隔列表定义为选项 atlas.server.ids 的值。</p></li><li><p>对于每个物理机，请列出IP地址/主机名和端口作为配置 atlas.server.address.id 的值，其中 id 指的是此物理机的标识符字符串。</p><ul><li><p>例如，如果您选择了 2 台主机名为 和 的计算机，则可以如下定义配置选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atlas.server.ids=id1,id2</span><br><span class="line">atlas.server.address.id1=host1.company.com:21000</span><br><span class="line">atlas.server.address.id2=host2.company.com:21000</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义使用的 Zookeeper 为 Atlas 提供高可用性功能</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atlas.server.ha.zookeeper.connect=zk1.company.com:2181,zk2.company.com:2181,zk3.company.com:2181</span><br></pre></td></tr></table></figure><ul><li>您可以查看为高可用性功能定义的其他配置选项，并根据需要在 atlas-application.properties 文件中进行设置。</li><li>对于生产环境，Atlas 所依赖的组件也必须在高可用性模式下设置。 这将在以下部分中详细描述。 按照这些说明设置和配置它们。</li><li>在选定的物理机器上安装 Atlas 软件。</li><li>将使用上述步骤创建的 atlas-application.properties 文件复制到所有计算机的配置目录。</li><li>启动相关组件。</li><li>启动 Atlas Web 服务的每个实例。</li></ul><p>要验证高可用性是否正常工作，请在安装了 Atlas Web Service 的每个实例上运行以下脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ATLAS_HOME/bin/atlas_admin.py -status</span><br></pre></td></tr></table></figure><p>此脚本可以打印以下值之一作为响应：</p><ul><li>ACTIVE：此实例处于活动状态，可以响应用户请求。</li><li>PASSIVE：此实例为 PASSIVE。它会将它收到的任何用户请求重定向到当前活动实例。</li><li>BECOMING_ACTIVE：如果服务器正在转换为 ACTIVE 实例，则将打印此消息。在此状态下，服务器无法处理任何元数据用户请求。</li><li>BECOMING_PASSIVE：如果服务器正在转换为 PASSIVE 实例，则将打印此消息。在此状态下，服务器无法处理任何元数据用户请求。</li></ul><p>在正常操作情况下，只有其中一个实例应该打印 ACTIVE 值作为对脚本的响应，而其他实例将打印 PASSIVE。</p><h4 id="配置客户端以使用高可用性功能"><a href="#配置客户端以使用高可用性功能" class="headerlink" title="配置客户端以使用高可用性功能"></a>配置客户端以使用高可用性功能</h4><p>Atlas Web 服务可以通过两种方式访问：</p><ul><li>使用 Atlas Web UI：这是一个基于浏览器的客户端，可用于查询存储在Atlas中的元数据。</li><li>使用 Atlas REST API：由于 Atlas 公开了一个 RESTful API，因此可以使用任何标准的 REST 客户端，包括其他应用程序中的库。事实上，Atlas 附带了一个名为 AtlasClient 的客户端，可以用作创建 REST 客户端访问的示例。</li></ul><p>为了利用客户端中的高可用性功能，可以有两个选项。</p><h4 id="使用中间代理"><a href="#使用中间代理" class="headerlink" title="使用中间代理"></a>使用中间代理</h4><p>启用高可用性访问 Atlas 的最简单的解决方案是安装和配置一些中间代理，其具有基于状态透明地切换服务的能力。一个这样的代理解决方案是 HAProxy。</p><p>下面是一个可以使用的 HAProxy 配置示例。注意，这只是为了说明，而不是作为推荐的生产配置。为此，请参阅 HAProxy文档以获取相应的说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frontend atlas_fe</span><br><span class="line">  bind *:41000</span><br><span class="line">  default_backend atlas_be</span><br><span class="line"></span><br><span class="line">backend atlas_be</span><br><span class="line">  mode http</span><br><span class="line">  option httpchk get /api/atlas/admin/status</span><br><span class="line">  http-check expect string ACTIVE</span><br><span class="line">  balance roundrobin</span><br><span class="line">  server host1_21000 host1:21000 check</span><br><span class="line">  server host2_21000 host2:21000 check backup</span><br><span class="line"></span><br><span class="line">listen atlas</span><br><span class="line">  bind localhost:42000</span><br></pre></td></tr></table></figure><p>以上配置绑定 HAProxy 侦听端口 41000 传入客户端连接。然后根据 HTTP 状态检查将连接路由到主机 host1 或 host2 中的任一个。状态检查是使用 REST URL / api / atlas / admin / status 上的 HTTP GET 完成的，只有当 HTTP 响应包含字符串ACTIVE 时，才认为成功。</p><h4 id="使用活动实例的自动检测"><a href="#使用活动实例的自动检测" class="headerlink" title="使用活动实例的自动检测"></a>使用活动实例的自动检测</h4><p>如果不想设置和管理单独的代理，则使用高可用性功能的另一个选项是构建能够检测状态和重试操作的客户端应用程序。在这样的设置中，可以使用形成集合的所有 Atlas Web 服务实例的 URL 启动客户端应用程序。然后，客户端应调用其中每一个上的 REST URL / api / atlas / admin / status，以确定哪个是活动实例。来自 Active 实例的响应将具有 {Status：ACTIVE}的形式。此外，当客户端在操作过程中遇到任何异常时，它应该再次确定哪些剩余的URL是活动的并重试该操作。</p><p>Atlas 附带的 AtlasClient 类可以用作一个示例客户端库，它实现了使用集合并选择正确的Active服务器实例的逻辑。</p><p>Atlas 中的实用程序（如quick_start.py和import-hive.sh）可以配置为使用多个服务器URL运行。当在此模式下启动时，AtlasClient 自动选择并使用当前活动实例。如果在之间设置了代理，则可以在运行 quick_start.py 或 import-hive.sh 时使用其地址。</p><h4 id="实现-Atlas-高可用"><a href="#实现-Atlas-高可用" class="headerlink" title="实现 Atlas 高可用"></a>实现 Atlas 高可用</h4><p>Atlas 高可用性工作在主 JIRA <a href="https://issues.apache.org/jira/browse/ATLAS-510">ATLAS-510</a> 下进行跟踪。根据其提交的 JIRA 具有关于高可用性功能如何实现的详细信息。在高级别可以调出以下几点：</p><ul><li>活动实例的自动选择以及到新的活动实例的自动故障转移通过领导者选择算法发生。</li><li>对于领导选举，我们使用 Apache Curator 的 Leader Latch Recipe。</li><li>Active 实例是唯一一个在后端存储中初始化，修改或读取状态以保持它们一致的实例。</li><li>此外，当实例被选为活动时，它会刷新后端存储中的任何缓存信息以获取最新信息。</li><li>servlet 过滤器确保只有活动的实例服务用户请求。如果被动实例接收到这些请求，它会自动将它们重定向到当前活动实例。</li></ul><h4 id="Metadata-Store"><a href="#Metadata-Store" class="headerlink" title="Metadata Store"></a>Metadata Store</h4><p>如上所述，Atlas 使用 Titan 来存储它管理的元数据。默认情况下，Atlas 使用独立的 HBase 实例作为 Titan 的后备存储。为了为元数据存储提供 HA，我们建议将 Atlas 配置为使用分布式 HBase 作为 Titan 的后备存储。这意味着您可以从 HBase 提供的 HA 保证中受益。为了将 Atlas 配置为在 HA 模式下使用 HBase，请执行以下操作：</p><ul><li>选择在HA模式中设置的现有 HBase 集群以在 Atlas（OR）中配置在 <a href="http://hbase.apache.org/book.html#quickstart_fully_distributed">HA模式</a> 下设置新的 HBase 集群。<ul><li>如果为 Atlas 设置 HBase，请按照 <a href="http://atlas.apache.org/InstallationSteps.html">Installation Steps</a> 中列出的用于设置 HBase 的说明进行操作。</li></ul></li><li>我们建议在使用 Zookeeper 协调的不同物理主机上的集群中使用多个 HBase 主机（至少2个），以提供 HBase的 冗余和高可用性。<ul><li>有关在 atlas.properties 中配置的选项的 <a href="http://atlas.apache.org/Configuration.html">Configuration page</a> ，请参考配置页面，以便使用 HBase 设置 Atlas。</li></ul></li></ul><h3 id="Index-Store"><a href="#Index-Store" class="headerlink" title="Index Store"></a>Index Store</h3><p>如上所述，Atlas 通过 Titan 索引元数据以支持全文搜索查询。 为了为索引存储提供 HA，我们建议将 Atlas 配置为使用 Solr作为 Titan 的后备索引存储。 为了将 Atlas 配置为在 HA 模式下使用 Solr，请执行以下操作：</p><ul><li>在 HA 模式下选择现有的 SolrCloud 群集设置以在 Atlas（OR）中配置设置新的 SolrCloud 群集。<ul><li>确保 Solr 在至少 2 个物理主机上启动以实现冗余，并且每个主机运行 Solr 节点。</li><li>我们建议将冗余数设置为至少 2。</li></ul></li><li>创建 Atlas 所需的 SolrCloud 集合，如安装步骤中所述</li><li>请参阅配置页面以了解在 atlas.properties 中配置的选项，以使用 Solr 设置 Atlas。</li></ul><h3 id="Notification-Server"><a href="#Notification-Server" class="headerlink" title="Notification Server"></a>Notification Server</h3><p>来自 Hook 的元数据通知事件通过写入到名为 ATLAS_HOOK 的 Kafka topic 发送到 Atlas 。类似地，从 Atlas 到其他集成组件（如Ranger）的事件写入名为 ATLAS_ENTITIES 的 Kafka topic。由于 Kafka 会保留这些消息，即使消费者在发送事件时失败，事件也不会丢失。此外，我们建议 Kafka 也设置容错，以便它具有更高的可用性保证。为了配置 Atlas 在 HA 模式下使用 Kafka，请执行以下操作：</p><ul><li><p>选择在 HA 模式中设置的现有 Kafka 集群以在 Atlas（OR）中配置设置新的 Kafka 集群。</p></li><li><p>我们建议在不同物理主机上的群集中有多个 Kafka 代理，它们使用 Zookeeper 协调，以提供 Kafka 的冗余和高可用性。</p><ul><li>设置至少 2 个物理主机以实现冗余，每个托管一个 Kafka 代理。</li></ul></li><li><p>为 Atlas 使用设置 Kafka 主题：</p><ul><li>ATLAS 主题的分区数应设置为1（numPartitions）</li><li>确定 Kafka 主题的副本数量：将此值设置为至少 2 以进行冗余。</li><li>运行以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper &lt;list of zookeeper host:port entries&gt; --topic ATLAS_HOOK --replication-factor &lt;numReplicas&gt; --partitions 1</span><br><span class="line">$KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper &lt;list of zookeeper host:port entries&gt; --topic ATLAS_ENTITIES --replication-factor &lt;numReplicas&gt; --partitions 1</span><br><span class="line">Here KAFKA_HOME points to the Kafka installation directory.</span><br></pre></td></tr></table></figure><ul><li>在 atlas-application.properties 中进行如下配置:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atlas.notification.embedded=false</span><br><span class="line">atlas.kafka.zookeeper.connect=&lt;comma separated list of servers forming Zookeeper quorum used by Kafka&gt;</span><br><span class="line">atlas.kafka.bootstrap.servers=&lt;comma separated list of Kafka broker endpoints in host:port form&gt; - Give at least 2 for redundancy.</span><br></pre></td></tr></table></figure></li></ul><h3 id="Known-Issues"><a href="#Known-Issues" class="headerlink" title="Known Issues"></a>Known Issues</h3><ul><li>如果托管 Atlas ‘titan’ HTable 的 HBase region servers 停机，Atlas 将无法在 HBase 恢复联机之前从 HBase 存储或检索元数据。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-Apache-Atlas-进行数据治理&quot;&gt;&lt;a href=&quot;#使用-Apache-Atlas-进行数据治理&quot; class=&quot;headerlink&quot; title=&quot;使用 Apache Atlas 进行数据治理&quot;&gt;&lt;/a&gt;使用 Apache Atlas 进行数据</summary>
      
    
    
    
    <category term="hadoop" scheme="http://rczmm.github.io/categories/hadoop/"/>
    
    
    <category term="hadoop" scheme="http://rczmm.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>js对象高级</title>
    <link href="http://rczmm.github.io/2021/09/12/js%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <id>http://rczmm.github.io/2021/09/12/js%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</id>
    <published>2021-09-12T02:21:04.000Z</published>
    <updated>2021-09-12T02:21:44.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><ul><li><p>Object构造函数模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.name = &#x27;Tom&#x27;</span><br><span class="line">obj.setName = function(name)&#123;this.name=name&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象字面量模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name : &#x27;Tom&#x27;,</span><br><span class="line">  setName : function(name)&#123;this.name = name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Person(&#x27;tom&#x27;, 12);</span><br></pre></td></tr></table></figure></li><li><p>构造函数+原型的组合模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">new Person(&#x27;tom&#x27;, 12);</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><ul><li><p>原型链继承 : 得到方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line">function Child()&#123;&#125;</span><br><span class="line">Child.prototype = new Parent(); // 子类型的原型指向父类型实例</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line">var child = new Child(); //有test()</span><br></pre></td></tr></table></figure></li><li><p>借用构造函数 : 得到属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">var child = new Child(&#x27;a&#x27;, &#x27;b&#x27;);  //child.xxx为&#x27;a&#x27;, 但child没有test()</span><br></pre></td></tr></table></figure></li><li><p>组合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">    Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent(); //得到test()</span><br><span class="line">var child = new Child(); //child.xxx为&#x27;a&#x27;, 也有test()</span><br></pre></td></tr></table></figure></li><li><p>new一个对象背后做了些什么?</p><ul><li>创建一个空对象</li><li>给对象设置__proto__, 值为构造函数对象的prototype属性值   this.<strong>proto</strong> = Fn.prototype</li><li>执行构造函数体(给对象添加属性/方法)</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象的创建模式&quot;&gt;&lt;a href=&quot;#对象的创建模式&quot; class=&quot;headerlink&quot; title=&quot;对象的创建模式&quot;&gt;&lt;/a&gt;对象的创建模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Object构造函数模式&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    <category term="html" scheme="http://rczmm.github.io/categories/html/"/>
    
    
    <category term="html" scheme="http://rczmm.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>js函数高级</title>
    <link href="http://rczmm.github.io/2021/09/12/js%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/"/>
    <id>http://rczmm.github.io/2021/09/12/js%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/</id>
    <published>2021-09-12T02:20:15.000Z</published>
    <updated>2021-09-12T02:20:50.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><ul><li>所有函数都有一个特别的属性:<ul><li><code>prototype</code> : 显式原型属性</li></ul></li><li>所有实例对象都有一个特别的属性:<ul><li><code>__proto__</code> : 隐式原型属性</li></ul></li><li>显式原型与隐式原型的关系<ul><li>函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象</li><li>实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li><li>原型对象即为当前实例对象的父对象</li></ul></li><li>原型链<ul><li>所有的实例对象都有__proto__属性, 它指向的就是原型对象</li><li>这样通过__proto__属性就形成了一个链的结构—-&gt;原型链</li><li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li><li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</li></ul></li></ul><h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><ul><li>变量提升与函数提升<ul><li>变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)</li><li>函数提升: 在函数定义语句之前, 就执行该函数</li><li>先有变量提升, 再有函数提升</li></ul></li><li>理解<ul><li>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性</li><li>执行上下文栈: 用来管理产生的多个执行上下文</li></ul></li><li>分类:<ul><li>全局: window</li><li>函数: 对程序员来说是透明的</li></ul></li><li>生命周期<ul><li>全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡</li><li>函数 : 调用函数时产生, 函数执行完时死亡</li></ul></li><li>包含哪些属性:<ul><li>全局 : <ul><li>用var定义的全局变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt;window</li></ul></li><li>函数<ul><li>用var定义的局部变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt; 调用函数的对象, 如果没有指定就是window </li><li>形参变量   ===&gt;对应实参值</li><li>arguments ===&gt;实参列表的伪数组</li></ul></li></ul></li><li>执行上下文创建和初始化的过程<ul><li>全局:<ul><li>在全局代码执行前最先创建一个全局执行上下文(window)</li><li>收集一些全局变量, 并初始化</li><li>将这些变量设置为window的属性</li></ul></li><li>函数:<ul><li>在调用函数时, 在执行函数体之前先创建一个函数执行上下文</li><li>收集一些局部变量, 并初始化</li><li>将这些变量设置为执行上下文的属性</li></ul></li></ul></li></ul><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><ul><li>理解:<ul><li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li><li>作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量</li></ul></li><li>分类:<ul><li>全局</li><li>函数</li><li>js没有块作用域(在ES6之前)</li></ul></li><li>作用<ul><li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li><li>作用域链: 查找变量</li></ul></li><li>区别作用域与执行上下文<ul><li>作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了</li><li>执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失</li><li>联系: 执行上下文环境是在对应的作用域中的</li></ul></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li><p>理解:</p><ul><li>当嵌套的内部函数引用了外部函数的变量时就产生了闭包</li><li>通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性</li></ul></li><li><p>作用:</p><ul><li>延长局部变量的生命周期</li><li>让函数外部能操作内部的局部变量</li></ul></li><li><p>写一个闭包程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line">  function fn2() &#123;</span><br><span class="line">    a++;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  return fn2;</span><br><span class="line">&#125;</span><br><span class="line">var f = fn1();</span><br><span class="line">f();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></li><li><p>闭包应用:</p><ul><li>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为</li><li>循环遍历加监听</li><li>JS框架(jQuery)大量使用了闭包</li></ul></li><li><p>缺点:</p><ul><li>变量占用内存的时间可能会过长</li><li>可能导致内存泄露</li><li>解决:<ul><li>及时释放 : f = null; //让内部函数对象成为垃圾对象</li></ul></li></ul></li></ul><h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><ol><li>内存溢出</li></ol><ul><li>一种程序运行出现的错误</li><li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li></ul><ol start="2"><li>内存泄露</li></ol><ul><li>占用的内存没有及时释放</li><li>内存泄露积累多了就容易导致内存溢出</li><li>常见的内存泄露:<ul><li>意外的全局变量</li><li>没有及时清理的计时器或回调函数</li><li>闭包</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原型与原型链&quot;&gt;&lt;a href=&quot;#原型与原型链&quot; class=&quot;headerlink&quot; title=&quot;原型与原型链&quot;&gt;&lt;/a&gt;原型与原型链&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;所有函数都有一个特别的属性:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt; : </summary>
      
    
    
    
    <category term="html" scheme="http://rczmm.github.io/categories/html/"/>
    
    
    <category term="html" scheme="http://rczmm.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>js基础总结深入</title>
    <link href="http://rczmm.github.io/2021/09/12/js%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E6%B7%B1%E5%85%A5/"/>
    <id>http://rczmm.github.io/2021/09/12/js%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E6%B7%B1%E5%85%A5/</id>
    <published>2021-09-12T02:20:15.000Z</published>
    <updated>2021-09-12T02:41:56.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型的分类和判断"><a href="#数据类型的分类和判断" class="headerlink" title="数据类型的分类和判断"></a>数据类型的分类和判断</h2><ul><li>基本(值)类型<ul><li>Number —– 任意数值 ——– typeof</li><li>String —– 任意字符串 —— typeof</li><li>Boolean —- true/false —– typeof</li><li>undefined — undefined —– typeof/===</li><li>null ——– null ———- ===</li></ul></li><li>对象(引用)类型<ul><li>Object —– typeof/instanceof</li><li>Array —— instanceof</li><li>Function —- typeof</li></ul></li></ul><h2 id="数据-变量-内存的理解"><a href="#数据-变量-内存的理解" class="headerlink" title="数据,变量, 内存的理解"></a>数据,变量, 内存的理解</h2><ul><li>什么是数据?<ul><li>在内存中可读的, 可传递的保存了特定信息的’东东’</li><li>一切皆数据, 函数也是数据</li><li>在内存中的所有操作的目标: 数据</li></ul></li><li>什么是变量?<ul><li>在程序运行过程中它的值是允许改变的量</li><li>一个变量对应一块小内存, 它的值保存在此内存中  </li></ul></li><li>什么是内存?<ul><li>内存条通电后产生的存储空间(临时的)</li><li>一块内存包含2个方面的数据<ul><li>内部存储的数据</li><li>地址值数据</li></ul></li><li>内存空间的分类<ul><li>栈空间: 全局变量和局部变量</li><li>堆空间: 对象 </li></ul></li></ul></li><li>内存,数据, 变量三者之间的关系<ul><li>内存是容器, 用来存储不同数据</li><li>变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  </li></ul></li></ul><h2 id="对象的理解和使用"><a href="#对象的理解和使用" class="headerlink" title="对象的理解和使用"></a>对象的理解和使用</h2><ul><li><p>什么是对象?</p><ul><li>多个数据(属性)的集合</li><li>用来保存多个数据(属性)的容器</li></ul></li><li><p>属性组成:</p><ul><li>属性名 : 字符串(标识)</li><li>属性值 : 任意类型</li></ul></li><li><p>属性的分类:</p><ul><li>一般 : 属性值不是function  描述对象的状态</li><li>方法 : 属性值为function的属性  描述对象的行为</li></ul></li><li><p>特别的对象</p><ul><li>数组: 属性名是0,1,2,3之类的索引</li><li>函数: 可以执行的</li></ul></li><li><p>如何操作内部属性(方法)</p><ul><li><p>.属性名</p></li><li><p>[‘属性名’]: 属性名有特殊字符/属性名是一个变量</p></li></ul></li></ul><h2 id="函数的理解和使用"><a href="#函数的理解和使用" class="headerlink" title="函数的理解和使用"></a>函数的理解和使用</h2><ul><li><p>什么是函数?</p><ul><li>用来实现特定功能的, n条语句的封装体</li><li>只有函数类型的数据是可以执行的, 其它的都不可以</li></ul></li><li><p>为什么要用函数?</p><ul><li>提高复用性</li><li>便于阅读交流</li></ul></li><li><p>函数也是对象</p><ul><li>instanceof Object===true</li><li>函数有属性: prototype</li><li>函数有方法: call()/apply()</li><li>可以添加新的属性/方法</li></ul></li><li><p>函数的3种不同角色</p><ul><li>一般函数 : 直接调用</li><li>构造函数 : 通过new调用</li><li>对象 : 通过.调用内部的属性/方法</li></ul></li><li><p>函数中的this</p><ul><li>显式指定谁: obj.xxx()</li><li>通过call/apply指定谁调用: xxx.call(obj)</li><li>不指定谁调用: xxx()  : window</li><li>回调函数: 看背后是通过谁来调用的: window/其它</li></ul></li><li><p>匿名函数自调用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(w, obj)&#123;</span><br><span class="line">  //实现代码</span><br><span class="line">&#125;)(window, obj)</span><br></pre></td></tr></table></figure><ul><li>专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式                          </li></ul></li><li><p>回调函数的理解</p><ul><li>什么函数才是回调函数?<ul><li>你定义的</li><li>你没有调用</li><li>但它最终执行了(在一定条件下或某个时刻)</li></ul></li><li>常用的回调函数<ul><li>dom事件回调函数</li><li>定时器回调函数</li><li>ajax请求回调函数</li><li>生命周期回调函数</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据类型的分类和判断&quot;&gt;&lt;a href=&quot;#数据类型的分类和判断&quot; class=&quot;headerlink&quot; title=&quot;数据类型的分类和判断&quot;&gt;&lt;/a&gt;数据类型的分类和判断&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基本(值)类型&lt;ul&gt;
&lt;li&gt;Number —– 任意数值 —</summary>
      
    
    
    
    <category term="html" scheme="http://rczmm.github.io/categories/html/"/>
    
    
    <category term="html" scheme="http://rczmm.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>html学习笔记01</title>
    <link href="http://rczmm.github.io/2021/09/10/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <id>http://rczmm.github.io/2021/09/10/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</id>
    <published>2021-09-10T01:13:27.000Z</published>
    <updated>2021-09-11T03:54:24.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、html"><a href="#1、html" class="headerlink" title="1、html"></a>1、html</h2><p>html作为一门超文本标记语言，包括一系列的标签，它通过这些标签将网络文档结构统一化，通过浏览器进行解析与阅读。</p><p>html文本是由html（htm）为后缀的由html命令组成的描述性文本，通过对标签的使用，可以描述文字，图形，动画，声音，表格，链接等等。</p><h2 id="2、position"><a href="#2、position" class="headerlink" title="2、position"></a>2、position</h2><p>dom position属性。</p><p>position属性把元素放置到一个静态的、相对的、绝对的、固定的的位置中去。</p><p>要理解这个属性，首先应该明白什么是流？</p><p>所谓的文档流，指的其实就是元素排版布局过程中，元素会自动从左到右，从上往下的流式排列。并最终窗体自上而下分成一行行，并在每行中按从左至右的排放元素。</p><p>顺便说一下，除了设置position的属性值为absolute与fixed之外，float对象也会<strong>打乱这个队列</strong>，这些都会暂时脱离流的存在，clear之后才会回到流之中（单指float）。</p><p>（float：right显然会打乱文档流，但是float：left也有这样的效果：其实是因为子元素设置了float属性，然而父元素没有设置（或者保持了默认的static），则子元素会从父元素中溢出，（最明显的表现就是，父元素不会随着子元素的扩大而扩大），因为当元素设置了float这个属性之后，其他没有设置float属性的盒子或者是标签会无视这个属性，也就是其他没有设置浮动的元素会和他进行叠加，这就可以当作脱离了文档流。但是要注意一点的就是，与position：absolute不同的是，其他盒子内的元素依然会为了float元素让出位置，因此不会出现互相叠加的情况。这种情况下消除浮动就可以解决）</p><p>其中，默认得到html流属性其实就是static，默认布局，这种布局，是没有定位的，而且不会继承父元素的属性，w3c的文档里提到，忽略top、bottom、left、right或者z-index声明，他是存在于流里面的。除此之外还有relative，相对布局，假如父元素采用了这种布局，那么子元素就是相对于父元素的绝对定位，一般会配合到top、right、bottom、left来使用，这种布局其实也是存在于流里面的。但是fixed浮动布局，是相对于浏览器窗口的绝对布局（上下滚动页面），一般同样配合上下左右来使用，这个布局是脱离了流的存在的。（！！ie不兼容这种模式！！）</p><p>absolute布局，绝对布局，相对于页面的绝对布局（上下滚动），同样配合四方使用，脱离了流的存在，最后一种我用的比较少，inherit布局，w3c的文档规定他是继承了父元素position的值。</p><p><strong>如果我们想在页面上固定元素，毫无疑问，选择absolute，他是以页面左上角为（0，0），根据tblr来布局的，与fixed不同，f是当前窗口布局，也是左上角为（0，0），但是会根据滚动条一起滚动，相对于当前窗口的位置不变。relative是相对位置，指的是子节点和父节点的关系，当一个子节点在父节点中的时候，默认的position就是relative，在子节点包含在父节点中，这个时候就算我们设置的子节点是absolute，也会成为relative，也就是相对于父节点的左上角排版。</strong></p><p><strong>总结：在html中，永远没有绝对，只有相对。所有元素都是document的子元素。</strong></p><h2 id="3、相对路径与绝对路径"><a href="#3、相对路径与绝对路径" class="headerlink" title="3、相对路径与绝对路径"></a>3、相对路径与绝对路径</h2><p><strong>参照物不同</strong>，导致的差别。</p><p>在计算机中，这是一个避免不了问题，无论是path环境变量还是classpath类加载路径都是源自于这两个路径的差别。他们的差别也很简单，绝对路径以磁盘为参照物，而相对路径则以当前路径为参照。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、html&quot;&gt;&lt;a href=&quot;#1、html&quot; class=&quot;headerlink&quot; title=&quot;1、html&quot;&gt;&lt;/a&gt;1、html&lt;/h2&gt;&lt;p&gt;html作为一门超文本标记语言，包括一系列的标签，它通过这些标签将网络文档结构统一化，通过浏览器进行解析与阅</summary>
      
    
    
    
    <category term="html" scheme="http://rczmm.github.io/categories/html/"/>
    
    
    <category term="html" scheme="http://rczmm.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>numpy</title>
    <link href="http://rczmm.github.io/2021/09/09/numpy/"/>
    <id>http://rczmm.github.io/2021/09/09/numpy/</id>
    <published>2021-09-09T01:26:33.000Z</published>
    <updated>2021-09-17T01:24:17.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><p>numpy是一个python的扩展程序库，支持大量的维度数组和矩阵运算，除此之外还为数组计算提供了大量的科学库，运行速度很快，包含了一个强大的多维数组对象ndarray，广播功能函数，整合了c与c++语言的工具，还有线性代数、随机数生成等功能。</p><h2 id="numpy是什么？"><a href="#numpy是什么？" class="headerlink" title="numpy是什么？"></a>numpy是什么？</h2><p>NumPy是使用Python进行科学计算的基础软件包。除其他外，它包括：</p><ul><li>功能强大的N维数组对象。</li><li>精密广播功能函数。</li><li>集成 C/C+和Fortran 代码的工具。</li><li>强大的线性代数、傅立叶变换和随机数功能。</li></ul><h2 id="numpy两大利器"><a href="#numpy两大利器" class="headerlink" title="numpy两大利器"></a>numpy两大利器</h2><h3 id="利器之一：Ndarray"><a href="#利器之一：Ndarray" class="headerlink" title="利器之一：Ndarray"></a>利器之一：Ndarray</h3><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。ndarray 对象是用于存放同类型元素的多维数组。ndarray 中的每个元素在内存中都有相同存储大小的区域。</p><h3 id="利器之二：切片和索引"><a href="#利器之二：切片和索引" class="headerlink" title="利器之二：切片和索引"></a>利器之二：切片和索引</h3><p>ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。</p><h2 id="numpy的主要应用"><a href="#numpy的主要应用" class="headerlink" title="numpy的主要应用"></a>numpy的主要应用</h2><p>NumPy是一个功能强大的Python库，主要用于对多维数组执行计算。NumPy这个词来源于两个单词– <code>Numerical</code>和<code>Python</code>。NumPy提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算。这类数值计算广泛用于以下任务：</p><ul><li><strong>机器学习模型</strong>：在编写机器学习算法时，需要对矩阵进行各种数值计算。例如矩阵乘法、换位、加法等。NumPy提供了一个非常好的库，用于简单(在编写代码方面)和快速(在速度方面)计算。NumPy数组用于存储训练数据和机器学习模型的参数。</li><li><strong>图像处理和计算机图形学</strong>：计算机中的图像表示为多维数字数组。NumPy成为同样情况下最自然的选择。实际上，NumPy提供了一些优秀的库函数来快速处理图像。例如，镜像图像、按特定角度旋转图像等。</li><li><strong>数学任务</strong>：NumPy对于执行各种数学任务非常有用，如数值积分、微分、内插、外推等。因此，当涉及到数学任务时，它形成了一种基于Python的MATLAB的快速替代。</li></ul><h2 id="numpy安装"><a href="#numpy安装" class="headerlink" title="numpy安装"></a>numpy安装</h2><p>值得一提的是，python官网提供的发行版并没有包含numpy库，我们需要单独的下载，其中最简单的就是通过pip安装，安装成功后，可以使用numpy中生成对角矩阵的eye方法来检测是否安装成功。</p><p>在你的计算机上安装NumPy的最快也是最简单的方法是在shell上使用以下命令：<code>pip install numpy</code>。</p><p>这将在你的计算机上安装最新/最稳定的NumPy版本。通过PIP安装是安装任何Python软件包的最简单方法。</p><h2 id="NumPy-Ndarray-对象"><a href="#NumPy-Ndarray-对象" class="headerlink" title="NumPy Ndarray 对象"></a>NumPy Ndarray 对象</h2><p>NumPy提供的最重要的数据结构是一个称为NumPy数组(Ndarray)的强大对象。NumPy数组是通常的Python数组的扩展。NumPy数组配备了大量的函数和运算符，可以帮助我们快速编写上面讨论过的各种类型计算的高性能代码。</p><p>这是numpy中一个重要的特性，他是同一类数据类型的集合，以0为下标开始索引。</p><p>这是一个存放同类对象的多维数组，其中每个元素都有相同的区域储存，ndarray内部由一个指向数据的指针，数据类型，一个描述数组形状的数组，一个跨度元组组成。</p><p><img src="/2021/09/09/numpy/image-20210909093335315.png" alt="mdarray对象内部结构">值得一提的是，跨度可以是负数，这样数组在内存之中就会产生向前移动的效果。</p><p>创建这个对象只需要调用array函数。            </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th>object</th><th>数组或者嵌套的数列（也是对象中的基本元素）</th></tr></thead><tbody><tr><td>dtype</td><td>数组中元素的数据类型</td></tr><tr><td>copy</td><td>数组中元素是否可复制</td></tr><tr><td>order</td><td>数组中元素的样式，C为行方向，F为列方向，A为任意方向（默认）</td></tr><tr><td>subok</td><td>返回一个与基本类型一样的数组</td></tr><tr><td>ndmin</td><td>指定生成数组的最小维度</td></tr></tbody></table><p>让我们看看如何快速定义一维NumPy数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">my_array = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) </span><br><span class="line"><span class="built_in">print</span>(my_array)</span><br></pre></td></tr></table></figure><p>在上面的简单示例中，我们首先使用import numpy作为np导入NumPy库。然后，我们创建了一个包含5个整数的简单NumPy数组，然后我们将其打印出来。继续在自己的机器上试一试。在看 “NumPy安装” 部分下面的步骤的时候，请确保已在计算机中安装了NumPy.</p><p>现在让我们看看我们可以用这个特定的NumPy数组能做些什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> my_array.shape</span><br></pre></td></tr></table></figure><p>它会打印我们创建的数组的形状：<code>(5, )</code>。意思就是 my_array 是一个包含5个元素的数组。</p><p>我们也可以打印各个元素。就像普通的Python数组一样，NumPy数组的起始索引编号为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> my_array[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> my_array[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>上述命令将分别在终端上打印1和2。我们还可以修改NumPy数组的元素。例如，假设我们编写以下2个命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_array[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> my_array</span><br></pre></td></tr></table></figure><p>我们将在屏幕上看到：<code>[-1,2,3,4,5]</code>。</p><p>现在假设，我们要创建一个长度为5的NumPy数组，但所有元素都为0，我们可以这样做吗？是的。NumPy提供了一种简单的方法来做同样的事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_new_array = np.zeros((<span class="number">5</span>)) </span><br><span class="line"><span class="built_in">print</span> my_new_array</span><br></pre></td></tr></table></figure><p>我们将看到输出了 <code>[0., 0., 0., 0., 0.]</code>。与 <code>np.zeros</code> 类似，我们也有 <code>np.ones</code>。  如果我们想创建一个随机值数组怎么办？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_random_array = np.random.random((<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span> my_random_array</span><br></pre></td></tr></table></figure><p>我们得到的输出看起来像 [0.22051844 0.35278286 0.11342404 0.79671772 0.62263151] 这样的数据。你获得的输出可能会有所不同，因为我们使用的是随机函数，它为每个元素分配0到1之间的随机值。</p><h2 id="NumPy-数据类型"><a href="#NumPy-数据类型" class="headerlink" title="NumPy 数据类型"></a>NumPy 数据类型</h2><p>numpy的数据类型内含，int与float由8到64位不等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;numpy&quot;&gt;&lt;a href=&quot;#numpy&quot; class=&quot;headerlink&quot; title=&quot;numpy&quot;&gt;&lt;/a&gt;numpy&lt;/h1&gt;&lt;p&gt;numpy是一个python的扩展程序库，支持大量的维度数组和矩阵运算，除此之外还为数组计算提供了大量的科学库，运行</summary>
      
    
    
    
    <category term="python" scheme="http://rczmm.github.io/categories/python/"/>
    
    
    <category term="python" scheme="http://rczmm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>进程基础概念</title>
    <link href="http://rczmm.github.io/2021/09/01/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://rczmm.github.io/2021/09/01/%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-09-01T07:27:13.000Z</published>
    <updated>2021-09-01T07:42:13.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>一般地，现代程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和io设备。处理器看上去就像在不间断的一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象就是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的的概念之一。</p><p>进程是操作系统对一个正在运行的程序的一种抽象，在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件。而<strong>并发运行</strong>，则是说一个进程的指令和另外一个进程的指令其实是交错着在执行的。</p><p>在大多数系统中，需要运行的进程数是可以多于可以运行他们的cpu个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序，这是通过处理器在进程之间切换来实现的，操作系统实现这种交错执行的机制成为<strong>上下文切换</strong>。</p><p>操作系统保持跟踪进程运行所需的所有状态信息，这种状态，也就是上下文，包括许多信息，比如pc（寄存器，处理器核心（大小为一个字的储存设备））和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单核处理器都只能执行一个进程的代码，当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。</p><p>一个进程到另一个进程的转换是由操作系统内核负责管理的，内核不是一个独立的进程，他是操作系统用来管理全部进程所用的代码和数据结构的集合。他是操作系统代码常驻主存的部分，当app需要操作系统的某些操作时，例如最简单的读写文件，内核就会执行一条特殊的系统调用指令，将控制权传递给内核，然后内核执行被请求的操作并返回app。</p><p>现在进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作，以后会揭示这项工作的基本原理，以及app是如何创建和控制他们的进程的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;p&gt;一般地，现代程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和io设备。处</summary>
      
    
    
    
    <category term="操作系统" scheme="http://rczmm.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://rczmm.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>信息就是位加上下文</title>
    <link href="http://rczmm.github.io/2021/08/16/%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://rczmm.github.io/2021/08/16/%E4%BF%A1%E6%81%AF%E5%B0%B1%E6%98%AF%E4%BD%8D%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2021-08-16T15:32:43.000Z</published>
    <updated>2021-08-16T16:23:56.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机系统是由硬件和系统软件组成的，他们共同的来运行应用程序。</p><p>我们通过一个简单的c程序输出hello程序的生命周期来开始分析：从它被程序员创建开始，到在系统上运行，输出简单的信息，然后终止。</p><h1 id="信息就是位加上下文"><a href="#信息就是位加上下文" class="headerlink" title="信息就是位加上下文"></a>信息就是位加上下文</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;计算机系统是由硬件和系统软件组成的，他们共同的来运行应用程序。&lt;/p&gt;
&lt;p&gt;我们通过一个简单的c程序输出hello程序的生命周期来开始分析</summary>
      
    
    
    
    <category term="操作系统" scheme="http://rczmm.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://rczmm.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>io编程</title>
    <link href="http://rczmm.github.io/2021/08/12/io%E7%BC%96%E7%A8%8B/"/>
    <id>http://rczmm.github.io/2021/08/12/io%E7%BC%96%E7%A8%8B/</id>
    <published>2021-08-12T08:58:23.000Z</published>
    <updated>2021-08-16T15:31:48.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="io编程"><a href="#io编程" class="headerlink" title="io编程"></a>io编程</h1><p>io（input|output，输入|输出）可以实现数据的读取和写入的操作。Java针对io提供了一给工具包。</p><h2 id="file文件操作"><a href="#file文件操作" class="headerlink" title="file文件操作"></a>file文件操作</h2><p>file类是一个与文件本身操作有关的类，创建、删除、重命名、取得文件大小、修改日期等常见的系统文件操作。</p><h3 id="file类的基本使用"><a href="#file类的基本使用" class="headerlink" title="file类的基本使用"></a>file类的基本使用</h3><p>如果要使用file类则必须提供完整的文件操作路径，对于文件路径的设置可以通过file类的构造方法来完成。</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>public File(String pathname)</td><td>构造</td><td>给定一个操作文件的完整路径</td></tr><tr><td>public File(String parent, String child)</td><td>构造</td><td>规定操作文件的完整路径和子文件名称</td></tr><tr><td>public boolean createNewFile() throws IOException</td><td>普通</td><td>创建文件</td></tr><tr><td>public boolean delete()</td><td>普通</td><td>删除文件</td></tr><tr><td>public boolean exists()</td><td>普通</td><td>判断文件路径是否存在</td></tr></tbody></table><h3 id="file类操作深入"><a href="#file类操作深入" class="headerlink" title="file类操作深入"></a>file类操作深入</h3><p>路径分割符：public static final String separator</p><p>文件路径定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;E:&quot;+File.separator+&quot;demo.txt&quot;</span><br></pre></td></tr></table></figure><p>file父路径操作方法</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>public File getParentFile()</td><td>普通</td><td>获取父路径</td></tr><tr><td>public boolean mkdirs()</td><td>普通</td><td>创建指定目录</td></tr></tbody></table><h3 id="获取文件元信息"><a href="#获取文件元信息" class="headerlink" title="获取文件元信息"></a>获取文件元信息</h3><p><img src="/2021/08/12/io%E7%BC%96%E7%A8%8B/image-20210812171347514.png" alt="image-20210812171347514"></p><h2 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h2><p><img src="/2021/08/12/io%E7%BC%96%E7%A8%8B/image-20210812171601095.png" alt="image-20210812171601095"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;io编程&quot;&gt;&lt;a href=&quot;#io编程&quot; class=&quot;headerlink&quot; title=&quot;io编程&quot;&gt;&lt;/a&gt;io编程&lt;/h1&gt;&lt;p&gt;io（input|output，输入|输出）可以实现数据的读取和写入的操作。Java针对io提供了一给工具包。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://rczmm.github.io/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://rczmm.github.io/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2021-08-06T13:03:56.000Z</published>
    <updated>2021-08-12T08:56:29.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><p>多线程编程是java最重要的特性之一，利用多线程可以提升单位时间内的程序处理性能，也是高并发的主要设计形式。</p><h2 id="1、进程和线程"><a href="#1、进程和线程" class="headerlink" title="1、进程和线程"></a>1、进程和线程</h2><p>计算机系统不断的升级，每一次升级都是在提升硬件处理性能。</p><p>进程是程序的动态执行过程，包括代码加载、执行到执行完毕的一个完整过程，这个过程也是进程本身产生、发展到消亡的过程。多进程系统可以同时运行多个进程（程序），由于cpu分时机制，每一个进程都可以循环得到自己的cpu时间片(运行时间段)，由于cpu执行速度很快，看起来就像是同时运行一样。</p><p>（进程在os中是调度切换执行的、每一个进程都有一个cpu时间片，在cpu时间片上运行完毕后切换到下一个进程）。</p><p>Windows属于多进程的处理操作，但是这个时候依然只有一组资源，所以说在同一个时间段会有多个程序共同执行，而同一个时间点上只能有一个进程执行。</p><p>多进程可以提高硬件资源的利用率，但是进程的启动与销毁依然需要大量的系统性能，导致程序执行下降，进一步提升并发操作的处理能力，在进程的基础上又提供了多线程，线程依附于指定的进程，并且可以快速启动和并发执行。</p><h2 id="java多线程实现"><a href="#java多线程实现" class="headerlink" title="java多线程实现"></a>java多线程实现</h2><p>依靠一个线程的主体类，主体类定义的时候有一些特殊的要求，继承thread类，实现runnable或者callable接口来完成定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day6;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    public MyThread(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int x = 1 ; x&lt;10;x++)&#123;</span><br><span class="line">            System.out.println(this.title+&quot;|&quot;+x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyThread(&quot;线程A&quot;).start();</span><br><span class="line">        new MyThread(&quot;线程B&quot;).start();</span><br><span class="line">        new MyThread(&quot;线程C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义了一个线程类，同时覆写了thread里的run方法，这个方法里实现了输出，多线程的执行方法都是fun中定义，但是多线程启动的时候不能直接调用run方法，由于多线程需要并发执行，因此需要调用操作系统的资源调度才可以，在java中就必须调用start方法，调用start方法时会间接的调用run方法。</p><p>结果分析：多个线程之间是彼此交替运行。</p><p>runnable和callable的区别：</p><p>前者比较早，后者比较晚。</p><p>runnable只提供了一个run方法，并且没有返回值的</p><p>callable提供有call方法，并且可以有返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day9;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line">    public MyThread(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int x = 1; x &lt; 10; x++) &#123;</span><br><span class="line">            System.out.println(this.title + &quot;:   &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(new MyThread(&quot;aaa&quot;));</span><br><span class="line">        Thread t2 = new Thread(new MyThread(&quot;bbb&quot;));</span><br><span class="line">        Thread t3 = new Thread(new MyThread(&quot;ccc&quot;));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runnable线程实现类结构</p><p><img src="/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20210809211257691.png" alt="image-20210809211257691"></p><p>并发资源访问（卖票程序）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day9;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private int ticket = 50;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int x = 0; x &lt; 100; x++) &#123;</span><br><span class="line">            if (this.ticket &gt; 0)&#123;</span><br><span class="line">                System.out.println(&quot;卖票，ticket  &quot;+this.ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread m1 = new MyThread();</span><br><span class="line">        new Thread(m1).start();</span><br><span class="line">        new Thread(m1).start();</span><br><span class="line">        new Thread(m1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CALLABLE实现多线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day9;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">class mythread11 implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        for (int x = 0;x&lt;10;x++)&#123;</span><br><span class="line">            System.out.println(&quot;程序执行：  &quot;+x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;www.baidu,com&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo02 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new mythread11());</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot; &quot;+task.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程运行状态</p><p>要想实现多线程，必须在主线程中创建新的线程对象。</p><p>任意线程一般来说都有五种基本状态：创建、就绪、运行、阻塞、终止。</p><p><img src="/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20210809214300501.png" alt="image-20210809214300501"></p><blockquote><p>基本转换状态</p></blockquote><p>多线程常用操作方法：</p><p>1、线程的取名</p><p>线程本身属于不可见的运行状态，每次操作时间是无法预料的，所以如果要想在程序中操作线程，唯一的依靠就是线程名称。</p><p>获取当前线程对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native Thread currentThread();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day9;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class my01 implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        my01 m1 = new my01();</span><br><span class="line">        new Thread(m1,&quot;A&quot;).start();</span><br><span class="line">        new Thread(m1,&quot;B&quot;).start();</span><br><span class="line">        new Thread(m1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程在哪里？</p><p>每一个jvm运行就是一个进程（当用户执行java命令执行一个类的时候就表示启动了一个jvm进程，而主方法就是这个进程上的一个线程）</p><p><img src="/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20210811150419324.png" alt="image-20210811150419324"></p><p>如果等待子线程完成？</p><p>（主线程的第n个操作任务需要子线程处理后的结果）</p><p>需要引入线程等待和唤醒机制</p><p>线程休眠</p><p>当一个线程启动后会按照既定的结构快速的执行完毕，如果需要暂缓线程的执行速度，就可以利用thread类中提供的休眠方法完成。</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>public static native void sleep(long millis) throws InterruptedException;</td><td>普通</td><td>设置线程休眠的毫秒数，时间一到自动唤醒。</td></tr><tr><td>public static void sleep(long millis, int nanos) throws InterruptedException</td><td>普通</td><td>设置线程休眠的毫秒数和纳秒数，时间一到自动唤醒</td></tr></tbody></table><p>在进行休眠的有可能产生中断异常InterruptedException，程序中必须强制性的进程该异常的捕获与处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Runnable run = () -&gt; &#123;</span><br><span class="line">            for (int x = 0; x &lt; 10;x++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int y = 0; y &lt; 5; y++) &#123;</span><br><span class="line">            new Thread(run,&quot;thread--&quot;+y).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程中断</p><p>在线程在执行过程中也可以被另外一个线程中断执行。</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>public boolean isInterrupted()</td><td>普通</td><td>判断线程是否被中断</td></tr><tr><td>public void interrupt()</td><td>普通</td><td>中断线程执行</td></tr></tbody></table><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">public class Threadinterrupt &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">           System.out.println(&quot;准备睡觉，10秒钟之内不要打扰我我！&quot;);</span><br><span class="line">           try &#123;</span><br><span class="line">               Thread.sleep(10000);</span><br><span class="line">               System.out.println(&quot;睡醒了，开始学习！！&quot;);</span><br><span class="line">           &#125;catch (InterruptedException e)&#123;</span><br><span class="line">               System.out.println(&quot;睡觉被打扰了，好烦！！！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        if (!thread.isInterrupted())&#123;</span><br><span class="line">            System.out.println(&quot;在你睡觉的旁边敲锣打鼓！&quot;);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程强制执行</p><p>在多线程并发执行中每一个线程对象都会交替执行，如果这个时候某个线程对象需要优先执行完成，则可以设置为强制执行，也就是等这个线程执行完毕了再执行其他线程。</p><p>线程强制执行的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final void join() throws InterruptedException</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">public class enforcement &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Thread main = Thread.currentThread();</span><br><span class="line">        Thread thread = new Thread(() -&gt;&#123;</span><br><span class="line">            for (int x = 0;x&lt;10;x++)&#123;</span><br><span class="line">                if(x == 3)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        main.join();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(200);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;执行：  &quot;+x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;随便一个线程！&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        for(int x=0;x&lt;10;x++)&#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            System.out.println(&quot;霸道的mian线程= &quot;+x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本程序启动了两个线程，main和子线程，在不满足条件时，两个线程交替执行，满足时，主线程执行完毕之后再执行子线程中的内容。</p><p>线程礼让</p><p>满足某些条件，可以将当前调度给其他线程执行，自己等待下次调度再执行。</p><p>线程礼让</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void yield();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">public class Threadcomity &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Thread thread = new Thread(()-&gt;&#123;</span><br><span class="line">           for (int x= 0;x&lt;10;x++)&#123;</span><br><span class="line">               if (x % 3==0 )&#123;</span><br><span class="line">                   Thread.yield();</span><br><span class="line">                   System.out.println(&quot;礼让！&quot;+Thread.currentThread().getName());</span><br><span class="line">               &#125;</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(100);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+&quot;执行：  &quot;+x);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,&quot;随意的一个线程&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        for (int x=0;x&lt;10;x++)&#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            System.out.println(&quot;main线程：&quot;+x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程优先级</p><p>在Java线程操作中，所有线程在运行前都是就绪状态，此时设置优先级，进行资源调度。</p><table><thead><tr><th>方法或常量</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>public static final int MIN_PRIORITY</td><td>常量</td><td>最低优先级，1</td></tr><tr><td>public static final int NORM_PRIORITY</td><td>常量</td><td>中等优先级，5</td></tr><tr><td>public static final int MAX_PRIORITY</td><td>常量</td><td>最高优先级，10</td></tr><tr><td>public final void setPriority(int newPriority)</td><td>方法</td><td>设置线程优先级</td></tr><tr><td>public final int getPriority()</td><td>方法</td><td>取得线程优先级</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">public class threadpriority &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable run = () -&gt;&#123;</span><br><span class="line">            for (int x=0;x&lt;10;x++)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;：&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(run,&quot;线程A&quot;);</span><br><span class="line">        Thread t2 = new Thread(run,&quot;线程B&quot;);</span><br><span class="line">        Thread t3 = new Thread(run,&quot;线程C&quot;);</span><br><span class="line">        Thread t4 = new Thread(run,&quot;线程D&quot;);</span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t4.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t3.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        System.out.println(&quot;===========&quot;);</span><br><span class="line">        t1.getPriority();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程同步与死锁：</p><p>多线程访问同一资源，一定会出现某些问题，例如，资源操作的完整性。</p><p>卖票问题：</p><p>假设现在剩下最后一张票，当第一个线程满足条件时，其他的线程也满足，同时进行自减，就有可能造成负数。</p><p>线程同步处理：</p><p>造成并发资源访问不同步的主要原因在于没有将若干个逻辑单元进行整体锁定。也就是判断数据和修改数据时只允许一个线程进行处理，而其他线程需要等待当前线程执行完毕之后才可以继续执行，这样就使得在同一个时间段内，只允许一个线程执行操作，从而实现同步处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized</span><br></pre></td></tr></table></figure><p>关键字实现同步处理，同步的关键时要加锁，对于锁的操作方式有两种，同步代码块，同步方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">    private int ticket = 20;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            synchronized (this)&#123;</span><br><span class="line">                if (ticket &gt; 0)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;卖票：  &quot;+this.ticket--);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    System.out.println(&quot;卖光了！！！&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Threadsynchronization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread mt = new MyThread();</span><br><span class="line">        new Thread(mt,&quot;售票员A&quot;).start();</span><br><span class="line">        new Thread(mt,&quot;售票员B&quot;).start();</span><br><span class="line">        new Thread(mt,&quot;售票员C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步会导致性能下降</p><p>同步操作的本质在于同一给时间段内只有一个线程，所以在此线程对象执行完之前其他的线程对象将处于一个就绪状态，这样就会导致性能下降。</p><p>同步方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">    private int ticket = 20;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (this.sale())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized boolean sale()&#123;</span><br><span class="line">        if(this.ticket&gt;0)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;  &quot;+this.ticket--);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;卖光了！！&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Threadsynchronization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread mt = new MyThread();</span><br><span class="line">        new Thread(mt,&quot;售票员A&quot;).start();</span><br><span class="line">        new Thread(mt,&quot;售票员B&quot;).start();</span><br><span class="line">        new Thread(mt,&quot;售票员C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程死锁：</p><p>同步指的是一个线程要等待另一个线程执行完才会继续执行的一种操作，虽然同步可以保证资源共享的正确性，但是过多同步也会产生一些问题。</p><p>例如：王老五想要小鹏的一本书，小鹏想要王老五的一口饭，两个人都在等待回复，最终都得不到自己想要的东西，这实际上就是死锁的概念。</p><p>所谓的死锁，指的是两个线程都在等待对方先完成，造成程序的停滞，一般程序的死锁都是在小程序运行时出现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">class Book&#123;</span><br><span class="line">    public synchronized void tell(Food food)&#123;</span><br><span class="line">        System.out.println(&quot;王老五对小鹏说，把你的书给我，我就给你一口饭吃！不给书就不给你饭吃&quot;);</span><br><span class="line">        food.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get()&#123;</span><br><span class="line">        System.out.println(&quot;王老五得到了小鹏的书！开始仔细阅读！发现是本无字天书！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Food&#123;</span><br><span class="line">    public synchronized void tell(Book book)&#123;</span><br><span class="line">        System.out.println(&quot;小鹏对王老五说，给我一口饭吃，我就把书给你，不给饭吃不给你书！&quot;);</span><br><span class="line">        book.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void get()&#123;</span><br><span class="line">        System.out.println(&quot;小鹏得到了一口饭，吃的老香了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class threaddeadlock implements Runnable&#123;</span><br><span class="line">    private Book book = new Book();</span><br><span class="line">    private Food food = new Food();</span><br><span class="line"></span><br><span class="line">    public threaddeadlock() &#123;</span><br><span class="line">        new Thread(this::run).start();</span><br><span class="line">        book.tell(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        food.tell(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new threaddeadlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程等待与唤醒：</p><p><img src="/2021/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20210812164151743.png" alt="image-20210812164151743"></p><p>优雅的停止线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day11;</span><br><span class="line"></span><br><span class="line">import javax.xml.stream.FactoryConfigurationError;</span><br><span class="line"></span><br><span class="line">public class threadstop &#123;</span><br><span class="line">    public static boolean flag = true;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        new Thread(() -&gt;&#123;</span><br><span class="line">           long num = 0;</span><br><span class="line">           while (flag)&#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(50);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+&quot;running &quot;+num++);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,&quot;线程AA&quot;).start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        flag = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台守护线程：</p><p>java中的线程分为两类，用户线程和守护线程。守护线程运行在后台，当全部用户线程消失，守护线程消失。</p><p>Java中有一个gc自动垃圾回收机制，其实就是守护线程。</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>public final void setDaemon(boolean on)</td><td>普通</td><td>设置为守护线程</td></tr><tr><td>public final boolean isDaemon()</td><td>普通</td><td>判断是否为守护线程</td></tr></tbody></table><p>volative关键字</p><p>在多线程中，线程为了实现公共资源的操作，为复制相对应的变量的副本，等待操作完成之后，再把副本和原始变量进行同步处理。开发者不希望通过怕副本数据进行操作，就可以在原始变量声明时，使用关键字。</p><p>volative和同步的区别：<br>关键字无法处理同步问题，他是一种直接内存的处理避免副本操作。同步是处理并发资源访问，关键字主要在属性上使用，同步在代码块和方法体上使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程编程&quot;&gt;&lt;a href=&quot;#多线程编程&quot; class=&quot;headerlink&quot; title=&quot;多线程编程&quot;&gt;&lt;/a&gt;多线程编程&lt;/h1&gt;&lt;p&gt;多线程编程是java最重要的特性之一，利用多线程可以提升单位时间内的程序处理性能，也是高并发的主要设计形式。&lt;/p&gt;</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://rczmm.github.io/2021/08/05/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://rczmm.github.io/2021/08/05/%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2021-08-05T08:43:55.000Z</published>
    <updated>2021-08-05T16:09:08.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>常见的嵌套结构，利用这样的结构使得内部类和外部类并存，并且可以方便的进行私有操作的访问，内部类又进一步扩展到了匿名内部类。</p><h2 id="1、内部类基本概念："><a href="#1、内部类基本概念：" class="headerlink" title="1、内部类基本概念："></a>1、内部类基本概念：</h2><p>程序开发为了更加准确的描述结构体的作用，提供各种的嵌套结构，类也是一种程序结构，它也是支持嵌套的。</p><p>内部类（普通类、抽象类、接口的统称）指的是一种嵌套的关系，也就是在一个类结构中除了属性和方法还定义了一个类结构，这样可以让程序更加灵活。</p><blockquote><p>定义内部类</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">class Outer&#123;</span><br><span class="line">    private String info = &quot;i love mm&quot;;</span><br><span class="line">    public void fun()&#123;</span><br><span class="line">        Inner i1 = new Inner();</span><br><span class="line">        i1.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Inner&#123;</span><br><span class="line">        public void print()&#123;</span><br><span class="line">            System.out.println(Outer.this.info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer o1 = new Outer();</span><br><span class="line">        o1.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心结构就是在外部类的方法里实例化了内部类对象，并且调用了内部类的方法，并且利用内部类的方法输出了外部类的私有属性。</p><blockquote><p>提问：内部类的结构差嘛？（从类的结构看，成员属性和方法，此时如果在一个类中定义许多的内部类，这样就会使得代码结构非常混乱，为什么要这么定义？）</p><p>答：内部类方便访问私有属性</p><p>实质上内部类在整体结构上破坏了良好的程序结构，但是最大的有点就是方便的访问外部类中的私有属性。</p><p>为了证明这一点，我们将上述的代码拆开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">class Outer1 &#123;</span><br><span class="line">    private String info = &quot;i love mm&quot;;</span><br><span class="line"></span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void fun() &#123;</span><br><span class="line">        Inner1 i1 = new Inner1(this);</span><br><span class="line">        i1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Inner1 &#123;</span><br><span class="line">    private Outer1 out;</span><br><span class="line"></span><br><span class="line">    public Inner1(Outer1 out) &#123;</span><br><span class="line">        this.out = out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(this.out.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer1 o1 = new Outer1();</span><br><span class="line">        o1.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意：之所以出现内部类，更多的时候是希望某一个类只为了单独的一个类服务</p><h2 id="2、内部类相关说明："><a href="#2、内部类相关说明：" class="headerlink" title="2、内部类相关说明："></a>2、内部类相关说明：</h2><p>内部类除了可以被定义的外部类操作之外，本身也可以被外部类明确实例化调用。</p><p>在内部类结构中，不仅是内部类可以方便的访问外部类的成员，外部类也同样可以方便的访问内部类的私有成员，内部类本身是一个独立的结构，这样在进行普通成员访问是，为了明确的标记出属性是外部类提供的，可以采用“外部类.this.属性”的方式进行标注。</p><blockquote><p>外部类访问内部类私有成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class f&#123;</span><br><span class="line">    private String info = &quot;i love mm&quot;;</span><br><span class="line">    public void fun()&#123;</span><br><span class="line">        s s1= new s();</span><br><span class="line">        s1.print();</span><br><span class="line">        System.out.println(s1.info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class s &#123;</span><br><span class="line">        private String info = &quot;i always love mm&quot;;</span><br><span class="line">        public void print()&#123;</span><br><span class="line">            System.out.println(f.this.info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        f f1 = new f();</span><br><span class="line">        f1.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>注意：内部类虽然被外部类包裹，但是本身也属于一个完整类，所以可以直接进行实例化对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 内部类对象 = new 外部类().new 内部类();</span><br></pre></td></tr></table></figure><p>要求先获取相应的外部类对象，再利用外部类对象对内部类进行实例化。</p><blockquote><p>提示：关于内部类的字节码文件名称</p><p>当内部类源码进行编译时，我们会发现有一个外部类$内部类的class文件，这个标识符来程序中会转化成.，因此内部类的全程就是外部类.内部类，由于内部类和外部类可以进行私有属性的访问，这样就必须保证在实例化内部类对象之前必须实例化外部类对象。</p></blockquote><blockquote><p>内部类私有化：</p><p>出现一个内部类不希望被其他类所使用，那么也可以使用private关键字将这个内部类定义为私有的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class d &#123;</span><br><span class="line">    private String info = &quot;mm&quot;;</span><br><span class="line">    private class x&#123;</span><br><span class="line">        public void fun()&#123;</span><br><span class="line">            System.out.println(d.this.info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>由于内部类用了private在定义，表示内部类只允许被外部类使用。</p><p>值得一提：private，protected这两个关键字定义类时只出现内部类。</p><blockquote><p>定义内部接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface I&#123;</span><br><span class="line">    public void send(m m1);</span><br><span class="line">    interface m&#123;</span><br><span class="line">        public String getinfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Is1 implements I&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void send(m m1) &#123;</span><br><span class="line">        System.out.println(m1.getinfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class mm1 implements m&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getinfo()&#123;</span><br><span class="line">            return &quot;mm&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo07 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        I i1 = new Is1();</span><br><span class="line">        i1.send(((Is1) i1).new mm1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类的形式定义了内部接口，并且分别的为外部接口和内部接口实现了子类，由于是内部接口，因此在定义子类的时候也要用内部类的形式</p></blockquote><blockquote><p>在接口中定义内部抽象类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface fatherinterface &#123;</span><br><span class="line">    public void send();</span><br><span class="line"></span><br><span class="line">    abstract class AbstractSon &#123;</span><br><span class="line">        public abstract String getinfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father implements fatherinterface &#123;</span><br><span class="line">    class Son extends AbstractSon &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getinfo() &#123;</span><br><span class="line">            return &quot;mm&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void send() &#123;</span><br><span class="line">        AbstractSon s1 = new Son();</span><br><span class="line">        System.out.println(s1.getinfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        fatherinterface f1 = new Father();</span><br><span class="line">        f1.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部接口中定义了内部抽象类，在定义外部接口的外部类的send方法时，利用内部抽象类的子类为父类对象实例化。</p></blockquote><blockquote><p>接口子类定义为自身内部类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface Father1&#123;</span><br><span class="line">    public void print();</span><br><span class="line">    class Son1 implements Father1&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(&quot;mm&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Father1 getinfo()&#123;</span><br><span class="line">        return new Son1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Father1 f1 = Father1.getinfo();</span><br><span class="line">        f1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>定义接口的时候直接在内部定义了子类，同时为了方便获取接口实例，就定义了一个静态方法，这样用户就可以在不关心子类的前提下，使用子类对象</p><h2 id="3、static定义内部类："><a href="#3、static定义内部类：" class="headerlink" title="3、static定义内部类："></a>3、static定义内部类：</h2><p>static定义的结构可以不用受类的制约，内部类也可以使用static定义类结构体。此时的内部类就不再受外部类对象的影响了，此时的内部类等同于一个外部类。内部类的名称是：外部类.内部类，使用static定义的内部类只能调用外部类中static定义的结构，并且在实例化的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 内部类对象 = new 外部类.内部类();</span><br></pre></td></tr></table></figure><p>如果接口中使用static定义“外部接口”，那么我们就需要在外部使用外部类分别实现外部接口。</p><h2 id="4、方法中定义内部类："><a href="#4、方法中定义内部类：" class="headerlink" title="4、方法中定义内部类："></a>4、方法中定义内部类：</h2><p>内部类的嵌套除了写在类中，也可以在代码块中完成，就典型的就是方法。</p><p>在方法中定义内部类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">class father&#123;</span><br><span class="line">    private String info = &quot;mm&quot;;</span><br><span class="line">    public void fun()&#123;</span><br><span class="line">        class son&#123;</span><br><span class="line">            public void print()&#123;</span><br><span class="line">                System.out.println(father.this.info);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new son().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new father().fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、匿名内部类："><a href="#5、匿名内部类：" class="headerlink" title="5、匿名内部类："></a>5、匿名内部类：</h2><p>继承开发需要子类，但是子类过多有可能产生很多额外代码。</p><p>在一个接口或者抽象类定义完成之后，在使用之前都需要专门定义子类，随后利用向上转型使用接口和抽象类，很多时候子类只使用一次，为了它单独创建一个类文件有些浪费，此时就可以使用匿名内部类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IMessage&#123;</span><br><span class="line">    public void send(String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IMessage mag = new IMessage() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void send(String str) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        mag.send(&quot;mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优势在于：减少类的定义次数。</p><p>结合static：</p><p>在接口中利用匿名内部类实现接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface Message&#123;</span><br><span class="line">    public void send(String str);</span><br><span class="line">    public static Message getInstance()&#123;</span><br><span class="line">        return new Message() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void send(String str) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo12 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Message.getInstance().send(&quot;mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、lambda表达式："><a href="#6、lambda表达式：" class="headerlink" title="6、lambda表达式："></a>6、lambda表达式：</h2><p>函数式编程：更加简洁</p><p>lambda表达式（jdk1.8之后）：指的是应用在含有一个抽象方法的接口的环境下的定义形式，用于解决匿名内部类的定义复杂问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">interface Messsage1&#123;</span><br><span class="line">    public void send(String str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo13 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Messsage1 msg = (str) -&gt; &#123;</span><br><span class="line">          System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        msg.send(&quot;mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用lambda表达式定义了接口的实现类。可以发现lambda表达式进一步简化了匿名内部类的定义结构。</p><p>lambda表达式应用在有抽象方法的接口上，而且只能有一个抽象方法。</p><p>此时可以使用@FunctionalInterface注解来标注出使用lambda表达式的接口，这样表示这个是函数式接口，里面只允许定义一个抽象方法。</p><h2 id="7、方法引用："><a href="#7、方法引用：" class="headerlink" title="7、方法引用："></a>7、方法引用：</h2><p>引用是java的灵魂，早期的时候，受到c++的影响，只有对象引用，后来加强了引用的概念，提供了方法的引用。</p><p>java中对象引用实现了不同的对象名操作一块堆内存。jdk8开始，方法也支持引用操作，这就相当于为方法定义了别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Func&lt;P,R&gt;&#123;</span><br><span class="line">    public R change(P p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo14 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Func&lt;Integer,String&gt; fun = String::valueOf;</span><br><span class="line">        String str = fun.change(100);</span><br><span class="line">        System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了函数式接口，利用方法引用的概念引用了string的valueof方法，并且利用这个方法将int转化字符串。</p><p>引用普通方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface func1&lt;T&gt;&#123;</span><br><span class="line">    public T upeer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1&lt;String&gt; f1 = &quot;www.baidu.mm&quot;::toUpperCase;</span><br><span class="line">System.out.println(f1.upeer());</span><br></pre></td></tr></table></figure><p>类：：方法，引用的一定是类中的静态方法，这种形式也可以引用普通方法</p><p>引用构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;  age:&quot;+this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface funcA&lt;R&gt;&#123;</span><br><span class="line">    public R create(String s, int a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface funcB&lt;E&gt;&#123;</span><br><span class="line">    public E create(String a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        funcA f1 = Person::new;</span><br><span class="line">        System.out.println(f1.create(&quot;mm&quot;,20));</span><br><span class="line"></span><br><span class="line">        funcB f2 = Person::new;</span><br><span class="line">        System.out.println(f2.create(&quot;love&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、内建函数式接口"><a href="#8、内建函数式接口" class="headerlink" title="8、内建函数式接口;"></a>8、内建函数式接口;</h2><p>1、功能性函数式接口：（有参数，有返回值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line">public R apply&lt;T t&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Function&lt;String, Boolean&gt; fun = &quot;www.google&quot;::startsWith;</span><br><span class="line">        System.out.println(fun.apply(&quot;www&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、消费型函数式接口：（只有参数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line">    void accept(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Consumer&lt;String&gt; con = System.out::println;</span><br><span class="line">        con.accept(&quot;aaaaaa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、供给型函数式接口：（有返回值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Supplier&lt;String&gt; sup = &quot;www.baidu.com&quot;::toUpperCase;</span><br><span class="line">        System.out.println(sup.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、断言型函数式接口：（主要是进行判断，接受参数，返回boolean）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Predicate&lt;String&gt; p1 = &quot;mm1&quot;::equals;</span><br><span class="line">        System.out.println(p1.test(&quot;mm&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、链表："><a href="#9、链表：" class="headerlink" title="9、链表："></a>9、链表：</h2><p>解决数组的问题，（固定长度）。</p><p>链表本身比较复杂，包含的内容，只介绍单向链表。</p><p>链表（动态数组）：本质是利用对象引用的逻辑来实现存储逻辑，一个链表是由若干个节点组成的，每一个节点依赖于上一个节点的引用来形成一个链。</p><p><img src="/2021/08/05/%E5%86%85%E9%83%A8%E7%B1%BB/image-20210805231331987.png" alt="image-20210805231331987"></p><p>设计的时候，为了避免安全隐患，用泛型定义，这样子为了保证链表中的数据类型统一。</p><p>直接使用node类存放多个数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import com.sun.tools.javac.Main;</span><br><span class="line"></span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line">class Node&lt;T&gt; &#123;</span><br><span class="line">    private T data;</span><br><span class="line">    private Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node&lt;T&gt; getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Node&lt;T&gt; next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo17 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node&lt;String&gt; n1 = new Node&lt;&gt;(&quot;mm&quot;);</span><br><span class="line">        Node&lt;String&gt; n2 = new Node&lt;&gt;(&quot;mm1&quot;);</span><br><span class="line">        Node&lt;String&gt; n3 = new Node&lt;&gt;(&quot;mm2&quot;);</span><br><span class="line">        Node&lt;String&gt; n4 = new Node&lt;&gt;(&quot;mm3&quot;);</span><br><span class="line">        n1.setNext(n2);</span><br><span class="line">        n2.setNext(n3);</span><br><span class="line">        n3.setNext(n4);</span><br><span class="line">        printNode(n1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printNode(Node&lt;?&gt; node) &#123;</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            System.out.print(node.getData() + &quot;、&quot;);</span><br><span class="line">            printNode(node.getNext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个链表的模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface ILink&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Link01&lt;T&gt; implements ILink&lt;T&gt;&#123;</span><br><span class="line">    private class Node&lt;T&gt;&#123;</span><br><span class="line">        private T data;</span><br><span class="line">        private Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        public Node(T data) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    以下的link类定义的结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、花店的例子："><a href="#10、花店的例子：" class="headerlink" title="10、花店的例子："></a>10、花店的例子：</h2><p>分析：要求许多种花上线，花店针对上线、下线、查询的信息依据接口实现，保存数据使用链表。</p><p><img src="/2021/08/05/%E5%86%85%E9%83%A8%E7%B1%BB/image-20210805233421891.png" alt="image-20210805233421891"></p><p>1、创建花的接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">public interface IFlower &#123;</span><br><span class="line">    public String getName();</span><br><span class="line">    public String getColor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、花和花的接口有关，但是和具体的花无关，因此创建花类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class Flower &#123;</span><br><span class="line">    private LinkedList&lt;IFlower&gt; allFlower = new LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public void add(IFlower flower)&#123;</span><br><span class="line">        this.allFlower.add(flower);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void delete(IFlower flower)&#123;</span><br><span class="line">        this.allFlower.remove(flower);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedList&lt;IFlower&gt; search(String keyword)&#123;</span><br><span class="line">        LinkedList&lt;IFlower&gt; searchResult = new LinkedList&lt;&gt;();</span><br><span class="line">        Object result[] = this.allFlower.toArray();</span><br><span class="line">        if (result != null)&#123;</span><br><span class="line">            for (Object obj:result) &#123;</span><br><span class="line">                IFlower flower = (IFlower) obj;</span><br><span class="line">                if(flower.getName().contains(keyword) || flower.getColor().contains(keyword))&#123;</span><br><span class="line">                    searchResult.add(flower);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return searchResult;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、根据花接口，定义具体的花，值得注意的是，为了保证链表中的方法可以正常使用，需要覆写equals方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">class Lavender implements IFlower&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Lavender(String name, String color) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getColor() &#123;</span><br><span class="line">        return this.color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj)&#123;</span><br><span class="line">        if (obj == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (!(obj instanceof Lavender))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (this == obj)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Lavender lavender = (Lavender) obj;</span><br><span class="line">        return this.name.equals(lavender.name) &amp;&amp; this.color.equals(lavender.color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;  color:&quot;+this.color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">class Lily implements IFlower&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    public Lily(String name, String color) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getColor() &#123;</span><br><span class="line">        return this.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj)&#123;</span><br><span class="line">        if (obj == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(obj instanceof Lily))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this == obj)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Lily lily = (Lily) obj;</span><br><span class="line">        return this.name.equals(lily.name) &amp;&amp; this.color.equals(lily.color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;  color:&quot;+this.color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、主类测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package flower;</span><br><span class="line"></span><br><span class="line">public class FlowerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FlowerShop shop = new FlowerShop();</span><br><span class="line">        shop.add(new Lily(&quot;白百合&quot;,&quot;白色&quot;));</span><br><span class="line">        shop.add(new Lily(&quot;粉百合&quot;,&quot;粉色&quot;));</span><br><span class="line">        shop.add(new Lily(&quot;黄百合&quot;,&quot;黄色&quot;));</span><br><span class="line">        shop.add(new Lily(&quot;黑百合&quot;,&quot;紫褐色&quot;));</span><br><span class="line">        shop.add(new Lavender(&quot;紫色薰衣草&quot;,&quot;紫色&quot;));</span><br><span class="line">        shop.add(new Lavender(&quot;蓝色薰衣草&quot;,&quot;蓝色&quot;));</span><br><span class="line">        shop.add(new Lavender(&quot;白色薰衣草&quot;,&quot;白色&quot;));</span><br><span class="line">        shop.delete(new Lily(&quot;白百合&quot;,&quot;白色&quot;));</span><br><span class="line">        Object result[] = shop.search(&quot;白&quot;).toArray();</span><br><span class="line">        for (Object obj: result) &#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h1&gt;&lt;p&gt;常见的嵌套结构，利用这样的结构使得内部类和外部类并存，并且可以方便的进行私有操作的访问，内部类又进一步扩展到了匿名内部类。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>异常-1</title>
    <link href="http://rczmm.github.io/2021/08/05/%E5%BC%82%E5%B8%B8-1/"/>
    <id>http://rczmm.github.io/2021/08/05/%E5%BC%82%E5%B8%B8-1/</id>
    <published>2021-08-05T07:12:37.000Z</published>
    <updated>2021-08-05T08:38:04.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在程序中，编译和运行是两个不同的阶段。编译主要针对的是语法检测，运行时有可能出现各种的错误导致程序中断，这些错误统一的被称为异常。</p><h2 id="1、认识异常"><a href="#1、认识异常" class="headerlink" title="1、认识异常"></a>1、认识异常</h2><p>异常是在程序执行时，由于程序处理逻辑的错误导致程序中断的一种指令流（机器执行指令序列 数据流）</p><p>当异常产生时，程序会在异常产生的地方被中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(10 / 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">at demo08.day5.demo01.main(demo01.java:5)</span><br></pre></td></tr></table></figure><p>程序中产生了数学异常，由于程序没有对异常做任何的处理，所以默认的进行了异常信息的打印，同时会终止异常之后的代码，</p><p>为了让程序出现异常后还可以正常执行，必须引入异常处理语句来完善代码编写。</p><h2 id="2、异常处理"><a href="#2、异常处理" class="headerlink" title="2、异常处理"></a>2、异常处理</h2><p>try catch finally三个核心关键字用来针对异常的处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(10 / 0);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;这是:&quot;+e+&quot;  异常！&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;程序执行完毕&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>异常的格式组合：</p><p>其实，catch和finally都是可选的，就是在这三个关键字的组成上，try是必不可少的，其次的catch和finally都是可以任何搭配的。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(10 / 0);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;app&quot;+ &quot;ing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取完整异常信息，所有的异常类都提供了printStackTrace方法，这个方法可以输出异常信息，明确的告诉我们那一行代码出现了异常。</p><blockquote><p>提问：finally的作用是不是较小</p><p>我们发现，异常处理之后的语句无论是否出现异常都可以正常运行，那么finally是不是有些冗余？</p><p>答：两者执行机制不一样</p><p>上述程序只是执行了一个简单的数学计算异常，并不能正常处理其他异常，而对于不能正常处理的代码，程序依然会中断执行，中断之后，后面的代码不会执行，但是finally依然会执行。在开发中finally一般用来资源释放。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;please input number:&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            int x = Integer.parseInt(input.next());</span><br><span class="line">            System.out.println(10 / x);</span><br><span class="line">        &#125;catch (ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;ing&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;app&quot;+ &quot;ing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、处理多个异常："><a href="#3、处理多个异常：" class="headerlink" title="3、处理多个异常："></a>3、处理多个异常：</h2><p>使用多个catch语句进行异常处理</p><h2 id="4、异常处理流程："><a href="#4、异常处理流程：" class="headerlink" title="4、异常处理流程："></a>4、异常处理流程：</h2><p>面向对象的核心设计思想就是统一标准。</p><p>前面提问：每次处理异常的时候都要去考虑所有的异常，那么直接使用判断不是更好嘛？</p><img src="/2021/08/05/%E5%BC%82%E5%B8%B8-1/image-20210805160039738.png" alt="异常处理流程" style="zoom:200%;"><p>核心：在于异常类的实例化对象类型。</p><hr><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">|-java.lang.Exception</span><br></pre></td></tr></table></figure></blockquote><p>如上，所有异常类的最高继承类是throwable。这个类下面有两个子类，其中一个是error，jvm错误。还有一个就是exception。</p><p>按照对象的引用原则，可以自动向上转型，按照这样的逻辑，所有的异常都可以用exception来处理。</p><blockquote><p>问题：为什么不用throwable？</p><p>答：表示的范围大，用户处理error错误</p><p>问题：异常一起处理好还是分开处理好？</p><p>答：根据实际要求</p></blockquote><p><strong>注意：处理多个异常时，范围小的要放在范围大的之前。</strong></p><h2 id="5、throws关键字"><a href="#5、throws关键字" class="headerlink" title="5、throws关键字"></a>5、throws关键字</h2><p>方法是类的主要操作形式。</p><p>在程序执行中，更多的考虑到的是方法的调用，为了方便调用时异常的处理，往往会在方法声明时对可能出现的异常进行标记。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            div(12,12);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int div(int x,int y) throws Exception&#123;</span><br><span class="line">        return x / y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题：以上的计算没有错误，为什么还是强制异常处理？</p><p>答：设计方法的需要</p></blockquote><p>主方法也是方法，如果主方法进行了throws异常抛出，那么在主方法里不用强制性地进行异常处理。异常交给了jvm默认处理，程序中断执行，并且打印异常信息。</p><p>注意：主方法就是程序的起点，因此所有的异常都应该在主方法里处理完成，而不应该选择向上抛出。</p><h2 id="6、throw关键字"><a href="#6、throw关键字" class="headerlink" title="6、throw关键字"></a>6、throw关键字</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           throw new Exception(&quot;跑着玩玩&quot;);</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，所有异常类的实例化对象都会自动生成并且自动抛出，但是为了方便用户，提供了手动抛出的异常。</p><blockquote><p>问题：两个关键字的区别，throws与throw</p><p>答：前者是在方法定义使用的，表示将方法中可能产生的异常明确的告诉调用者，由调用进行处理。后者是在代码块使用，手动进行异常对象抛出。</p></blockquote><h2 id="7、自定义异常类"><a href="#7、自定义异常类" class="headerlink" title="7、自定义异常类"></a>7、自定义异常类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DemoException extends Exception&#123;</span><br><span class="line">    public DemoException(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void eat (int num) throws DemoException&#123;</span><br><span class="line">        if (num &gt;999)&#123;</span><br><span class="line">            throw new DemoException(&quot;吃撑了！&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;不怕胖，一直吃！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">          DemoException.eat(6708);</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、assert关键字"><a href="#8、assert关键字" class="headerlink" title="8、assert关键字"></a>8、assert关键字</h2><p>断言：程序执行到一定阶段时，其结果一定是预期的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package demo08.day5;</span><br><span class="line"></span><br><span class="line">public class demo02 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        int x = 10;</span><br><span class="line">        assert x == 100 : &quot;x no 100&quot;;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java默认不开启断言的，如果想要启动断言，需要加入（“-ea”）选项。</p><blockquote><p>java -ea demo08.day5.demo02<br>Exception in thread “main” java.lang.AssertionError: x no 100<br> at demo08.day5.demo02.main(demo02.java:6)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h1&gt;&lt;p&gt;在程序中，编译和运行是两个不同的阶段。编译主要针对的是语法检测，运行时有可能出现各种的错误导致程序中断，这些错误统一的被称为异常。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>类结构扩展</title>
    <link href="http://rczmm.github.io/2021/08/03/%E7%B1%BB%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95/"/>
    <id>http://rczmm.github.io/2021/08/03/%E7%B1%BB%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95/</id>
    <published>2021-08-03T15:10:06.000Z</published>
    <updated>2021-08-04T15:36:58.465Z</updated>
    
    <content type="html"><![CDATA[<p>类结构扩展</p><p>面向对象中核心组成是类与接口，在项目中会利用包进行一组相关类的管理，这样适用于程序代码的更新。也符合了我们面向对象封装性的概念。</p><p>包</p><p>可以把一个大型项目中的类分别独立出来，并且分别存在文件里，再把这些文件放到一起编译运行。这样的程序更加方便维护，避免代码开发中因为命名所造成的代码冲突。</p><p>包的定义</p><p>包的主要目的是把不同功能的文件进行分割，所谓的包就是文件夹，在java里可以用package定义包，此语句编写在源代码首行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">public class hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本程序把hello类放到一个自定义包中，这样一来在程序编译后就必须将class文件保存在指定的目录中，但是手动的建立程序包目录比较麻烦，最好的就是进行打包编译处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d(表示生成目录) .(表示当前目录下生成程序文件) hello,java</span><br></pre></td></tr></table></figure><p>项目中必须提供包：在实际开发中，所有的程序类都必须放在一个包里，并且往往会设计一个总包名称和子包名称，所有字母必须小写。</p><p>包的导入：<br>利用的包的定义可以将不同功能的程序类保存在不同的包中以实现不同的需要，但是不同的包中的类也可能存在这相互调用的关系，这个时候就需要使用import导入语句来导入被调用的其他包中的程序类。</p><blockquote><p>注意：类定义的时候必须要使用public class</p><p>如果一个包中的类想被其他包中的类使用，那么这个类一定要定位为public class，而不能用class来声明，因为class声明的类只能在同一个包中使用。</p><p>注意：public class与class</p><p>public class：文件名与类名保持一致，在一个java文件中只能存在public class，同时一个类要想被外部包访问，就必须定义为public class</p><p>class：文件名可以与类名不一致，一个java文件可以存在多个class，并且编译时会形成多个class文件，使用class定义的类只能在本包中被使用。</p></blockquote><p>编译顺序：</p><p>问题：现在import导入了一个类，问是那个类先被编译。<br>答：先编译导入的类，然后再编译主类。</p><p>可以使用java自动编译。</p><p>在开发中如果所有程序代码按照顺序编译，就很可怕，为了解决这个问题，java中可以用*.java的匹配模式进行编译</p><p>还可以import 包名.*来导入所有的类。</p><p>静态导入</p><p>static</p><p>当一个类中所有的方法都是静态方法的时候，就可以进行静态导入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static 包名.类名</span><br></pre></td></tr></table></figure><p>优点：不同类的静态方法就感觉是在主类中定义一样，不需要类名称就可以调用。</p><p>jar文件</p><p>为了整体管理，对程序进行打包，java提供了文件jar。</p><p>jar（java archive 归档文件）是java提供的一种压缩格式，即将class文件压缩为jar给用户，这样方便程序的维护。</p><p>使用jar：（先编译，再打包）</p><p>jar–help</p><p>jar -c 创建一个新的文件</p><p>jar -v 生成标准的压缩信息</p><p>jar -f 由用户自己指定jar的文件名称</p><p>系统常用包：</p><p>9之后的版本：实际上提供的是一个jar文件。</p><p>访问控制权限：</p><p>面向对象：封装。（对类结构的保护）</p><p>java实现封装就是通过访问控制权限。</p><table><thead><tr><th>范围</th><th>private</th><th>default</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个包的同一个类</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一个包不同类</td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td>不同包的子类</td><td></td><td></td><td>√</td><td>√</td></tr><tr><td>不同包的非子类</td><td></td><td></td><td></td><td>√</td></tr></tbody></table><p>初学者原则：属性private，方法public。</p><p>构造方法私有化</p><p>new实例化对象，在设计中，可以让构造方法私有来控制控制实例化对象。</p><p>单例设计模式：</p><p>整个系统只允许一个类提供实例化对象为，为了实现这个要求，就可以用private封装构造方法，这样子这个类就无法在外部利用new实例化对象。</p><p>饿汉单例设计模式：（定义成员属性时，进行对象实例化）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">class Food&#123;</span><br><span class="line">    private static final Food INFO = new Food();</span><br><span class="line"></span><br><span class="line">    private Food() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Food getInfo()&#123;</span><br><span class="line">        return INFO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Food f1 = null;</span><br><span class="line">        f1 = Food.getInfo();</span><br><span class="line">        f1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉单例设计模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    private static Person info;</span><br><span class="line"></span><br><span class="line">    private Person() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Person getInfo()&#123;</span><br><span class="line">        if (info == null)&#123;</span><br><span class="line">            info = new Person();</span><br><span class="line">        &#125;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class demo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p1 = null;</span><br><span class="line">        p1 = Person.getInfo();</span><br><span class="line">        p1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义成员属性的时候没有实例化，而是第一次调用方法时实例化了，这样节约程序启动资源。</p><p>多例设计模式：</p><p>多例设计模式会定义出多个对象，例如性别类，就应该定义男和女两个对象。类似这样的类不应该由用户无限制的创造实例化对象，所以只使用有限的几个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">class Sex&#123;</span><br><span class="line">    private static final Sex MAN = new Sex(&quot;man&quot;);</span><br><span class="line">    private static final Sex WOMAN = new Sex(&quot;woman&quot;);</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    private Sex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sex getInstance(String sex)&#123;</span><br><span class="line">        switch (sex)&#123;</span><br><span class="line">            case &quot;man&quot;:</span><br><span class="line">                return MAN;</span><br><span class="line">            case &quot;woman&quot;:</span><br><span class="line">                return WOMAN;</span><br><span class="line">            case &quot;男&quot;:</span><br><span class="line">                return MAN;</span><br><span class="line">            case &quot;女&quot;:</span><br><span class="line">                return WOMAN;</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Sex s1 = Sex.getInstance(&quot;男&quot;);</span><br><span class="line">        s1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举（一个有名字的集合）</p><p>enum，利用此关键字可以实现枚举的定义。利用枚举可以简化多例设计模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">enum Color &#123;</span><br><span class="line">    RED, GREEN, WHITE, BLACK, YELLOW, BLUE, GRAY,PURPLE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Color c: Color.values()) &#123;</span><br><span class="line">            System.out.print(c+&quot;、&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch操作类型：int、char、string、枚举</p><p>enum类</p><p>枚举不是一种新类型，它只是提供了一种方便的结构，实际上都是继承了一个父类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;</span><br><span class="line">        implements Comparable&lt;E&gt;, Serializable &#123;</span><br></pre></td></tr></table></figure><p>常用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final String name();</span><br><span class="line">public final int ordinal();</span><br><span class="line">protected Enum(String name, int ordinal)</span><br></pre></td></tr></table></figure><p>1、获取对象名</p><p>2、获取对象序号</p><p>3、传入名字和序号</p><p>定义枚举结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line">enum Color &#123;</span><br><span class="line">    RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;);</span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    private Color(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print(Color color)&#123;</span><br><span class="line">        System.out.println(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Color c: Color.values()) &#123;</span><br><span class="line">            System.out.print(c.ordinal()+c.name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举对象必须写在首行。</p><p>枚举应用案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package demo08;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum Sex1&#123;</span><br><span class="line">    MAN(&quot;男&quot;),WOMAN(&quot;女&quot;);</span><br><span class="line">    private String sex;</span><br><span class="line"></span><br><span class="line">    private Sex1(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return this.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person1&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Sex1 sex;</span><br><span class="line"></span><br><span class="line">    public Person1(String name, int age, Sex1 sex) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return this.name+this.age+this.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(new Person1(&quot;mm&quot;,7,Sex1.WOMAN));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;类结构扩展&lt;/p&gt;
&lt;p&gt;面向对象中核心组成是类与接口，在项目中会利用包进行一组相关类的管理，这样适用于程序代码的更新。也符合了我们面向对象封装性的概念。&lt;/p&gt;
&lt;p&gt;包&lt;/p&gt;
&lt;p&gt;可以把一个大型项目中的类分别独立出来，并且分别存在文件里，再把这些文件放到一起编译运行</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="http://rczmm.github.io/2021/08/03/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://rczmm.github.io/2021/08/03/%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-08-03T05:14:08.000Z</published>
    <updated>2021-08-04T19:22:44.127Z</updated>
    
    <content type="html"><![CDATA[<p>泛型</p><p>泛型其实不是java最开始的概念，他起源于jdk5之后，是一个新加入的特性。</p><p>泛型的出现是为了解决对象强制转型之后可能出现的安全隐患问题。</p><p>我们知道，为了方便参数的统一，我们会使用object类，利用此类对象可以接受所有类型的数据，包括基本数据类型和引用数据类型，但是由于其描述的数据类型过大，所以在实现中就会出现传入数据类型错误，从而引发异常classcastexception异常。</p><p>例如：</p><p>现在要设计一个描述坐标的类，point（包括x与y坐标轴信息），对于坐标点，允许保留整形、浮点与字符串三类数据。</p><p>于是在设计point的时候，就需要考虑到x和y的具体类型，这个类型要求就可以保存以上三种类型的数据，于是最明显的就是利用object进行定义，这是因为存在以下的转换关系：</p><p>整形：基本数据类型—包装为integer对象—自动向上转型为object</p><p>浮点：基本数据类型——包装为double对象—自动向上转型为object</p><p>字符串：string类对象——自动向上转型为object</p><p>定义point坐标类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">    private Object x;</span><br><span class="line">    private Object y;</span><br><span class="line"></span><br><span class="line">    public Object getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(Object x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(Object y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为采用了object作为存储类型，这样就可以接受任意的数据类型，于是此时可能出现两种情况：</p><p>1、使用者按照同意的数据类型设计坐标内容，并且利用向下转型获取原始坐标数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point p1 = new Point();</span><br><span class="line">        p1.setX(10);</span><br><span class="line">        p1.setY(20);</span><br><span class="line"></span><br><span class="line">        int x = (Integer) p1.getX();</span><br><span class="line">        int y = (Integer) p1.getY();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;x:&quot;+x+&quot;y:&quot;+y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用基本数据类型自动装箱为包装类对象的特点向point类对象传入了x与y两个坐标信息，并且在获取坐标原始数据时，也依据设置的数据类型进行强制性的向下转型，所以可以得到正确的执行结果。</p><p>2、使用者没有按照统一的数据类型设置坐标内容，读取数据时使用了错误的类型进行强制转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point p2 = new Point();</span><br><span class="line">p2.setX(100);</span><br><span class="line">p2.setY(&quot;北纬20度&quot;);</span><br><span class="line"></span><br><span class="line">int x1 = (Integer) p2.getX();</span><br><span class="line">int y1 = (Integer) p2.getY();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;x:&quot; + x + &quot;y:&quot; + y);</span><br></pre></td></tr></table></figure><p>值得一提的是，程序完全符合语法规范，不会在编译的时候告诉开发者，而是会在执行过程中才会出现安全隐患，而造成此问题的核心就是object类型能够接收的类型过大。</p><p>泛型：可以在编译时检测出程序的安全隐患，使得程序更加的健壮。</p><p>如果想要解决项目中可能出现的classcastexception安全隐患，最核心的方案就是避免强制性的向下转型，所以泛型的核心思想就是，类中的属性或方法的参数与返回值的类型采用动态标记，在对象实例化的时候动态配置要使用的数据类型。</p><blockquote><p><strong>泛型在类上标记出以后，需要通过实例化对象进行类型的设置，而所设置的类型只能够是引用数据类型，如果要设置基本数据类型，则必须采用包装类的形式，这就是为什么jdk5之后才引入包装类对象的自动装箱和自动拆箱机制的原因。</strong></p></blockquote><p>在类上使用泛型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Point&lt;T&gt; &#123;</span><br><span class="line">    private T x;</span><br><span class="line">    private T y;</span><br><span class="line"></span><br><span class="line">    public T getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(T x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(T y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point&lt;Integer&gt; p1 = new Point&lt;Integer&gt;();</span><br><span class="line">        p1.setX(100);</span><br><span class="line">        p1.setY(20);</span><br><span class="line"></span><br><span class="line">        int x = p1.getX();</span><br><span class="line">        int y = p1.getY();</span><br><span class="line">        System.out.println(&quot;x:&quot;+x+&quot;y:&quot;+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本程序中实例化point类对象所采用的的泛型设置为了integer，这样一类当前point类对象的x，y的属性类型就是integer，对应的方法参数和返回值也都是integer，这样不仅可以在编译的时候明确知道数据类型的错误，也避免了对象向下转型操作。</p><blockquote><p>7之后的jdk版本再定义泛型的时候简化了，在实例化对象时的泛型类型就通过声明时的泛型类型来定义了，但是依旧建议使用完整语法。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;Integer&gt; p1 = new Point&lt;&gt;();</span><br></pre></td></tr></table></figure></blockquote><p>为了照顾到最初的开发者，允许开发者在实例化对象时不设置泛型类型，这样在程序的编译时就会出现相应的警告信息，同时为了保证程序不出错，未设置的泛型类型将使用object作为默认类型。</p><p>泛型虽然保证了代码的正确性。但是对于引用传递会带来参数统一问题。</p><p>利用泛型类在实例化对象时进行的动态类型匹配，虽然可以有效地解决对象向下转型的安全隐患，但是在程序中实例化泛型类对象时，不同的泛型类型对象之间彼此是无法进行引用传递的。</p><p>所以在进行泛型类型的引用对象时，为了可以适应所有本类的实例化对象，则可以在接收时使用“？”作为泛型通配符来使用，利用？表示的泛型类型只允许从对象中获取数据，而不允许修改数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Point&lt;T&gt; &#123;</span><br><span class="line">    private T x;</span><br><span class="line">    private T y;</span><br><span class="line"></span><br><span class="line">    public T getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(T x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(T y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point&lt;Integer&gt; p1 = new Point&lt;Integer&gt;();</span><br><span class="line">        p1.setY(100);</span><br><span class="line">        fun(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fun (Point &lt;?&gt; temp)&#123;</span><br><span class="line">        System.out.println(temp.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不设置泛型类型或者设置泛型类型为object可否解决以上问题？</p><p>1、public static void fun(point <object> temp){}</object></p><p>2、public static void fun(point temp){}</p><p>泛型需要考虑到操作类型统一性</p><p>首先搞清楚一个核心问题，object可以接收一切的数据类型，但是在泛型概念里，point<string>与point<integer>这是两个不同的类型的对象。</integer></string></p><p>如果采取类型1的引用，表示fun方法只接收point<object>类型的引用</object></p><p>如果采取类型2的引用，实际上可以解决当前问题（不同泛型类型的对象传递），但是也会带来新的问题，允许随意修改数据</p><p><strong>观察不设置泛型类型的方法参数定义：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Point&lt;T&gt; &#123;</span><br><span class="line">    private T x;</span><br><span class="line">    private T y;</span><br><span class="line"></span><br><span class="line">    public T getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(T x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(T y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Point&lt;Integer&gt; p1 = new Point&lt;Integer&gt;();</span><br><span class="line">        p1.setY(100);</span><br><span class="line">        fun(p1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fun (Point temp)&#123;</span><br><span class="line">        temp.setY(199);</span><br><span class="line">        System.out.println(temp.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完程序可以发现，虽然不设置泛型类型可以实现对所有泛型类型的接收，但是无法对修改做出控制，然而使用了通配符？只允许获取，不允许修改。</p></blockquote><p>通配符？除了可以匹配任意的泛型类型之外，还可以通过泛型上限和下限的配置实现更加严格的类型定义。</p><p>类和方法：设置泛型的上限，（？ extends 类）只能够使用当前类或者其子类设置泛型</p><p>方法：设置泛型的下限，（？ super 类）只能设置指定的类或者父类。</p><p>设置泛型上限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class  demo22_1 &lt;T extends Number&gt;&#123;</span><br><span class="line">    private T content;</span><br><span class="line"></span><br><span class="line">    public T getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(T content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo22 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo22_1&lt;Integer&gt; d1 = new demo22_1&lt;Integer&gt;();</span><br><span class="line">        d1.setContent(199);</span><br><span class="line">        fun(d1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fun(demo22_1&lt;? extends Number&gt; temp)&#123;</span><br><span class="line">        System.out.println(temp.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置泛型的下限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class demo23_1&lt;T&gt;&#123;</span><br><span class="line">    private T content;</span><br><span class="line"></span><br><span class="line">    public T getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(T content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo23_1&lt;String&gt; d1 = new demo23_1&lt;&gt;();</span><br><span class="line">        d1.setContent(&quot;i always love mm&quot;);</span><br><span class="line">        fun(d1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void fun(demo23_1&lt;? super String&gt; temp)&#123;</span><br><span class="line">        System.out.println(temp.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口</p><p>泛型可以定义在任意程序的结构体中</p><p>泛型也可以定义在接口上，这样的接口叫做泛型接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface demo24_1&lt;T&gt;&#123;</span><br><span class="line">    String echo(T t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于此时的泛型接口来说，子类定义时就有两种方式，在子类中继续声明泛型和子类中为父类设置泛型类型。</p><p>1、在子类中继续声明泛型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface demo24_1&lt;T&gt;&#123;</span><br><span class="line">    String echo(T t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class demo24_2&lt;S&gt; implements demo24_1&lt;S&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String echo(S t1) &#123;</span><br><span class="line">        return &quot;echo:&quot;+t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo24_1&lt;String&gt; d1= new demo24_2&lt;String&gt;();</span><br><span class="line">        System.out.println(d1.echo(&quot;i always like mm&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义子类声明了一个泛型标记S，并且实例化子类对象的时候，设置的泛型类型会传递到泛型接口中去。</p><p>2、在子类中为父类设置泛型;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface demo24_1&lt;T&gt;&#123;</span><br><span class="line">    String echo(T t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class demo24_2 implements demo24_1&lt;String&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String echo(String t1) &#123;</span><br><span class="line">        return &quot;echo:&quot;+t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo24_1&lt;String&gt; d1= new demo24_2();</span><br><span class="line">        System.out.println(d1.echo(&quot;i always like mm&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类时，没有定义泛型标记，而是为父接口设置了泛型类型为string，所以说在覆写echo方法的时候，参数类型就是string。</p><p>泛型方法：对于泛型，除了可以定义在类上之外，也可以在方法上进行定义，而在方法上直接定义的泛型不一定要在类中定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class demo25 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer num [] = fun(1,2,3,4,5,6,7,8,9);</span><br><span class="line">        for (int temp: num) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T[] fun(T... args)&#123;</span><br><span class="line">        return args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，这是在一个没有泛型声明的类中定义了泛型方法，所以在fun方法声明处就必须单独定义泛型标记，此时的泛型类型由传入的参数来决定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;泛型&lt;/p&gt;
&lt;p&gt;泛型其实不是java最开始的概念，他起源于jdk5之后，是一个新加入的特性。&lt;/p&gt;
&lt;p&gt;泛型的出现是为了解决对象强制转型之后可能出现的安全隐患问题。&lt;/p&gt;
&lt;p&gt;我们知道，为了方便参数的统一，我们会使用object类，利用此类对象可以接受所有类型的</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>抽象类与接口</title>
    <link href="http://rczmm.github.io/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://rczmm.github.io/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-08-01T12:20:38.000Z</published>
    <updated>2021-08-03T13:16:00.479Z</updated>
    
    <content type="html"><![CDATA[<p>抽象类与接口：有效拆分大型系统，避免产生耦合。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>类继承主要是为了扩充已有的类功能，子类可以根据需要决定是否覆写父类中的方法，所以一个设计完善的父类是无法对子类做出任何强制性的覆写约定。为了解决这个问题，抽象类的概念就诞生了，抽象类和普通类相比唯一增加的就是抽象方法，同时抽象类在使用时要求必须被继承，而且必须全部覆写抽象类中的抽象方法。</p><p>普通类只是一个设计完善，可以直接产生实例化对象并且调用类中的属性和方法，抽象类最大特点，就是必须被子类继承，并且抽象类本身无法进行实例化。在实际项目中，往往很少设计普通类，大多都会选择继承抽象类。</p><p>抽象类基本定义：抽象类是为了方法覆写而提供的类结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abstract class javademo01&#123;</span><br><span class="line">    private String type;</span><br><span class="line">    public abstract String getconn();</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本实例中利用abstract关键字声明了抽象类与抽象方法：</p><p>1、抽象方法与普通方法不一样，抽象方法不能有方法体{}</p><p>2、抽象类不是一个完整的类，抽象类必须提供子类，子类继承依然用extends关键字</p><p>3、子类（非抽象类）一定要覆写抽象类中的全部抽象方法</p><p>4、抽象类的对象实例化可以通过子类向上转型来实现</p><p>抽象类的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">abstract class javademo01&#123;</span><br><span class="line">    private String type;</span><br><span class="line">    public abstract String getconn();</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class javademo02 extends javademo01&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getconn()&#123;</span><br><span class="line">        return super.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo13  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        javademo01 j1 = new javademo02();</span><br><span class="line">        j1.setType(&quot;mm&quot;);</span><br><span class="line">        System.out.println(j1.getconn());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类最大特点的是自己无法对象实例化，所以说在实际项目中，抽象类用来当中间过渡，当我们想要使用抽象类中，往往是为了解决继承中带来的代码重复处理。</p><p>抽象类的说明</p><p>1、抽象类必须有子类继承，抽象方法必须被覆写，所以抽象类定义时，不允许final定义抽象类和抽象方法。</p><p>2、抽象类也可以定义成员属性和普通方法，为了给抽象类的成员属性初始化，我们可以给抽象类设计构造方法，子类在继承时会调用抽象类的无参构造，如果抽象类没有提供，那么就需要super关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">abstract  class javademo01&#123;</span><br><span class="line">    private String type;</span><br><span class="line">    public abstract  String getconn();</span><br><span class="line"></span><br><span class="line">    public javademo01(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class javademo02 extends javademo01&#123;</span><br><span class="line"></span><br><span class="line">    public javademo02(String type) &#123;</span><br><span class="line">        super(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getconn()&#123;</span><br><span class="line">        return super.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo13  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        javademo01 j1 = new javademo02(&quot;mm&quot;);</span><br><span class="line">        System.out.println(j1.getconn());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类中可以没有抽象方法，即使没有抽象方法，也不能使用new关键字实例化对象。</p><p>抽象类中可以使用static定义静态方法，直接通过类名调用，毫无影响。</p><span id="more"></span><h2 id="模板设计模式（servlet）："><a href="#模板设计模式（servlet）：" class="headerlink" title="模板设计模式（servlet）："></a>模板设计模式（servlet）：</h2><p>类的作用是对一类事物的特征进行抽象化，从设计上来说，抽象类的级别比普通类要高。抽象类是对类的进一步抽象。</p><p>机器人：充电+工作</p><p>人：吃饭+睡觉+工作</p><p>猪：吃饭+睡觉</p><p>这三个类有公共的行为可以抽象，这时候就可以利用抽象类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ForkJoinWorkerThread;</span><br><span class="line"></span><br><span class="line">abstract class Action&#123;</span><br><span class="line">    public static final int EAT = 1;</span><br><span class="line">    public static final int SLEEP = 5;</span><br><span class="line">    public static final int WORK = 10;</span><br><span class="line">    public void command (int code)&#123;</span><br><span class="line">        switch (code)&#123;</span><br><span class="line">            case EAT:&#123;</span><br><span class="line">                this.eat();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case SLEEP:&#123;</span><br><span class="line">                this.sleep();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case WORK:&#123;</span><br><span class="line">                this.work();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case EAT+SLEEP+WORK:&#123;</span><br><span class="line">                this.eat();</span><br><span class="line">                this.sleep();</span><br><span class="line">                this.work();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void eat();</span><br><span class="line">    public abstract void sleep();</span><br><span class="line">    public abstract void work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Robot extends Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;机器人需要充电&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;机器人开始工作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person11 extends Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;饿的时候吃饭！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;困的时候睡觉！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;穷的时候去工作！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pig extends Action&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃饲料！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;倒地就睡！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo14 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Action robot = new Robot();</span><br><span class="line">        Action person = new Person11();</span><br><span class="line">        Action pig = new Pig();</span><br><span class="line">        System.out.println(&quot;----------------Robot-----------------&quot;);</span><br><span class="line">        robot.command(Action.EAT);</span><br><span class="line">        robot.command(Action.WORK);</span><br><span class="line">        System.out.println(&quot;---------------person------------------&quot;);</span><br><span class="line">        person.command(Action.EAT);</span><br><span class="line">        person.command(Action.SLEEP);</span><br><span class="line">        person.command(Action.WORK);</span><br><span class="line">        System.out.println(&quot;--------------pig----------------------&quot;);</span><br><span class="line">        pig.command(Action.EAT);</span><br><span class="line">        pig.command(Action.SLEEP);</span><br><span class="line">        System.out.println(&quot;--------------no pig================&quot;);</span><br><span class="line">        person.command(Action.EAT+Action.SLEEP+ Action.WORK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类定义了3个子类，这三个子类会根据需要进行方法的覆写，对于暂时不需要的功能，以空方法体进行实现。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>为了统一参数类型，需要针对基本数据类型进行引用传递，所以java提供了包装类的概念。</p><p>java是一门面向对象的语言，但是基本数据类型和这一理念冲突。</p><p>利用类的结构对基本数据类型进行包装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Int &#123;   // 定义了一个包装类</span><br><span class="line">    private int data;  // 包装了一个基本数据类型</span><br><span class="line"></span><br><span class="line">    public Int(int data) &#123; //构造方法设置基本数据类型</span><br><span class="line">        this.data = data;   // 保存基本数据类型</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int intValue()&#123;  // 从包装类中获取基本数据类型</span><br><span class="line">        return this.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object obj = new Int(10); // 装箱,将基本数据类型保存在包装类中</span><br><span class="line">        int x = ((Int) obj).intValue(); //拆箱，从包装类对象中取出基本数据类型</span><br><span class="line">        System.out.println(x * 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面对这样的设计缺陷，java也有自己的方案，设计了8个包装类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = new Integer(10);</span><br><span class="line">int num = i1.intValue(); </span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure><p>如上就是针对int数据类型的装箱、拆箱操作。</p><p>如上的操作，在jdk5之前必须做，但是5之后，java提供了自动装箱和拆箱的机制，并且包装类的对象可以自行计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i2 = 10;</span><br><span class="line">int num1 = i2;</span><br><span class="line">System.out.println(num1);</span><br></pre></td></tr></table></figure><p>这个其实就已经和string类型差不多了，因为他有两种实例化方式，一个是构造方法，一个是直接赋值，其实和string一样，直接赋值直接入池，反之。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = new Integer(10);</span><br><span class="line">int num = i1.intValue();</span><br><span class="line">System.out.println(num);</span><br><span class="line"></span><br><span class="line">Integer i2 = 10;</span><br><span class="line">int num1 = i2;</span><br><span class="line">System.out.println(num1);</span><br><span class="line"></span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>除此之外，还要注意一点。</p><p>自动装箱的相等判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer ii1 = 100;</span><br><span class="line">Integer ii2 = 100;</span><br><span class="line">System.out.println(ii1 == ii2);</span><br><span class="line"></span><br><span class="line">Integer ii3 = 130;</span><br><span class="line">Integer ii4 = 130;</span><br><span class="line"></span><br><span class="line">System.out.println(ii3 == ii4);</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>这里要注意，不再-128~127范围内的数，通过==比较返回的就是false。</p><p>自动装箱中，如果范围属于-128到127，可以自动实现堆内存的引用，否则不行。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>将字符串转化为int</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line">int num = Integer.parseInt(str);</span><br><span class="line">System.out.println(num + num);</span><br></pre></td></tr></table></figure><p>如果含有非数字，就会抛出异常。</p><p>Exception in thread “main” java.lang.NumberFormatException</p><p>字符串转boolean（不是true或者false，统一返回false）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;1sa23&quot;;</span><br><span class="line">boolean b1 = Boolean.parseBoolean(str);</span><br><span class="line">System.out.println(b1);</span><br></pre></td></tr></table></figure><p>基本数据类型转string</p><p>+连接符连接一个空字符串就可以了</p><h2 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h2><p>比抽象类更重要，定义开发标准。</p><p>接口是一个特殊的类，通过interface关键字定义，在接口中可以定义全局常量、抽象方法（访问权限必须是public）、default方法以及static方法。</p><p>定义标准接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IMessage &#123;</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、接口中存在抽象方法，因此无法被实例化。</p><p>2、接口需要被子类实现，子类通过implements关键字实现多个父接口</p><p>3、子类如果不是抽象类，子类一定要覆写全部的抽象方法</p><p>4、接口对象可以利用子类对象实现向上转型</p><p>继承和实现的顺序：先继承后实现接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface IMessage &#123;</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class fff &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class sss extends fff implements IMessage&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的基本使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface face01&#123;</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class demo16_1 implements face01&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return &quot;i love mm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        face01 f1 = new demo16_1();</span><br><span class="line">        System.out.println(f1.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本程序利用关键字定义了接口子类，并且利用子类对象向上转型实例化了接口对象。</p><p>子类实现多个父接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 定义接口</span><br><span class="line">interface face01&#123;</span><br><span class="line">//    全局常量</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">//    抽象方法</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">interface face02&#123;</span><br><span class="line">//    抽象方法</span><br><span class="line">    public abstract boolean conn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现多个接口</span><br><span class="line">class demo16_1 implements face01,face02&#123;</span><br><span class="line">    </span><br><span class="line">//    方法覆写</span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        if(this.conn())&#123;</span><br><span class="line">            return &quot;i love mm&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;default&quot;+face01.INFO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean conn() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        face01 f1 = new demo16_1();</span><br><span class="line">        System.out.println(f1.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result: i love mm</span><br></pre></td></tr></table></figure><p>本程序在子类上实现了两个父接口，这样就必须全部覆写接口中的抽象方法，因此实际上子类是object与这两个父接口的实例。</p><p>观察接口实例转换:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class demo16 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        face01 f1 = new demo16_1();</span><br><span class="line">        Object obj = f1;</span><br><span class="line">        face02 f2 = (face02) obj;</span><br><span class="line">        System.out.println(f2.conn());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有子类，那么object与两个父接口是没有任何关系的，但是由于子类同时实现了这些接口并且默认继承了object父类，所以该实例就可以进行任意父接口的转型。</p><p>关于接口的简化定义</p><p>完整定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义接口</span><br><span class="line">interface face01&#123;</span><br><span class="line">//    全局常量</span><br><span class="line">    public static final String INFO = &quot;i love mm&quot;;</span><br><span class="line">//    抽象方法</span><br><span class="line">    public abstract String getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface face03&#123;</span><br><span class="line">    String INFO =&quot;i love mm&quot;;</span><br><span class="line">    String getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种定义的作用完全相同，但是从实际的开发程序来讲，在接口中定义抽象方法时建议保留public的声明，这样的接口定义会更加的清楚。</p><p>在面向对象设计中，抽象类也是必不可少的一种结构，利用抽象类可以实现一些公共方法的定义，可以利用extends先继承父类再利用implements实现若干父接口的顺序完成子类定义。</p><p>java中的extends关键字除了具有类继承的作用外，也可以在接口上使用以实现接口的继承关系，并且可以同时实现多个父接口。</p><p>接口之间的继承，不存在任何强制性的覆写，类无法继承接口，只能实现。</p><p>接口的使用分析：在面向对象设计中，接口的核心用处是为了实现方法名的暴露与子类的隐藏。</p><hr><p>接口定义加强</p><p>接口是java诞生之初就提出的设计结构，其最初的组成就是抽象方法与全局常量，但是随着技术发展，在8之后的接口组成除了提供有全局常量和抽象方法之外，还可以定义普通方法或者静态方法。</p><p>这就使得接口中不仅仅只有抽象方法，同时这些普通方法也可以直接被子类继承。</p><p>接口中定义普通方法的意义：</p><p>便于扩充接口功能，同时简化设计结构</p><p>在设计中，接口主要是为了进行公共标准的定义，但是随着技术的发展，接口的设计也有可能得到更新，那么此时假设有一个早期版本的接口，并且随着发展，他已经有了很多个子类。如果现在需要对接口中新增一个方法，并且所有的子类对于此方法的实现完全相同的时候，就需要修改所有定义的子类，重复复制实现方法，这样就会导致代码的可维护性降低，在8之前的时候，为了解决这个问题，我们可以定义一个中间的过渡抽象类，由抽象类去继承接口，然后子类继承抽象类。接口中追加方法，在抽象类中做出实现，最后子类再继承抽象类。那么接口再扩充公共方法时，就只需要修改抽象类，所以为了解决这样的设计，在8之后就提供了普通方法的支持，同时，如果子类发现父接口中公共的方法功能不足时，也可以进行覆写。</p><p>普通方法需要通过接口实例化对象才可以调用，为了避免实例化对象的依赖，在接口中也可以使用static定义静态方法，此方法可以直接利用接口名称调用。</p><p>友情提示：个人认为，虽然接口中普通方法和静态方法很大程度上与抽象类的作用有一些重叠，但是要注意开发中尽量的在接口与子类之中，建立一个过渡抽象类。不要着急定义子类。</p><p>定义接口标准</p><p>项目功能设计中接口往往是最先定义的，这样就定义好了操作的标准。对于接口而言，最重要的就是进行标准的定义，实际上在日常中，你也会听到许多接口的名词，例如：usb接口，鼠标接口等等，这样接口实际上都是属于标准的定义与应用。</p><p>以usb的程序为例，计算机上可以插入各种usb的设备，所以计算上认识的知识usb标准，而不关心这个标准的具体子类。</p><p>利用接口定义标准：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">interface face_usb&#123;</span><br><span class="line">    public boolean check();</span><br><span class="line">    public void work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class computer&#123;</span><br><span class="line">    public void plugin(face_usb usb)&#123;</span><br><span class="line">        if (usb.check())&#123;</span><br><span class="line">            usb.work();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;There are some problems here!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class keyboard implements face_usb&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean check() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.println(&quot;starting study!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo17 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        computer c1 = new computer();</span><br><span class="line">        c1.plugin(new keyboard());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂设计模式：</p><p>接口在实际开发过程中主要特点是进行标准的定义，而标准的定义是一个灵活的概念，也就是说，标准不应该与具体的子类绑在一起，为了解决代码耦合的问题，在开发中针对接口对象的获得，往往通过工厂设计模式来呈现。</p><p><img src="/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20210803003800286.png" alt="工厂设计模式"></p><p>一个工厂类，在此类中提供一个静态方法返回接口实例化对象，这样在主类调用时，就不需要关注具体的接口子类，只需要传入指定的类型标记就可以获取接口对象。</p><p>当然也存在许多问题，比如当接口扩产子类时都需要修改工厂类，这样的子类一旦很多，工厂类的代码就会很多。如果有若干接口都需要工厂类来获取实例，对于工厂类需要追加大量的static方法，一个项目可能只需要某个接口的特定子类，这个子类往往可以通过配置文件的形式进行定义，修改时也可以通过配置文件的修改而更换子类，所以这种固定标记的做法可能导致代码的混乱。</p><p>代理设计模式</p><p>为了实现核心业务与辅助功能的细分，可以通过代理设计模式。</p><p>这是java开发中使用较多的一种模式，是指一个代理主题来操作真实主题，真实主题执行具体的业务操作，而代理主题则负责其他相关业务的办理，简单理解，你现在肚子饿了，如果你只会吃饭而不会做饭的话，肯定要去外面吃，而饭店会为你吃饭做一些辅助的业务（例如，买菜，买盘子等等），而你只负责吃就可以了。</p><p><img src="/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20210803123739591.png" alt="代理设计模式"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">interface IEat &#123;</span><br><span class="line">    public void get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatReal implements IEat &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        System.out.println(&quot;得到一份食物，开始吃饭！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatProxy implements IEat &#123;</span><br><span class="line"></span><br><span class="line">    private IEat eat;</span><br><span class="line"></span><br><span class="line">    public EatProxy(IEat eat) &#123;</span><br><span class="line">        this.eat = eat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        this.prepare();</span><br><span class="line">        this.eat.get();</span><br><span class="line">        this.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void prepare()&#123;</span><br><span class="line">        System.out.println(&quot;1、购买食材&quot;);</span><br><span class="line">        System.out.println(&quot;2、处理食材&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        System.out.println(&quot;3、洗盘子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo18 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IEat eat = new EatProxy(new EatReal());</span><br><span class="line">        eat.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本程序为接口实现了两个子类，真实主题类和代理主题类，真实主题类只有在代理类提供支持的情况下才可以正常完成核心业务，但是对于主类而言，所关注的只是接口执行标准，而具体实现那一个子类并不去关注。</p><p>代理设计模式结合工厂设计模式</p><p>以上程序中，直接在主类中实例化了主类，这其实是不符合要求的，所有自定义的接口对象都应该通过工厂获得，修改后：</p><p><img src="/2021/08/01/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/image-20210803125650132.png" alt="工厂设计模式与代理设计模式整合"></p><p>修改代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">interface IEat &#123;</span><br><span class="line">    public void get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatReal implements IEat &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        System.out.println(&quot;得到一份食物，开始吃饭！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EatProxy implements IEat &#123;</span><br><span class="line"></span><br><span class="line">    private IEat eat;</span><br><span class="line"></span><br><span class="line">    public EatProxy(IEat eat) &#123;</span><br><span class="line">        this.eat = eat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        this.prepare();</span><br><span class="line">        this.eat.get();</span><br><span class="line">        this.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void prepare()&#123;</span><br><span class="line">        System.out.println(&quot;1、购买食材&quot;);</span><br><span class="line">        System.out.println(&quot;2、处理食材&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clear()&#123;</span><br><span class="line">        System.out.println(&quot;3、洗盘子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Factory&#123;</span><br><span class="line">    public static IEat get()&#123;</span><br><span class="line">        return new EatProxy(new EatReal());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class demo18 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IEat eat = Factory.get();</span><br><span class="line">        eat.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类与接口的区别：</p><table><thead><tr><th>no</th><th>区别</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>1</td><td>关键字</td><td>abstract class</td><td>interface</td></tr><tr><td>2</td><td>组成</td><td>常量、变量、抽象方法、普通方法、静态方法</td><td>全局常量、抽象方法、普通方法、静态方法</td></tr><tr><td>3</td><td>权限</td><td>各种权限</td><td>只能是public</td></tr><tr><td>4</td><td>关系</td><td>一个抽象类可以实现多个接口</td><td>接口不能继承抽象类，可以继承多接口</td></tr><tr><td>5</td><td>使用</td><td>子类使用extends继承抽象类</td><td>子类使用implements实现接口</td></tr><tr><td></td><td></td><td>抽象类和接口都是利用对象多态性的向上转型，进行接口或者抽象类的实例化操作</td><td></td></tr><tr><td>6</td><td>设计模式</td><td>模板设计模式</td><td>工厂设计模式、代理设计模式</td></tr><tr><td>7</td><td>局限</td><td>一个子类只能继承一个抽象类</td><td>一个子类可以实现多个接口</td></tr></tbody></table><p>接口是在类之上的定义</p><p>一个简短的分析：<br>想要我们想要定义一个动物，那么动物肯定是一个公共的标准，而这个公共标准就可以通过接口来完成，动物中又分为两类，哺乳动物和卵生动物，而这个标准属于对动物标准的进一步细化，应该称为子标准，所以此种关系可以使用接口的继承来表示，而哺乳动物又可以继续划分为人、狗、猫不同的类型，由于这些类型不表示具体的实物标准，因此使用抽象类表示。如果要表示出工人或者是学生这样的概念，那么就肯定是一个具体的定义，则使用类的方式，然而每一个学生和工人都是具体的，那么就通过对象来表示。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;抽象类与接口：有效拆分大型系统，避免产生耦合。&lt;/p&gt;
&lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;p&gt;类继承主要是为了扩充已有的类功能，子类可以根据需要决定是否覆写父类中的方法，所以一个设计完善的父类是无法对子类做出任何强制性的覆写约定。为了解决这个问题，抽象类的概念就诞生了，抽象类和普通类相比唯一增加的就是抽象方法，同时抽象类在使用时要求必须被继承，而且必须全部覆写抽象类中的抽象方法。&lt;/p&gt;
&lt;p&gt;普通类只是一个设计完善，可以直接产生实例化对象并且调用类中的属性和方法，抽象类最大特点，就是必须被子类继承，并且抽象类本身无法进行实例化。在实际项目中，往往很少设计普通类，大多都会选择继承抽象类。&lt;/p&gt;
&lt;p&gt;抽象类基本定义：抽象类是为了方法覆写而提供的类结构。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abstract class javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private String type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract String getconn();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getType() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setType(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.type = type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;本实例中利用abstract关键字声明了抽象类与抽象方法：&lt;/p&gt;
&lt;p&gt;1、抽象方法与普通方法不一样，抽象方法不能有方法体{}&lt;/p&gt;
&lt;p&gt;2、抽象类不是一个完整的类，抽象类必须提供子类，子类继承依然用extends关键字&lt;/p&gt;
&lt;p&gt;3、子类（非抽象类）一定要覆写抽象类中的全部抽象方法&lt;/p&gt;
&lt;p&gt;4、抽象类的对象实例化可以通过子类向上转型来实现&lt;/p&gt;
&lt;p&gt;抽象类的使用：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abstract class javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private String type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract String getconn();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getType() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setType(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.type = type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class javademo02 extends javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getconn()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return super.getType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class demo13  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        javademo01 j1 = new javademo02();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j1.setType(&amp;quot;mm&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(j1.getconn());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;抽象类最大特点的是自己无法对象实例化，所以说在实际项目中，抽象类用来当中间过渡，当我们想要使用抽象类中，往往是为了解决继承中带来的代码重复处理。&lt;/p&gt;
&lt;p&gt;抽象类的说明&lt;/p&gt;
&lt;p&gt;1、抽象类必须有子类继承，抽象方法必须被覆写，所以抽象类定义时，不允许final定义抽象类和抽象方法。&lt;/p&gt;
&lt;p&gt;2、抽象类也可以定义成员属性和普通方法，为了给抽象类的成员属性初始化，我们可以给抽象类设计构造方法，子类在继承时会调用抽象类的无参构造，如果抽象类没有提供，那么就需要super关键字。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abstract  class javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private String type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract  String getconn();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public javademo01(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.type = type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getType() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setType(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.type = type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class javademo02 extends javademo01&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public javademo02(String type) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super(type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getconn()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return super.getType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class demo13  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        javademo01 j1 = new javademo02(&amp;quot;mm&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(j1.getconn());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;抽象类中可以没有抽象方法，即使没有抽象方法，也不能使用new关键字实例化对象。&lt;/p&gt;
&lt;p&gt;抽象类中可以使用static定义静态方法，直接通过类名调用，毫无影响。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="http://rczmm.github.io/2021/07/28/%E7%BB%A7%E6%89%BF/"/>
    <id>http://rczmm.github.io/2021/07/28/%E7%BB%A7%E6%89%BF/</id>
    <published>2021-07-28T14:35:30.000Z</published>
    <updated>2021-07-31T14:44:28.653Z</updated>
    
    <content type="html"><![CDATA[<p>继承</p><p>面向对象的优点：模块化设计和代码重用，而依靠单一的类与对象是很难实现效果的。</p><p>（例如，学生类，人类，学生类本就属于人类，但是学生表示的范围比人又要小，因此人类是无法满足需求的）</p><p>在面向对象设计中，类是基本的逻辑单元，而对于基本的逻辑单元之间需要考虑到重用的问题，所以提供了继承，来实现类的重用。</p><p>严格来讲，类的继承是扩充一个类原有的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java中，实现继承的语法。</p><p>在继承结构里，很多时候会把子类叫做派生类，父类叫做超类。</p><p>继承的小例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son s1= new Son();</span><br><span class="line">        s1.setName(&quot;mm&quot;);</span><br><span class="line">        System.out.println(s1.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：子类没有定义任何结构，但是实例化对象之后能直接调用父类的方法与属性，证明子类重用了父类中的结构，同时可以根据子类功能进行调整。</p><p>在子类中扩充父类的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Son extends Father&#123;</span><br><span class="line">    private String school;</span><br><span class="line"></span><br><span class="line">    public String getSchool() &#123;</span><br><span class="line">        return school;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSchool(String school) &#123;</span><br><span class="line">        this.school = school;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son s1= new Son();</span><br><span class="line">        s1.setName(&quot;mm&quot;);</span><br><span class="line">        s1.setSchool(&quot;宇宙联合大学&quot;);</span><br><span class="line">        System.out.println(s1.getName()+&quot;\t&quot;+s1.getSchool());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类在父类基础上扩充了新的属性和方法，相比于父类，他更加的具体。</p><p>子类对象实例化流程：</p><p>继承关系中会产生父类和子类两种实例化对象。</p><p>子类调用父类的结构，所以说在进行子类对象实例化之前，我们会默认的调用父类的无参构造方法，为父类对象实例化（属性初始化），而后再进行子类构造调用，为子类对象实例化（属性初始化）。</p><p>子类对象实例化（无参构造调用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Father1 &#123;</span><br><span class="line">    public Father1()&#123;</span><br><span class="line">        System.out.println(&quot;父类构造方法正在调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son1 extends Father1&#123;</span><br><span class="line">    public Son1()&#123;</span><br><span class="line">        System.out.println(&quot;子类构造方法正在调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son1 s1 = new Son1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父类构造方法正在调用！</span><br><span class="line">子类构造方法正在调用！</span><br></pre></td></tr></table></figure><p>总结：程序只调用了子类的构造方法，结果发现，父类构造方法会默认的调用，执行完毕之后再执行子类的构造，所以得出结论，子类对象实例化一定会实例化父类对象，实际上相当于子类的构造方法隐含了一个super()的形式。</p><p>观察子类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Son1 extends Father1&#123;</span><br><span class="line">    public Son1()&#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;子类构造方法正在调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super的作用表示在子类中明确调用父类的构造方法，不写也会默认调用，对于super在子类构造方法中的定义，要注意，一定要写在第一行。</p><p>如果父类没有提供无参的构造方法，就可以通过super(参数)的形式调用指定参数的构造方法。</p><p>明确调用父类构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Father1 &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Father1(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son1 extends Father1 &#123;</span><br><span class="line">    private String school;</span><br><span class="line"></span><br><span class="line">    public Son1(String name, int age, String school) &#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.school = school;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son1 s1 = new Son1(&quot;mm&quot;,7,&quot;宇宙小学&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序里，父类就不再提供无参的构造方法了，这样在子类中就必须通过super关键字去明确子类要调用的父类结构，并且该语句必须放在首行。</p><p>子类一定要调用父类构造嘛？</p><p>一定的。</p><p>换一种说法，先有父母，才有子女。先有父类出生，才有子类出生。</p><p>继承限制</p><p>虽然，继承可以实现代码重用，但是这并不代表他是没有限制的。</p><p>1、单继承，一个子类只能继承一个父类。</p><p>首先，其他语言中存在多继承，也就是一个子类可以继承多个父类，在java中也可以实现这样的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public A(String name)&#123;</span><br><span class="line">        System.out.println(&quot;name:&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public B(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B&#123;</span><br><span class="line">    public C(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C类实际上是孙类，B类继承了A类的属性，C类继承了B类的属性，这就相当于了C类继承了A和B类的属性和方法，这样的操作叫<strong>多层继承</strong>，在java中只允许多层继承，不允许多重继承。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class D extends A,B,C&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：继承层数不要太多，太多影响到代码的阅读。</p><p>2、子类在继承时，会继承父类所有的属性和方法，包括私有属性。但是，对非私有的，属于显式继承（直接能用对象操作），私有的叫隐式继承（间接完成）。</p><p>没有继承私有属性，但继承了getter和setter方法。（间接完成）</p><p>覆写</p><p>在继承关系中，父类是最基础的存在，定义的结构都是为了本类的需要，但是有时候子类有一些特殊的需要，有可能会定义和父类相同名的属性和方法，这种情况就被称为覆写。</p><p>方法覆写</p><p>子类继承父类的全部方法，当父类中有些方法无法满足，就可以对这个方法进行扩充，这时，子类中定义一个方法名、返回值类型、参数类型和个数完全相同的方法的时候，就被称为方法覆写。</p><p>方法覆写基本实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;父类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DataBaese extends Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;子类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataBaese d1 = new DataBaese();</span><br><span class="line">        d1.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法覆写主要为了定义子类个性化的方法，同时保持了父类结构。</p><p>如果说，我们想要调用父类被覆写之后的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import javax.xml.parsers.SAXParser;</span><br><span class="line"></span><br><span class="line">class Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;父类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DataBaese extends Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        super.connect();</span><br><span class="line">        System.out.println(&quot;子类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataBaese d1 = new DataBaese();</span><br><span class="line">        d1.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此处，用this替代super则会报栈溢出的错误。</p><p>Exception in thread “main” java.lang.StackOverflowError</p><p>所以说，我们可以得出结论，同样是调用类结构，super不会查找自身，直接调用父类。</p><p>方法覆写限制</p><p>子类中覆写的方法不能比父类的方法具有更严格的控制权限。</p><p>private&lt;default&lt;public</p><p>子类的权限大于等于父类权限</p><p>注意：父类方法定义为private时，子类无法覆写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Channel&#123;</span><br><span class="line">    private void connect()&#123;</span><br><span class="line">        System.out.println(&quot;父类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void m1()&#123;</span><br><span class="line">        this.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DataBaese extends Channel&#123;</span><br><span class="line">    public void connect()&#123;</span><br><span class="line">        System.out.println(&quot;子类连接资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo08 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataBaese d1 = new DataBaese();</span><br><span class="line">        d1.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载与覆写：</p><p>重载：方法名相同、其他可以不同、没有权限要求、发生了一个类中</p><p>覆写：方法名、参数、返回值都想同、子类覆写的方法权限要大于等于父类方法、发生在继承关系中。</p><p>属性覆盖</p><p>子类依据自身需求对父类属性进行重命名定义。</p><p>要注意：private属性无效。</p><p>只需要属性名一致即可，数据类型可以不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class animal&#123;</span><br><span class="line">    double age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class person11 extends animal&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    public void info()&#123;</span><br><span class="line">        System.out.println(this.age);</span><br><span class="line">        System.out.println(super.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        person11 p1 = new person11();</span><br><span class="line">        p1.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super和this</p><p>super：表示父类对象、父类操作，属性，方法，（）构造方法、调用父类构造，放在首行、由子类查找父类</p><p>this：表示本类对象、本类操作，属性，方法，（）构造方法、调用本来构造，放在首行、从本类查找、表示当前对象</p><p>final关键字</p><p>为了保护父类定义</p><p>final在java描述为终接器。</p><p>定义不能继承的类，不能覆写的方法，常量（全局常量）。</p><p>关于常量和字符串连接的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class demo09 &#123;</span><br><span class="line"></span><br><span class="line">    public static final String str1 = &quot;mm&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str2 = &quot;ilovemm&quot;;</span><br><span class="line">        String str3 = &quot;ilove&quot;+str1;</span><br><span class="line">        System.out.println(str2==str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>annotation注解(明确声明，为了良好的代码阅读)</p><p>1、准确覆写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class F &#123;</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class S extends F &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;子类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解就可以在不清楚父类结构的情况下，分析哪些是覆写方法，哪些是自定义方法，此处还可以在编译时检测因为子类拼写造成的方法覆写错误。</p><p>2、过期声明</p><p>程序是不断更新的，有时候会有一些不再推荐使用的结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class F &#123;</span><br><span class="line">    </span><br><span class="line">    @Deprecated</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void m3()&#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class S extends F &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;子类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合理开发时，不要使用已经被注解之后的，弃用结构，不利于后期更新。</p><p>3、压制警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class F &#123;</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void m2() &#123;</span><br><span class="line">        System.out.println(&quot;父类正在运行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo10 &#123;</span><br><span class="line">    @SuppressWarnings(value = &#123;&quot;deprecation&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new F().m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证代码的合理性，在编译时会抛出警告，但是有些错误不必要，为了防止这些信息出现，就可以用压制警告注解。</p><p>deprecation：使用了不赞成的类或方法。</p><p>多态</p><p>同一种结构会根据不同形式展示出不同的效果。</p><p>方法的多态性：</p><p>重载：同一方法，根据传入参数不同实现不同功能</p><p>覆写：同一个方法根据子类不同实现不同功能</p><p>对象的多态性：</p><p>父类与子类的转换</p><p>向上转型：父类 父类实例 = 子类实例 （自动转换）</p><p>向下转型：子类 子类实例 = （子类）父类实例 （强制转换完成）</p><p>参考意见：实际的转型处理上看，向上转型用的比较多，向下转型往往都在使用子类特殊功能的时候，还有不转型使用（例如：String类）</p><p>父类定义标准，子类定义个性化。（覆写）</p><p>向上转型：子类对象实例化之前一定会实例化父类对象，这个时候如果我们把子类对象的实例通过父类来接受，即可实现对象的向上转型。而此时的本质还是子类实例，所以说，一旦调用子类覆写了父类的方法，调用的一定是覆写之后的方法。</p><p>最大的特点在于可以通过父类对象接受子类实例，这一原则有助于实现方法接受或返回参数的统一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class animal &#123;</span><br><span class="line">    public double age = 7;</span><br><span class="line">    public void info()&#123;</span><br><span class="line">        System.out.println(&quot;父类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class person11 extends animal &#123;</span><br><span class="line">    public int age = 7;</span><br><span class="line"></span><br><span class="line">    public void info() &#123;</span><br><span class="line">       System.out.println(&quot;子类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo09 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        animal a1 = new person11();</span><br><span class="line">        a1.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不要看类名称，看实例化对象的类。关键看调用哪个类的构造。（new后的内容，不看左边看右边）</p><p>最大的特点在于可以通过父类对象接受子类实例，这一原则有助于实现方法接受或返回参数的统一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class kafka extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am kafka&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mq extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am mq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class database&#123;</span><br><span class="line">    /*</span><br><span class="line">     * 接受message对象，由于存在自动向上转型的机制，所以可以接受所有的子类实例</span><br><span class="line">     */</span><br><span class="line">    public static void m3(message m1)&#123;</span><br><span class="line">        m1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        database.m3(new kafka());</span><br><span class="line">        database.m3(new mq());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本类中定义的m3方法，参数类型是message，这就意味着所有message以及子类对象都可以接受，相当于统一了参数类型。</p><p>向上转型主要是为了实现操作标准的统一性。</p><p>向下转型：保持子类实例的个性化</p><p>子类继承父类之后可以对已经有的功能进行扩充（覆写，新加），对于子类之中扩充的方法只有具体的子类实例才可以调用，在这样的情况下，如果子类发生了向上转型呐？</p><p>需要通过强制向下转型来实现子类扩充方法的调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class kafka extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am kafka&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print2()&#123;</span><br><span class="line">        System.out.println(&quot;i am java 11&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mq extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am mq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        message m1 = new kafka();</span><br><span class="line">        m1.print();</span><br><span class="line">        kafka k1 = (kafka) m1;</span><br><span class="line">        k1.print2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，通过kafka子类接收了message对象，此时m1只能调用本类或者是m1父类的方法，如果此时需要调用子类中扩充的方法，就必须强制转换为指定的子类类型。</p><p>要先发生向上转型，才可以进行向下转型。</p><p>父类实例是不可能强者转换成任意子类实例的，因为两者之间没有联系。必须先通过子类实例，利用向上转型让父类对象和子类实例发生关系才可以向下转型，否则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    message m1 = new message();</span><br><span class="line">    kafka k1 = (kafka) m1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException</span><br></pre></td></tr></table></figure><p>这里就是message对象并没有和kafka子类产生联系，所以无法强制转换。向下转换永远都存在安全隐患。</p><p>为了保证转换的安全性，给出了instanceof关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    message m1 = new kafka();</span><br><span class="line">    kafka k1 = (kafka) m1;</span><br><span class="line">    System.out.println(m1 instanceof message);</span><br><span class="line">    System.out.println(k1 instanceof message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>所以说，我们可以通过先判断再转换的方式去进行转型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class kafka extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am kafka&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print2()&#123;</span><br><span class="line">        System.out.println(&quot;i am java 11&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mq extends message&#123;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i am mq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        message m1 = new kafka();</span><br><span class="line">        m1.print();</span><br><span class="line">        if (m1 instanceof kafka)&#123;</span><br><span class="line">            kafka k1 = (kafka) m1;</span><br><span class="line">            k1.print2();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object类</p><p>在java里是最重要的程序类，也是所有类的父类。</p><p>方便操作类型的统一，方便每一个类定义一些公共操作，专门设计了一个公共的object父类，object是唯一一个没有父类的类。但是却是所有类的父类，所有利用class关键字定义的类默认都全部继承于object类，因此：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class message extends Object&#123;</span><br><span class="line">class message &#123;</span><br></pre></td></tr></table></figure><p>这两种类定义的效果都是一样的。</p><p>所有类都是object的子类，那么就代表所有类对象都可以利用向上转型为obejct类对象实例化。</p><p>这样优势在于，当某些操作需要接受或者返回任意类型时候，最适合的参数类型就是object。</p><p>object除了能接收所有的类实例之外，还可以接收所有的引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object a1 = new int[]&#123;1,2,3&#125;;</span><br><span class="line">    if (a1 instanceof int[])&#123;</span><br><span class="line">        int data [] = (int[]) a1;</span><br><span class="line">        for (int temp: data) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取对象信息</p><p>在object类中有一个tostring（）方法，利用这个方法可以实现对象信息的获取，同时这个方法在进行对象输出被默认调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object a1 = new int[]&#123;1,2,3&#125;;</span><br><span class="line">System.out.println(a1.toString());</span><br><span class="line">System.out.println(a1);</span><br></pre></td></tr></table></figure><p>具体中，我们可以根据需要覆写tostring方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class message &#123;</span><br><span class="line">    private int length;</span><br><span class="line"></span><br><span class="line">    public int getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLength(int length) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public message(int length) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;i love mm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;队列长度:&quot; + this.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object a1 = new message(12);</span><br><span class="line">        System.out.println(a1.toString());</span><br><span class="line">        System.out.println(a1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本例中，定义了length属性，覆写了tostring方法，而后调用时，就会实现我们自己实现的方法体内的内容。</p><p>对象比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class demo extends Object&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public demo(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj)&#123;</span><br><span class="line">        if (!(obj instanceof demo))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj == null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this == obj)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        demo d1 = (demo) obj;</span><br><span class="line">        return this.name.equals(d1.name) &amp;&amp; this.age == d1.age;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class demo12 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        demo d1 = new demo(&quot;mm&quot;,7);</span><br><span class="line">        demo d2 = new demo(&quot;mm&quot;,7);</span><br><span class="line">        System.out.println(d1.equals(d2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继承&lt;/p&gt;
&lt;p&gt;面向对象的优点：模块化设计和代码重用，而依靠单一的类与对象是很难实现效果的。&lt;/p&gt;
&lt;p&gt;（例如，学生类，人类，学生类本就属于人类，但是学生表示的范围比人又要小，因此人类是无法满足需求的）&lt;/p&gt;
&lt;p&gt;在面向对象设计中，类是基本的逻辑单元，而对于基本</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>String类</title>
    <link href="http://rczmm.github.io/2021/07/27/String%E7%B1%BB/"/>
    <id>http://rczmm.github.io/2021/07/27/String%E7%B1%BB/</id>
    <published>2021-07-27T14:59:04.000Z</published>
    <updated>2021-07-29T08:21:22.872Z</updated>
    
    <content type="html"><![CDATA[<p>String 类</p><p>string在实际开发中，几乎是一个必须使用的程序类，也可以说是项目的核心组件类。</p><p>string用“”双引号定义，可以用+实现字符串连接。</p><p>1、string类对象实例化</p><p>java中基本数据类型不包含string，但是考虑到程序开发的实际需要，就设计了string类，并且这个类的对象可以直接赋值进行实例化。</p><p>java程序中使用双引号定义的内容，都是字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line"></span><br><span class="line">private final byte[] value</span><br></pre></td></tr></table></figure><p>jdk8 保存的是字符数组，jdk9之后字符串源代码实现就是字节数组。</p><p>我们可以得出一个结论，string就是对数组的特殊包装应用，而对数组而言最大的问题是长度的固定。</p><p>string本身是一个系统类，除了可以赋值进行对象实例化之外，还可以使用相关的构造方法来进行对象实例化。</p><p>string类构造方法(之一)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String(String original) &#123;</span><br><span class="line">    this.value = original.value;</span><br><span class="line">    this.coder = original.coder;</span><br><span class="line">    this.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    String str02 = new String(&quot;2222&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，两种定义方式，看起来效果几乎完全一样，但实际上两者是有本质差别的。</p><p>字符串比较</p><p>如果是基本数据类型，在java中，可以使用==比较运算符直接进行比较。</p><p>但是string属于引用数据类型，他的对象名中保存的是堆内存地址，string对象使用==比较的就不再是内容，而是堆内存地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    String str03 = &quot;1111&quot;;</span><br><span class="line">    String str02 = new String(&quot;1111&quot;);</span><br><span class="line">    System.out.println(str02==str01);</span><br><span class="line">    System.out.println(str03==str01);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于自定义类的比较，和字符串一样，都是比较的堆内存地址。</p><p>在string类里，提供了equals（）方法来比较字符串内容（区分大小写）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    String str03 = &quot;1111&quot;;</span><br><span class="line">    String str02 = new String(&quot;1111&quot;);</span><br><span class="line">    System.out.println(str01.equals(str02));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>字符串常量</p><p>常量就是不会修改的内容。</p><p>字符串常量，严格意义上说是string类的匿名对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = &quot;1111&quot;;</span><br><span class="line">    System.out.println(&quot;1111&quot;.equals(str01));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的普通方法只有对象能调用，所以我们说字符串常量是string类的匿名对象。</p><p>所谓的直接赋值的操作，实际上就是给匿名对象一个名字而已。</p><p>区别：string类的匿名对象是系统自动生成的，不再由用户自己创建。</p><p>实际问题——字符串比较：</p><p>如果我们要获取用户输入，然后进行字符串比较，但是用户没有输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String input = null;</span><br><span class="line">    if (input.equals(&quot;baidu&quot;))&#123;</span><br><span class="line">        System.out.println(&quot;www。baidu.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></pre></td></tr></table></figure><p>解决途径：（回避）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String input = null;</span><br><span class="line">    if (&quot;baidu&quot;.equals(input))&#123;</span><br><span class="line">        System.out.println(&quot;www。baidu.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中直接调用了字符串常量“baidu”来执行。equals方法，因为字符串<strong>常量</strong>是string对象，所以永远不可能是null，而equals方法的参数又是object，因此这就避免了空指针异常。</p><p>两种实例化方式的比较：</p><p>1、直接赋值：</p><p>在堆内存中开辟一块地址，保存字符串常量，并且栈内存直接引用这一部分的堆内存。</p><p>而且，对同一字符串的多次直接赋值还可以实现对堆内存的重复利用。也就是说采用直接赋值的方式进行string对象实例化，在内容相同（字符串常量一致）的情况下，不会开辟新的堆内存空间，而会直接指向已有的堆内存。</p><p>字符串对象池</p><p><strong>jvm的底层的存在一个对象池</strong>（string只是对象池中的一种类型），当我们使用直接赋值的方式定义了一个string对象之后，字符串所使用的匿名对象入池保存，如果后面我们还有string对象直接赋值定义，并且采用了同一块字符串常量，也就是内容相同，那么就不会开辟新的堆内存空间，而是使用已经有的对象进行引用的分配。</p><p>共享设计模式的应用：（如果有一天，你需要一把剪刀，你出去买了一把，用完之后不可以丢掉，放在家里，等下一次用的时候再继续使用，剪刀放在工具箱里，同样工具箱的东西都可以下一次继续使用）</p><p>构造方法实例化：</p><p>如果要明确的调用string类的构造方法进行实例化string对象，那么一定要使用new关键字，而每当使用new关键字时，就会开辟新的堆内存空间。而这块堆内存的内容就是构造方法传入的字符串常量。</p><p>构造方法定义时：传入的字符串常量会创建一个匿名对象，然后new关键字会开辟一块堆内存空间，也会传入一个字符串常量。那么就相当于一共创建了两块堆内存空间，并且字符串常量也就是匿名对象创建的堆内存只负责实例化string对象，不与构造方法实例化出的string对象有关联。真正使用的堆内存是new开辟的堆内存，而之前定义字符串常量开辟的堆内存空间不会被任何栈内存引用（指向），成为垃圾空间，等待gc回收。</p><p>因此，构造方法创建string对象，会开辟两份空间，并且一块空间成为垃圾。</p><p>除此之外。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = new String(&quot;mm&quot;);</span><br><span class="line">    String str02 = &quot;mm&quot;;</span><br><span class="line">    System.out.println(str01 == str02);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>使用构造方法定义的string对象不会自动入池保存。</p><p>string对象手动入池：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str01 = new String(&quot;mm&quot;).intern();</span><br><span class="line">    String str02 = &quot;mm&quot;;</span><br><span class="line">    System.out.println(str01 == str02);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>所以，实际开发时，尽量的直接赋值定义字符串。</p><p>字符串常量池</p><p>为了防止字符串过多，jdk进行了结构上的优化。（本质是一个动态对象数组），所有直接赋值的字符串对象都可以自动保存在常量池中，方便下次使用。</p><p>静态常量池：</p><p>程序（class）在加载（不是运行）时会把字符串、常量、类、方法全部进行分配</p><p>运行时常量池：</p><p>加载之后，有一些字符串内容是通过拼接的，由于string对象内容可以改变，所以叫做运行时常量池。</p><p>字符串修改：</p><p>常量的内容一旦被定义就无法修改，但是字符串比较特殊，重新实例化来实现修改字符串内容。</p><p>string类关于数据的存储是通过数组，数组本身又是定长的数据类型。实际上就代表了string对象一旦被实例化，内容就无法改变，那么字符串对象内容实际上就是通过改变引用的方式来实现的。</p><p>要注意：这样会产生许多的垃圾空间。</p><p>主方法组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String [] args) &#123;&#125;</span><br></pre></td></tr></table></figure><p>public: 一种访问权限、主方法是一切程序的入口，有且只能有一个，一定是公共的。</p><p>static：程序的执行是通过类，所以这个方法由类直接调用。</p><p>void：主方法是一切程序的起点，程序一旦开始，不需要返回结果。</p><p>main：系统定义好的方法名称，当java执行时，自动寻找。</p><p>String [] args：字符串的数组，可以实现启动参数的接受。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class demo04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if (args.length == 0)&#123;</span><br><span class="line">            System.out.println(&quot;please input your argments:&quot;);</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for (String temp:args) &#123;</span><br><span class="line">                System.out.println(temp+&quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java demo04 one 2 3 4 5</span><br></pre></td></tr></table></figure><p>string类常用方法：</p><p>1、字符数组转字符串（字节等同理）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char [] char01 =new char[]&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;&#125;;</span><br><span class="line">String str01 = new String(char01);</span><br><span class="line">System.out.println(str01);</span><br></pre></td></tr></table></figure><p>2、指定范围转换（第二个参数是步长）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char [] char01 =new char[]&#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;&#125;;</span><br><span class="line">String str01 = new String(char01,0,3);</span><br><span class="line">System.out.println(str01);</span><br></pre></td></tr></table></figure><p>3、获取指定索引的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.charAt(0));</span><br></pre></td></tr></table></figure><p>4、大小写转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.toLowerCase());</span><br><span class="line">System.out.println(str01.toUpperCase());</span><br></pre></td></tr></table></figure><p>5、截取字符串（开始索引到结束索引）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.substring(0,10));</span><br><span class="line">System.out.println(str01.substring(0));</span><br></pre></td></tr></table></figure><p>6、判断是否以指定字符串开头、结尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.startsWith(&quot;12&quot;));</span><br><span class="line">System.out.println(str01.startsWith(&quot;12&quot;,3));</span><br><span class="line">System.out.println(str01.endsWith(&quot;rf&quot;));</span><br></pre></td></tr></table></figure><p>7、字符串替换（全部替换，替换第一个）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str01 = &quot;121e3drwcfefrf&quot;;</span><br><span class="line">System.out.println(str01.replaceAll(&quot;1&quot;,&quot;mm&quot;));</span><br><span class="line">System.out.println(str01.replaceFirst(&quot;3&quot;,&quot;mm&quot;));</span><br></pre></td></tr></table></figure><p>………..</p><p>java doc文档</p><p>这是java官方提供的关于jdk相关api的文档，文档中详细描述了每一个模块中不同的包里不同的类的相关定义和相关说明信息，以及成员属性介绍，包括构造方法普通方法以及其他的说明摘要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;String 类&lt;/p&gt;
&lt;p&gt;string在实际开发中，几乎是一个必须使用的程序类，也可以说是项目的核心组件类。&lt;/p&gt;
&lt;p&gt;string用“”双引号定义，可以用+实现字符串连接。&lt;/p&gt;
&lt;p&gt;1、string类对象实例化&lt;/p&gt;
&lt;p&gt;java中基本数据类型不包含s</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://rczmm.github.io/2021/07/26/%E6%95%B0%E7%BB%84/"/>
    <id>http://rczmm.github.io/2021/07/26/%E6%95%B0%E7%BB%84/</id>
    <published>2021-07-26T15:31:38.000Z</published>
    <updated>2021-07-27T14:51:33.994Z</updated>
    
    <content type="html"><![CDATA[<p>数组</p><p>数组是程序设计语言里面一门很重要的数据结构，java里，数组是引用数据类型，就必然牵扯到栈内存的开辟和引用传递。</p><p>数组是一门非常基础的线性存储结构，可以实现一组变量的有效关联。</p><p>数组是一些相关变量的集合。如果我现在要定义100个整形变量，</p><p>int i1，i2，i3…i100.</p><p>以上的定义方式可以满足需求，但是每一个变量之间不存在逻辑控制关系，每一个变量完全独立，就会出现不方便管理变量的情况。</p><p>数组：</p><p>声明与开辟：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int listDemo01 [] = new int[10];</span><br><span class="line">int [] listDemo02 = new int[10];</span><br><span class="line">数据类型 [] 数组名称 = new 数据类型[长度]</span><br></pre></td></tr></table></figure><p>声明：</p><p>数据类型 [] 数组名称 = null；</p><p>开辟：</p><p>数据名称 = new 数据类型 [长度]；</p><p>当数组开辟空间之后，就可以通过访问下标，索引的方式去实现查询，修改，删除。所有数组的索引都是从0开始的。如果访问的索引超过了数组下标的长度，那就会抛出异常，（数据越界）</p><p>以上的都是动态初始化的内容，只给了数组长度，如果如上声明，则每一个元素的数据类型都是int，且根据默认值，是0。</p><p>数组是一种顺序结构，长度是固定的，输出的时候采用循环。（for循环）</p><p>java为了方便获取数组长度，提供了此listDemo01.length属性。</p><p>数组的核心：声明并且分配内存空间，而后根据索引进行访问。</p><p>数组和对象：差别就在于堆内存中，对象保存的是属性，数组保存的是信息。</p><p>静态初始化（在开辟内存空间的时候，就给出数组中元素的值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int data [] =null;</span><br><span class="line">data = new int[] &#123;1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure><p>数组最大的方便就是在于可以使用线性结构来存储相同数据类型的变量，但是另一个角度来看，最大的缺陷也正是如此，保存个数固定，因此在实际中，我们会采用类集框架（java提供的数据结构实现）来实现动态数组的操作。但是这并不意味着，我们不会使用数组。</p><p>数组引用传递分析：</p><p>数组属于引用数据类型，在使用是需要new关键字开辟堆内存空间，一个堆内存可以被多个栈内存指向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int data[] = new int[]&#123;10, 20, 30&#125;;</span><br><span class="line">int temp[] = data;</span><br><span class="line">temp[0] = 99;</span><br><span class="line">for (int i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">    System.out.print(data[i]+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">992030</span><br></pre></td></tr></table></figure><p>要注意对数组来说，如果只是声明，没有开辟空间，是无法根据下标访问的，否则会报空指针异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int temp[] = null;</span><br><span class="line">temp[0] = 99;</span><br><span class="line">System.out.println(temp[0]);</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></pre></td></tr></table></figure><p>foreach输出</p><p>数组的输出除了索引和循环之外，还提供了foreach结构。</p><p>数组，定长。</p><p>foreach（加强的for循环）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int data[] = new int[]&#123;10, 20, 30&#125;;</span><br><span class="line"></span><br><span class="line">for (int temp : data) &#123;</span><br><span class="line">    System.out.println(temp+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：没有foreach关键字。</p><p>利用foreach输出，可以避免数组越界异常。</p><p>二维数组：</p><p>两个数组的嵌套。</p><p>之前的数组，一维数组，实际上是一种线性结构。（相当于只描述了一行的内容）</p><p>现在我们要描述多行多列的内容，那就需要用到二维数组。（多维数组）</p><p>动态初始化、静态初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int data [][] = new int [8][8];</span><br><span class="line">int data1 [][] = new int [][] &#123;&#123;1,1,1&#125;,&#123;2,2,2&#125;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int data1 [][] = new int [][] &#123;&#123;1,1,1&#125;,&#123;2,2,2&#125;,&#123;1,2,4,5,6,7&#125;&#125;;</span><br><span class="line">for (int x =0 ;x&lt;data1.length;x++)&#123;</span><br><span class="line">    for (int y=0;y&lt;data1[x].length;y++)&#123;</span><br><span class="line">        System.out.print(data1[x][y]+&quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外层循环控制行，内存循环控制列。</p><p>foreach循环输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int temp[] : data) &#123;</span><br><span class="line">    for (int num: temp) &#123;</span><br><span class="line">        System.out.print(num + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组与方法：</p><p>在数组进行引用传递，最为常见的就是利用方法进行引用数据的处理或者返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int data[][] = new int[][]&#123;&#123;1, 1, 1&#125;, &#123;2, 2, 2&#125;, &#123;1, 2, 4, 5, 6, 7&#125;&#125;;</span><br><span class="line">    printArray(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void printArray(int data[][])&#123;</span><br><span class="line">    for (int temp[] : data) &#123;</span><br><span class="line">        for (int num: temp) &#123;</span><br><span class="line">            System.out.print(num + &quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void changeArray(int data[][])&#123;</span><br><span class="line">    for (int temp[] : data) &#123;</span><br><span class="line">        for (int num: temp) &#123;</span><br><span class="line">            num *= 2;</span><br><span class="line">            System.out.print(num+&quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int data[] = new int[]&#123;1, 3, 4, 5, 6, 78, 23, 54, 65, 76, 432, 32, 54&#125;;</span><br><span class="line">    Arrays.sort(data);</span><br><span class="line"></span><br><span class="line">    for (int temp : data) &#123;</span><br><span class="line">        System.out.print(temp + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组转置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int data[] = new int[]&#123;1, 3, 4, 5, 6, 78, 23, 54, 65, 76, 432, 32, 54&#125;;</span><br><span class="line">    Arrays.sort(data);</span><br><span class="line"></span><br><span class="line">    int center = data.length / 2; //确定交换次数</span><br><span class="line">    int head = 0;</span><br><span class="line">    int tail = data.length - 1;</span><br><span class="line">    for (int x = 0; x &lt; center; x++) &#123;</span><br><span class="line">        int temp = data[head];</span><br><span class="line">        data[head] = data[tail];</span><br><span class="line">        data[tail] = temp;</span><br><span class="line">        head++;</span><br><span class="line">        tail--;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int temp : data) &#123;</span><br><span class="line">        System.out.print(temp + &quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组复制：</p><p>是把源数组部分内容复制到另一个数组，但是数组长度不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int data[] = new int[]&#123;1, 3, 4, 5, 6, 78, 23, 54, 65, 76, 432, 32, 54&#125;;</span><br><span class="line">int data1[] = new int[]&#123;1, 3, 4, 5, 6&#125;;</span><br><span class="line"></span><br><span class="line">System.arraycopy(data,4,data1,1,3);</span><br></pre></td></tr></table></figure><p>（源数组名称、源数组开始点、目标数组名、目标数组开始点、长度）</p><p>方法可变参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int sum(int... data) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int temp:data) &#123;</span><br><span class="line">        sum += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(sum(data));</span><br><span class="line">System.out.println(sum(1,23,45,65,7543,9));</span><br></pre></td></tr></table></figure><p>为了方便我们灵活的定义方法，避免参数限制，就给出了方便可变参数。</p><p>（参数类型…变量）</p><p>混合参数定义时（既有普通参数，也有可变的参数）</p><p>可变参数一定要写在最后、并且一个方法只能有一个可变参数</p><p>对象数组</p><p>数组内不止可以存放基本数据类型，还可以存放引用数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Person0 &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person0(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return &quot;name:&quot; + this.name + &quot;\tage:&quot; + this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person0 p1[] = new Person0[3];</span><br><span class="line">        p1[0] = new Person0(&quot;mm&quot;, 7);</span><br><span class="line">        p1[1] = new Person0(&quot;mm01&quot;, 4);</span><br><span class="line">        p1[2] = new Person0(&quot;mm01&quot;, 8);</span><br><span class="line">        for (Person0 temp : p1) &#123;</span><br><span class="line">            System.out.println(temp.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用传递应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line">    private Person1 person;</span><br><span class="line"></span><br><span class="line">    public Car(String name, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person1 getPerson() &#123;</span><br><span class="line">        return this.person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPerson(Person1 person) &#123;</span><br><span class="line">        this.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tprice:&quot;+this.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person1&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Car car;</span><br><span class="line"></span><br><span class="line">    public Person1(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Car getCar() &#123;</span><br><span class="line">        return this.car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCar(Car car) &#123;</span><br><span class="line">        this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tage:&quot;+this.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person1 p1 = new Person1(&quot;mm&quot;,7);</span><br><span class="line">        Car c1 = new Car(&quot;mm01&quot;,1223132.32);</span><br><span class="line">        p1.setCar(c1);</span><br><span class="line">        c1.setPerson(p1);</span><br><span class="line">        System.out.println(p1.getCar().getInfo());</span><br><span class="line">        System.out.println(c1.getPerson().getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意87、88.代码链。</p><p>自身类结构关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double price;</span><br><span class="line">    private Person1 person;</span><br><span class="line"></span><br><span class="line">    public Car(String name, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person1 getPerson() &#123;</span><br><span class="line">        return this.person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPerson(Person1 person) &#123;</span><br><span class="line">        this.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tprice:&quot;+this.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person1&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person1[] getChild() &#123;</span><br><span class="line">        return this.child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setChild(Person1[] child) &#123;</span><br><span class="line">        this.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Car car;</span><br><span class="line">    private Person1 child[];</span><br><span class="line"></span><br><span class="line">    public Person1(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Car getCar() &#123;</span><br><span class="line">        return this.car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCar(Car car) &#123;</span><br><span class="line">        this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;name:&quot;+this.name+&quot;\tage:&quot;+this.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person1 p1 = new Person1(&quot;mm&quot;,7);</span><br><span class="line">        Person1 child1 = new Person1(&quot;mm01&quot;,7);</span><br><span class="line">        Person1 child2 = new Person1(&quot;mm02&quot;,7);</span><br><span class="line">        child1.setCar(new Car(&quot;法拉克&quot;,121321321.2221));</span><br><span class="line">        child2.setCar(new Car(&quot;卡车拉货&quot;,12132.3231));</span><br><span class="line">        p1.setChild(new Person1[]&#123;child1,child2&#125;);</span><br><span class="line">        Car c1 = new Car(&quot;bbb&quot;,12121.32);</span><br><span class="line">        p1.setCar(c1);</span><br><span class="line">        c1.setPerson(p1);</span><br><span class="line"></span><br><span class="line">        for (int x=0;x&lt;p1.getChild().length;x++)&#123;</span><br><span class="line">            System.out.println(p1.getChild()[x].getInfo());</span><br><span class="line">            System.out.println(p1.getChild()[x].getCar().getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合成设计模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Pc &#123;   //父结构</span><br><span class="line">    private 显示器 对象数组[];  //一台计算机可以连接多个小显示器</span><br><span class="line">    private 主机 对象; //一台计算机只能有一个主机</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 显示器 &#123;  //独立类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 主机 &#123;   //子结构</span><br><span class="line">    private 主板 对象; //一块主板</span><br><span class="line">    private 鼠标 对象1; //一个鼠标</span><br><span class="line">    private 键盘 对象2; //一块键盘</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 主板 &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 鼠标 &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 键盘 &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过不同的类实现子结构，然后在父结构中整合。（如上，就是典型的面向对象思想）</p><p>引用数据类型不仅仅是内存的操作形式，更多的是抽象和关联的设计思想</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组&lt;/p&gt;
&lt;p&gt;数组是程序设计语言里面一门很重要的数据结构，java里，数组是引用数据类型，就必然牵扯到栈内存的开辟和引用传递。&lt;/p&gt;
&lt;p&gt;数组是一门非常基础的线性存储结构，可以实现一组变量的有效关联。&lt;/p&gt;
&lt;p&gt;数组是一些相关变量的集合。如果我现在要定义100</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>类与对象</title>
    <link href="http://rczmm.github.io/2021/07/25/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-1/"/>
    <id>http://rczmm.github.io/2021/07/25/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-1/</id>
    <published>2021-07-25T14:49:45.000Z</published>
    <updated>2021-07-26T15:31:23.418Z</updated>
    
    <content type="html"><![CDATA[<p>类与对象</p><p>面向对象，java一大特点之一。</p><p>面向对象三大特性：封装、继承、多态。</p><p>类：成员属性和成员方法组成的，成员属性实际上就是一个变量，方法就是操作上的行为。</p><p>定义类，要根据程序语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    </span><br><span class="line">    public void tell()&#123;</span><br><span class="line">        System.out.println(name+&quot;\t&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点注意，没有static。</p><p>调用形式不同，主类中（public修饰的类）由主方法（main）直接调用的方法必须加static。但是现在tell方法是由对象调用的。</p><p>一个类定义完成之后。并不能直接使用，因为类描述的只是一个广泛的概念，具体的操作要通过对象来执行，类属于引用数据类型。</p><p>对象的定义格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person();</span><br></pre></td></tr></table></figure><p>类名 对象名 = new 类名（）;</p><p>java里引用数据类型是需要进行内存分配，所以在定义的时候必须用new关键字来分配相对应的内存空间，这个过程也被叫实例化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(p1.name);</span><br><span class="line">System.out.println(p1.age);</span><br><span class="line">p1.tell();</span><br></pre></td></tr></table></figure><p>对象内存分析</p><p>引用数据类型必须用new开辟内存，才可以储存成员属性，在引用数据类型操作中最重要的内存有两块。</p><p>heap（堆）：对象的具体信息（成员属性），new开辟的也正是堆内存</p><p>stack（栈）：保存的是堆内存的地址，也就是通过地址找到堆，而后找到对象内容，简单理解就是栈里保存了对象名称。</p><p>方法信息</p><p>类中成员属性是对象私有的，但是方法是对象共有的，方法的信息会保存在全局方法区（公共内存）</p><p>对象引用传递分析</p><p>引用传递是java的核心概念。引用数据类型的核心就是在于堆内存和栈内存的分配与指向处理，同一块堆内存可以指向不同的栈内存。（一个人可以有很有名字）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">p1.name=&quot;mm&quot;;</span><br><span class="line">p1.age=8;</span><br><span class="line">p1.tell();</span><br><span class="line">Person p2=p1;</span><br><span class="line">p2.age=9;</span><br><span class="line">p1.tell();</span><br></pre></td></tr></table></figure><p>引用传递（将p1对象的内存堆地址赋值给p2）这就相当于两个不同的栈内存指向了同一块堆内存。</p><p>引用传递与垃圾产生分析</p><p>内存管理，java——gc机制。</p><p>一块栈只允许一个堆内存地址信息。（如果需要改变，那就存在一个丢弃原有的引用实体，更换新的引用实体的问题。）</p><p>丢弃原始引用实体的时候（产生垃圾）</p><p>所有的垃圾都将等待gc不定期回收释放。</p><p>开发的时候尽量避免垃圾产生。</p><p>成员属性封装</p><p>封装性、本质上就是让内部结构对外不可见。</p><p>如果没有封装，类中的所有成员属性可以直接通过实例化对象在类外部直接调用，但是这样的调用是很不安全的，这时最稳妥的就是使用private关键字对成员属性进行封装处理。</p><p>当使用了private之后，是不允许外部对象直接访问成员属性的。</p><p>此时，访问成员属性，需要用到getter（），setter（）方法。</p><p>实际上，不仅针对成员属性封装，还有方法、内部类封装，这里只说一点点。</p><p>setter和getter的目的，是为了设置和取得属性内容，有时候或许不会用到其中某一个，但是作为一种标准，我们必须全部提供。</p><p>还可以在setter里添加限制条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if (age &gt;= 0 &amp;&amp; age &lt;= 300) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;this age is error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tell() &#123;</span><br><span class="line">        System.out.println(name + &quot;\t&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法与匿名对象</p><p>构造方法是实例化的时候一种重要的结构，一种特殊的方法。在new这个类的时候，默认调用构造方法，功能：主要是为了完成成员属性的初始化操作。</p><p>构造方法名和类名一样，构造方法没有返回值<strong>类型</strong>。</p><p>其实，对象实例化一定要求有构造方法的，java提供了一个默认的构造方法。（这个方法没有参数、没有返回值，如果我们定义了，那就不会生成。）一个类中至少存在一个构造方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的构造方法。</p><p>构造方法虽然特殊，但还是方法，就存在重载。不过构造方法重载的时候只需要考虑参数的类型个数就可以了。</p><p>对象实例化的时候，new关键字主要是进行开辟堆内存，对象名称是为了对堆内存的引用，这样一是为了防止堆内存变成垃圾空间。</p><p>有了构造方法之后，在堆内存开辟的同时就可以对对象进行实例化处理，也就是即使没有栈内存指向，也就是没有对象名称，但是对象至少可以使用一次，对于这种没有指向的对象就叫做匿名对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class demo01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Person(&quot;mm&quot;,7).tell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String tempname,int tempage)&#123;</span><br><span class="line">        name = tempname;</span><br><span class="line">        age = tempage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if (age &gt;= 0 &amp;&amp; age &lt;= 300) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;this age is error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tell() &#123;</span><br><span class="line">        System.out.println(name + &quot;\t&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序，因为没有栈内存的指向，所以这个对象在使用了一次之后将成为垃圾空间。</p><p>匿名对象相当于一个一次性饭盒，使用一次就被定义为垃圾空间，等待gc回收，普通对象存在一个引用关系，所以就可以反复操作。</p><p>this关键字</p><p>this描述的是本类结构调用的关键字，java里this可以描述3种结构</p><p>1、类的属性</p><p>2、类的方法</p><p>3、当前对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    char sex;</span><br><span class="line"></span><br><span class="line">    public Person(String name,int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if (age &gt;= 0 &amp;&amp; age &lt;= 300) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;this age is error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tell() &#123;</span><br><span class="line">        System.out.println(this.name + &quot;\t&quot; + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明确的标注了本类属性。</p><p>在日后，为了避免不必要的bug，只要是调用成员属性时，最好加this。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name,int age)&#123;</span><br><span class="line">    this.setName(name);</span><br><span class="line">    setAge(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对于是否使用this没有明确要求，但是从标准出发，采用this.方法名（）</p><p>但一个程序出现多个构造方法时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name,int age)&#123;\</span><br><span class="line">    this();</span><br><span class="line">    this.setName(name);</span><br><span class="line">    setAge(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Person()&#123;</span><br><span class="line">    System.out.println(&quot;this is a person&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，要注意，这里为了避免出现死循环（递归调用），要注意留一个出口。</p><p>this当前对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Person p1 = new Person();</span><br><span class="line">    p1.tell();</span><br><span class="line">    Person p2 = new Person();</span><br><span class="line">    p2.tell();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void tell() &#123;</span><br><span class="line">        System.out.println(this.name + &quot;\t&quot; + this.age);</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里实例化了两个person对象，分别调用了tell方法，通过执行结果得出，this会随着对象不同而表现出不同的实例。</p><p>this.属性，严格意义上来说，这一操作执行的是当前对象的属性。</p><p>static关键字</p><p>属性、方法、代码块</p><p>类的成员，属性和方法，静态的和非静态的。</p><p>对象不同，各自的属性内容也不同。</p><p>静态的含义：类中的某个属性变成公共的。（所有对象都可以去使用），则在声明前加上static关键字。</p><p>static关键字声明后，this调用不了。</p><p>static属性属于类，而不属于对象。</p><p>所以在调用的时候，直接用类名访问。</p><p>static属性存在（全局数据区）</p><p>static方法</p><p>static定义方法时，通过类名来调用。（方法体不能含有当前对象的属性或方法也就是this调用的属性或者方法。）</p><p>static代码块</p><p>主类</p><p>优于主方法执行</p><p>非主类</p><p>优于构造代码块执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;类与对象&lt;/p&gt;
&lt;p&gt;面向对象，java一大特点之一。&lt;/p&gt;
&lt;p&gt;面向对象三大特性：封装、继承、多态。&lt;/p&gt;
&lt;p&gt;类：成员属性和成员方法组成的，成员属性实际上就是一个变量，方法就是操作上的行为。&lt;/p&gt;
&lt;p&gt;定义类，要根据程序语法。&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>方法</title>
    <link href="http://rczmm.github.io/2021/07/25/%E6%96%B9%E6%B3%95/"/>
    <id>http://rczmm.github.io/2021/07/25/%E6%96%B9%E6%B3%95/</id>
    <published>2021-07-25T14:19:54.000Z</published>
    <updated>2021-07-25T14:48:50.370Z</updated>
    
    <content type="html"><![CDATA[<p>方法（method，有时候也被叫做函数），指的是一段可以被重复调用的代码块，利用方法可以实现程序的拆分</p><p>public static void main(String [] args){}</p><p>公共的 静态的 返回值类型 方法名（参数）{</p><p>方法体</p><p>return【返回值】</p><p>}</p><p>定义一个无参数，且无返回值的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void method1()&#123;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">method1();</span><br></pre></td></tr></table></figure><p>return结束方法调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(10);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void method1(int num)&#123;</span><br><span class="line">    if (num &lt;= 10)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(10);</span><br><span class="line">    method1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void method1(int num)&#123;</span><br><span class="line">    if (num &lt;= 10)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void method1()&#123;</span><br><span class="line">    System.out.println(&quot;i am method1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：方法名相同，但是参数不同（个数、类型）、返回值类型不同。</p><p>（为了统一标准，一般来说都用同一种返回值类型，当然也可以不用）</p><p>方法递归调用</p><p>一种特殊的方法嵌套形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(100);</span><br><span class="line">    System.out.println(method1(100));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int method1(int num)&#123;</span><br><span class="line">    if (num==1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num + method1(num-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求阶乘和。（由于计算结果过大，所以使用了double类型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    method1(100);</span><br><span class="line">    System.out.println(method1(100));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static double method1(int num)&#123;</span><br><span class="line">    if (num==1)&#123;</span><br><span class="line">        return method2(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return method2(num) + method1(num-1);</span><br><span class="line">&#125;</span><br><span class="line">public static double method2(int num)&#123;</span><br><span class="line">    if (num==1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return num * method2(num-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法（method，有时候也被叫做函数），指的是一段可以被重复调用的代码块，利用方法可以实现程序的拆分&lt;/p&gt;
&lt;p&gt;public static void main(String [] args){}&lt;/p&gt;
&lt;p&gt;公共的 静态的 返回值类型 方法名（参数）{&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="java" scheme="http://rczmm.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://rczmm.github.io/tags/java/"/>
    
  </entry>
  
</feed>
